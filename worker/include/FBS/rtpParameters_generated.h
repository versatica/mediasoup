// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_
#define FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace FBS {
namespace RtpParameters {

struct Boolean;
struct BooleanBuilder;

struct Integer;
struct IntegerBuilder;

struct IntegerArray;
struct IntegerArrayBuilder;

struct Double;
struct DoubleBuilder;

struct String;
struct StringBuilder;

struct Parameter;
struct ParameterBuilder;

struct RtcpFeedback;
struct RtcpFeedbackBuilder;

struct RtpCodecParameters;
struct RtpCodecParametersBuilder;

struct RtpHeaderExtensionParameters;
struct RtpHeaderExtensionParametersBuilder;

struct Rtx;
struct RtxBuilder;

struct RtpEncodingParameters;
struct RtpEncodingParametersBuilder;

struct RtcpParameters;
struct RtcpParametersBuilder;

struct RtpParameters;
struct RtpParametersBuilder;

inline const flatbuffers::TypeTable *BooleanTypeTable();

inline const flatbuffers::TypeTable *IntegerTypeTable();

inline const flatbuffers::TypeTable *IntegerArrayTypeTable();

inline const flatbuffers::TypeTable *DoubleTypeTable();

inline const flatbuffers::TypeTable *StringTypeTable();

inline const flatbuffers::TypeTable *ParameterTypeTable();

inline const flatbuffers::TypeTable *RtcpFeedbackTypeTable();

inline const flatbuffers::TypeTable *RtpCodecParametersTypeTable();

inline const flatbuffers::TypeTable *RtpHeaderExtensionParametersTypeTable();

inline const flatbuffers::TypeTable *RtxTypeTable();

inline const flatbuffers::TypeTable *RtpEncodingParametersTypeTable();

inline const flatbuffers::TypeTable *RtcpParametersTypeTable();

inline const flatbuffers::TypeTable *RtpParametersTypeTable();

enum class MediaKind : uint8_t {
  ALL = 0,
  AUDIO = 1,
  VIDEO = 2,
  MIN = ALL,
  MAX = VIDEO
};

inline const MediaKind (&EnumValuesMediaKind())[3] {
  static const MediaKind values[] = {
    MediaKind::ALL,
    MediaKind::AUDIO,
    MediaKind::VIDEO
  };
  return values;
}

inline const char * const *EnumNamesMediaKind() {
  static const char * const names[4] = {
    "ALL",
    "AUDIO",
    "VIDEO",
    nullptr
  };
  return names;
}

inline const char *EnumNameMediaKind(MediaKind e) {
  if (flatbuffers::IsOutRange(e, MediaKind::ALL, MediaKind::VIDEO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMediaKind()[index];
}

enum class Type : uint8_t {
  NONE = 0,
  SIMPLE = 1,
  SIMULCAST = 2,
  SVC = 3,
  PIPE = 4,
  MIN = NONE,
  MAX = PIPE
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type::NONE,
    Type::SIMPLE,
    Type::SIMULCAST,
    Type::SVC,
    Type::PIPE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[6] = {
    "NONE",
    "SIMPLE",
    "SIMULCAST",
    "SVC",
    "PIPE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type::NONE, Type::PIPE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum class Value : uint8_t {
  NONE = 0,
  Boolean = 1,
  Integer = 2,
  Double = 3,
  String = 4,
  IntegerArray = 5,
  MIN = NONE,
  MAX = IntegerArray
};

inline const Value (&EnumValuesValue())[6] {
  static const Value values[] = {
    Value::NONE,
    Value::Boolean,
    Value::Integer,
    Value::Double,
    Value::String,
    Value::IntegerArray
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[7] = {
    "NONE",
    "Boolean",
    "Integer",
    "Double",
    "String",
    "IntegerArray",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (flatbuffers::IsOutRange(e, Value::NONE, Value::IntegerArray)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value::NONE;
};

template<> struct ValueTraits<FBS::RtpParameters::Boolean> {
  static const Value enum_value = Value::Boolean;
};

template<> struct ValueTraits<FBS::RtpParameters::Integer> {
  static const Value enum_value = Value::Integer;
};

template<> struct ValueTraits<FBS::RtpParameters::Double> {
  static const Value enum_value = Value::Double;
};

template<> struct ValueTraits<FBS::RtpParameters::String> {
  static const Value enum_value = Value::String;
};

template<> struct ValueTraits<FBS::RtpParameters::IntegerArray> {
  static const Value enum_value = Value::IntegerArray;
};

bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Value> *types);

struct Boolean FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BooleanBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BooleanTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanBuilder {
  typedef Boolean Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(Boolean::VT_VALUE, value, 0);
  }
  explicit BooleanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Boolean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Boolean>(end);
    return o;
  }
};

inline flatbuffers::Offset<Boolean> CreateBoolean(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  BooleanBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Integer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntegerBuilder {
  typedef Integer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Integer::VT_VALUE, value, 0);
  }
  explicit IntegerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Integer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Integer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Integer> CreateInteger(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntegerBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntegerArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerArrayBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerArrayTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct IntegerArrayBuilder {
  typedef IntegerArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(IntegerArray::VT_VALUE, value);
  }
  explicit IntegerArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntegerArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntegerArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntegerArray> CreateIntegerArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  IntegerArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntegerArray> CreateIntegerArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return FBS::RtpParameters::CreateIntegerArray(
      _fbb,
      value__);
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DoubleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return FBS::RtpParameters::CreateString(
      _fbb,
      value__);
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParameterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParameterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  FBS::RtpParameters::Value value_type() const {
    return static_cast<FBS::RtpParameters::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const FBS::RtpParameters::Boolean *value_as_Boolean() const {
    return value_type() == FBS::RtpParameters::Value::Boolean ? static_cast<const FBS::RtpParameters::Boolean *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Integer *value_as_Integer() const {
    return value_type() == FBS::RtpParameters::Value::Integer ? static_cast<const FBS::RtpParameters::Integer *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Double *value_as_Double() const {
    return value_type() == FBS::RtpParameters::Value::Double ? static_cast<const FBS::RtpParameters::Double *>(value()) : nullptr;
  }
  const FBS::RtpParameters::String *value_as_String() const {
    return value_type() == FBS::RtpParameters::Value::String ? static_cast<const FBS::RtpParameters::String *>(value()) : nullptr;
  }
  const FBS::RtpParameters::IntegerArray *value_as_IntegerArray() const {
    return value_type() == FBS::RtpParameters::Value::IntegerArray ? static_cast<const FBS::RtpParameters::IntegerArray *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::RtpParameters::Boolean *Parameter::value_as<FBS::RtpParameters::Boolean>() const {
  return value_as_Boolean();
}

template<> inline const FBS::RtpParameters::Integer *Parameter::value_as<FBS::RtpParameters::Integer>() const {
  return value_as_Integer();
}

template<> inline const FBS::RtpParameters::Double *Parameter::value_as<FBS::RtpParameters::Double>() const {
  return value_as_Double();
}

template<> inline const FBS::RtpParameters::String *Parameter::value_as<FBS::RtpParameters::String>() const {
  return value_as_String();
}

template<> inline const FBS::RtpParameters::IntegerArray *Parameter::value_as<FBS::RtpParameters::IntegerArray>() const {
  return value_as_IntegerArray();
}

struct ParameterBuilder {
  typedef Parameter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Parameter::VT_NAME, name);
  }
  void add_value_type(FBS::RtpParameters::Value value_type) {
    fbb_.AddElement<uint8_t>(Parameter::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Parameter::VT_VALUE, value);
  }
  explicit ParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parameter>(end);
    fbb_.Required(o, Parameter::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Parameter> CreateParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    FBS::RtpParameters::Value value_type = FBS::RtpParameters::Value::NONE,
    flatbuffers::Offset<void> value = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Parameter> CreateParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    FBS::RtpParameters::Value value_type = FBS::RtpParameters::Value::NONE,
    flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return FBS::RtpParameters::CreateParameter(
      _fbb,
      name__,
      value_type,
      value);
}

struct RtcpFeedback FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtcpFeedbackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtcpFeedbackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PARAMETER = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *parameter() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           verifier.EndTable();
  }
};

struct RtcpFeedbackBuilder {
  typedef RtcpFeedback Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(RtcpFeedback::VT_TYPE, type);
  }
  void add_parameter(flatbuffers::Offset<flatbuffers::String> parameter) {
    fbb_.AddOffset(RtcpFeedback::VT_PARAMETER, parameter);
  }
  explicit RtcpFeedbackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtcpFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtcpFeedback>(end);
    fbb_.Required(o, RtcpFeedback::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<RtcpFeedback> CreateRtcpFeedback(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> parameter = 0) {
  RtcpFeedbackBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtcpFeedback> CreateRtcpFeedbackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *parameter = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  return FBS::RtpParameters::CreateRtcpFeedback(
      _fbb,
      type__,
      parameter__);
}

struct RtpCodecParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpCodecParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpCodecParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIMETYPE = 4,
    VT_PAYLOADTYPE = 6,
    VT_CLOCKRATE = 8,
    VT_CHANNELS = 10,
    VT_PARAMETERS = 12,
    VT_RTCPFEEDBACK = 14
  };
  const flatbuffers::String *mimeType() const {
    return GetPointer<const flatbuffers::String *>(VT_MIMETYPE);
  }
  uint8_t payloadType() const {
    return GetField<uint8_t>(VT_PAYLOADTYPE, 0);
  }
  uint32_t clockRate() const {
    return GetField<uint32_t>(VT_CLOCKRATE, 0);
  }
  uint8_t channels() const {
    return GetField<uint8_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>> *>(VT_PARAMETERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *rtcpFeedback() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *>(VT_RTCPFEEDBACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOADTYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_CLOCKRATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_RTCPFEEDBACK) &&
           verifier.VerifyVector(rtcpFeedback()) &&
           verifier.VerifyVectorOfTables(rtcpFeedback()) &&
           verifier.EndTable();
  }
};

struct RtpCodecParametersBuilder {
  typedef RtpCodecParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mimeType(flatbuffers::Offset<flatbuffers::String> mimeType) {
    fbb_.AddOffset(RtpCodecParameters::VT_MIMETYPE, mimeType);
  }
  void add_payloadType(uint8_t payloadType) {
    fbb_.AddElement<uint8_t>(RtpCodecParameters::VT_PAYLOADTYPE, payloadType, 0);
  }
  void add_clockRate(uint32_t clockRate) {
    fbb_.AddElement<uint32_t>(RtpCodecParameters::VT_CLOCKRATE, clockRate, 0);
  }
  void add_channels(uint8_t channels) {
    fbb_.AddElement<uint8_t>(RtpCodecParameters::VT_CHANNELS, channels, 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters) {
    fbb_.AddOffset(RtpCodecParameters::VT_PARAMETERS, parameters);
  }
  void add_rtcpFeedback(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>> rtcpFeedback) {
    fbb_.AddOffset(RtpCodecParameters::VT_RTCPFEEDBACK, rtcpFeedback);
  }
  explicit RtpCodecParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpCodecParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpCodecParameters>(end);
    fbb_.Required(o, RtpCodecParameters::VT_MIMETYPE);
    return o;
  }
};

inline flatbuffers::Offset<RtpCodecParameters> CreateRtpCodecParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mimeType = 0,
    uint8_t payloadType = 0,
    uint32_t clockRate = 0,
    uint8_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>> rtcpFeedback = 0) {
  RtpCodecParametersBuilder builder_(_fbb);
  builder_.add_rtcpFeedback(rtcpFeedback);
  builder_.add_parameters(parameters);
  builder_.add_clockRate(clockRate);
  builder_.add_mimeType(mimeType);
  builder_.add_channels(channels);
  builder_.add_payloadType(payloadType);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpCodecParameters> CreateRtpCodecParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mimeType = nullptr,
    uint8_t payloadType = 0,
    uint32_t clockRate = 0,
    uint8_t channels = 0,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *rtcpFeedback = nullptr) {
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::Parameter>>(*parameters) : 0;
  auto rtcpFeedback__ = rtcpFeedback ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>(*rtcpFeedback) : 0;
  return FBS::RtpParameters::CreateRtpCodecParameters(
      _fbb,
      mimeType__,
      payloadType,
      clockRate,
      channels,
      parameters__,
      rtcpFeedback__);
}

struct RtpHeaderExtensionParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpHeaderExtensionParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpHeaderExtensionParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_ID = 6,
    VT_ENCRYPT = 8,
    VT_PARAMETERS = 10
  };
  const flatbuffers::String *uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  bool encrypt() const {
    return GetField<uint8_t>(VT_ENCRYPT, 0) != 0;
  }
  const flatbuffers::String *parameters() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPT, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyString(parameters()) &&
           verifier.EndTable();
  }
};

struct RtpHeaderExtensionParametersBuilder {
  typedef RtpHeaderExtensionParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(RtpHeaderExtensionParameters::VT_URI, uri);
  }
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(RtpHeaderExtensionParameters::VT_ID, id, 0);
  }
  void add_encrypt(bool encrypt) {
    fbb_.AddElement<uint8_t>(RtpHeaderExtensionParameters::VT_ENCRYPT, static_cast<uint8_t>(encrypt), 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::String> parameters) {
    fbb_.AddOffset(RtpHeaderExtensionParameters::VT_PARAMETERS, parameters);
  }
  explicit RtpHeaderExtensionParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpHeaderExtensionParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpHeaderExtensionParameters>(end);
    fbb_.Required(o, RtpHeaderExtensionParameters::VT_URI);
    return o;
  }
};

inline flatbuffers::Offset<RtpHeaderExtensionParameters> CreateRtpHeaderExtensionParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uri = 0,
    uint8_t id = 0,
    bool encrypt = false,
    flatbuffers::Offset<flatbuffers::String> parameters = 0) {
  RtpHeaderExtensionParametersBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_uri(uri);
  builder_.add_encrypt(encrypt);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpHeaderExtensionParameters> CreateRtpHeaderExtensionParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    uint8_t id = 0,
    bool encrypt = false,
    const char *parameters = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto parameters__ = parameters ? _fbb.CreateString(parameters) : 0;
  return FBS::RtpParameters::CreateRtpHeaderExtensionParameters(
      _fbb,
      uri__,
      id,
      encrypt,
      parameters__);
}

struct Rtx FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4
  };
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           verifier.EndTable();
  }
};

struct RtxBuilder {
  typedef Rtx Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(Rtx::VT_SSRC, ssrc, 0);
  }
  explicit RtxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rtx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rtx>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rtx> CreateRtx(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0) {
  RtxBuilder builder_(_fbb);
  builder_.add_ssrc(ssrc);
  return builder_.Finish();
}

struct RtpEncodingParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpEncodingParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpEncodingParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4,
    VT_RID = 6,
    VT_CODECPAYLOADTYPE = 8,
    VT_RTX = 10,
    VT_DTX = 12,
    VT_SCALABILITYMODE = 14,
    VT_SCALERESOLUTIONDOWNBY = 16,
    VT_MAXBITRATE = 18
  };
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  const flatbuffers::String *rid() const {
    return GetPointer<const flatbuffers::String *>(VT_RID);
  }
  uint8_t codecPayloadType() const {
    return GetField<uint8_t>(VT_CODECPAYLOADTYPE, 0);
  }
  const FBS::RtpParameters::Rtx *rtx() const {
    return GetPointer<const FBS::RtpParameters::Rtx *>(VT_RTX);
  }
  bool dtx() const {
    return GetField<uint8_t>(VT_DTX, 0) != 0;
  }
  const flatbuffers::String *scalabilityMode() const {
    return GetPointer<const flatbuffers::String *>(VT_SCALABILITYMODE);
  }
  uint8_t scaleResolutionDownBy() const {
    return GetField<uint8_t>(VT_SCALERESOLUTIONDOWNBY, 0);
  }
  uint32_t maxBitrate() const {
    return GetField<uint32_t>(VT_MAXBITRATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyField<uint8_t>(verifier, VT_CODECPAYLOADTYPE, 1) &&
           VerifyOffset(verifier, VT_RTX) &&
           verifier.VerifyTable(rtx()) &&
           VerifyField<uint8_t>(verifier, VT_DTX, 1) &&
           VerifyOffset(verifier, VT_SCALABILITYMODE) &&
           verifier.VerifyString(scalabilityMode()) &&
           VerifyField<uint8_t>(verifier, VT_SCALERESOLUTIONDOWNBY, 1) &&
           VerifyField<uint32_t>(verifier, VT_MAXBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct RtpEncodingParametersBuilder {
  typedef RtpEncodingParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(RtpEncodingParameters::VT_SSRC, ssrc, 0);
  }
  void add_rid(flatbuffers::Offset<flatbuffers::String> rid) {
    fbb_.AddOffset(RtpEncodingParameters::VT_RID, rid);
  }
  void add_codecPayloadType(uint8_t codecPayloadType) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_CODECPAYLOADTYPE, codecPayloadType, 0);
  }
  void add_rtx(flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx) {
    fbb_.AddOffset(RtpEncodingParameters::VT_RTX, rtx);
  }
  void add_dtx(bool dtx) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_DTX, static_cast<uint8_t>(dtx), 0);
  }
  void add_scalabilityMode(flatbuffers::Offset<flatbuffers::String> scalabilityMode) {
    fbb_.AddOffset(RtpEncodingParameters::VT_SCALABILITYMODE, scalabilityMode);
  }
  void add_scaleResolutionDownBy(uint8_t scaleResolutionDownBy) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_SCALERESOLUTIONDOWNBY, scaleResolutionDownBy, 0);
  }
  void add_maxBitrate(uint32_t maxBitrate) {
    fbb_.AddElement<uint32_t>(RtpEncodingParameters::VT_MAXBITRATE, maxBitrate, 0);
  }
  explicit RtpEncodingParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpEncodingParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpEncodingParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<RtpEncodingParameters> CreateRtpEncodingParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0,
    flatbuffers::Offset<flatbuffers::String> rid = 0,
    uint8_t codecPayloadType = 0,
    flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx = 0,
    bool dtx = false,
    flatbuffers::Offset<flatbuffers::String> scalabilityMode = 0,
    uint8_t scaleResolutionDownBy = 0,
    uint32_t maxBitrate = 0) {
  RtpEncodingParametersBuilder builder_(_fbb);
  builder_.add_maxBitrate(maxBitrate);
  builder_.add_scalabilityMode(scalabilityMode);
  builder_.add_rtx(rtx);
  builder_.add_rid(rid);
  builder_.add_ssrc(ssrc);
  builder_.add_scaleResolutionDownBy(scaleResolutionDownBy);
  builder_.add_dtx(dtx);
  builder_.add_codecPayloadType(codecPayloadType);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpEncodingParameters> CreateRtpEncodingParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0,
    const char *rid = nullptr,
    uint8_t codecPayloadType = 0,
    flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx = 0,
    bool dtx = false,
    const char *scalabilityMode = nullptr,
    uint8_t scaleResolutionDownBy = 0,
    uint32_t maxBitrate = 0) {
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  auto scalabilityMode__ = scalabilityMode ? _fbb.CreateString(scalabilityMode) : 0;
  return FBS::RtpParameters::CreateRtpEncodingParameters(
      _fbb,
      ssrc,
      rid__,
      codecPayloadType,
      rtx,
      dtx,
      scalabilityMode__,
      scaleResolutionDownBy,
      maxBitrate);
}

struct RtcpParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtcpParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtcpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CNAME = 4,
    VT_REDUCEDSIZE = 6,
    VT_MUX = 8
  };
  const flatbuffers::String *cname() const {
    return GetPointer<const flatbuffers::String *>(VT_CNAME);
  }
  bool reducedSize() const {
    return GetField<uint8_t>(VT_REDUCEDSIZE, 1) != 0;
  }
  bool mux() const {
    return GetField<uint8_t>(VT_MUX, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           VerifyField<uint8_t>(verifier, VT_REDUCEDSIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MUX, 1) &&
           verifier.EndTable();
  }
};

struct RtcpParametersBuilder {
  typedef RtcpParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cname(flatbuffers::Offset<flatbuffers::String> cname) {
    fbb_.AddOffset(RtcpParameters::VT_CNAME, cname);
  }
  void add_reducedSize(bool reducedSize) {
    fbb_.AddElement<uint8_t>(RtcpParameters::VT_REDUCEDSIZE, static_cast<uint8_t>(reducedSize), 1);
  }
  void add_mux(bool mux) {
    fbb_.AddElement<uint8_t>(RtcpParameters::VT_MUX, static_cast<uint8_t>(mux), 1);
  }
  explicit RtcpParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtcpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtcpParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<RtcpParameters> CreateRtcpParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cname = 0,
    bool reducedSize = true,
    bool mux = true) {
  RtcpParametersBuilder builder_(_fbb);
  builder_.add_cname(cname);
  builder_.add_mux(mux);
  builder_.add_reducedSize(reducedSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtcpParameters> CreateRtcpParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cname = nullptr,
    bool reducedSize = true,
    bool mux = true) {
  auto cname__ = cname ? _fbb.CreateString(cname) : 0;
  return FBS::RtpParameters::CreateRtcpParameters(
      _fbb,
      cname__,
      reducedSize,
      mux);
}

struct RtpParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MID = 4,
    VT_CODECS = 6,
    VT_HEADEREXTENSIONS = 8,
    VT_ENCODINGS = 10,
    VT_RTCP = 12
  };
  const flatbuffers::String *mid() const {
    return GetPointer<const flatbuffers::String *>(VT_MID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *codecs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *>(VT_CODECS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *headerExtensions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *>(VT_HEADEREXTENSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *encodings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *>(VT_ENCODINGS);
  }
  const FBS::RtpParameters::RtcpParameters *rtcp() const {
    return GetPointer<const FBS::RtpParameters::RtcpParameters *>(VT_RTCP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MID) &&
           verifier.VerifyString(mid()) &&
           VerifyOffsetRequired(verifier, VT_CODECS) &&
           verifier.VerifyVector(codecs()) &&
           verifier.VerifyVectorOfTables(codecs()) &&
           VerifyOffset(verifier, VT_HEADEREXTENSIONS) &&
           verifier.VerifyVector(headerExtensions()) &&
           verifier.VerifyVectorOfTables(headerExtensions()) &&
           VerifyOffset(verifier, VT_ENCODINGS) &&
           verifier.VerifyVector(encodings()) &&
           verifier.VerifyVectorOfTables(encodings()) &&
           VerifyOffset(verifier, VT_RTCP) &&
           verifier.VerifyTable(rtcp()) &&
           verifier.EndTable();
  }
};

struct RtpParametersBuilder {
  typedef RtpParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mid(flatbuffers::Offset<flatbuffers::String> mid) {
    fbb_.AddOffset(RtpParameters::VT_MID, mid);
  }
  void add_codecs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>> codecs) {
    fbb_.AddOffset(RtpParameters::VT_CODECS, codecs);
  }
  void add_headerExtensions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>> headerExtensions) {
    fbb_.AddOffset(RtpParameters::VT_HEADEREXTENSIONS, headerExtensions);
  }
  void add_encodings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> encodings) {
    fbb_.AddOffset(RtpParameters::VT_ENCODINGS, encodings);
  }
  void add_rtcp(flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp) {
    fbb_.AddOffset(RtpParameters::VT_RTCP, rtcp);
  }
  explicit RtpParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpParameters>(end);
    fbb_.Required(o, RtpParameters::VT_CODECS);
    return o;
  }
};

inline flatbuffers::Offset<RtpParameters> CreateRtpParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>> codecs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>> headerExtensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> encodings = 0,
    flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp = 0) {
  RtpParametersBuilder builder_(_fbb);
  builder_.add_rtcp(rtcp);
  builder_.add_encodings(encodings);
  builder_.add_headerExtensions(headerExtensions);
  builder_.add_codecs(codecs);
  builder_.add_mid(mid);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpParameters> CreateRtpParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mid = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *codecs = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *headerExtensions = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *encodings = nullptr,
    flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp = 0) {
  auto mid__ = mid ? _fbb.CreateString(mid) : 0;
  auto codecs__ = codecs ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>(*codecs) : 0;
  auto headerExtensions__ = headerExtensions ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>(*headerExtensions) : 0;
  auto encodings__ = encodings ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>(*encodings) : 0;
  return FBS::RtpParameters::CreateRtpParameters(
      _fbb,
      mid__,
      codecs__,
      headerExtensions__,
      encodings__,
      rtcp);
}

inline bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value::NONE: {
      return true;
    }
    case Value::Boolean: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Boolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Integer: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Integer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Double: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::String: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::IntegerArray: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::IntegerArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Value> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *MediaKindTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable
  };
  static const char * const names[] = {
    "ALL",
    "AUDIO",
    "VIDEO"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::TypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "SIMPLE",
    "SIMULCAST",
    "SVC",
    "PIPE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ValueTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::BooleanTypeTable,
    FBS::RtpParameters::IntegerTypeTable,
    FBS::RtpParameters::DoubleTypeTable,
    FBS::RtpParameters::StringTypeTable,
    FBS::RtpParameters::IntegerArrayTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Boolean",
    "Integer",
    "Double",
    "String",
    "IntegerArray"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BooleanTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DoubleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ParameterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ValueTypeTable
  };
  static const char * const names[] = {
    "name",
    "value_type",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtcpFeedbackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "type",
    "parameter"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpCodecParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ParameterTypeTable,
    FBS::RtpParameters::RtcpFeedbackTypeTable
  };
  static const char * const names[] = {
    "mimeType",
    "payloadType",
    "clockRate",
    "channels",
    "parameters",
    "rtcpFeedback"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpHeaderExtensionParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "uri",
    "id",
    "encrypt",
    "parameters"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "ssrc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpEncodingParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::RtxTypeTable
  };
  static const char * const names[] = {
    "ssrc",
    "rid",
    "codecPayloadType",
    "rtx",
    "dtx",
    "scalabilityMode",
    "scaleResolutionDownBy",
    "maxBitrate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtcpParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "cname",
    "reducedSize",
    "mux"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::RtpCodecParametersTypeTable,
    FBS::RtpParameters::RtpHeaderExtensionParametersTypeTable,
    FBS::RtpParameters::RtpEncodingParametersTypeTable,
    FBS::RtpParameters::RtcpParametersTypeTable
  };
  static const char * const names[] = {
    "mid",
    "codecs",
    "headerExtensions",
    "encodings",
    "rtcp"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace RtpParameters
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_
