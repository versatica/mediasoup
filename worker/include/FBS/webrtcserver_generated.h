// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEBRTCSERVER_FBS_WEBRTCSERVER_H_
#define FLATBUFFERS_GENERATED_WEBRTCSERVER_FBS_WEBRTCSERVER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace FBS {
namespace WebRtcServer {

struct IpPort;
struct IpPortBuilder;

struct IceUserNameFragment;
struct IceUserNameFragmentBuilder;

struct TupleHash;
struct TupleHashBuilder;

struct WebRtcServerDump;
struct WebRtcServerDumpBuilder;

inline const flatbuffers::TypeTable *IpPortTypeTable();

inline const flatbuffers::TypeTable *IceUserNameFragmentTypeTable();

inline const flatbuffers::TypeTable *TupleHashTypeTable();

inline const flatbuffers::TypeTable *WebRtcServerDumpTypeTable();

struct IpPort FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IpPortBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IpPortTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4,
    VT_PORT = 6
  };
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           verifier.EndTable();
  }
};

struct IpPortBuilder {
  typedef IpPort Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(IpPort::VT_IP, ip);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(IpPort::VT_PORT, port, 0);
  }
  explicit IpPortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IpPort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IpPort>(end);
    fbb_.Required(o, IpPort::VT_IP);
    return o;
  }
};

inline flatbuffers::Offset<IpPort> CreateIpPort(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    uint16_t port = 0) {
  IpPortBuilder builder_(_fbb);
  builder_.add_ip(ip);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<IpPort> CreateIpPortDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr,
    uint16_t port = 0) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return FBS::WebRtcServer::CreateIpPort(
      _fbb,
      ip__,
      port);
}

struct IceUserNameFragment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IceUserNameFragmentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceUserNameFragmentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALICEUSERNAMEFRAGMENT = 4,
    VT_WEBRTCTRANSPORTID = 6
  };
  const flatbuffers::String *localIceUsernameFragment() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALICEUSERNAMEFRAGMENT);
  }
  const flatbuffers::String *webRtcTransportId() const {
    return GetPointer<const flatbuffers::String *>(VT_WEBRTCTRANSPORTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOCALICEUSERNAMEFRAGMENT) &&
           verifier.VerifyString(localIceUsernameFragment()) &&
           VerifyOffsetRequired(verifier, VT_WEBRTCTRANSPORTID) &&
           verifier.VerifyString(webRtcTransportId()) &&
           verifier.EndTable();
  }
};

struct IceUserNameFragmentBuilder {
  typedef IceUserNameFragment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_localIceUsernameFragment(flatbuffers::Offset<flatbuffers::String> localIceUsernameFragment) {
    fbb_.AddOffset(IceUserNameFragment::VT_LOCALICEUSERNAMEFRAGMENT, localIceUsernameFragment);
  }
  void add_webRtcTransportId(flatbuffers::Offset<flatbuffers::String> webRtcTransportId) {
    fbb_.AddOffset(IceUserNameFragment::VT_WEBRTCTRANSPORTID, webRtcTransportId);
  }
  explicit IceUserNameFragmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IceUserNameFragment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IceUserNameFragment>(end);
    fbb_.Required(o, IceUserNameFragment::VT_LOCALICEUSERNAMEFRAGMENT);
    fbb_.Required(o, IceUserNameFragment::VT_WEBRTCTRANSPORTID);
    return o;
  }
};

inline flatbuffers::Offset<IceUserNameFragment> CreateIceUserNameFragment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> localIceUsernameFragment = 0,
    flatbuffers::Offset<flatbuffers::String> webRtcTransportId = 0) {
  IceUserNameFragmentBuilder builder_(_fbb);
  builder_.add_webRtcTransportId(webRtcTransportId);
  builder_.add_localIceUsernameFragment(localIceUsernameFragment);
  return builder_.Finish();
}

inline flatbuffers::Offset<IceUserNameFragment> CreateIceUserNameFragmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *localIceUsernameFragment = nullptr,
    const char *webRtcTransportId = nullptr) {
  auto localIceUsernameFragment__ = localIceUsernameFragment ? _fbb.CreateString(localIceUsernameFragment) : 0;
  auto webRtcTransportId__ = webRtcTransportId ? _fbb.CreateString(webRtcTransportId) : 0;
  return FBS::WebRtcServer::CreateIceUserNameFragment(
      _fbb,
      localIceUsernameFragment__,
      webRtcTransportId__);
}

struct TupleHash FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleHashBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TupleHashTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALICEUSERNAMEFRAGMENT = 4,
    VT_WEBRTCTRANSPORTID = 6
  };
  uint64_t localIceUsernameFragment() const {
    return GetField<uint64_t>(VT_LOCALICEUSERNAMEFRAGMENT, 0);
  }
  const flatbuffers::String *webRtcTransportId() const {
    return GetPointer<const flatbuffers::String *>(VT_WEBRTCTRANSPORTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOCALICEUSERNAMEFRAGMENT, 8) &&
           VerifyOffsetRequired(verifier, VT_WEBRTCTRANSPORTID) &&
           verifier.VerifyString(webRtcTransportId()) &&
           verifier.EndTable();
  }
};

struct TupleHashBuilder {
  typedef TupleHash Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_localIceUsernameFragment(uint64_t localIceUsernameFragment) {
    fbb_.AddElement<uint64_t>(TupleHash::VT_LOCALICEUSERNAMEFRAGMENT, localIceUsernameFragment, 0);
  }
  void add_webRtcTransportId(flatbuffers::Offset<flatbuffers::String> webRtcTransportId) {
    fbb_.AddOffset(TupleHash::VT_WEBRTCTRANSPORTID, webRtcTransportId);
  }
  explicit TupleHashBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TupleHash> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TupleHash>(end);
    fbb_.Required(o, TupleHash::VT_WEBRTCTRANSPORTID);
    return o;
  }
};

inline flatbuffers::Offset<TupleHash> CreateTupleHash(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t localIceUsernameFragment = 0,
    flatbuffers::Offset<flatbuffers::String> webRtcTransportId = 0) {
  TupleHashBuilder builder_(_fbb);
  builder_.add_localIceUsernameFragment(localIceUsernameFragment);
  builder_.add_webRtcTransportId(webRtcTransportId);
  return builder_.Finish();
}

inline flatbuffers::Offset<TupleHash> CreateTupleHashDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t localIceUsernameFragment = 0,
    const char *webRtcTransportId = nullptr) {
  auto webRtcTransportId__ = webRtcTransportId ? _fbb.CreateString(webRtcTransportId) : 0;
  return FBS::WebRtcServer::CreateTupleHash(
      _fbb,
      localIceUsernameFragment,
      webRtcTransportId__);
}

struct WebRtcServerDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebRtcServerDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcServerDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_UDPSOCKETS = 6,
    VT_TCPSERVERS = 8,
    VT_WEBRTCTRANSPORTIDS = 10,
    VT_LOCALICEUSERNAMEFRAGMENTS = 12,
    VT_TUPLEHASHES = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>> *udpSockets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>> *>(VT_UDPSOCKETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>> *tcpServers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>> *>(VT_TCPSERVERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *webRtcTransportIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_WEBRTCTRANSPORTIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IceUserNameFragment>> *localIceUsernameFragments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IceUserNameFragment>> *>(VT_LOCALICEUSERNAMEFRAGMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::TupleHash>> *tupleHashes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::TupleHash>> *>(VT_TUPLEHASHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_UDPSOCKETS) &&
           verifier.VerifyVector(udpSockets()) &&
           verifier.VerifyVectorOfTables(udpSockets()) &&
           VerifyOffset(verifier, VT_TCPSERVERS) &&
           verifier.VerifyVector(tcpServers()) &&
           verifier.VerifyVectorOfTables(tcpServers()) &&
           VerifyOffset(verifier, VT_WEBRTCTRANSPORTIDS) &&
           verifier.VerifyVector(webRtcTransportIds()) &&
           verifier.VerifyVectorOfStrings(webRtcTransportIds()) &&
           VerifyOffset(verifier, VT_LOCALICEUSERNAMEFRAGMENTS) &&
           verifier.VerifyVector(localIceUsernameFragments()) &&
           verifier.VerifyVectorOfTables(localIceUsernameFragments()) &&
           VerifyOffset(verifier, VT_TUPLEHASHES) &&
           verifier.VerifyVector(tupleHashes()) &&
           verifier.VerifyVectorOfTables(tupleHashes()) &&
           verifier.EndTable();
  }
};

struct WebRtcServerDumpBuilder {
  typedef WebRtcServerDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(WebRtcServerDump::VT_ID, id);
  }
  void add_udpSockets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>>> udpSockets) {
    fbb_.AddOffset(WebRtcServerDump::VT_UDPSOCKETS, udpSockets);
  }
  void add_tcpServers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>>> tcpServers) {
    fbb_.AddOffset(WebRtcServerDump::VT_TCPSERVERS, tcpServers);
  }
  void add_webRtcTransportIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> webRtcTransportIds) {
    fbb_.AddOffset(WebRtcServerDump::VT_WEBRTCTRANSPORTIDS, webRtcTransportIds);
  }
  void add_localIceUsernameFragments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IceUserNameFragment>>> localIceUsernameFragments) {
    fbb_.AddOffset(WebRtcServerDump::VT_LOCALICEUSERNAMEFRAGMENTS, localIceUsernameFragments);
  }
  void add_tupleHashes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::TupleHash>>> tupleHashes) {
    fbb_.AddOffset(WebRtcServerDump::VT_TUPLEHASHES, tupleHashes);
  }
  explicit WebRtcServerDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebRtcServerDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebRtcServerDump>(end);
    fbb_.Required(o, WebRtcServerDump::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<WebRtcServerDump> CreateWebRtcServerDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>>> udpSockets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>>> tcpServers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> webRtcTransportIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::IceUserNameFragment>>> localIceUsernameFragments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::WebRtcServer::TupleHash>>> tupleHashes = 0) {
  WebRtcServerDumpBuilder builder_(_fbb);
  builder_.add_tupleHashes(tupleHashes);
  builder_.add_localIceUsernameFragments(localIceUsernameFragments);
  builder_.add_webRtcTransportIds(webRtcTransportIds);
  builder_.add_tcpServers(tcpServers);
  builder_.add_udpSockets(udpSockets);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebRtcServerDump> CreateWebRtcServerDumpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>> *udpSockets = nullptr,
    const std::vector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>> *tcpServers = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *webRtcTransportIds = nullptr,
    const std::vector<flatbuffers::Offset<FBS::WebRtcServer::IceUserNameFragment>> *localIceUsernameFragments = nullptr,
    const std::vector<flatbuffers::Offset<FBS::WebRtcServer::TupleHash>> *tupleHashes = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto udpSockets__ = udpSockets ? _fbb.CreateVector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>>(*udpSockets) : 0;
  auto tcpServers__ = tcpServers ? _fbb.CreateVector<flatbuffers::Offset<FBS::WebRtcServer::IpPort>>(*tcpServers) : 0;
  auto webRtcTransportIds__ = webRtcTransportIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*webRtcTransportIds) : 0;
  auto localIceUsernameFragments__ = localIceUsernameFragments ? _fbb.CreateVector<flatbuffers::Offset<FBS::WebRtcServer::IceUserNameFragment>>(*localIceUsernameFragments) : 0;
  auto tupleHashes__ = tupleHashes ? _fbb.CreateVector<flatbuffers::Offset<FBS::WebRtcServer::TupleHash>>(*tupleHashes) : 0;
  return FBS::WebRtcServer::CreateWebRtcServerDump(
      _fbb,
      id__,
      udpSockets__,
      tcpServers__,
      webRtcTransportIds__,
      localIceUsernameFragments__,
      tupleHashes__);
}

inline const flatbuffers::TypeTable *IpPortTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "ip",
    "port"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IceUserNameFragmentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "localIceUsernameFragment",
    "webRtcTransportId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TupleHashTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "localIceUsernameFragment",
    "webRtcTransportId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebRtcServerDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcServer::IpPortTypeTable,
    FBS::WebRtcServer::IceUserNameFragmentTypeTable,
    FBS::WebRtcServer::TupleHashTypeTable
  };
  static const char * const names[] = {
    "id",
    "udpSockets",
    "tcpServers",
    "webRtcTransportIds",
    "localIceUsernameFragments",
    "tupleHashes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace WebRtcServer
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_WEBRTCSERVER_FBS_WEBRTCSERVER_H_
