// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTXSTREAM_FBS_RTXSTREAM_H_
#define FLATBUFFERS_GENERATED_RTXSTREAM_FBS_RTXSTREAM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace FBS {
namespace RtxStream {

struct Params;
struct ParamsBuilder;

struct RtxDump;
struct RtxDumpBuilder;

inline const flatbuffers::TypeTable *ParamsTypeTable();

inline const flatbuffers::TypeTable *RtxDumpTypeTable();

struct Params FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParamsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParamsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4,
    VT_PAYLOADTYPE = 6,
    VT_MIMETYPE = 8,
    VT_CLOCKRATE = 10,
    VT_RRID = 12,
    VT_CNAME = 14
  };
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  uint8_t payloadType() const {
    return GetField<uint8_t>(VT_PAYLOADTYPE, 0);
  }
  const flatbuffers::String *mimeType() const {
    return GetPointer<const flatbuffers::String *>(VT_MIMETYPE);
  }
  uint32_t clockRate() const {
    return GetField<uint32_t>(VT_CLOCKRATE, 0);
  }
  const flatbuffers::String *rrid() const {
    return GetPointer<const flatbuffers::String *>(VT_RRID);
  }
  const flatbuffers::String *cname() const {
    return GetPointer<const flatbuffers::String *>(VT_CNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOADTYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyField<uint32_t>(verifier, VT_CLOCKRATE, 4) &&
           VerifyOffset(verifier, VT_RRID) &&
           verifier.VerifyString(rrid()) &&
           VerifyOffsetRequired(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           verifier.EndTable();
  }
};

struct ParamsBuilder {
  typedef Params Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(Params::VT_SSRC, ssrc, 0);
  }
  void add_payloadType(uint8_t payloadType) {
    fbb_.AddElement<uint8_t>(Params::VT_PAYLOADTYPE, payloadType, 0);
  }
  void add_mimeType(flatbuffers::Offset<flatbuffers::String> mimeType) {
    fbb_.AddOffset(Params::VT_MIMETYPE, mimeType);
  }
  void add_clockRate(uint32_t clockRate) {
    fbb_.AddElement<uint32_t>(Params::VT_CLOCKRATE, clockRate, 0);
  }
  void add_rrid(flatbuffers::Offset<flatbuffers::String> rrid) {
    fbb_.AddOffset(Params::VT_RRID, rrid);
  }
  void add_cname(flatbuffers::Offset<flatbuffers::String> cname) {
    fbb_.AddOffset(Params::VT_CNAME, cname);
  }
  explicit ParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Params> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Params>(end);
    fbb_.Required(o, Params::VT_MIMETYPE);
    fbb_.Required(o, Params::VT_CNAME);
    return o;
  }
};

inline flatbuffers::Offset<Params> CreateParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0,
    uint8_t payloadType = 0,
    flatbuffers::Offset<flatbuffers::String> mimeType = 0,
    uint32_t clockRate = 0,
    flatbuffers::Offset<flatbuffers::String> rrid = 0,
    flatbuffers::Offset<flatbuffers::String> cname = 0) {
  ParamsBuilder builder_(_fbb);
  builder_.add_cname(cname);
  builder_.add_rrid(rrid);
  builder_.add_clockRate(clockRate);
  builder_.add_mimeType(mimeType);
  builder_.add_ssrc(ssrc);
  builder_.add_payloadType(payloadType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Params> CreateParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0,
    uint8_t payloadType = 0,
    const char *mimeType = nullptr,
    uint32_t clockRate = 0,
    const char *rrid = nullptr,
    const char *cname = nullptr) {
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto rrid__ = rrid ? _fbb.CreateString(rrid) : 0;
  auto cname__ = cname ? _fbb.CreateString(cname) : 0;
  return FBS::RtxStream::CreateParams(
      _fbb,
      ssrc,
      payloadType,
      mimeType__,
      clockRate,
      rrid__,
      cname__);
}

struct RtxDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtxDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtxDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMS = 4
  };
  const FBS::RtxStream::Params *params() const {
    return GetPointer<const FBS::RtxStream::Params *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyTable(params()) &&
           verifier.EndTable();
  }
};

struct RtxDumpBuilder {
  typedef RtxDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<FBS::RtxStream::Params> params) {
    fbb_.AddOffset(RtxDump::VT_PARAMS, params);
  }
  explicit RtxDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtxDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtxDump>(end);
    fbb_.Required(o, RtxDump::VT_PARAMS);
    return o;
  }
};

inline flatbuffers::Offset<RtxDump> CreateRtxDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::RtxStream::Params> params = 0) {
  RtxDumpBuilder builder_(_fbb);
  builder_.add_params(params);
  return builder_.Finish();
}

inline const flatbuffers::TypeTable *ParamsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "ssrc",
    "payloadType",
    "mimeType",
    "clockRate",
    "rrid",
    "cname"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtxDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtxStream::ParamsTypeTable
  };
  static const char * const names[] = {
    "params"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace RtxStream
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_RTXSTREAM_FBS_RTXSTREAM_H_
