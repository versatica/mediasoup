//! Flatbuffers data structures compiled from `.fbs` files
pub use root::fbs::*;

const _: () = ::planus::check_version_compatibility("planus-0.4.0");

/// The root namespace
///
/// Generated from these locations:
/// * File `../worker/fbs/activeSpeakerObserver.fbs`
#[no_implicit_prelude]
mod root {
    /// The namespace `FBS`
    ///
    /// Generated from these locations:
    /// * File `../worker/fbs/activeSpeakerObserver.fbs`
    #[allow(missing_docs)]
    #[allow(clippy::all)]
    pub mod fbs {
        /// The namespace `FBS.ActiveSpeakerObserver`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/activeSpeakerObserver.fbs`
        pub mod active_speaker_observer {
            /// The table `ActiveSpeakerObserverOptions` in the namespace `FBS.ActiveSpeakerObserver`
            ///
            /// Generated from these locations:
            /// * Table `ActiveSpeakerObserverOptions` in the file `../worker/fbs/activeSpeakerObserver.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ActiveSpeakerObserverOptions {
                /// The field `interval` in the table `ActiveSpeakerObserverOptions`
                pub interval: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ActiveSpeakerObserverOptions {
                fn default() -> Self {
                    Self { interval: 0 }
                }
            }

            impl ActiveSpeakerObserverOptions {
                /// Creates a [ActiveSpeakerObserverOptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ActiveSpeakerObserverOptionsBuilder<()> {
                    ActiveSpeakerObserverOptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_interval: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_interval = field_interval.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_interval.is_some() {
                        table_writer.write_entry::<u16>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_interval) =
                                prepared_interval
                            {
                                object_writer.write::<_, _, 2>(&prepared_interval);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptions
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptions
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ActiveSpeakerObserverOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ActiveSpeakerObserverOptions> for ActiveSpeakerObserverOptions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions> {
                    ActiveSpeakerObserverOptions::create(builder, self.interval)
                }
            }

            /// Builder for serializing an instance of the [ActiveSpeakerObserverOptions] type.
            ///
            /// Can be created using the [ActiveSpeakerObserverOptions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ActiveSpeakerObserverOptionsBuilder<State>(State);

            impl ActiveSpeakerObserverOptionsBuilder<()> {
                /// Setter for the [`interval` field](ActiveSpeakerObserverOptions#structfield.interval).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn interval<T0>(self, value: T0) -> ActiveSpeakerObserverOptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u16, u16>,
                {
                    ActiveSpeakerObserverOptionsBuilder((value,))
                }

                /// Sets the [`interval` field](ActiveSpeakerObserverOptions#structfield.interval) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn interval_as_default(
                    self,
                ) -> ActiveSpeakerObserverOptionsBuilder<(::planus::DefaultValue,)>
                {
                    self.interval(::planus::DefaultValue)
                }
            }

            impl<T0> ActiveSpeakerObserverOptionsBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ActiveSpeakerObserverOptions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions>
                where
                    Self: ::planus::WriteAsOffset<ActiveSpeakerObserverOptions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u16, u16>>
                ::planus::WriteAs<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptionsBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ActiveSpeakerObserverOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u16, u16>>
                ::planus::WriteAsOptional<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptionsBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ActiveSpeakerObserverOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ActiveSpeakerObserverOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u16, u16>>
                ::planus::WriteAsOffset<ActiveSpeakerObserverOptions>
                for ActiveSpeakerObserverOptionsBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions> {
                    let (v0,) = &self.0;
                    ActiveSpeakerObserverOptions::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ActiveSpeakerObserverOptions].
            #[derive(Copy, Clone)]
            pub struct ActiveSpeakerObserverOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ActiveSpeakerObserverOptionsRef<'a> {
                /// Getter for the [`interval` field](ActiveSpeakerObserverOptions#structfield.interval).
                #[inline]
                pub fn interval(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ActiveSpeakerObserverOptions", "interval")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ActiveSpeakerObserverOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ActiveSpeakerObserverOptionsRef");
                    f.field("interval", &self.interval());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ActiveSpeakerObserverOptionsRef<'a>>
                for ActiveSpeakerObserverOptions
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ActiveSpeakerObserverOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        interval: ::core::convert::TryInto::try_into(value.interval()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ActiveSpeakerObserverOptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ActiveSpeakerObserverOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ActiveSpeakerObserverOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptions
            {
                type Value = ::planus::Offset<ActiveSpeakerObserverOptions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ActiveSpeakerObserverOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ActiveSpeakerObserverOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ActiveSpeakerObserverOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DominantSpeakerNotification` in the namespace `FBS.ActiveSpeakerObserver`
            ///
            /// Generated from these locations:
            /// * Table `DominantSpeakerNotification` in the file `../worker/fbs/activeSpeakerObserver.fbs:9`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DominantSpeakerNotification {
                /// The field `producer_id` in the table `DominantSpeakerNotification`
                pub producer_id: ::planus::alloc::string::String,
            }

            impl DominantSpeakerNotification {
                /// Creates a [DominantSpeakerNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DominantSpeakerNotificationBuilder<()> {
                    DominantSpeakerNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DominantSpeakerNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DominantSpeakerNotification> for DominantSpeakerNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification> {
                    DominantSpeakerNotification::create(builder, &self.producer_id)
                }
            }

            /// Builder for serializing an instance of the [DominantSpeakerNotification] type.
            ///
            /// Can be created using the [DominantSpeakerNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DominantSpeakerNotificationBuilder<State>(State);

            impl DominantSpeakerNotificationBuilder<()> {
                /// Setter for the [`producer_id` field](DominantSpeakerNotification#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T0>(self, value: T0) -> DominantSpeakerNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DominantSpeakerNotificationBuilder((value,))
                }
            }

            impl<T0> DominantSpeakerNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DominantSpeakerNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification>
                where
                    Self: ::planus::WriteAsOffset<DominantSpeakerNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DominantSpeakerNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DominantSpeakerNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DominantSpeakerNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<DominantSpeakerNotification>
                for DominantSpeakerNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification> {
                    let (v0,) = &self.0;
                    DominantSpeakerNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [DominantSpeakerNotification].
            #[derive(Copy, Clone)]
            pub struct DominantSpeakerNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DominantSpeakerNotificationRef<'a> {
                /// Getter for the [`producer_id` field](DominantSpeakerNotification#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "DominantSpeakerNotification", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for DominantSpeakerNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DominantSpeakerNotificationRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DominantSpeakerNotificationRef<'a>>
                for DominantSpeakerNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DominantSpeakerNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DominantSpeakerNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DominantSpeakerNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DominantSpeakerNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotification
            {
                type Value = ::planus::Offset<DominantSpeakerNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DominantSpeakerNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DominantSpeakerNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DominantSpeakerNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.AudioLevelObserver`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/audioLevelObserver.fbs`
        pub mod audio_level_observer {
            /// The table `AudioLevelObserverOptions` in the namespace `FBS.AudioLevelObserver`
            ///
            /// Generated from these locations:
            /// * Table `AudioLevelObserverOptions` in the file `../worker/fbs/audioLevelObserver.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct AudioLevelObserverOptions {
                /// The field `max_entries` in the table `AudioLevelObserverOptions`
                pub max_entries: u16,
                /// The field `threshold` in the table `AudioLevelObserverOptions`
                pub threshold: i8,
                /// The field `interval` in the table `AudioLevelObserverOptions`
                pub interval: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for AudioLevelObserverOptions {
                fn default() -> Self {
                    Self {
                        max_entries: 0,
                        threshold: 0,
                        interval: 0,
                    }
                }
            }

            impl AudioLevelObserverOptions {
                /// Creates a [AudioLevelObserverOptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> AudioLevelObserverOptionsBuilder<()> {
                    AudioLevelObserverOptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_max_entries: impl ::planus::WriteAsDefault<u16, u16>,
                    field_threshold: impl ::planus::WriteAsDefault<i8, i8>,
                    field_interval: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_max_entries = field_max_entries.prepare(builder, &0);
                    let prepared_threshold = field_threshold.prepare(builder, &0);
                    let prepared_interval = field_interval.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    if prepared_max_entries.is_some() {
                        table_writer.write_entry::<u16>(0);
                    }
                    if prepared_interval.is_some() {
                        table_writer.write_entry::<u16>(2);
                    }
                    if prepared_threshold.is_some() {
                        table_writer.write_entry::<i8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_max_entries) =
                                prepared_max_entries
                            {
                                object_writer.write::<_, _, 2>(&prepared_max_entries);
                            }
                            if let ::core::option::Option::Some(prepared_interval) =
                                prepared_interval
                            {
                                object_writer.write::<_, _, 2>(&prepared_interval);
                            }
                            if let ::core::option::Option::Some(prepared_threshold) =
                                prepared_threshold
                            {
                                object_writer.write::<_, _, 1>(&prepared_threshold);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<AudioLevelObserverOptions>> for AudioLevelObserverOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<AudioLevelObserverOptions>>
                for AudioLevelObserverOptions
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<AudioLevelObserverOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<AudioLevelObserverOptions> for AudioLevelObserverOptions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions> {
                    AudioLevelObserverOptions::create(
                        builder,
                        self.max_entries,
                        self.threshold,
                        self.interval,
                    )
                }
            }

            /// Builder for serializing an instance of the [AudioLevelObserverOptions] type.
            ///
            /// Can be created using the [AudioLevelObserverOptions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct AudioLevelObserverOptionsBuilder<State>(State);

            impl AudioLevelObserverOptionsBuilder<()> {
                /// Setter for the [`max_entries` field](AudioLevelObserverOptions#structfield.max_entries).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_entries<T0>(self, value: T0) -> AudioLevelObserverOptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u16, u16>,
                {
                    AudioLevelObserverOptionsBuilder((value,))
                }

                /// Sets the [`max_entries` field](AudioLevelObserverOptions#structfield.max_entries) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_entries_as_default(
                    self,
                ) -> AudioLevelObserverOptionsBuilder<(::planus::DefaultValue,)> {
                    self.max_entries(::planus::DefaultValue)
                }
            }

            impl<T0> AudioLevelObserverOptionsBuilder<(T0,)> {
                /// Setter for the [`threshold` field](AudioLevelObserverOptions#structfield.threshold).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn threshold<T1>(self, value: T1) -> AudioLevelObserverOptionsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<i8, i8>,
                {
                    let (v0,) = self.0;
                    AudioLevelObserverOptionsBuilder((v0, value))
                }

                /// Sets the [`threshold` field](AudioLevelObserverOptions#structfield.threshold) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn threshold_as_default(
                    self,
                ) -> AudioLevelObserverOptionsBuilder<(T0, ::planus::DefaultValue)>
                {
                    self.threshold(::planus::DefaultValue)
                }
            }

            impl<T0, T1> AudioLevelObserverOptionsBuilder<(T0, T1)> {
                /// Setter for the [`interval` field](AudioLevelObserverOptions#structfield.interval).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn interval<T2>(
                    self,
                    value: T2,
                ) -> AudioLevelObserverOptionsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0, v1) = self.0;
                    AudioLevelObserverOptionsBuilder((v0, v1, value))
                }

                /// Sets the [`interval` field](AudioLevelObserverOptions#structfield.interval) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn interval_as_default(
                    self,
                ) -> AudioLevelObserverOptionsBuilder<(T0, T1, ::planus::DefaultValue)>
                {
                    self.interval(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> AudioLevelObserverOptionsBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AudioLevelObserverOptions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions>
                where
                    Self: ::planus::WriteAsOffset<AudioLevelObserverOptions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<i8, i8>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAs<::planus::Offset<AudioLevelObserverOptions>>
                for AudioLevelObserverOptionsBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<AudioLevelObserverOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<i8, i8>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOptional<::planus::Offset<AudioLevelObserverOptions>>
                for AudioLevelObserverOptionsBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<AudioLevelObserverOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<AudioLevelObserverOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<i8, i8>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOffset<AudioLevelObserverOptions>
                for AudioLevelObserverOptionsBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions> {
                    let (v0, v1, v2) = &self.0;
                    AudioLevelObserverOptions::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [AudioLevelObserverOptions].
            #[derive(Copy, Clone)]
            pub struct AudioLevelObserverOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> AudioLevelObserverOptionsRef<'a> {
                /// Getter for the [`max_entries` field](AudioLevelObserverOptions#structfield.max_entries).
                #[inline]
                pub fn max_entries(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "AudioLevelObserverOptions", "max_entries")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`threshold` field](AudioLevelObserverOptions#structfield.threshold).
                #[inline]
                pub fn threshold(&self) -> ::planus::Result<i8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "AudioLevelObserverOptions", "threshold")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`interval` field](AudioLevelObserverOptions#structfield.interval).
                #[inline]
                pub fn interval(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "AudioLevelObserverOptions", "interval")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for AudioLevelObserverOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("AudioLevelObserverOptionsRef");
                    f.field("max_entries", &self.max_entries());
                    f.field("threshold", &self.threshold());
                    f.field("interval", &self.interval());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<AudioLevelObserverOptionsRef<'a>> for AudioLevelObserverOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: AudioLevelObserverOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        max_entries: ::core::convert::TryInto::try_into(value.max_entries()?)?,
                        threshold: ::core::convert::TryInto::try_into(value.threshold()?)?,
                        interval: ::core::convert::TryInto::try_into(value.interval()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for AudioLevelObserverOptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for AudioLevelObserverOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[AudioLevelObserverOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<AudioLevelObserverOptions>>
                for AudioLevelObserverOptions
            {
                type Value = ::planus::Offset<AudioLevelObserverOptions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<AudioLevelObserverOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for AudioLevelObserverOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[AudioLevelObserverOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `Volume` in the namespace `FBS.AudioLevelObserver`
            ///
            /// Generated from these locations:
            /// * Table `Volume` in the file `../worker/fbs/audioLevelObserver.fbs:11`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Volume {
                /// The field `producer_id` in the table `Volume`
                pub producer_id: ::planus::alloc::string::String,
                /// The field `volume` in the table `Volume`
                pub volume: i8,
            }

            impl Volume {
                /// Creates a [VolumeBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> VolumeBuilder<()> {
                    VolumeBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_volume: impl ::planus::WriteAsDefault<i8, i8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);
                    let prepared_volume = field_volume.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_volume.is_some() {
                        table_writer.write_entry::<i8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                            if let ::core::option::Option::Some(prepared_volume) = prepared_volume {
                                object_writer.write::<_, _, 1>(&prepared_volume);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Volume>> for Volume {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Volume>> for Volume {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Volume>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Volume> for Volume {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume> {
                    Volume::create(builder, &self.producer_id, self.volume)
                }
            }

            /// Builder for serializing an instance of the [Volume] type.
            ///
            /// Can be created using the [Volume::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct VolumeBuilder<State>(State);

            impl VolumeBuilder<()> {
                /// Setter for the [`producer_id` field](Volume#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T0>(self, value: T0) -> VolumeBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    VolumeBuilder((value,))
                }
            }

            impl<T0> VolumeBuilder<(T0,)> {
                /// Setter for the [`volume` field](Volume#structfield.volume).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn volume<T1>(self, value: T1) -> VolumeBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<i8, i8>,
                {
                    let (v0,) = self.0;
                    VolumeBuilder((v0, value))
                }

                /// Sets the [`volume` field](Volume#structfield.volume) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn volume_as_default(self) -> VolumeBuilder<(T0, ::planus::DefaultValue)> {
                    self.volume(::planus::DefaultValue)
                }
            }

            impl<T0, T1> VolumeBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Volume].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume>
                where
                    Self: ::planus::WriteAsOffset<Volume>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<i8, i8>,
                > ::planus::WriteAs<::planus::Offset<Volume>> for VolumeBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Volume>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<i8, i8>,
                > ::planus::WriteAsOptional<::planus::Offset<Volume>> for VolumeBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Volume>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Volume>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<i8, i8>,
                > ::planus::WriteAsOffset<Volume> for VolumeBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume> {
                    let (v0, v1) = &self.0;
                    Volume::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [Volume].
            #[derive(Copy, Clone)]
            pub struct VolumeRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> VolumeRef<'a> {
                /// Getter for the [`producer_id` field](Volume#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Volume", "producer_id")
                }

                /// Getter for the [`volume` field](Volume#structfield.volume).
                #[inline]
                pub fn volume(&self) -> ::planus::Result<i8> {
                    ::core::result::Result::Ok(self.0.access(1, "Volume", "volume")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for VolumeRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("VolumeRef");
                    f.field("producer_id", &self.producer_id());
                    f.field("volume", &self.volume());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<VolumeRef<'a>> for Volume {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: VolumeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        volume: ::core::convert::TryInto::try_into(value.volume()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for VolumeRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for VolumeRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VolumeRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Volume>> for Volume {
                type Value = ::planus::Offset<Volume>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Volume>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for VolumeRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[VolumeRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `VolumesNotification` in the namespace `FBS.AudioLevelObserver`
            ///
            /// Generated from these locations:
            /// * Table `VolumesNotification` in the file `../worker/fbs/audioLevelObserver.fbs:16`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct VolumesNotification {
                /// The field `volumes` in the table `VolumesNotification`
                pub volumes: ::planus::alloc::vec::Vec<self::Volume>,
            }

            impl VolumesNotification {
                /// Creates a [VolumesNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> VolumesNotificationBuilder<()> {
                    VolumesNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_volumes: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::Volume>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_volumes = field_volumes.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::Volume>]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_volumes);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<VolumesNotification>> for VolumesNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<VolumesNotification>> for VolumesNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<VolumesNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<VolumesNotification> for VolumesNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification> {
                    VolumesNotification::create(builder, &self.volumes)
                }
            }

            /// Builder for serializing an instance of the [VolumesNotification] type.
            ///
            /// Can be created using the [VolumesNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct VolumesNotificationBuilder<State>(State);

            impl VolumesNotificationBuilder<()> {
                /// Setter for the [`volumes` field](VolumesNotification#structfield.volumes).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn volumes<T0>(self, value: T0) -> VolumesNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Volume>]>>,
                {
                    VolumesNotificationBuilder((value,))
                }
            }

            impl<T0> VolumesNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VolumesNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification>
                where
                    Self: ::planus::WriteAsOffset<VolumesNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Volume>]>>>
                ::planus::WriteAs<::planus::Offset<VolumesNotification>>
                for VolumesNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<VolumesNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Volume>]>>>
                ::planus::WriteAsOptional<::planus::Offset<VolumesNotification>>
                for VolumesNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<VolumesNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<VolumesNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Volume>]>>>
                ::planus::WriteAsOffset<VolumesNotification> for VolumesNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification> {
                    let (v0,) = &self.0;
                    VolumesNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [VolumesNotification].
            #[derive(Copy, Clone)]
            pub struct VolumesNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> VolumesNotificationRef<'a> {
                /// Getter for the [`volumes` field](VolumesNotification#structfield.volumes).
                #[inline]
                pub fn volumes(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VolumeRef<'a>>>>
                {
                    self.0.access_required(0, "VolumesNotification", "volumes")
                }
            }

            impl<'a> ::core::fmt::Debug for VolumesNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("VolumesNotificationRef");
                    f.field("volumes", &self.volumes());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<VolumesNotificationRef<'a>> for VolumesNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: VolumesNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        volumes: value.volumes()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for VolumesNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for VolumesNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VolumesNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<VolumesNotification>> for VolumesNotification {
                type Value = ::planus::Offset<VolumesNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<VolumesNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for VolumesNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VolumesNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.Common`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/common.fbs`
        pub mod common {
            /// The table `StringString` in the namespace `FBS.Common`
            ///
            /// Generated from these locations:
            /// * Table `StringString` in the file `../worker/fbs/common.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StringString {
                /// The field `key` in the table `StringString`
                pub key: ::planus::alloc::string::String,
                /// The field `value` in the table `StringString`
                pub value: ::planus::alloc::string::String,
            }

            impl StringString {
                /// Creates a [StringStringBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StringStringBuilder<()> {
                    StringStringBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder);
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_key);
                            object_writer.write::<_, _, 4>(&prepared_value);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StringString>> for StringString {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StringString>> for StringString {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringString>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StringString> for StringString {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString> {
                    StringString::create(builder, &self.key, &self.value)
                }
            }

            /// Builder for serializing an instance of the [StringString] type.
            ///
            /// Can be created using the [StringString::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StringStringBuilder<State>(State);

            impl StringStringBuilder<()> {
                /// Setter for the [`key` field](StringString#structfield.key).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key<T0>(self, value: T0) -> StringStringBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StringStringBuilder((value,))
                }
            }

            impl<T0> StringStringBuilder<(T0,)> {
                /// Setter for the [`value` field](StringString#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T1>(self, value: T1) -> StringStringBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    StringStringBuilder((v0, value))
                }
            }

            impl<T0, T1> StringStringBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StringString].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString>
                where
                    Self: ::planus::WriteAsOffset<StringString>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<StringString>>
                for StringStringBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<StringString>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<StringString>>
                for StringStringBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<StringString>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringString>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<StringString> for StringStringBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString> {
                    let (v0, v1) = &self.0;
                    StringString::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [StringString].
            #[derive(Copy, Clone)]
            pub struct StringStringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringStringRef<'a> {
                /// Getter for the [`key` field](StringString#structfield.key).
                #[inline]
                pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StringString", "key")
                }

                /// Getter for the [`value` field](StringString#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "StringString", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringStringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringStringRef");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringStringRef<'a>> for StringString {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringStringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringStringRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringStringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringStringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StringString>> for StringString {
                type Value = ::planus::Offset<StringString>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StringString>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringStringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringStringRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `StringUint8` in the namespace `FBS.Common`
            ///
            /// Generated from these locations:
            /// * Table `StringUint8` in the file `../worker/fbs/common.fbs:8`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StringUint8 {
                /// The field `key` in the table `StringUint8`
                pub key: ::planus::alloc::string::String,
                /// The field `value` in the table `StringUint8`
                pub value: u8,
            }

            impl StringUint8 {
                /// Creates a [StringUint8Builder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StringUint8Builder<()> {
                    StringUint8Builder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder);
                    let prepared_value = field_value.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_value.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_key);
                            if let ::core::option::Option::Some(prepared_value) = prepared_value {
                                object_writer.write::<_, _, 1>(&prepared_value);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StringUint8>> for StringUint8 {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StringUint8>> for StringUint8 {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringUint8>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StringUint8> for StringUint8 {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8> {
                    StringUint8::create(builder, &self.key, self.value)
                }
            }

            /// Builder for serializing an instance of the [StringUint8] type.
            ///
            /// Can be created using the [StringUint8::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StringUint8Builder<State>(State);

            impl StringUint8Builder<()> {
                /// Setter for the [`key` field](StringUint8#structfield.key).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key<T0>(self, value: T0) -> StringUint8Builder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StringUint8Builder((value,))
                }
            }

            impl<T0> StringUint8Builder<(T0,)> {
                /// Setter for the [`value` field](StringUint8#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T1>(self, value: T1) -> StringUint8Builder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    StringUint8Builder((v0, value))
                }

                /// Sets the [`value` field](StringUint8#structfield.value) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value_as_default(self) -> StringUint8Builder<(T0, ::planus::DefaultValue)> {
                    self.value(::planus::DefaultValue)
                }
            }

            impl<T0, T1> StringUint8Builder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StringUint8].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8>
                where
                    Self: ::planus::WriteAsOffset<StringUint8>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAs<::planus::Offset<StringUint8>>
                for StringUint8Builder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<StringUint8>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOptional<::planus::Offset<StringUint8>>
                for StringUint8Builder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<StringUint8>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringUint8>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOffset<StringUint8> for StringUint8Builder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8> {
                    let (v0, v1) = &self.0;
                    StringUint8::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [StringUint8].
            #[derive(Copy, Clone)]
            pub struct StringUint8Ref<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringUint8Ref<'a> {
                /// Getter for the [`key` field](StringUint8#structfield.key).
                #[inline]
                pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StringUint8", "key")
                }

                /// Getter for the [`value` field](StringUint8#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "StringUint8", "value")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for StringUint8Ref<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringUint8Ref");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringUint8Ref<'a>> for StringUint8 {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringUint8Ref<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringUint8Ref<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringUint8Ref<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringUint8Ref]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StringUint8>> for StringUint8 {
                type Value = ::planus::Offset<StringUint8>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StringUint8>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringUint8Ref<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringUint8Ref]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Uint16String` in the namespace `FBS.Common`
            ///
            /// Generated from these locations:
            /// * Table `Uint16String` in the file `../worker/fbs/common.fbs:13`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Uint16String {
                /// The field `key` in the table `Uint16String`
                pub key: u16,
                /// The field `value` in the table `Uint16String`
                pub value: ::planus::alloc::string::String,
            }

            impl Uint16String {
                /// Creates a [Uint16StringBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Uint16StringBuilder<()> {
                    Uint16StringBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAsDefault<u16, u16>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder, &0);
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_key.is_some() {
                        table_writer.write_entry::<u16>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_value);
                            if let ::core::option::Option::Some(prepared_key) = prepared_key {
                                object_writer.write::<_, _, 2>(&prepared_key);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Uint16String>> for Uint16String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Uint16String>> for Uint16String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Uint16String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Uint16String> for Uint16String {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String> {
                    Uint16String::create(builder, self.key, &self.value)
                }
            }

            /// Builder for serializing an instance of the [Uint16String] type.
            ///
            /// Can be created using the [Uint16String::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Uint16StringBuilder<State>(State);

            impl Uint16StringBuilder<()> {
                /// Setter for the [`key` field](Uint16String#structfield.key).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key<T0>(self, value: T0) -> Uint16StringBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u16, u16>,
                {
                    Uint16StringBuilder((value,))
                }

                /// Sets the [`key` field](Uint16String#structfield.key) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key_as_default(self) -> Uint16StringBuilder<(::planus::DefaultValue,)> {
                    self.key(::planus::DefaultValue)
                }
            }

            impl<T0> Uint16StringBuilder<(T0,)> {
                /// Setter for the [`value` field](Uint16String#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T1>(self, value: T1) -> Uint16StringBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    Uint16StringBuilder((v0, value))
                }
            }

            impl<T0, T1> Uint16StringBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Uint16String].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String>
                where
                    Self: ::planus::WriteAsOffset<Uint16String>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<Uint16String>>
                for Uint16StringBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Uint16String>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<Uint16String>>
                for Uint16StringBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Uint16String>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Uint16String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<Uint16String> for Uint16StringBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String> {
                    let (v0, v1) = &self.0;
                    Uint16String::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [Uint16String].
            #[derive(Copy, Clone)]
            pub struct Uint16StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Uint16StringRef<'a> {
                /// Getter for the [`key` field](Uint16String#structfield.key).
                #[inline]
                pub fn key(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Uint16String", "key")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`value` field](Uint16String#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "Uint16String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for Uint16StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Uint16StringRef");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Uint16StringRef<'a>> for Uint16String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Uint16StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Uint16StringRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Uint16StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Uint16StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Uint16String>> for Uint16String {
                type Value = ::planus::Offset<Uint16String>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Uint16String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Uint16StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Uint16StringRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Uint32String` in the namespace `FBS.Common`
            ///
            /// Generated from these locations:
            /// * Table `Uint32String` in the file `../worker/fbs/common.fbs:18`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Uint32String {
                /// The field `key` in the table `Uint32String`
                pub key: u32,
                /// The field `value` in the table `Uint32String`
                pub value: ::planus::alloc::string::String,
            }

            impl Uint32String {
                /// Creates a [Uint32StringBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Uint32StringBuilder<()> {
                    Uint32StringBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAsDefault<u32, u32>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder, &0);
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_key.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_key) = prepared_key {
                                object_writer.write::<_, _, 4>(&prepared_key);
                            }
                            object_writer.write::<_, _, 4>(&prepared_value);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Uint32String>> for Uint32String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Uint32String>> for Uint32String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Uint32String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Uint32String> for Uint32String {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String> {
                    Uint32String::create(builder, self.key, &self.value)
                }
            }

            /// Builder for serializing an instance of the [Uint32String] type.
            ///
            /// Can be created using the [Uint32String::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Uint32StringBuilder<State>(State);

            impl Uint32StringBuilder<()> {
                /// Setter for the [`key` field](Uint32String#structfield.key).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key<T0>(self, value: T0) -> Uint32StringBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    Uint32StringBuilder((value,))
                }

                /// Sets the [`key` field](Uint32String#structfield.key) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key_as_default(self) -> Uint32StringBuilder<(::planus::DefaultValue,)> {
                    self.key(::planus::DefaultValue)
                }
            }

            impl<T0> Uint32StringBuilder<(T0,)> {
                /// Setter for the [`value` field](Uint32String#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T1>(self, value: T1) -> Uint32StringBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    Uint32StringBuilder((v0, value))
                }
            }

            impl<T0, T1> Uint32StringBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Uint32String].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String>
                where
                    Self: ::planus::WriteAsOffset<Uint32String>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<Uint32String>>
                for Uint32StringBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Uint32String>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<Uint32String>>
                for Uint32StringBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Uint32String>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Uint32String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<Uint32String> for Uint32StringBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String> {
                    let (v0, v1) = &self.0;
                    Uint32String::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [Uint32String].
            #[derive(Copy, Clone)]
            pub struct Uint32StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Uint32StringRef<'a> {
                /// Getter for the [`key` field](Uint32String#structfield.key).
                #[inline]
                pub fn key(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Uint32String", "key")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`value` field](Uint32String#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "Uint32String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for Uint32StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Uint32StringRef");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Uint32StringRef<'a>> for Uint32String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Uint32StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Uint32StringRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Uint32StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Uint32StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Uint32String>> for Uint32String {
                type Value = ::planus::Offset<Uint32String>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Uint32String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Uint32StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Uint32StringRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `StringStringArray` in the namespace `FBS.Common`
            ///
            /// Generated from these locations:
            /// * Table `StringStringArray` in the file `../worker/fbs/common.fbs:23`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StringStringArray {
                /// The field `key` in the table `StringStringArray`
                pub key: ::planus::alloc::string::String,
                /// The field `values` in the table `StringStringArray`
                pub values: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            }

            impl StringStringArray {
                /// Creates a [StringStringArrayBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StringStringArrayBuilder<()> {
                    StringStringArrayBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_values: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder);
                    let prepared_values = field_values.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_key);
                            object_writer.write::<_, _, 4>(&prepared_values);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StringStringArray>> for StringStringArray {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StringStringArray>> for StringStringArray {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringStringArray>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StringStringArray> for StringStringArray {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray> {
                    StringStringArray::create(builder, &self.key, &self.values)
                }
            }

            /// Builder for serializing an instance of the [StringStringArray] type.
            ///
            /// Can be created using the [StringStringArray::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StringStringArrayBuilder<State>(State);

            impl StringStringArrayBuilder<()> {
                /// Setter for the [`key` field](StringStringArray#structfield.key).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key<T0>(self, value: T0) -> StringStringArrayBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StringStringArrayBuilder((value,))
                }
            }

            impl<T0> StringStringArrayBuilder<(T0,)> {
                /// Setter for the [`values` field](StringStringArray#structfield.values).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn values<T1>(self, value: T1) -> StringStringArrayBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0,) = self.0;
                    StringStringArrayBuilder((v0, value))
                }
            }

            impl<T0, T1> StringStringArrayBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StringStringArray].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray>
                where
                    Self: ::planus::WriteAsOffset<StringStringArray>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAs<::planus::Offset<StringStringArray>>
                for StringStringArrayBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<StringStringArray>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<StringStringArray>>
                for StringStringArrayBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<StringStringArray>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringStringArray>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAsOffset<StringStringArray>
                for StringStringArrayBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray> {
                    let (v0, v1) = &self.0;
                    StringStringArray::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [StringStringArray].
            #[derive(Copy, Clone)]
            pub struct StringStringArrayRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringStringArrayRef<'a> {
                /// Getter for the [`key` field](StringStringArray#structfield.key).
                #[inline]
                pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StringStringArray", "key")
                }

                /// Getter for the [`values` field](StringStringArray#structfield.values).
                #[inline]
                pub fn values(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(1, "StringStringArray", "values")
                }
            }

            impl<'a> ::core::fmt::Debug for StringStringArrayRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringStringArrayRef");
                    f.field("key", &self.key());
                    f.field("values", &self.values());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringStringArrayRef<'a>> for StringStringArray {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringStringArrayRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        values: value.values()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringStringArrayRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringStringArrayRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringStringArrayRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StringStringArray>> for StringStringArray {
                type Value = ::planus::Offset<StringStringArray>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StringStringArray>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringStringArrayRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringStringArrayRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `TraceDirection` in the namespace `FBS.Common`
            ///
            /// Generated from these locations:
            /// * Enum `TraceDirection` in the file `../worker/fbs/common.fbs:29`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceDirection {
                /// The variant `DIRECTION_IN` in the enum `TraceDirection`
                DirectionIn = 0,

                /// The variant `DIRECTION_OUT` in the enum `TraceDirection`
                DirectionOut = 1,
            }

            impl TraceDirection {
                /// Array containing all valid variants of TraceDirection
                pub const ENUM_VALUES: [Self; 2] = [Self::DirectionIn, Self::DirectionOut];
            }

            impl ::core::convert::TryFrom<u8> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceDirection::DirectionIn),
                        1 => ::core::result::Result::Ok(TraceDirection::DirectionOut),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceDirection> for u8 {
                #[inline]
                fn from(value: TraceDirection) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceDirection {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceDirection> for TraceDirection {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceDirection {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceDirection, TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceDirection,
                ) -> ::core::option::Option<TraceDirection> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceDirection> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceDirection {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceDirection",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceDirection> for TraceDirection {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }
        }
        /// The namespace `FBS.Consumer`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/consumer.fbs`
        pub mod consumer {
            /// The table `ConsumerLayers` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `ConsumerLayers` in the file `../worker/fbs/consumer.fbs:8`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumerLayers {
                /// The field `spatial_layer` in the table `ConsumerLayers`
                pub spatial_layer: u8,
                /// The field `temporal_layer` in the table `ConsumerLayers`
                pub temporal_layer: ::core::option::Option<u8>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConsumerLayers {
                fn default() -> Self {
                    Self {
                        spatial_layer: 0,
                        temporal_layer: ::core::default::Default::default(),
                    }
                }
            }

            impl ConsumerLayers {
                /// Creates a [ConsumerLayersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsumerLayersBuilder<()> {
                    ConsumerLayersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_spatial_layer: impl ::planus::WriteAsDefault<u8, u8>,
                    field_temporal_layer: impl ::planus::WriteAsOptional<u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_spatial_layer = field_spatial_layer.prepare(builder, &0);
                    let prepared_temporal_layer = field_temporal_layer.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_spatial_layer.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }
                    if prepared_temporal_layer.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_spatial_layer) =
                                prepared_spatial_layer
                            {
                                object_writer.write::<_, _, 1>(&prepared_spatial_layer);
                            }
                            if let ::core::option::Option::Some(prepared_temporal_layer) =
                                prepared_temporal_layer
                            {
                                object_writer.write::<_, _, 1>(&prepared_temporal_layer);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumerLayers>> for ConsumerLayers {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumerLayers>> for ConsumerLayers {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerLayers>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumerLayers> for ConsumerLayers {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers> {
                    ConsumerLayers::create(builder, self.spatial_layer, self.temporal_layer)
                }
            }

            /// Builder for serializing an instance of the [ConsumerLayers] type.
            ///
            /// Can be created using the [ConsumerLayers::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsumerLayersBuilder<State>(State);

            impl ConsumerLayersBuilder<()> {
                /// Setter for the [`spatial_layer` field](ConsumerLayers#structfield.spatial_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spatial_layer<T0>(self, value: T0) -> ConsumerLayersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    ConsumerLayersBuilder((value,))
                }

                /// Sets the [`spatial_layer` field](ConsumerLayers#structfield.spatial_layer) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spatial_layer_as_default(
                    self,
                ) -> ConsumerLayersBuilder<(::planus::DefaultValue,)> {
                    self.spatial_layer(::planus::DefaultValue)
                }
            }

            impl<T0> ConsumerLayersBuilder<(T0,)> {
                /// Setter for the [`temporal_layer` field](ConsumerLayers#structfield.temporal_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn temporal_layer<T1>(self, value: T1) -> ConsumerLayersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<u8>,
                {
                    let (v0,) = self.0;
                    ConsumerLayersBuilder((v0, value))
                }

                /// Sets the [`temporal_layer` field](ConsumerLayers#structfield.temporal_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn temporal_layer_as_null(self) -> ConsumerLayersBuilder<(T0, ())> {
                    self.temporal_layer(())
                }
            }

            impl<T0, T1> ConsumerLayersBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsumerLayers].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers>
                where
                    Self: ::planus::WriteAsOffset<ConsumerLayers>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>, T1: ::planus::WriteAsOptional<u8>>
                ::planus::WriteAs<::planus::Offset<ConsumerLayers>>
                for ConsumerLayersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ConsumerLayers>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>, T1: ::planus::WriteAsOptional<u8>>
                ::planus::WriteAsOptional<::planus::Offset<ConsumerLayers>>
                for ConsumerLayersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ConsumerLayers>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerLayers>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>, T1: ::planus::WriteAsOptional<u8>>
                ::planus::WriteAsOffset<ConsumerLayers> for ConsumerLayersBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers> {
                    let (v0, v1) = &self.0;
                    ConsumerLayers::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [ConsumerLayers].
            #[derive(Copy, Clone)]
            pub struct ConsumerLayersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumerLayersRef<'a> {
                /// Getter for the [`spatial_layer` field](ConsumerLayers#structfield.spatial_layer).
                #[inline]
                pub fn spatial_layer(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ConsumerLayers", "spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`temporal_layer` field](ConsumerLayers#structfield.temporal_layer).
                #[inline]
                pub fn temporal_layer(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(1, "ConsumerLayers", "temporal_layer")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumerLayersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumerLayersRef");
                    f.field("spatial_layer", &self.spatial_layer());
                    if let ::core::option::Option::Some(field_temporal_layer) =
                        self.temporal_layer().transpose()
                    {
                        f.field("temporal_layer", &field_temporal_layer);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumerLayersRef<'a>> for ConsumerLayers {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumerLayersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        spatial_layer: ::core::convert::TryInto::try_into(value.spatial_layer()?)?,
                        temporal_layer: if let ::core::option::Option::Some(temporal_layer) =
                            value.temporal_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                temporal_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumerLayersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumerLayersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumerLayersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumerLayers>> for ConsumerLayers {
                type Value = ::planus::Offset<ConsumerLayers>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumerLayers>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumerLayersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumerLayersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConsumerScore` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `ConsumerScore` in the file `../worker/fbs/consumer.fbs:13`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumerScore {
                /// The field `score` in the table `ConsumerScore`
                pub score: u8,
                /// The field `producer_score` in the table `ConsumerScore`
                pub producer_score: u8,
                /// The field `producer_scores` in the table `ConsumerScore`
                pub producer_scores: ::planus::alloc::vec::Vec<u8>,
            }

            impl ConsumerScore {
                /// Creates a [ConsumerScoreBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsumerScoreBuilder<()> {
                    ConsumerScoreBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_producer_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_producer_scores: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_score = field_score.prepare(builder, &0);
                    let prepared_producer_score = field_producer_score.prepare(builder, &0);
                    let prepared_producer_scores = field_producer_scores.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u8]>>(2);
                    if prepared_score.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }
                    if prepared_producer_score.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_scores);
                            if let ::core::option::Option::Some(prepared_score) = prepared_score {
                                object_writer.write::<_, _, 1>(&prepared_score);
                            }
                            if let ::core::option::Option::Some(prepared_producer_score) =
                                prepared_producer_score
                            {
                                object_writer.write::<_, _, 1>(&prepared_producer_score);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumerScore>> for ConsumerScore {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumerScore>> for ConsumerScore {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerScore>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumerScore> for ConsumerScore {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore> {
                    ConsumerScore::create(
                        builder,
                        self.score,
                        self.producer_score,
                        &self.producer_scores,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConsumerScore] type.
            ///
            /// Can be created using the [ConsumerScore::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsumerScoreBuilder<State>(State);

            impl ConsumerScoreBuilder<()> {
                /// Setter for the [`score` field](ConsumerScore#structfield.score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score<T0>(self, value: T0) -> ConsumerScoreBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    ConsumerScoreBuilder((value,))
                }

                /// Sets the [`score` field](ConsumerScore#structfield.score) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score_as_default(self) -> ConsumerScoreBuilder<(::planus::DefaultValue,)> {
                    self.score(::planus::DefaultValue)
                }
            }

            impl<T0> ConsumerScoreBuilder<(T0,)> {
                /// Setter for the [`producer_score` field](ConsumerScore#structfield.producer_score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_score<T1>(self, value: T1) -> ConsumerScoreBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    ConsumerScoreBuilder((v0, value))
                }

                /// Sets the [`producer_score` field](ConsumerScore#structfield.producer_score) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_score_as_default(
                    self,
                ) -> ConsumerScoreBuilder<(T0, ::planus::DefaultValue)> {
                    self.producer_score(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ConsumerScoreBuilder<(T0, T1)> {
                /// Setter for the [`producer_scores` field](ConsumerScore#structfield.producer_scores).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_scores<T2>(self, value: T2) -> ConsumerScoreBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    let (v0, v1) = self.0;
                    ConsumerScoreBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> ConsumerScoreBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsumerScore].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore>
                where
                    Self: ::planus::WriteAsOffset<ConsumerScore>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u8, u8>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAs<::planus::Offset<ConsumerScore>>
                for ConsumerScoreBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<ConsumerScore>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u8, u8>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOptional<::planus::Offset<ConsumerScore>>
                for ConsumerScoreBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<ConsumerScore>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerScore>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u8, u8>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOffset<ConsumerScore> for ConsumerScoreBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore> {
                    let (v0, v1, v2) = &self.0;
                    ConsumerScore::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [ConsumerScore].
            #[derive(Copy, Clone)]
            pub struct ConsumerScoreRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumerScoreRef<'a> {
                /// Getter for the [`score` field](ConsumerScore#structfield.score).
                #[inline]
                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "ConsumerScore", "score")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`producer_score` field](ConsumerScore#structfield.producer_score).
                #[inline]
                pub fn producer_score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ConsumerScore", "producer_score")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`producer_scores` field](ConsumerScore#structfield.producer_scores).
                #[inline]
                pub fn producer_scores(&self) -> ::planus::Result<&'a [u8]> {
                    self.0
                        .access_required(2, "ConsumerScore", "producer_scores")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumerScoreRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumerScoreRef");
                    f.field("score", &self.score());
                    f.field("producer_score", &self.producer_score());
                    f.field("producer_scores", &self.producer_scores());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumerScoreRef<'a>> for ConsumerScore {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumerScoreRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                        producer_score: ::core::convert::TryInto::try_into(
                            value.producer_score()?,
                        )?,
                        producer_scores: value.producer_scores()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumerScoreRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumerScoreRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumerScoreRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumerScore>> for ConsumerScore {
                type Value = ::planus::Offset<ConsumerScore>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumerScore>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumerScoreRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumerScoreRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SetPreferredLayersRequest` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `SetPreferredLayersRequest` in the file `../worker/fbs/consumer.fbs:19`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPreferredLayersRequest {
                /// The field `preferred_layers` in the table `SetPreferredLayersRequest`
                pub preferred_layers: ::planus::alloc::boxed::Box<self::ConsumerLayers>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPreferredLayersRequest {
                fn default() -> Self {
                    Self {
                        preferred_layers: ::core::default::Default::default(),
                    }
                }
            }

            impl SetPreferredLayersRequest {
                /// Creates a [SetPreferredLayersRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetPreferredLayersRequestBuilder<()> {
                    SetPreferredLayersRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_preferred_layers: impl ::planus::WriteAs<
                        ::planus::Offset<self::ConsumerLayers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::ConsumerLayers>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_preferred_layers);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPreferredLayersRequest>> for SetPreferredLayersRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPreferredLayersRequest>>
                for SetPreferredLayersRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPreferredLayersRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPreferredLayersRequest> for SetPreferredLayersRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest> {
                    SetPreferredLayersRequest::create(builder, &self.preferred_layers)
                }
            }

            /// Builder for serializing an instance of the [SetPreferredLayersRequest] type.
            ///
            /// Can be created using the [SetPreferredLayersRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetPreferredLayersRequestBuilder<State>(State);

            impl SetPreferredLayersRequestBuilder<()> {
                /// Setter for the [`preferred_layers` field](SetPreferredLayersRequest#structfield.preferred_layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers<T0>(
                    self,
                    value: T0,
                ) -> SetPreferredLayersRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>,
                {
                    SetPreferredLayersRequestBuilder((value,))
                }
            }

            impl<T0> SetPreferredLayersRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetPreferredLayersRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest>
                where
                    Self: ::planus::WriteAsOffset<SetPreferredLayersRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAs<::planus::Offset<SetPreferredLayersRequest>>
                for SetPreferredLayersRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPreferredLayersRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAsOptional<::planus::Offset<SetPreferredLayersRequest>>
                for SetPreferredLayersRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPreferredLayersRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPreferredLayersRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAsOffset<SetPreferredLayersRequest>
                for SetPreferredLayersRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest> {
                    let (v0,) = &self.0;
                    SetPreferredLayersRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetPreferredLayersRequest].
            #[derive(Copy, Clone)]
            pub struct SetPreferredLayersRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPreferredLayersRequestRef<'a> {
                /// Getter for the [`preferred_layers` field](SetPreferredLayersRequest#structfield.preferred_layers).
                #[inline]
                pub fn preferred_layers(&self) -> ::planus::Result<self::ConsumerLayersRef<'a>> {
                    self.0
                        .access_required(0, "SetPreferredLayersRequest", "preferred_layers")
                }
            }

            impl<'a> ::core::fmt::Debug for SetPreferredLayersRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPreferredLayersRequestRef");
                    f.field("preferred_layers", &self.preferred_layers());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPreferredLayersRequestRef<'a>> for SetPreferredLayersRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPreferredLayersRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        preferred_layers: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.preferred_layers()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPreferredLayersRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPreferredLayersRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPreferredLayersRequest>>
                for SetPreferredLayersRequest
            {
                type Value = ::planus::Offset<SetPreferredLayersRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPreferredLayersRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPreferredLayersRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SetPreferredLayersResponse` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `SetPreferredLayersResponse` in the file `../worker/fbs/consumer.fbs:23`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPreferredLayersResponse {
                /// The field `preferred_layers` in the table `SetPreferredLayersResponse`
                pub preferred_layers:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::ConsumerLayers>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPreferredLayersResponse {
                fn default() -> Self {
                    Self {
                        preferred_layers: ::core::default::Default::default(),
                    }
                }
            }

            impl SetPreferredLayersResponse {
                /// Creates a [SetPreferredLayersResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetPreferredLayersResponseBuilder<()> {
                    SetPreferredLayersResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_preferred_layers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::ConsumerLayers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_preferred_layers.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::ConsumerLayers>>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_preferred_layers) =
                                prepared_preferred_layers
                            {
                                object_writer.write::<_, _, 4>(&prepared_preferred_layers);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponse
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponse
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPreferredLayersResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPreferredLayersResponse> for SetPreferredLayersResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse> {
                    SetPreferredLayersResponse::create(builder, &self.preferred_layers)
                }
            }

            /// Builder for serializing an instance of the [SetPreferredLayersResponse] type.
            ///
            /// Can be created using the [SetPreferredLayersResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetPreferredLayersResponseBuilder<State>(State);

            impl SetPreferredLayersResponseBuilder<()> {
                /// Setter for the [`preferred_layers` field](SetPreferredLayersResponse#structfield.preferred_layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers<T0>(
                    self,
                    value: T0,
                ) -> SetPreferredLayersResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::ConsumerLayers>>,
                {
                    SetPreferredLayersResponseBuilder((value,))
                }

                /// Sets the [`preferred_layers` field](SetPreferredLayersResponse#structfield.preferred_layers) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers_as_null(self) -> SetPreferredLayersResponseBuilder<((),)> {
                    self.preferred_layers(())
                }
            }

            impl<T0> SetPreferredLayersResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetPreferredLayersResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse>
                where
                    Self: ::planus::WriteAsOffset<SetPreferredLayersResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsOptional<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAs<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPreferredLayersResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsOptional<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAsOptional<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPreferredLayersResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPreferredLayersResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsOptional<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAsOffset<SetPreferredLayersResponse>
                for SetPreferredLayersResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse> {
                    let (v0,) = &self.0;
                    SetPreferredLayersResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetPreferredLayersResponse].
            #[derive(Copy, Clone)]
            pub struct SetPreferredLayersResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPreferredLayersResponseRef<'a> {
                /// Getter for the [`preferred_layers` field](SetPreferredLayersResponse#structfield.preferred_layers).
                #[inline]
                pub fn preferred_layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ConsumerLayersRef<'a>>>
                {
                    self.0
                        .access(0, "SetPreferredLayersResponse", "preferred_layers")
                }
            }

            impl<'a> ::core::fmt::Debug for SetPreferredLayersResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPreferredLayersResponseRef");
                    if let ::core::option::Option::Some(field_preferred_layers) =
                        self.preferred_layers().transpose()
                    {
                        f.field("preferred_layers", &field_preferred_layers);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPreferredLayersResponseRef<'a>>
                for SetPreferredLayersResponse
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPreferredLayersResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        preferred_layers: if let ::core::option::Option::Some(preferred_layers) =
                            value.preferred_layers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(preferred_layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPreferredLayersResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPreferredLayersResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponse
            {
                type Value = ::planus::Offset<SetPreferredLayersResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPreferredLayersResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPreferredLayersResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SetPriorityRequest` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `SetPriorityRequest` in the file `../worker/fbs/consumer.fbs:27`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPriorityRequest {
                /// The field `priority` in the table `SetPriorityRequest`
                pub priority: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPriorityRequest {
                fn default() -> Self {
                    Self { priority: 0 }
                }
            }

            impl SetPriorityRequest {
                /// Creates a [SetPriorityRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetPriorityRequestBuilder<()> {
                    SetPriorityRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_priority: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_priority = field_priority.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_priority.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_priority) =
                                prepared_priority
                            {
                                object_writer.write::<_, _, 1>(&prepared_priority);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPriorityRequest>> for SetPriorityRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPriorityRequest>> for SetPriorityRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPriorityRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPriorityRequest> for SetPriorityRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest> {
                    SetPriorityRequest::create(builder, self.priority)
                }
            }

            /// Builder for serializing an instance of the [SetPriorityRequest] type.
            ///
            /// Can be created using the [SetPriorityRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetPriorityRequestBuilder<State>(State);

            impl SetPriorityRequestBuilder<()> {
                /// Setter for the [`priority` field](SetPriorityRequest#structfield.priority).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority<T0>(self, value: T0) -> SetPriorityRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    SetPriorityRequestBuilder((value,))
                }

                /// Sets the [`priority` field](SetPriorityRequest#structfield.priority) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority_as_default(
                    self,
                ) -> SetPriorityRequestBuilder<(::planus::DefaultValue,)> {
                    self.priority(::planus::DefaultValue)
                }
            }

            impl<T0> SetPriorityRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetPriorityRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest>
                where
                    Self: ::planus::WriteAsOffset<SetPriorityRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAs<::planus::Offset<SetPriorityRequest>>
                for SetPriorityRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPriorityRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAsOptional<::planus::Offset<SetPriorityRequest>>
                for SetPriorityRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPriorityRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPriorityRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>> ::planus::WriteAsOffset<SetPriorityRequest>
                for SetPriorityRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest> {
                    let (v0,) = &self.0;
                    SetPriorityRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetPriorityRequest].
            #[derive(Copy, Clone)]
            pub struct SetPriorityRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPriorityRequestRef<'a> {
                /// Getter for the [`priority` field](SetPriorityRequest#structfield.priority).
                #[inline]
                pub fn priority(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetPriorityRequest", "priority")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetPriorityRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPriorityRequestRef");
                    f.field("priority", &self.priority());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPriorityRequestRef<'a>> for SetPriorityRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPriorityRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPriorityRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPriorityRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPriorityRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPriorityRequest>> for SetPriorityRequest {
                type Value = ::planus::Offset<SetPriorityRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPriorityRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPriorityRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SetPriorityRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SetPriorityResponse` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `SetPriorityResponse` in the file `../worker/fbs/consumer.fbs:31`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPriorityResponse {
                /// The field `priority` in the table `SetPriorityResponse`
                pub priority: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPriorityResponse {
                fn default() -> Self {
                    Self { priority: 0 }
                }
            }

            impl SetPriorityResponse {
                /// Creates a [SetPriorityResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetPriorityResponseBuilder<()> {
                    SetPriorityResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_priority: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_priority = field_priority.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_priority.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_priority) =
                                prepared_priority
                            {
                                object_writer.write::<_, _, 1>(&prepared_priority);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPriorityResponse>> for SetPriorityResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPriorityResponse>> for SetPriorityResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPriorityResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPriorityResponse> for SetPriorityResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse> {
                    SetPriorityResponse::create(builder, self.priority)
                }
            }

            /// Builder for serializing an instance of the [SetPriorityResponse] type.
            ///
            /// Can be created using the [SetPriorityResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetPriorityResponseBuilder<State>(State);

            impl SetPriorityResponseBuilder<()> {
                /// Setter for the [`priority` field](SetPriorityResponse#structfield.priority).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority<T0>(self, value: T0) -> SetPriorityResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    SetPriorityResponseBuilder((value,))
                }

                /// Sets the [`priority` field](SetPriorityResponse#structfield.priority) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority_as_default(
                    self,
                ) -> SetPriorityResponseBuilder<(::planus::DefaultValue,)> {
                    self.priority(::planus::DefaultValue)
                }
            }

            impl<T0> SetPriorityResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetPriorityResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse>
                where
                    Self: ::planus::WriteAsOffset<SetPriorityResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAs<::planus::Offset<SetPriorityResponse>>
                for SetPriorityResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPriorityResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAsOptional<::planus::Offset<SetPriorityResponse>>
                for SetPriorityResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetPriorityResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPriorityResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>> ::planus::WriteAsOffset<SetPriorityResponse>
                for SetPriorityResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse> {
                    let (v0,) = &self.0;
                    SetPriorityResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetPriorityResponse].
            #[derive(Copy, Clone)]
            pub struct SetPriorityResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPriorityResponseRef<'a> {
                /// Getter for the [`priority` field](SetPriorityResponse#structfield.priority).
                #[inline]
                pub fn priority(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetPriorityResponse", "priority")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetPriorityResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPriorityResponseRef");
                    f.field("priority", &self.priority());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPriorityResponseRef<'a>> for SetPriorityResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPriorityResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPriorityResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPriorityResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPriorityResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPriorityResponse>> for SetPriorityResponse {
                type Value = ::planus::Offset<SetPriorityResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPriorityResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPriorityResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPriorityResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The enum `TraceEventType` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Enum `TraceEventType` in the file `../worker/fbs/consumer.fbs:35`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceEventType {
                /// The variant `KEYFRAME` in the enum `TraceEventType`
                Keyframe = 0,

                /// The variant `FIR` in the enum `TraceEventType`
                Fir = 1,

                /// The variant `NACK` in the enum `TraceEventType`
                Nack = 2,

                /// The variant `PLI` in the enum `TraceEventType`
                Pli = 3,

                /// The variant `RTP` in the enum `TraceEventType`
                Rtp = 4,
            }

            impl TraceEventType {
                /// Array containing all valid variants of TraceEventType
                pub const ENUM_VALUES: [Self; 5] =
                    [Self::Keyframe, Self::Fir, Self::Nack, Self::Pli, Self::Rtp];
            }

            impl ::core::convert::TryFrom<u8> for TraceEventType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceEventType::Keyframe),
                        1 => ::core::result::Result::Ok(TraceEventType::Fir),
                        2 => ::core::result::Result::Ok(TraceEventType::Nack),
                        3 => ::core::result::Result::Ok(TraceEventType::Pli),
                        4 => ::core::result::Result::Ok(TraceEventType::Rtp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceEventType> for u8 {
                #[inline]
                fn from(value: TraceEventType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceEventType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceEventType> for TraceEventType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceEventType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceEventType, TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceEventType,
                ) -> ::core::option::Option<TraceEventType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceEventType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceEventType {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceEventType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceEventType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceEventType> for TraceEventType {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `EnableTraceEventRequest` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `EnableTraceEventRequest` in the file `../worker/fbs/consumer.fbs:43`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EnableTraceEventRequest {
                /// The field `events` in the table `EnableTraceEventRequest`
                pub events: ::planus::alloc::vec::Vec<self::TraceEventType>,
            }

            impl EnableTraceEventRequest {
                /// Creates a [EnableTraceEventRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> EnableTraceEventRequestBuilder<()> {
                    EnableTraceEventRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_events: impl ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_events = field_events.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[self::TraceEventType]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_events);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EnableTraceEventRequest> for EnableTraceEventRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    EnableTraceEventRequest::create(builder, &self.events)
                }
            }

            /// Builder for serializing an instance of the [EnableTraceEventRequest] type.
            ///
            /// Can be created using the [EnableTraceEventRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct EnableTraceEventRequestBuilder<State>(State);

            impl EnableTraceEventRequestBuilder<()> {
                /// Setter for the [`events` field](EnableTraceEventRequest#structfield.events).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn events<T0>(self, value: T0) -> EnableTraceEventRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                {
                    EnableTraceEventRequestBuilder((value,))
                }
            }

            impl<T0> EnableTraceEventRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [EnableTraceEventRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest>
                where
                    Self: ::planus::WriteAsOffset<EnableTraceEventRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<EnableTraceEventRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<EnableTraceEventRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAsOffset<EnableTraceEventRequest>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    let (v0,) = &self.0;
                    EnableTraceEventRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [EnableTraceEventRequest].
            #[derive(Copy, Clone)]
            pub struct EnableTraceEventRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EnableTraceEventRequestRef<'a> {
                /// Getter for the [`events` field](EnableTraceEventRequest#structfield.events).
                #[inline]
                pub fn events(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::core::result::Result<
                            self::TraceEventType,
                            ::planus::errors::UnknownEnumTag,
                        >,
                    >,
                > {
                    self.0
                        .access_required(0, "EnableTraceEventRequest", "events")
                }
            }

            impl<'a> ::core::fmt::Debug for EnableTraceEventRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EnableTraceEventRequestRef");
                    f.field("events", &self.events());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EnableTraceEventRequestRef<'a>> for EnableTraceEventRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EnableTraceEventRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        events: value.events()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EnableTraceEventRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EnableTraceEventRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Value = ::planus::Offset<EnableTraceEventRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EnableTraceEventRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EnableTraceEventRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/consumer.fbs:47`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `data` in the table `DumpResponse`
                pub data: ::planus::alloc::boxed::Box<self::ConsumerDump>,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<self::ConsumerDump>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::ConsumerDump>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`data` field](DumpResponse#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::ConsumerDump>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerDump>>>
                ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerDump>>>
                ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerDump>>>
                ::planus::WriteAsOffset<DumpResponse> for DumpResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0,) = &self.0;
                    DumpResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`data` field](DumpResponse#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<self::ConsumerDumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.data()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `BaseConsumerDump` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `BaseConsumerDump` in the file `../worker/fbs/consumer.fbs:51`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BaseConsumerDump {
                /// The field `id` in the table `BaseConsumerDump`
                pub id: ::planus::alloc::string::String,
                /// The field `type` in the table `BaseConsumerDump`
                pub type_: super::rtp_parameters::Type,
                /// The field `producer_id` in the table `BaseConsumerDump`
                pub producer_id: ::planus::alloc::string::String,
                /// The field `kind` in the table `BaseConsumerDump`
                pub kind: super::rtp_parameters::MediaKind,
                /// The field `rtp_parameters` in the table `BaseConsumerDump`
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                /// The field `consumable_rtp_encodings` in the table `BaseConsumerDump`
                pub consumable_rtp_encodings:
                    ::planus::alloc::vec::Vec<super::rtp_parameters::RtpEncodingParameters>,
                /// The field `supported_codec_payload_types` in the table `BaseConsumerDump`
                pub supported_codec_payload_types: ::planus::alloc::vec::Vec<u8>,
                /// The field `trace_event_types` in the table `BaseConsumerDump`
                pub trace_event_types: ::planus::alloc::vec::Vec<self::TraceEventType>,
                /// The field `paused` in the table `BaseConsumerDump`
                pub paused: bool,
                /// The field `producer_paused` in the table `BaseConsumerDump`
                pub producer_paused: bool,
                /// The field `priority` in the table `BaseConsumerDump`
                pub priority: u8,
            }

            impl BaseConsumerDump {
                /// Creates a [BaseConsumerDumpBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BaseConsumerDumpBuilder<()> {
                    BaseConsumerDumpBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_consumable_rtp_encodings: impl ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    field_supported_codec_payload_types: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                    field_trace_event_types: impl ::planus::WriteAs<
                        ::planus::Offset<[self::TraceEventType]>,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_producer_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_priority: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::Simple);
                    let prepared_producer_id = field_producer_id.prepare(builder);
                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::Audio);
                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);
                    let prepared_consumable_rtp_encodings =
                        field_consumable_rtp_encodings.prepare(builder);
                    let prepared_supported_codec_payload_types =
                        field_supported_codec_payload_types.prepare(builder);
                    let prepared_trace_event_types = field_trace_event_types.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder, &false);
                    let prepared_producer_paused = field_producer_paused.prepare(builder, &false);
                    let prepared_priority = field_priority.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<26> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    table_writer
                        .write_entry::<::planus::Offset<super::rtp_parameters::RtpParameters>>(4);
                    table_writer.write_entry::<::planus::Offset<
                        [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                    >>(5);
                    table_writer.write_entry::<::planus::Offset<[u8]>>(6);
                    table_writer.write_entry::<::planus::Offset<[self::TraceEventType]>>(7);
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::Type>(1);
                    }
                    if prepared_kind.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::MediaKind>(3);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(8);
                    }
                    if prepared_producer_paused.is_some() {
                        table_writer.write_entry::<bool>(9);
                    }
                    if prepared_priority.is_some() {
                        table_writer.write_entry::<u8>(10);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                            object_writer.write::<_, _, 4>(&prepared_rtp_parameters);
                            object_writer.write::<_, _, 4>(&prepared_consumable_rtp_encodings);
                            object_writer.write::<_, _, 4>(&prepared_supported_codec_payload_types);
                            object_writer.write::<_, _, 4>(&prepared_trace_event_types);
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                                object_writer.write::<_, _, 1>(&prepared_kind);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                            if let ::core::option::Option::Some(prepared_producer_paused) =
                                prepared_producer_paused
                            {
                                object_writer.write::<_, _, 1>(&prepared_producer_paused);
                            }
                            if let ::core::option::Option::Some(prepared_priority) =
                                prepared_priority
                            {
                                object_writer.write::<_, _, 1>(&prepared_priority);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BaseConsumerDump>> for BaseConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BaseConsumerDump>> for BaseConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BaseConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BaseConsumerDump> for BaseConsumerDump {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump> {
                    BaseConsumerDump::create(
                        builder,
                        &self.id,
                        self.type_,
                        &self.producer_id,
                        self.kind,
                        &self.rtp_parameters,
                        &self.consumable_rtp_encodings,
                        &self.supported_codec_payload_types,
                        &self.trace_event_types,
                        self.paused,
                        self.producer_paused,
                        self.priority,
                    )
                }
            }

            /// Builder for serializing an instance of the [BaseConsumerDump] type.
            ///
            /// Can be created using the [BaseConsumerDump::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BaseConsumerDumpBuilder<State>(State);

            impl BaseConsumerDumpBuilder<()> {
                /// Setter for the [`id` field](BaseConsumerDump#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> BaseConsumerDumpBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    BaseConsumerDumpBuilder((value,))
                }
            }

            impl<T0> BaseConsumerDumpBuilder<(T0,)> {
                /// Setter for the [`type` field](BaseConsumerDump#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T1>(self, value: T1) -> BaseConsumerDumpBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                {
                    let (v0,) = self.0;
                    BaseConsumerDumpBuilder((v0, value))
                }

                /// Sets the [`type` field](BaseConsumerDump#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> BaseConsumerDumpBuilder<(T0, ::planus::DefaultValue)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1> BaseConsumerDumpBuilder<(T0, T1)> {
                /// Setter for the [`producer_id` field](BaseConsumerDump#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T2>(self, value: T2) -> BaseConsumerDumpBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> BaseConsumerDumpBuilder<(T0, T1, T2)> {
                /// Setter for the [`kind` field](BaseConsumerDump#structfield.kind).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind<T3>(self, value: T3) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, value))
                }

                /// Sets the [`kind` field](BaseConsumerDump#structfield.kind) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind_as_default(
                    self,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.kind(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> BaseConsumerDumpBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`rtp_parameters` field](BaseConsumerDump#structfield.rtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_parameters<T4>(
                    self,
                    value: T4,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`consumable_rtp_encodings` field](BaseConsumerDump#structfield.consumable_rtp_encodings).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn consumable_rtp_encodings<T5>(
                    self,
                    value: T5,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`supported_codec_payload_types` field](BaseConsumerDump#structfield.supported_codec_payload_types).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn supported_codec_payload_types<T6>(
                    self,
                    value: T6,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`trace_event_types` field](BaseConsumerDump#structfield.trace_event_types).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trace_event_types<T7>(
                    self,
                    value: T7,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`paused` field](BaseConsumerDump#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T8>(
                    self,
                    value: T8,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`paused` field](BaseConsumerDump#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Setter for the [`producer_paused` field](BaseConsumerDump#structfield.producer_paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_paused<T9>(
                    self,
                    value: T9,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`producer_paused` field](BaseConsumerDump#structfield.producer_paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_paused_as_default(
                    self,
                ) -> BaseConsumerDumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    ::planus::DefaultValue,
                )> {
                    self.producer_paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`priority` field](BaseConsumerDump#structfield.priority).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority<T10>(
                    self,
                    value: T10,
                ) -> BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    BaseConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`priority` field](BaseConsumerDump#structfield.priority) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority_as_default(
                    self,
                ) -> BaseConsumerDumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.priority(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BaseConsumerDump].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump>
                where
                    Self: ::planus::WriteAsOffset<BaseConsumerDump>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[u8]>>,
                    T7: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAs<::planus::Offset<BaseConsumerDump>>
                for BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                type Prepared = ::planus::Offset<BaseConsumerDump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[u8]>>,
                    T7: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOptional<::planus::Offset<BaseConsumerDump>>
                for BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                type Prepared = ::planus::Offset<BaseConsumerDump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BaseConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[u8]>>,
                    T7: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOffset<BaseConsumerDump>
                for BaseConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = &self.0;
                    BaseConsumerDump::create(builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10)
                }
            }

            /// Reference to a deserialized [BaseConsumerDump].
            #[derive(Copy, Clone)]
            pub struct BaseConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BaseConsumerDumpRef<'a> {
                /// Getter for the [`id` field](BaseConsumerDump#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "BaseConsumerDump", "id")
                }

                /// Getter for the [`type` field](BaseConsumerDump#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "BaseConsumerDump", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::Simple),
                    )
                }

                /// Getter for the [`producer_id` field](BaseConsumerDump#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "BaseConsumerDump", "producer_id")
                }

                /// Getter for the [`kind` field](BaseConsumerDump#structfield.kind).
                #[inline]
                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "BaseConsumerDump", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::Audio),
                    )
                }

                /// Getter for the [`rtp_parameters` field](BaseConsumerDump#structfield.rtp_parameters).
                #[inline]
                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0
                        .access_required(4, "BaseConsumerDump", "rtp_parameters")
                }

                /// Getter for the [`consumable_rtp_encodings` field](BaseConsumerDump#structfield.consumable_rtp_encodings).
                #[inline]
                pub fn consumable_rtp_encodings(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::planus::Result<super::rtp_parameters::RtpEncodingParametersRef<'a>>,
                    >,
                > {
                    self.0
                        .access_required(5, "BaseConsumerDump", "consumable_rtp_encodings")
                }

                /// Getter for the [`supported_codec_payload_types` field](BaseConsumerDump#structfield.supported_codec_payload_types).
                #[inline]
                pub fn supported_codec_payload_types(&self) -> ::planus::Result<&'a [u8]> {
                    self.0
                        .access_required(6, "BaseConsumerDump", "supported_codec_payload_types")
                }

                /// Getter for the [`trace_event_types` field](BaseConsumerDump#structfield.trace_event_types).
                #[inline]
                pub fn trace_event_types(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::core::result::Result<
                            self::TraceEventType,
                            ::planus::errors::UnknownEnumTag,
                        >,
                    >,
                > {
                    self.0
                        .access_required(7, "BaseConsumerDump", "trace_event_types")
                }

                /// Getter for the [`paused` field](BaseConsumerDump#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "BaseConsumerDump", "paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`producer_paused` field](BaseConsumerDump#structfield.producer_paused).
                #[inline]
                pub fn producer_paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "BaseConsumerDump", "producer_paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`priority` field](BaseConsumerDump#structfield.priority).
                #[inline]
                pub fn priority(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "BaseConsumerDump", "priority")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BaseConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BaseConsumerDumpRef");
                    f.field("id", &self.id());
                    f.field("type_", &self.type_());
                    f.field("producer_id", &self.producer_id());
                    f.field("kind", &self.kind());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("consumable_rtp_encodings", &self.consumable_rtp_encodings());
                    f.field(
                        "supported_codec_payload_types",
                        &self.supported_codec_payload_types(),
                    );
                    f.field("trace_event_types", &self.trace_event_types());
                    f.field("paused", &self.paused());
                    f.field("producer_paused", &self.producer_paused());
                    f.field("priority", &self.priority());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BaseConsumerDumpRef<'a>> for BaseConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BaseConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        consumable_rtp_encodings: value
                            .consumable_rtp_encodings()?
                            .to_vec_result()?,
                        supported_codec_payload_types: value
                            .supported_codec_payload_types()?
                            .to_vec(),
                        trace_event_types: value.trace_event_types()?.to_vec_result()?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        producer_paused: ::core::convert::TryInto::try_into(
                            value.producer_paused()?,
                        )?,
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BaseConsumerDumpRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BaseConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BaseConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BaseConsumerDump>> for BaseConsumerDump {
                type Value = ::planus::Offset<BaseConsumerDump>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BaseConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BaseConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BaseConsumerDumpRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConsumerDump` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `ConsumerDump` in the file `../worker/fbs/consumer.fbs:65`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct ConsumerDump {
                /// The field `base` in the table `ConsumerDump`
                pub base: ::planus::alloc::boxed::Box<self::BaseConsumerDump>,
                /// The field `rtp_streams` in the table `ConsumerDump`
                pub rtp_streams: ::planus::alloc::vec::Vec<super::rtp_stream::Dump>,
                /// The field `preferred_spatial_layer` in the table `ConsumerDump`
                pub preferred_spatial_layer: ::core::option::Option<i16>,
                /// The field `target_spatial_layer` in the table `ConsumerDump`
                pub target_spatial_layer: ::core::option::Option<i16>,
                /// The field `current_spatial_layer` in the table `ConsumerDump`
                pub current_spatial_layer: ::core::option::Option<i16>,
                /// The field `preferred_temporal_layer` in the table `ConsumerDump`
                pub preferred_temporal_layer: ::core::option::Option<i16>,
                /// The field `target_temporal_layer` in the table `ConsumerDump`
                pub target_temporal_layer: ::core::option::Option<i16>,
                /// The field `current_temporal_layer` in the table `ConsumerDump`
                pub current_temporal_layer: ::core::option::Option<i16>,
            }

            impl ConsumerDump {
                /// Creates a [ConsumerDumpBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsumerDumpBuilder<()> {
                    ConsumerDumpBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    field_rtp_streams: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    field_preferred_spatial_layer: impl ::planus::WriteAsOptional<i16>,
                    field_target_spatial_layer: impl ::planus::WriteAsOptional<i16>,
                    field_current_spatial_layer: impl ::planus::WriteAsOptional<i16>,
                    field_preferred_temporal_layer: impl ::planus::WriteAsOptional<i16>,
                    field_target_temporal_layer: impl ::planus::WriteAsOptional<i16>,
                    field_current_temporal_layer: impl ::planus::WriteAsOptional<i16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_rtp_streams = field_rtp_streams.prepare(builder);
                    let prepared_preferred_spatial_layer =
                        field_preferred_spatial_layer.prepare(builder);
                    let prepared_target_spatial_layer = field_target_spatial_layer.prepare(builder);
                    let prepared_current_spatial_layer =
                        field_current_spatial_layer.prepare(builder);
                    let prepared_preferred_temporal_layer =
                        field_preferred_temporal_layer.prepare(builder);
                    let prepared_target_temporal_layer =
                        field_target_temporal_layer.prepare(builder);
                    let prepared_current_temporal_layer =
                        field_current_temporal_layer.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::BaseConsumerDump>>(0);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>>(1);
                    if prepared_preferred_spatial_layer.is_some() {
                        table_writer.write_entry::<i16>(2);
                    }
                    if prepared_target_spatial_layer.is_some() {
                        table_writer.write_entry::<i16>(3);
                    }
                    if prepared_current_spatial_layer.is_some() {
                        table_writer.write_entry::<i16>(4);
                    }
                    if prepared_preferred_temporal_layer.is_some() {
                        table_writer.write_entry::<i16>(5);
                    }
                    if prepared_target_temporal_layer.is_some() {
                        table_writer.write_entry::<i16>(6);
                    }
                    if prepared_current_temporal_layer.is_some() {
                        table_writer.write_entry::<i16>(7);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_rtp_streams);
                            if let ::core::option::Option::Some(prepared_preferred_spatial_layer) =
                                prepared_preferred_spatial_layer
                            {
                                object_writer.write::<_, _, 2>(&prepared_preferred_spatial_layer);
                            }
                            if let ::core::option::Option::Some(prepared_target_spatial_layer) =
                                prepared_target_spatial_layer
                            {
                                object_writer.write::<_, _, 2>(&prepared_target_spatial_layer);
                            }
                            if let ::core::option::Option::Some(prepared_current_spatial_layer) =
                                prepared_current_spatial_layer
                            {
                                object_writer.write::<_, _, 2>(&prepared_current_spatial_layer);
                            }
                            if let ::core::option::Option::Some(prepared_preferred_temporal_layer) =
                                prepared_preferred_temporal_layer
                            {
                                object_writer.write::<_, _, 2>(&prepared_preferred_temporal_layer);
                            }
                            if let ::core::option::Option::Some(prepared_target_temporal_layer) =
                                prepared_target_temporal_layer
                            {
                                object_writer.write::<_, _, 2>(&prepared_target_temporal_layer);
                            }
                            if let ::core::option::Option::Some(prepared_current_temporal_layer) =
                                prepared_current_temporal_layer
                            {
                                object_writer.write::<_, _, 2>(&prepared_current_temporal_layer);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumerDump>> for ConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumerDump>> for ConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumerDump> for ConsumerDump {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerDump> {
                    ConsumerDump::create(
                        builder,
                        &self.base,
                        &self.rtp_streams,
                        self.preferred_spatial_layer,
                        self.target_spatial_layer,
                        self.current_spatial_layer,
                        self.preferred_temporal_layer,
                        self.target_temporal_layer,
                        self.current_temporal_layer,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConsumerDump] type.
            ///
            /// Can be created using the [ConsumerDump::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsumerDumpBuilder<State>(State);

            impl ConsumerDumpBuilder<()> {
                /// Setter for the [`base` field](ConsumerDump#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> ConsumerDumpBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                {
                    ConsumerDumpBuilder((value,))
                }
            }

            impl<T0> ConsumerDumpBuilder<(T0,)> {
                /// Setter for the [`rtp_streams` field](ConsumerDump#structfield.rtp_streams).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_streams<T1>(self, value: T1) -> ConsumerDumpBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                {
                    let (v0,) = self.0;
                    ConsumerDumpBuilder((v0, value))
                }
            }

            impl<T0, T1> ConsumerDumpBuilder<(T0, T1)> {
                /// Setter for the [`preferred_spatial_layer` field](ConsumerDump#structfield.preferred_spatial_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_spatial_layer<T2>(
                    self,
                    value: T2,
                ) -> ConsumerDumpBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<i16>,
                {
                    let (v0, v1) = self.0;
                    ConsumerDumpBuilder((v0, v1, value))
                }

                /// Sets the [`preferred_spatial_layer` field](ConsumerDump#structfield.preferred_spatial_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_spatial_layer_as_null(self) -> ConsumerDumpBuilder<(T0, T1, ())> {
                    self.preferred_spatial_layer(())
                }
            }

            impl<T0, T1, T2> ConsumerDumpBuilder<(T0, T1, T2)> {
                /// Setter for the [`target_spatial_layer` field](ConsumerDump#structfield.target_spatial_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn target_spatial_layer<T3>(
                    self,
                    value: T3,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<i16>,
                {
                    let (v0, v1, v2) = self.0;
                    ConsumerDumpBuilder((v0, v1, v2, value))
                }

                /// Sets the [`target_spatial_layer` field](ConsumerDump#structfield.target_spatial_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn target_spatial_layer_as_null(self) -> ConsumerDumpBuilder<(T0, T1, T2, ())> {
                    self.target_spatial_layer(())
                }
            }

            impl<T0, T1, T2, T3> ConsumerDumpBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`current_spatial_layer` field](ConsumerDump#structfield.current_spatial_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn current_spatial_layer<T4>(
                    self,
                    value: T4,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<i16>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ConsumerDumpBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`current_spatial_layer` field](ConsumerDump#structfield.current_spatial_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn current_spatial_layer_as_null(
                    self,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, ())> {
                    self.current_spatial_layer(())
                }
            }

            impl<T0, T1, T2, T3, T4> ConsumerDumpBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`preferred_temporal_layer` field](ConsumerDump#structfield.preferred_temporal_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_temporal_layer<T5>(
                    self,
                    value: T5,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<i16>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ConsumerDumpBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`preferred_temporal_layer` field](ConsumerDump#structfield.preferred_temporal_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_temporal_layer_as_null(
                    self,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.preferred_temporal_layer(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`target_temporal_layer` field](ConsumerDump#structfield.target_temporal_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn target_temporal_layer<T6>(
                    self,
                    value: T6,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsOptional<i16>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    ConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`target_temporal_layer` field](ConsumerDump#structfield.target_temporal_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn target_temporal_layer_as_null(
                    self,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, ())> {
                    self.target_temporal_layer(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`current_temporal_layer` field](ConsumerDump#structfield.current_temporal_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn current_temporal_layer<T7>(
                    self,
                    value: T7,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsOptional<i16>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    ConsumerDumpBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`current_temporal_layer` field](ConsumerDump#structfield.current_temporal_layer) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn current_temporal_layer_as_null(
                    self,
                ) -> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, ())> {
                    self.current_temporal_layer(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsumerDump].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerDump>
                where
                    Self: ::planus::WriteAsOffset<ConsumerDump>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    T2: ::planus::WriteAsOptional<i16>,
                    T3: ::planus::WriteAsOptional<i16>,
                    T4: ::planus::WriteAsOptional<i16>,
                    T5: ::planus::WriteAsOptional<i16>,
                    T6: ::planus::WriteAsOptional<i16>,
                    T7: ::planus::WriteAsOptional<i16>,
                > ::planus::WriteAs<::planus::Offset<ConsumerDump>>
                for ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<ConsumerDump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    T2: ::planus::WriteAsOptional<i16>,
                    T3: ::planus::WriteAsOptional<i16>,
                    T4: ::planus::WriteAsOptional<i16>,
                    T5: ::planus::WriteAsOptional<i16>,
                    T6: ::planus::WriteAsOptional<i16>,
                    T7: ::planus::WriteAsOptional<i16>,
                > ::planus::WriteAsOptional<::planus::Offset<ConsumerDump>>
                for ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<ConsumerDump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    T2: ::planus::WriteAsOptional<i16>,
                    T3: ::planus::WriteAsOptional<i16>,
                    T4: ::planus::WriteAsOptional<i16>,
                    T5: ::planus::WriteAsOptional<i16>,
                    T6: ::planus::WriteAsOptional<i16>,
                    T7: ::planus::WriteAsOptional<i16>,
                > ::planus::WriteAsOffset<ConsumerDump>
                for ConsumerDumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerDump> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    ConsumerDump::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [ConsumerDump].
            #[derive(Copy, Clone)]
            pub struct ConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumerDumpRef<'a> {
                /// Getter for the [`base` field](ConsumerDump#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<self::BaseConsumerDumpRef<'a>> {
                    self.0.access_required(0, "ConsumerDump", "base")
                }

                /// Getter for the [`rtp_streams` field](ConsumerDump#structfield.rtp_streams).
                #[inline]
                pub fn rtp_streams(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::rtp_stream::DumpRef<'a>>>,
                > {
                    self.0.access_required(1, "ConsumerDump", "rtp_streams")
                }

                /// Getter for the [`preferred_spatial_layer` field](ConsumerDump#structfield.preferred_spatial_layer).
                #[inline]
                pub fn preferred_spatial_layer(
                    &self,
                ) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(2, "ConsumerDump", "preferred_spatial_layer")
                }

                /// Getter for the [`target_spatial_layer` field](ConsumerDump#structfield.target_spatial_layer).
                #[inline]
                pub fn target_spatial_layer(
                    &self,
                ) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(3, "ConsumerDump", "target_spatial_layer")
                }

                /// Getter for the [`current_spatial_layer` field](ConsumerDump#structfield.current_spatial_layer).
                #[inline]
                pub fn current_spatial_layer(
                    &self,
                ) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(4, "ConsumerDump", "current_spatial_layer")
                }

                /// Getter for the [`preferred_temporal_layer` field](ConsumerDump#structfield.preferred_temporal_layer).
                #[inline]
                pub fn preferred_temporal_layer(
                    &self,
                ) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(5, "ConsumerDump", "preferred_temporal_layer")
                }

                /// Getter for the [`target_temporal_layer` field](ConsumerDump#structfield.target_temporal_layer).
                #[inline]
                pub fn target_temporal_layer(
                    &self,
                ) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(6, "ConsumerDump", "target_temporal_layer")
                }

                /// Getter for the [`current_temporal_layer` field](ConsumerDump#structfield.current_temporal_layer).
                #[inline]
                pub fn current_temporal_layer(
                    &self,
                ) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(7, "ConsumerDump", "current_temporal_layer")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumerDumpRef");
                    f.field("base", &self.base());
                    f.field("rtp_streams", &self.rtp_streams());
                    if let ::core::option::Option::Some(field_preferred_spatial_layer) =
                        self.preferred_spatial_layer().transpose()
                    {
                        f.field("preferred_spatial_layer", &field_preferred_spatial_layer);
                    }
                    if let ::core::option::Option::Some(field_target_spatial_layer) =
                        self.target_spatial_layer().transpose()
                    {
                        f.field("target_spatial_layer", &field_target_spatial_layer);
                    }
                    if let ::core::option::Option::Some(field_current_spatial_layer) =
                        self.current_spatial_layer().transpose()
                    {
                        f.field("current_spatial_layer", &field_current_spatial_layer);
                    }
                    if let ::core::option::Option::Some(field_preferred_temporal_layer) =
                        self.preferred_temporal_layer().transpose()
                    {
                        f.field("preferred_temporal_layer", &field_preferred_temporal_layer);
                    }
                    if let ::core::option::Option::Some(field_target_temporal_layer) =
                        self.target_temporal_layer().transpose()
                    {
                        f.field("target_temporal_layer", &field_target_temporal_layer);
                    }
                    if let ::core::option::Option::Some(field_current_temporal_layer) =
                        self.current_temporal_layer().transpose()
                    {
                        f.field("current_temporal_layer", &field_current_temporal_layer);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumerDumpRef<'a>> for ConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtp_streams: value.rtp_streams()?.to_vec_result()?,
                        preferred_spatial_layer: if let ::core::option::Option::Some(
                            preferred_spatial_layer,
                        ) = value.preferred_spatial_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                preferred_spatial_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        target_spatial_layer: if let ::core::option::Option::Some(
                            target_spatial_layer,
                        ) = value.target_spatial_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                target_spatial_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        current_spatial_layer: if let ::core::option::Option::Some(
                            current_spatial_layer,
                        ) = value.current_spatial_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                current_spatial_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        preferred_temporal_layer: if let ::core::option::Option::Some(
                            preferred_temporal_layer,
                        ) = value.preferred_temporal_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                preferred_temporal_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        target_temporal_layer: if let ::core::option::Option::Some(
                            target_temporal_layer,
                        ) = value.target_temporal_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                target_temporal_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        current_temporal_layer: if let ::core::option::Option::Some(
                            current_temporal_layer,
                        ) = value.current_temporal_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                current_temporal_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumerDumpRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumerDump>> for ConsumerDump {
                type Value = ::planus::Offset<ConsumerDump>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumerDumpRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/consumer.fbs:76`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `stats` in the table `GetStatsResponse`
                pub stats: ::planus::alloc::vec::Vec<super::rtp_stream::Stats>,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stats: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_stats = field_stats.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_stats);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.stats)
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`stats` field](GetStatsResponse#structfield.stats).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn stats<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                {
                    GetStatsResponseBuilder((value,))
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                > ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0,) = &self.0;
                    GetStatsResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`stats` field](GetStatsResponse#structfield.stats).
                #[inline]
                pub fn stats(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::rtp_stream::StatsRef<'a>>>,
                > {
                    self.0.access_required(0, "GetStatsResponse", "stats")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("stats", &self.stats());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stats: value.stats()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `LayersChangeNotification` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `LayersChangeNotification` in the file `../worker/fbs/consumer.fbs:82`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct LayersChangeNotification {
                /// The field `layers` in the table `LayersChangeNotification`
                pub layers: ::planus::alloc::boxed::Box<self::ConsumerLayers>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for LayersChangeNotification {
                fn default() -> Self {
                    Self {
                        layers: ::core::default::Default::default(),
                    }
                }
            }

            impl LayersChangeNotification {
                /// Creates a [LayersChangeNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> LayersChangeNotificationBuilder<()> {
                    LayersChangeNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_layers: impl ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_layers = field_layers.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::ConsumerLayers>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_layers);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<LayersChangeNotification>> for LayersChangeNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<LayersChangeNotification>>
                for LayersChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<LayersChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<LayersChangeNotification> for LayersChangeNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification> {
                    LayersChangeNotification::create(builder, &self.layers)
                }
            }

            /// Builder for serializing an instance of the [LayersChangeNotification] type.
            ///
            /// Can be created using the [LayersChangeNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct LayersChangeNotificationBuilder<State>(State);

            impl LayersChangeNotificationBuilder<()> {
                /// Setter for the [`layers` field](LayersChangeNotification#structfield.layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn layers<T0>(self, value: T0) -> LayersChangeNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>,
                {
                    LayersChangeNotificationBuilder((value,))
                }
            }

            impl<T0> LayersChangeNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [LayersChangeNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification>
                where
                    Self: ::planus::WriteAsOffset<LayersChangeNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAs<::planus::Offset<LayersChangeNotification>>
                for LayersChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<LayersChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAsOptional<::planus::Offset<LayersChangeNotification>>
                for LayersChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<LayersChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<LayersChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerLayers>>>
                ::planus::WriteAsOffset<LayersChangeNotification>
                for LayersChangeNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification> {
                    let (v0,) = &self.0;
                    LayersChangeNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [LayersChangeNotification].
            #[derive(Copy, Clone)]
            pub struct LayersChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> LayersChangeNotificationRef<'a> {
                /// Getter for the [`layers` field](LayersChangeNotification#structfield.layers).
                #[inline]
                pub fn layers(&self) -> ::planus::Result<self::ConsumerLayersRef<'a>> {
                    self.0
                        .access_required(0, "LayersChangeNotification", "layers")
                }
            }

            impl<'a> ::core::fmt::Debug for LayersChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("LayersChangeNotificationRef");
                    f.field("layers", &self.layers());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<LayersChangeNotificationRef<'a>> for LayersChangeNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: LayersChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        layers: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.layers()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for LayersChangeNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for LayersChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[LayersChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<LayersChangeNotification>>
                for LayersChangeNotification
            {
                type Value = ::planus::Offset<LayersChangeNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<LayersChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for LayersChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[LayersChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `RtpNotification` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `RtpNotification` in the file `../worker/fbs/consumer.fbs:86`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpNotification {
                /// The field `data` in the table `RtpNotification`
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl RtpNotification {
                /// Creates a [RtpNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpNotificationBuilder<()> {
                    RtpNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpNotification>> for RtpNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpNotification>> for RtpNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpNotification> for RtpNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification> {
                    RtpNotification::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [RtpNotification] type.
            ///
            /// Can be created using the [RtpNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpNotificationBuilder<State>(State);

            impl RtpNotificationBuilder<()> {
                /// Setter for the [`data` field](RtpNotification#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> RtpNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    RtpNotificationBuilder((value,))
                }
            }

            impl<T0> RtpNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification>
                where
                    Self: ::planus::WriteAsOffset<RtpNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAs<::planus::Offset<RtpNotification>>
                for RtpNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtpNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOptional<::planus::Offset<RtpNotification>>
                for RtpNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtpNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOffset<RtpNotification> for RtpNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification> {
                    let (v0,) = &self.0;
                    RtpNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RtpNotification].
            #[derive(Copy, Clone)]
            pub struct RtpNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpNotificationRef<'a> {
                /// Getter for the [`data` field](RtpNotification#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(0, "RtpNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpNotificationRef<'a>> for RtpNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpNotification>> for RtpNotification {
                type Value = ::planus::Offset<RtpNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ScoreNotification` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `ScoreNotification` in the file `../worker/fbs/consumer.fbs:90`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ScoreNotification {
                /// The field `score` in the table `ScoreNotification`
                pub score: ::planus::alloc::boxed::Box<self::ConsumerScore>,
            }

            impl ScoreNotification {
                /// Creates a [ScoreNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ScoreNotificationBuilder<()> {
                    ScoreNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_score: impl ::planus::WriteAs<::planus::Offset<self::ConsumerScore>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_score = field_score.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::ConsumerScore>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_score);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScoreNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ScoreNotification> for ScoreNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ScoreNotification::create(builder, &self.score)
                }
            }

            /// Builder for serializing an instance of the [ScoreNotification] type.
            ///
            /// Can be created using the [ScoreNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ScoreNotificationBuilder<State>(State);

            impl ScoreNotificationBuilder<()> {
                /// Setter for the [`score` field](ScoreNotification#structfield.score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score<T0>(self, value: T0) -> ScoreNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::ConsumerScore>>,
                {
                    ScoreNotificationBuilder((value,))
                }
            }

            impl<T0> ScoreNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ScoreNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification>
                where
                    Self: ::planus::WriteAsOffset<ScoreNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerScore>>>
                ::planus::WriteAs<::planus::Offset<ScoreNotification>>
                for ScoreNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ScoreNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerScore>>>
                ::planus::WriteAsOptional<::planus::Offset<ScoreNotification>>
                for ScoreNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ScoreNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScoreNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::ConsumerScore>>>
                ::planus::WriteAsOffset<ScoreNotification> for ScoreNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    let (v0,) = &self.0;
                    ScoreNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ScoreNotification].
            #[derive(Copy, Clone)]
            pub struct ScoreNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScoreNotificationRef<'a> {
                /// Getter for the [`score` field](ScoreNotification#structfield.score).
                #[inline]
                pub fn score(&self) -> ::planus::Result<self::ConsumerScoreRef<'a>> {
                    self.0.access_required(0, "ScoreNotification", "score")
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreNotificationRef");
                    f.field("score", &self.score());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScoreNotificationRef<'a>> for ScoreNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScoreNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        score: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.score()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScoreNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScoreNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Value = ::planus::Offset<ScoreNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ScoreNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScoreNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ScoreNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `TraceInfo` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Union `TraceInfo` in the file `../worker/fbs/consumer.fbs:94`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum TraceInfo {
                /// The variant of type `KeyFrameTraceInfo` in the union `TraceInfo`
                KeyFrameTraceInfo(::planus::alloc::boxed::Box<self::KeyFrameTraceInfo>),

                /// The variant of type `FirTraceInfo` in the union `TraceInfo`
                FirTraceInfo(::planus::alloc::boxed::Box<self::FirTraceInfo>),

                /// The variant of type `PliTraceInfo` in the union `TraceInfo`
                PliTraceInfo(::planus::alloc::boxed::Box<self::PliTraceInfo>),

                /// The variant of type `RtpTraceInfo` in the union `TraceInfo`
                RtpTraceInfo(::planus::alloc::boxed::Box<self::RtpTraceInfo>),
            }

            impl TraceInfo {
                /// Creates a [TraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TraceInfoBuilder<::planus::Uninitialized> {
                    TraceInfoBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_key_frame_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_fir_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::FirTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_pli_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PliTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_rtp_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RtpTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<TraceInfo> for TraceInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::KeyFrameTraceInfo(value) => {
                            Self::create_key_frame_trace_info(builder, value)
                        }
                        Self::FirTraceInfo(value) => Self::create_fir_trace_info(builder, value),
                        Self::PliTraceInfo(value) => Self::create_pli_trace_info(builder, value),
                        Self::RtpTraceInfo(value) => Self::create_rtp_trace_info(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [TraceInfo] type.
            ///
            /// Can be created using the [TraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TraceInfoBuilder<T>(T);

            impl TraceInfoBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`KeyFrameTraceInfo` variant](TraceInfo#variant.KeyFrameTraceInfo).
                #[inline]
                pub fn key_frame_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`FirTraceInfo` variant](TraceInfo#variant.FirTraceInfo).
                #[inline]
                pub fn fir_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::FirTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PliTraceInfo` variant](TraceInfo#variant.PliTraceInfo).
                #[inline]
                pub fn pli_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::PliTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`RtpTraceInfo` variant](TraceInfo#variant.RtpTraceInfo).
                #[inline]
                pub fn rtp_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<self::RtpTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> TraceInfoBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [TraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo>
                where
                    Self: ::planus::WriteAsUnion<TraceInfo>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::FirTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::FirTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::PliTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::PliTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::RtpTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::RtpTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [TraceInfo].
            #[derive(Copy, Clone, Debug)]
            pub enum TraceInfoRef<'a> {
                KeyFrameTraceInfo(self::KeyFrameTraceInfoRef<'a>),
                FirTraceInfo(self::FirTraceInfoRef<'a>),
                PliTraceInfo(self::PliTraceInfoRef<'a>),
                RtpTraceInfo(self::RtpTraceInfoRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<TraceInfoRef<'a>> for TraceInfo {
                type Error = ::planus::Error;

                fn try_from(value: TraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        TraceInfoRef::KeyFrameTraceInfo(value) => {
                            Self::KeyFrameTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::FirTraceInfo(value) => {
                            Self::FirTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::PliTraceInfo(value) => {
                            Self::PliTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::RtpTraceInfo(value) => {
                            Self::RtpTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for TraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::KeyFrameTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::FirTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::PliTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::RtpTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `KeyFrameTraceInfo` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `KeyFrameTraceInfo` in the file `../worker/fbs/consumer.fbs:101`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct KeyFrameTraceInfo {
                /// The field `rtp_packet` in the table `KeyFrameTraceInfo`
                pub rtp_packet: ::planus::alloc::boxed::Box<super::rtp_packet::Dump>,
                /// The field `is_rtx` in the table `KeyFrameTraceInfo`
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for KeyFrameTraceInfo {
                fn default() -> Self {
                    Self {
                        rtp_packet: ::core::default::Default::default(),
                        is_rtx: false,
                    }
                }
            }

            impl KeyFrameTraceInfo {
                /// Creates a [KeyFrameTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> KeyFrameTraceInfoBuilder<()> {
                    KeyFrameTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_packet: impl ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_packet = field_rtp_packet.prepare(builder);
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::rtp_packet::Dump>>(0);
                    if prepared_is_rtx.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_packet);
                            if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                                object_writer.write::<_, _, 1>(&prepared_is_rtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<KeyFrameTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<KeyFrameTraceInfo> for KeyFrameTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    KeyFrameTraceInfo::create(builder, &self.rtp_packet, self.is_rtx)
                }
            }

            /// Builder for serializing an instance of the [KeyFrameTraceInfo] type.
            ///
            /// Can be created using the [KeyFrameTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct KeyFrameTraceInfoBuilder<State>(State);

            impl KeyFrameTraceInfoBuilder<()> {
                /// Setter for the [`rtp_packet` field](KeyFrameTraceInfo#structfield.rtp_packet).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet<T0>(self, value: T0) -> KeyFrameTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                {
                    KeyFrameTraceInfoBuilder((value,))
                }
            }

            impl<T0> KeyFrameTraceInfoBuilder<(T0,)> {
                /// Setter for the [`is_rtx` field](KeyFrameTraceInfo#structfield.is_rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx<T1>(self, value: T1) -> KeyFrameTraceInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    KeyFrameTraceInfoBuilder((v0, value))
                }

                /// Sets the [`is_rtx` field](KeyFrameTraceInfo#structfield.is_rtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx_as_default(
                    self,
                ) -> KeyFrameTraceInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.is_rtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1> KeyFrameTraceInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [KeyFrameTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<KeyFrameTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<KeyFrameTraceInfo>>
                for KeyFrameTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<KeyFrameTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<KeyFrameTraceInfo>>
                for KeyFrameTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<KeyFrameTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<KeyFrameTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<KeyFrameTraceInfo>
                for KeyFrameTraceInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    let (v0, v1) = &self.0;
                    KeyFrameTraceInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [KeyFrameTraceInfo].
            #[derive(Copy, Clone)]
            pub struct KeyFrameTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> KeyFrameTraceInfoRef<'a> {
                /// Getter for the [`rtp_packet` field](KeyFrameTraceInfo#structfield.rtp_packet).
                #[inline]
                pub fn rtp_packet(&self) -> ::planus::Result<super::rtp_packet::DumpRef<'a>> {
                    self.0.access_required(0, "KeyFrameTraceInfo", "rtp_packet")
                }

                /// Getter for the [`is_rtx` field](KeyFrameTraceInfo#structfield.is_rtx).
                #[inline]
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "KeyFrameTraceInfo", "is_rtx")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for KeyFrameTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("KeyFrameTraceInfoRef");
                    f.field("rtp_packet", &self.rtp_packet());
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<KeyFrameTraceInfoRef<'a>> for KeyFrameTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: KeyFrameTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_packet: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_packet()?)?,
                        ),
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for KeyFrameTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for KeyFrameTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[KeyFrameTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Value = ::planus::Offset<KeyFrameTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<KeyFrameTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for KeyFrameTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[KeyFrameTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `FirTraceInfo` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `FirTraceInfo` in the file `../worker/fbs/consumer.fbs:106`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct FirTraceInfo {
                /// The field `ssrc` in the table `FirTraceInfo`
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for FirTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl FirTraceInfo {
                /// Creates a [FirTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> FirTraceInfoBuilder<()> {
                    FirTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FirTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<FirTraceInfo> for FirTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    FirTraceInfo::create(builder, self.ssrc)
                }
            }

            /// Builder for serializing an instance of the [FirTraceInfo] type.
            ///
            /// Can be created using the [FirTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct FirTraceInfoBuilder<State>(State);

            impl FirTraceInfoBuilder<()> {
                /// Setter for the [`ssrc` field](FirTraceInfo#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> FirTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    FirTraceInfoBuilder((value,))
                }

                /// Sets the [`ssrc` field](FirTraceInfo#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> FirTraceInfoBuilder<(::planus::DefaultValue,)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0> FirTraceInfoBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [FirTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<FirTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<FirTraceInfo>> for FirTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<FirTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<FirTraceInfo>>
                for FirTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<FirTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FirTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>> ::planus::WriteAsOffset<FirTraceInfo>
                for FirTraceInfoBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    let (v0,) = &self.0;
                    FirTraceInfo::create(builder, v0)
                }
            }

            /// Reference to a deserialized [FirTraceInfo].
            #[derive(Copy, Clone)]
            pub struct FirTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FirTraceInfoRef<'a> {
                /// Getter for the [`ssrc` field](FirTraceInfo#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "FirTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for FirTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FirTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FirTraceInfoRef<'a>> for FirTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FirTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FirTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FirTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FirTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Value = ::planus::Offset<FirTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<FirTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FirTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FirTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `PliTraceInfo` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `PliTraceInfo` in the file `../worker/fbs/consumer.fbs:110`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PliTraceInfo {
                /// The field `ssrc` in the table `PliTraceInfo`
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PliTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl PliTraceInfo {
                /// Creates a [PliTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PliTraceInfoBuilder<()> {
                    PliTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PliTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PliTraceInfo> for PliTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    PliTraceInfo::create(builder, self.ssrc)
                }
            }

            /// Builder for serializing an instance of the [PliTraceInfo] type.
            ///
            /// Can be created using the [PliTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PliTraceInfoBuilder<State>(State);

            impl PliTraceInfoBuilder<()> {
                /// Setter for the [`ssrc` field](PliTraceInfo#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> PliTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    PliTraceInfoBuilder((value,))
                }

                /// Sets the [`ssrc` field](PliTraceInfo#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> PliTraceInfoBuilder<(::planus::DefaultValue,)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0> PliTraceInfoBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PliTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<PliTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<PliTraceInfo>> for PliTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<PliTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<PliTraceInfo>>
                for PliTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<PliTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PliTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>> ::planus::WriteAsOffset<PliTraceInfo>
                for PliTraceInfoBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    let (v0,) = &self.0;
                    PliTraceInfo::create(builder, v0)
                }
            }

            /// Reference to a deserialized [PliTraceInfo].
            #[derive(Copy, Clone)]
            pub struct PliTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PliTraceInfoRef<'a> {
                /// Getter for the [`ssrc` field](PliTraceInfo#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "PliTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PliTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PliTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PliTraceInfoRef<'a>> for PliTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PliTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PliTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PliTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PliTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Value = ::planus::Offset<PliTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PliTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PliTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PliTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpTraceInfo` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `RtpTraceInfo` in the file `../worker/fbs/consumer.fbs:114`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpTraceInfo {
                /// The field `rtp_packet` in the table `RtpTraceInfo`
                pub rtp_packet: ::planus::alloc::boxed::Box<super::rtp_packet::Dump>,
                /// The field `is_rtx` in the table `RtpTraceInfo`
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpTraceInfo {
                fn default() -> Self {
                    Self {
                        rtp_packet: ::core::default::Default::default(),
                        is_rtx: false,
                    }
                }
            }

            impl RtpTraceInfo {
                /// Creates a [RtpTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpTraceInfoBuilder<()> {
                    RtpTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_packet: impl ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_packet = field_rtp_packet.prepare(builder);
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::rtp_packet::Dump>>(0);
                    if prepared_is_rtx.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_packet);
                            if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                                object_writer.write::<_, _, 1>(&prepared_is_rtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpTraceInfo> for RtpTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    RtpTraceInfo::create(builder, &self.rtp_packet, self.is_rtx)
                }
            }

            /// Builder for serializing an instance of the [RtpTraceInfo] type.
            ///
            /// Can be created using the [RtpTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpTraceInfoBuilder<State>(State);

            impl RtpTraceInfoBuilder<()> {
                /// Setter for the [`rtp_packet` field](RtpTraceInfo#structfield.rtp_packet).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet<T0>(self, value: T0) -> RtpTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                {
                    RtpTraceInfoBuilder((value,))
                }
            }

            impl<T0> RtpTraceInfoBuilder<(T0,)> {
                /// Setter for the [`is_rtx` field](RtpTraceInfo#structfield.is_rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx<T1>(self, value: T1) -> RtpTraceInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    RtpTraceInfoBuilder((v0, value))
                }

                /// Sets the [`is_rtx` field](RtpTraceInfo#structfield.is_rtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx_as_default(
                    self,
                ) -> RtpTraceInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.is_rtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RtpTraceInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<RtpTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<RtpTraceInfo>>
                for RtpTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtpTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<RtpTraceInfo>>
                for RtpTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtpTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<RtpTraceInfo> for RtpTraceInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    let (v0, v1) = &self.0;
                    RtpTraceInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RtpTraceInfo].
            #[derive(Copy, Clone)]
            pub struct RtpTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpTraceInfoRef<'a> {
                /// Getter for the [`rtp_packet` field](RtpTraceInfo#structfield.rtp_packet).
                #[inline]
                pub fn rtp_packet(&self) -> ::planus::Result<super::rtp_packet::DumpRef<'a>> {
                    self.0.access_required(0, "RtpTraceInfo", "rtp_packet")
                }

                /// Getter for the [`is_rtx` field](RtpTraceInfo#structfield.is_rtx).
                #[inline]
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "RtpTraceInfo", "is_rtx")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RtpTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpTraceInfoRef");
                    f.field("rtp_packet", &self.rtp_packet());
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpTraceInfoRef<'a>> for RtpTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_packet: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_packet()?)?,
                        ),
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Value = ::planus::Offset<RtpTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `TraceNotification` in the namespace `FBS.Consumer`
            ///
            /// Generated from these locations:
            /// * Table `TraceNotification` in the file `../worker/fbs/consumer.fbs:119`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TraceNotification {
                /// The field `type` in the table `TraceNotification`
                pub type_: self::TraceEventType,
                /// The field `timestamp` in the table `TraceNotification`
                pub timestamp: u64,
                /// The field `direction` in the table `TraceNotification`
                pub direction: super::common::TraceDirection,
                /// The field `info` in the table `TraceNotification`
                pub info: ::core::option::Option<self::TraceInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for TraceNotification {
                fn default() -> Self {
                    Self {
                        type_: self::TraceEventType::Keyframe,
                        timestamp: 0,
                        direction: super::common::TraceDirection::DirectionIn,
                        info: ::core::default::Default::default(),
                    }
                }
            }

            impl TraceNotification {
                /// Creates a [TraceNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TraceNotificationBuilder<()> {
                    TraceNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<
                        self::TraceEventType,
                        self::TraceEventType,
                    >,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_direction: impl ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    field_info: impl ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ =
                        field_type_.prepare(builder, &self::TraceEventType::Keyframe);
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_direction = field_direction
                        .prepare(builder, &super::common::TraceDirection::DirectionIn);
                    let prepared_info = field_info.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(1);
                    }
                    if prepared_info.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::TraceInfo>>(4);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<self::TraceEventType>(0);
                    }
                    if prepared_direction.is_some() {
                        table_writer.write_entry::<super::common::TraceDirection>(2);
                    }
                    if prepared_info.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_info) = prepared_info {
                                object_writer.write::<_, _, 4>(&prepared_info.offset());
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_direction) =
                                prepared_direction
                            {
                                object_writer.write::<_, _, 1>(&prepared_direction);
                            }
                            if let ::core::option::Option::Some(prepared_info) = prepared_info {
                                object_writer.write::<_, _, 1>(&prepared_info.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TraceNotification> for TraceNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    TraceNotification::create(
                        builder,
                        self.type_,
                        self.timestamp,
                        self.direction,
                        &self.info,
                    )
                }
            }

            /// Builder for serializing an instance of the [TraceNotification] type.
            ///
            /// Can be created using the [TraceNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TraceNotificationBuilder<State>(State);

            impl TraceNotificationBuilder<()> {
                /// Setter for the [`type` field](TraceNotification#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T0>(self, value: T0) -> TraceNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                {
                    TraceNotificationBuilder((value,))
                }

                /// Sets the [`type` field](TraceNotification#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> TraceNotificationBuilder<(::planus::DefaultValue,)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0> TraceNotificationBuilder<(T0,)> {
                /// Setter for the [`timestamp` field](TraceNotification#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T1>(self, value: T1) -> TraceNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0,) = self.0;
                    TraceNotificationBuilder((v0, value))
                }

                /// Sets the [`timestamp` field](TraceNotification#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(
                    self,
                ) -> TraceNotificationBuilder<(T0, ::planus::DefaultValue)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0, T1> TraceNotificationBuilder<(T0, T1)> {
                /// Setter for the [`direction` field](TraceNotification#structfield.direction).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction<T2>(self, value: T2) -> TraceNotificationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                {
                    let (v0, v1) = self.0;
                    TraceNotificationBuilder((v0, v1, value))
                }

                /// Sets the [`direction` field](TraceNotification#structfield.direction) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction_as_default(
                    self,
                ) -> TraceNotificationBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.direction(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> TraceNotificationBuilder<(T0, T1, T2)> {
                /// Setter for the [`info` field](TraceNotification#structfield.info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn info<T3>(self, value: T3) -> TraceNotificationBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                {
                    let (v0, v1, v2) = self.0;
                    TraceNotificationBuilder((v0, v1, v2, value))
                }

                /// Sets the [`info` field](TraceNotification#structfield.info) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn info_as_null(self) -> TraceNotificationBuilder<(T0, T1, T2, ())> {
                    self.info(())
                }
            }

            impl<T0, T1, T2, T3> TraceNotificationBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TraceNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification>
                where
                    Self: ::planus::WriteAsOffset<TraceNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAs<::planus::Offset<TraceNotification>>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<TraceNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAsOptional<::planus::Offset<TraceNotification>>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<TraceNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAsOffset<TraceNotification>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    let (v0, v1, v2, v3) = &self.0;
                    TraceNotification::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [TraceNotification].
            #[derive(Copy, Clone)]
            pub struct TraceNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TraceNotificationRef<'a> {
                /// Getter for the [`type` field](TraceNotification#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<self::TraceEventType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TraceNotification", "type_")?
                            .unwrap_or(self::TraceEventType::Keyframe),
                    )
                }

                /// Getter for the [`timestamp` field](TraceNotification#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "TraceNotification", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`direction` field](TraceNotification#structfield.direction).
                #[inline]
                pub fn direction(&self) -> ::planus::Result<super::common::TraceDirection> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "TraceNotification", "direction")?
                            .unwrap_or(super::common::TraceDirection::DirectionIn),
                    )
                }

                /// Getter for the [`info` field](TraceNotification#structfield.info).
                #[inline]
                pub fn info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TraceInfoRef<'a>>>
                {
                    self.0.access_union(3, "TraceNotification", "info")
                }
            }

            impl<'a> ::core::fmt::Debug for TraceNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TraceNotificationRef");
                    f.field("type_", &self.type_());
                    f.field("timestamp", &self.timestamp());
                    f.field("direction", &self.direction());
                    if let ::core::option::Option::Some(field_info) = self.info().transpose() {
                        f.field("info", &field_info);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TraceNotificationRef<'a>> for TraceNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TraceNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        direction: ::core::convert::TryInto::try_into(value.direction()?)?,
                        info: if let ::core::option::Option::Some(info) = value.info()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(info)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TraceNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TraceNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TraceNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TraceNotification>> for TraceNotification {
                type Value = ::planus::Offset<TraceNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TraceNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TraceNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TraceNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.RtpPacket`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/rtpPacket.fbs`
        pub mod rtp_packet {
            /// The table `Dump` in the namespace `FBS.RtpPacket`
            ///
            /// Generated from these locations:
            /// * Table `Dump` in the file `../worker/fbs/rtpPacket.fbs:5`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Dump {
                /// The field `payload_type` in the table `Dump`
                pub payload_type: u8,
                /// The field `sequence_number` in the table `Dump`
                pub sequence_number: u16,
                /// The field `timestamp` in the table `Dump`
                pub timestamp: u32,
                /// The field `marker` in the table `Dump`
                pub marker: bool,
                /// The field `ssrc` in the table `Dump`
                pub ssrc: u32,
                /// The field `is_key_frame` in the table `Dump`
                pub is_key_frame: bool,
                /// The field `size` in the table `Dump`
                pub size: u64,
                /// The field `payload_size` in the table `Dump`
                pub payload_size: u64,
                /// The field `spatial_layer` in the table `Dump`
                pub spatial_layer: u8,
                /// The field `temporal_layer` in the table `Dump`
                pub temporal_layer: u8,
                /// The field `mid` in the table `Dump`
                pub mid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `rid` in the table `Dump`
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `rrid` in the table `Dump`
                pub rrid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `wide_sequence_number` in the table `Dump`
                pub wide_sequence_number: ::core::option::Option<u16>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Dump {
                fn default() -> Self {
                    Self {
                        payload_type: 0,
                        sequence_number: 0,
                        timestamp: 0,
                        marker: false,
                        ssrc: 0,
                        is_key_frame: false,
                        size: 0,
                        payload_size: 0,
                        spatial_layer: 0,
                        temporal_layer: 0,
                        mid: ::core::default::Default::default(),
                        rid: ::core::default::Default::default(),
                        rrid: ::core::default::Default::default(),
                        wide_sequence_number: ::core::default::Default::default(),
                    }
                }
            }

            impl Dump {
                /// Creates a [DumpBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpBuilder<()> {
                    DumpBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_sequence_number: impl ::planus::WriteAsDefault<u16, u16>,
                    field_timestamp: impl ::planus::WriteAsDefault<u32, u32>,
                    field_marker: impl ::planus::WriteAsDefault<bool, bool>,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_is_key_frame: impl ::planus::WriteAsDefault<bool, bool>,
                    field_size: impl ::planus::WriteAsDefault<u64, u64>,
                    field_payload_size: impl ::planus::WriteAsDefault<u64, u64>,
                    field_spatial_layer: impl ::planus::WriteAsDefault<u8, u8>,
                    field_temporal_layer: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_rrid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_wide_sequence_number: impl ::planus::WriteAsOptional<u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_payload_type = field_payload_type.prepare(builder, &0);
                    let prepared_sequence_number = field_sequence_number.prepare(builder, &0);
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_marker = field_marker.prepare(builder, &false);
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);
                    let prepared_is_key_frame = field_is_key_frame.prepare(builder, &false);
                    let prepared_size = field_size.prepare(builder, &0);
                    let prepared_payload_size = field_payload_size.prepare(builder, &0);
                    let prepared_spatial_layer = field_spatial_layer.prepare(builder, &0);
                    let prepared_temporal_layer = field_temporal_layer.prepare(builder, &0);
                    let prepared_mid = field_mid.prepare(builder);
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_rrid = field_rrid.prepare(builder);
                    let prepared_wide_sequence_number = field_wide_sequence_number.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<32> =
                        ::core::default::Default::default();
                    if prepared_size.is_some() {
                        table_writer.write_entry::<u64>(6);
                    }
                    if prepared_payload_size.is_some() {
                        table_writer.write_entry::<u64>(7);
                    }
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u32>(2);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_mid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(10);
                    }
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(11);
                    }
                    if prepared_rrid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(12);
                    }
                    if prepared_sequence_number.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }
                    if prepared_wide_sequence_number.is_some() {
                        table_writer.write_entry::<u16>(13);
                    }
                    if prepared_payload_type.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }
                    if prepared_marker.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }
                    if prepared_is_key_frame.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }
                    if prepared_spatial_layer.is_some() {
                        table_writer.write_entry::<u8>(8);
                    }
                    if prepared_temporal_layer.is_some() {
                        table_writer.write_entry::<u8>(9);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_size) = prepared_size {
                                object_writer.write::<_, _, 8>(&prepared_size);
                            }
                            if let ::core::option::Option::Some(prepared_payload_size) =
                                prepared_payload_size
                            {
                                object_writer.write::<_, _, 8>(&prepared_payload_size);
                            }
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 4>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            if let ::core::option::Option::Some(prepared_mid) = prepared_mid {
                                object_writer.write::<_, _, 4>(&prepared_mid);
                            }
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 4>(&prepared_rid);
                            }
                            if let ::core::option::Option::Some(prepared_rrid) = prepared_rrid {
                                object_writer.write::<_, _, 4>(&prepared_rrid);
                            }
                            if let ::core::option::Option::Some(prepared_sequence_number) =
                                prepared_sequence_number
                            {
                                object_writer.write::<_, _, 2>(&prepared_sequence_number);
                            }
                            if let ::core::option::Option::Some(prepared_wide_sequence_number) =
                                prepared_wide_sequence_number
                            {
                                object_writer.write::<_, _, 2>(&prepared_wide_sequence_number);
                            }
                            if let ::core::option::Option::Some(prepared_payload_type) =
                                prepared_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_payload_type);
                            }
                            if let ::core::option::Option::Some(prepared_marker) = prepared_marker {
                                object_writer.write::<_, _, 1>(&prepared_marker);
                            }
                            if let ::core::option::Option::Some(prepared_is_key_frame) =
                                prepared_is_key_frame
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_key_frame);
                            }
                            if let ::core::option::Option::Some(prepared_spatial_layer) =
                                prepared_spatial_layer
                            {
                                object_writer.write::<_, _, 1>(&prepared_spatial_layer);
                            }
                            if let ::core::option::Option::Some(prepared_temporal_layer) =
                                prepared_temporal_layer
                            {
                                object_writer.write::<_, _, 1>(&prepared_temporal_layer);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Dump> for Dump {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    Dump::create(
                        builder,
                        self.payload_type,
                        self.sequence_number,
                        self.timestamp,
                        self.marker,
                        self.ssrc,
                        self.is_key_frame,
                        self.size,
                        self.payload_size,
                        self.spatial_layer,
                        self.temporal_layer,
                        &self.mid,
                        &self.rid,
                        &self.rrid,
                        self.wide_sequence_number,
                    )
                }
            }

            /// Builder for serializing an instance of the [Dump] type.
            ///
            /// Can be created using the [Dump::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpBuilder<State>(State);

            impl DumpBuilder<()> {
                /// Setter for the [`payload_type` field](Dump#structfield.payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type<T0>(self, value: T0) -> DumpBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    DumpBuilder((value,))
                }

                /// Sets the [`payload_type` field](Dump#structfield.payload_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type_as_default(self) -> DumpBuilder<(::planus::DefaultValue,)> {
                    self.payload_type(::planus::DefaultValue)
                }
            }

            impl<T0> DumpBuilder<(T0,)> {
                /// Setter for the [`sequence_number` field](Dump#structfield.sequence_number).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sequence_number<T1>(self, value: T1) -> DumpBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0,) = self.0;
                    DumpBuilder((v0, value))
                }

                /// Sets the [`sequence_number` field](Dump#structfield.sequence_number) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sequence_number_as_default(
                    self,
                ) -> DumpBuilder<(T0, ::planus::DefaultValue)> {
                    self.sequence_number(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpBuilder<(T0, T1)> {
                /// Setter for the [`timestamp` field](Dump#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T2>(self, value: T2) -> DumpBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1) = self.0;
                    DumpBuilder((v0, v1, value))
                }

                /// Sets the [`timestamp` field](Dump#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(self) -> DumpBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> DumpBuilder<(T0, T1, T2)> {
                /// Setter for the [`marker` field](Dump#structfield.marker).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn marker<T3>(self, value: T3) -> DumpBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpBuilder((v0, v1, v2, value))
                }

                /// Sets the [`marker` field](Dump#structfield.marker) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn marker_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.marker(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> DumpBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`ssrc` field](Dump#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T4>(self, value: T4) -> DumpBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`ssrc` field](Dump#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> DumpBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`is_key_frame` field](Dump#structfield.is_key_frame).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_key_frame<T5>(self, value: T5) -> DumpBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`is_key_frame` field](Dump#structfield.is_key_frame) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_key_frame_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                    self.is_key_frame(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`size` field](Dump#structfield.size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn size<T6>(self, value: T6) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`size` field](Dump#structfield.size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn size_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)> {
                    self.size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`payload_size` field](Dump#structfield.payload_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_size<T7>(
                    self,
                    value: T7,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`payload_size` field](Dump#structfield.payload_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_size_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.payload_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`spatial_layer` field](Dump#structfield.spatial_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spatial_layer<T8>(
                    self,
                    value: T8,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`spatial_layer` field](Dump#structfield.spatial_layer) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spatial_layer_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.spatial_layer(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`temporal_layer` field](Dump#structfield.temporal_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn temporal_layer<T9>(
                    self,
                    value: T9,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`temporal_layer` field](Dump#structfield.temporal_layer) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn temporal_layer_as_default(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ::planus::DefaultValue)>
                {
                    self.temporal_layer(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)> {
                /// Setter for the [`mid` field](Dump#structfield.mid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid<T10>(
                    self,
                    value: T10,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`mid` field](Dump#structfield.mid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, ())> {
                    self.mid(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`rid` field](Dump#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T11>(
                    self,
                    value: T11,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`rid` field](Dump#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ())>
                {
                    self.rid(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`rrid` field](Dump#structfield.rrid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rrid<T12>(
                    self,
                    value: T12,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`rrid` field](Dump#structfield.rrid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rrid_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ())>
                {
                    self.rrid(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`wide_sequence_number` field](Dump#structfield.wide_sequence_number).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wide_sequence_number<T13>(
                    self,
                    value: T13,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
                where
                    T13: ::planus::WriteAsOptional<u16>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value))
                }

                /// Sets the [`wide_sequence_number` field](Dump#structfield.wide_sequence_number) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wide_sequence_number_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ())>
                {
                    self.wide_sequence_number(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Dump].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump>
                where
                    Self: ::planus::WriteAsOffset<Dump>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u8, u8>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u8, u8>,
                    T9: ::planus::WriteAsDefault<u8, u8>,
                    T10: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T11: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T12: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T13: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAs<::planus::Offset<Dump>>
                for DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                type Prepared = ::planus::Offset<Dump>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u8, u8>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u8, u8>,
                    T9: ::planus::WriteAsDefault<u8, u8>,
                    T10: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T11: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T12: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T13: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAsOptional<::planus::Offset<Dump>>
                for DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                type Prepared = ::planus::Offset<Dump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u8, u8>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u8, u8>,
                    T9: ::planus::WriteAsDefault<u8, u8>,
                    T10: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T11: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T12: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T13: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAsOffset<Dump>
                for DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = &self.0;
                    Dump::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
                    )
                }
            }

            /// Reference to a deserialized [Dump].
            #[derive(Copy, Clone)]
            pub struct DumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpRef<'a> {
                /// Getter for the [`payload_type` field](Dump#structfield.payload_type).
                #[inline]
                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Dump", "payload_type")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`sequence_number` field](Dump#structfield.sequence_number).
                #[inline]
                pub fn sequence_number(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Dump", "sequence_number")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`timestamp` field](Dump#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(2, "Dump", "timestamp")?.unwrap_or(0))
                }

                /// Getter for the [`marker` field](Dump#structfield.marker).
                #[inline]
                pub fn marker(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(self.0.access(3, "Dump", "marker")?.unwrap_or(false))
                }

                /// Getter for the [`ssrc` field](Dump#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(4, "Dump", "ssrc")?.unwrap_or(0))
                }

                /// Getter for the [`is_key_frame` field](Dump#structfield.is_key_frame).
                #[inline]
                pub fn is_key_frame(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "Dump", "is_key_frame")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`size` field](Dump#structfield.size).
                #[inline]
                pub fn size(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(self.0.access(6, "Dump", "size")?.unwrap_or(0))
                }

                /// Getter for the [`payload_size` field](Dump#structfield.payload_size).
                #[inline]
                pub fn payload_size(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(7, "Dump", "payload_size")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`spatial_layer` field](Dump#structfield.spatial_layer).
                #[inline]
                pub fn spatial_layer(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(8, "Dump", "spatial_layer")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`temporal_layer` field](Dump#structfield.temporal_layer).
                #[inline]
                pub fn temporal_layer(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "Dump", "temporal_layer")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`mid` field](Dump#structfield.mid).
                #[inline]
                pub fn mid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(10, "Dump", "mid")
                }

                /// Getter for the [`rid` field](Dump#structfield.rid).
                #[inline]
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(11, "Dump", "rid")
                }

                /// Getter for the [`rrid` field](Dump#structfield.rrid).
                #[inline]
                pub fn rrid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(12, "Dump", "rrid")
                }

                /// Getter for the [`wide_sequence_number` field](Dump#structfield.wide_sequence_number).
                #[inline]
                pub fn wide_sequence_number(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(13, "Dump", "wide_sequence_number")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpRef");
                    f.field("payload_type", &self.payload_type());
                    f.field("sequence_number", &self.sequence_number());
                    f.field("timestamp", &self.timestamp());
                    f.field("marker", &self.marker());
                    f.field("ssrc", &self.ssrc());
                    f.field("is_key_frame", &self.is_key_frame());
                    f.field("size", &self.size());
                    f.field("payload_size", &self.payload_size());
                    f.field("spatial_layer", &self.spatial_layer());
                    f.field("temporal_layer", &self.temporal_layer());
                    if let ::core::option::Option::Some(field_mid) = self.mid().transpose() {
                        f.field("mid", &field_mid);
                    }
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_rrid) = self.rrid().transpose() {
                        f.field("rrid", &field_rrid);
                    }
                    if let ::core::option::Option::Some(field_wide_sequence_number) =
                        self.wide_sequence_number().transpose()
                    {
                        f.field("wide_sequence_number", &field_wide_sequence_number);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpRef<'a>> for Dump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        sequence_number: ::core::convert::TryInto::try_into(
                            value.sequence_number()?,
                        )?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        marker: ::core::convert::TryInto::try_into(value.marker()?)?,
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        is_key_frame: ::core::convert::TryInto::try_into(value.is_key_frame()?)?,
                        size: ::core::convert::TryInto::try_into(value.size()?)?,
                        payload_size: ::core::convert::TryInto::try_into(value.payload_size()?)?,
                        spatial_layer: ::core::convert::TryInto::try_into(value.spatial_layer()?)?,
                        temporal_layer: ::core::convert::TryInto::try_into(
                            value.temporal_layer()?,
                        )?,
                        mid: if let ::core::option::Option::Some(mid) = value.mid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(mid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rrid: if let ::core::option::Option::Some(rrid) = value.rrid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rrid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        wide_sequence_number: if let ::core::option::Option::Some(
                            wide_sequence_number,
                        ) = value.wide_sequence_number()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                wide_sequence_number,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Dump>> for Dump {
                type Value = ::planus::Offset<Dump>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Dump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.RtpParameters`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/rtpParameters.fbs`
        pub mod rtp_parameters {
            /// The enum `MediaKind` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Enum `MediaKind` in the file `../worker/fbs/rtpParameters.fbs:3`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum MediaKind {
                /// The variant `AUDIO` in the enum `MediaKind`
                Audio = 0,

                /// The variant `VIDEO` in the enum `MediaKind`
                Video = 1,
            }

            impl MediaKind {
                /// Array containing all valid variants of MediaKind
                pub const ENUM_VALUES: [Self; 2] = [Self::Audio, Self::Video];
            }

            impl ::core::convert::TryFrom<u8> for MediaKind {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(MediaKind::Audio),
                        1 => ::core::result::Result::Ok(MediaKind::Video),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<MediaKind> for u8 {
                #[inline]
                fn from(value: MediaKind) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for MediaKind {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<MediaKind> for MediaKind {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<MediaKind> for MediaKind {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> MediaKind {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<MediaKind, MediaKind> for MediaKind {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &MediaKind,
                ) -> ::core::option::Option<MediaKind> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<MediaKind> for MediaKind {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<MediaKind> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for MediaKind {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for MediaKind {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "MediaKind",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<MediaKind> for MediaKind {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `Type` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Enum `Type` in the file `../worker/fbs/rtpParameters.fbs:8`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Type {
                /// The variant `SIMPLE` in the enum `Type`
                Simple = 0,

                /// The variant `SIMULCAST` in the enum `Type`
                Simulcast = 1,

                /// The variant `SVC` in the enum `Type`
                Svc = 2,

                /// The variant `PIPE` in the enum `Type`
                Pipe = 3,
            }

            impl Type {
                /// Array containing all valid variants of Type
                pub const ENUM_VALUES: [Self; 4] =
                    [Self::Simple, Self::Simulcast, Self::Svc, Self::Pipe];
            }

            impl ::core::convert::TryFrom<u8> for Type {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Type::Simple),
                        1 => ::core::result::Result::Ok(Type::Simulcast),
                        2 => ::core::result::Result::Ok(Type::Svc),
                        3 => ::core::result::Result::Ok(Type::Pipe),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Type> for u8 {
                #[inline]
                fn from(value: Type) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Type {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Type> for Type {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Type {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Type, Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Type,
                ) -> ::core::option::Option<Type> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Type> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Type {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Type {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Type",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Type> for Type {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `Boolean` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `Boolean` in the file `../worker/fbs/rtpParameters.fbs:16`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Boolean {
                /// The field `value` in the table `Boolean`
                pub value: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Boolean {
                fn default() -> Self {
                    Self { value: 0 }
                }
            }

            impl Boolean {
                /// Creates a [BooleanBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BooleanBuilder<()> {
                    BooleanBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_value.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_value) = prepared_value {
                                object_writer.write::<_, _, 1>(&prepared_value);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Boolean>> for Boolean {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Boolean>> for Boolean {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Boolean>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Boolean> for Boolean {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean> {
                    Boolean::create(builder, self.value)
                }
            }

            /// Builder for serializing an instance of the [Boolean] type.
            ///
            /// Can be created using the [Boolean::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BooleanBuilder<State>(State);

            impl BooleanBuilder<()> {
                /// Setter for the [`value` field](Boolean#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T0>(self, value: T0) -> BooleanBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    BooleanBuilder((value,))
                }

                /// Sets the [`value` field](Boolean#structfield.value) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value_as_default(self) -> BooleanBuilder<(::planus::DefaultValue,)> {
                    self.value(::planus::DefaultValue)
                }
            }

            impl<T0> BooleanBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Boolean].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean>
                where
                    Self: ::planus::WriteAsOffset<Boolean>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>> ::planus::WriteAs<::planus::Offset<Boolean>>
                for BooleanBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Boolean>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAsOptional<::planus::Offset<Boolean>> for BooleanBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Boolean>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Boolean>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>> ::planus::WriteAsOffset<Boolean>
                for BooleanBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean> {
                    let (v0,) = &self.0;
                    Boolean::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Boolean].
            #[derive(Copy, Clone)]
            pub struct BooleanRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BooleanRef<'a> {
                /// Getter for the [`value` field](Boolean#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(self.0.access(0, "Boolean", "value")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for BooleanRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BooleanRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BooleanRef<'a>> for Boolean {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BooleanRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BooleanRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BooleanRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BooleanRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Boolean>> for Boolean {
                type Value = ::planus::Offset<Boolean>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Boolean>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BooleanRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BooleanRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Integer32` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `Integer32` in the file `../worker/fbs/rtpParameters.fbs:20`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Integer32 {
                /// The field `value` in the table `Integer32`
                pub value: i32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Integer32 {
                fn default() -> Self {
                    Self { value: 0 }
                }
            }

            impl Integer32 {
                /// Creates a [Integer32Builder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Integer32Builder<()> {
                    Integer32Builder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsDefault<i32, i32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_value.is_some() {
                        table_writer.write_entry::<i32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_value) = prepared_value {
                                object_writer.write::<_, _, 4>(&prepared_value);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Integer32>> for Integer32 {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer32> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Integer32>> for Integer32 {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Integer32>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Integer32> for Integer32 {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer32> {
                    Integer32::create(builder, self.value)
                }
            }

            /// Builder for serializing an instance of the [Integer32] type.
            ///
            /// Can be created using the [Integer32::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Integer32Builder<State>(State);

            impl Integer32Builder<()> {
                /// Setter for the [`value` field](Integer32#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T0>(self, value: T0) -> Integer32Builder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<i32, i32>,
                {
                    Integer32Builder((value,))
                }

                /// Sets the [`value` field](Integer32#structfield.value) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value_as_default(self) -> Integer32Builder<(::planus::DefaultValue,)> {
                    self.value(::planus::DefaultValue)
                }
            }

            impl<T0> Integer32Builder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Integer32].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer32>
                where
                    Self: ::planus::WriteAsOffset<Integer32>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<i32, i32>>
                ::planus::WriteAs<::planus::Offset<Integer32>> for Integer32Builder<(T0,)>
            {
                type Prepared = ::planus::Offset<Integer32>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer32> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<i32, i32>>
                ::planus::WriteAsOptional<::planus::Offset<Integer32>> for Integer32Builder<(T0,)>
            {
                type Prepared = ::planus::Offset<Integer32>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Integer32>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<i32, i32>> ::planus::WriteAsOffset<Integer32>
                for Integer32Builder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer32> {
                    let (v0,) = &self.0;
                    Integer32::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Integer32].
            #[derive(Copy, Clone)]
            pub struct Integer32Ref<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Integer32Ref<'a> {
                /// Getter for the [`value` field](Integer32#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(self.0.access(0, "Integer32", "value")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for Integer32Ref<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Integer32Ref");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Integer32Ref<'a>> for Integer32 {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Integer32Ref<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Integer32Ref<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Integer32Ref<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Integer32Ref]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Integer32>> for Integer32 {
                type Value = ::planus::Offset<Integer32>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Integer32>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Integer32Ref<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Integer32Ref]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Integer32Array` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `Integer32Array` in the file `../worker/fbs/rtpParameters.fbs:24`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Integer32Array {
                /// The field `value` in the table `Integer32Array`
                pub value: ::core::option::Option<::planus::alloc::vec::Vec<i32>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Integer32Array {
                fn default() -> Self {
                    Self {
                        value: ::core::default::Default::default(),
                    }
                }
            }

            impl Integer32Array {
                /// Creates a [Integer32ArrayBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Integer32ArrayBuilder<()> {
                    Integer32ArrayBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsOptional<::planus::Offset<[i32]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_value.is_some() {
                        table_writer.write_entry::<::planus::Offset<[i32]>>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_value) = prepared_value {
                                object_writer.write::<_, _, 4>(&prepared_value);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Integer32Array>> for Integer32Array {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Integer32Array> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Integer32Array>> for Integer32Array {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Integer32Array>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Integer32Array> for Integer32Array {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Integer32Array> {
                    Integer32Array::create(builder, &self.value)
                }
            }

            /// Builder for serializing an instance of the [Integer32Array] type.
            ///
            /// Can be created using the [Integer32Array::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Integer32ArrayBuilder<State>(State);

            impl Integer32ArrayBuilder<()> {
                /// Setter for the [`value` field](Integer32Array#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T0>(self, value: T0) -> Integer32ArrayBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<[i32]>>,
                {
                    Integer32ArrayBuilder((value,))
                }

                /// Sets the [`value` field](Integer32Array#structfield.value) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value_as_null(self) -> Integer32ArrayBuilder<((),)> {
                    self.value(())
                }
            }

            impl<T0> Integer32ArrayBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Integer32Array].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Integer32Array>
                where
                    Self: ::planus::WriteAsOffset<Integer32Array>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsOptional<::planus::Offset<[i32]>>>
                ::planus::WriteAs<::planus::Offset<Integer32Array>>
                for Integer32ArrayBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Integer32Array>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Integer32Array> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsOptional<::planus::Offset<[i32]>>>
                ::planus::WriteAsOptional<::planus::Offset<Integer32Array>>
                for Integer32ArrayBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Integer32Array>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Integer32Array>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsOptional<::planus::Offset<[i32]>>>
                ::planus::WriteAsOffset<Integer32Array> for Integer32ArrayBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Integer32Array> {
                    let (v0,) = &self.0;
                    Integer32Array::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Integer32Array].
            #[derive(Copy, Clone)]
            pub struct Integer32ArrayRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Integer32ArrayRef<'a> {
                /// Getter for the [`value` field](Integer32Array#structfield.value).
                #[inline]
                pub fn value(
                    &self,
                ) -> ::planus::Result<::core::option::Option<::planus::Vector<'a, i32>>>
                {
                    self.0.access(0, "Integer32Array", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for Integer32ArrayRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Integer32ArrayRef");
                    if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                        f.field("value", &field_value);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Integer32ArrayRef<'a>> for Integer32Array {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Integer32ArrayRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: if let ::core::option::Option::Some(value) = value.value()? {
                            ::core::option::Option::Some(value.to_vec()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Integer32ArrayRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Integer32ArrayRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Integer32ArrayRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Integer32Array>> for Integer32Array {
                type Value = ::planus::Offset<Integer32Array>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Integer32Array>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Integer32ArrayRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Integer32ArrayRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Double` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `Double` in the file `../worker/fbs/rtpParameters.fbs:28`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Double {
                /// The field `value` in the table `Double`
                pub value: f64,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Double {
                fn default() -> Self {
                    Self { value: 0.0 }
                }
            }

            impl Double {
                /// Creates a [DoubleBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DoubleBuilder<()> {
                    DoubleBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsDefault<f64, f64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder, &0.0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_value.is_some() {
                        table_writer.write_entry::<f64>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_value) = prepared_value {
                                object_writer.write::<_, _, 8>(&prepared_value);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Double>> for Double {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Double>> for Double {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Double>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Double> for Double {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double> {
                    Double::create(builder, self.value)
                }
            }

            /// Builder for serializing an instance of the [Double] type.
            ///
            /// Can be created using the [Double::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DoubleBuilder<State>(State);

            impl DoubleBuilder<()> {
                /// Setter for the [`value` field](Double#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T0>(self, value: T0) -> DoubleBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f64, f64>,
                {
                    DoubleBuilder((value,))
                }

                /// Sets the [`value` field](Double#structfield.value) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value_as_default(self) -> DoubleBuilder<(::planus::DefaultValue,)> {
                    self.value(::planus::DefaultValue)
                }
            }

            impl<T0> DoubleBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Double].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double>
                where
                    Self: ::planus::WriteAsOffset<Double>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<f64, f64>> ::planus::WriteAs<::planus::Offset<Double>>
                for DoubleBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Double>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<f64, f64>>
                ::planus::WriteAsOptional<::planus::Offset<Double>> for DoubleBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Double>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Double>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<f64, f64>> ::planus::WriteAsOffset<Double>
                for DoubleBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double> {
                    let (v0,) = &self.0;
                    Double::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Double].
            #[derive(Copy, Clone)]
            pub struct DoubleRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DoubleRef<'a> {
                /// Getter for the [`value` field](Double#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<f64> {
                    ::core::result::Result::Ok(self.0.access(0, "Double", "value")?.unwrap_or(0.0))
                }
            }

            impl<'a> ::core::fmt::Debug for DoubleRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DoubleRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DoubleRef<'a>> for Double {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DoubleRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DoubleRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DoubleRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DoubleRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Double>> for Double {
                type Value = ::planus::Offset<Double>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Double>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DoubleRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DoubleRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `String` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `String` in the file `../worker/fbs/rtpParameters.fbs:32`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct String {
                /// The field `value` in the table `String`
                pub value: ::planus::alloc::string::String,
            }

            impl String {
                /// Creates a [StringBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StringBuilder<()> {
                    StringBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_value);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String> for String {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    String::create(builder, &self.value)
                }
            }

            /// Builder for serializing an instance of the [String] type.
            ///
            /// Can be created using the [String::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StringBuilder<State>(State);

            impl StringBuilder<()> {
                /// Setter for the [`value` field](String#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T0>(self, value: T0) -> StringBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StringBuilder((value,))
                }
            }

            impl<T0> StringBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [String].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<String>
                where
                    Self: ::planus::WriteAsOffset<String>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<String>> for StringBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<String>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<String>> for StringBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<String>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<String>
                for StringBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    let (v0,) = &self.0;
                    String::create(builder, v0)
                }
            }

            /// Reference to a deserialized [String].
            #[derive(Copy, Clone)]
            pub struct StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringRef<'a> {
                /// Getter for the [`value` field](String#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringRef<'a>> for String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String>> for String {
                type Value = ::planus::Offset<String>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `Value` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Union `Value` in the file `../worker/fbs/rtpParameters.fbs:36`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Value {
                /// The variant of type `Boolean` in the union `Value`
                Boolean(::planus::alloc::boxed::Box<self::Boolean>),

                /// The variant of type `Integer32` in the union `Value`
                Integer32(::planus::alloc::boxed::Box<self::Integer32>),

                /// The variant of type `Double` in the union `Value`
                Double(::planus::alloc::boxed::Box<self::Double>),

                /// The variant of type `String` in the union `Value`
                String(::planus::alloc::boxed::Box<self::String>),

                /// The variant of type `Integer32Array` in the union `Value`
                Integer32Array(::planus::alloc::boxed::Box<self::Integer32Array>),
            }

            impl Value {
                /// Creates a [ValueBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ValueBuilder<::planus::Uninitialized> {
                    ValueBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_boolean(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Boolean>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_integer32(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Integer32>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_double(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Double>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_string(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::String>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_integer32_array(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Integer32Array>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Value> for Value {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::Boolean(value) => Self::create_boolean(builder, value),
                        Self::Integer32(value) => Self::create_integer32(builder, value),
                        Self::Double(value) => Self::create_double(builder, value),
                        Self::String(value) => Self::create_string(builder, value),
                        Self::Integer32Array(value) => Self::create_integer32_array(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Value> for Value {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [Value] type.
            ///
            /// Can be created using the [Value::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ValueBuilder<T>(T);

            impl ValueBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`Boolean` variant](Value#variant.Boolean).
                #[inline]
                pub fn boolean<T>(self, value: T) -> ValueBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::Boolean>,
                {
                    ValueBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Integer32` variant](Value#variant.Integer32).
                #[inline]
                pub fn integer32<T>(self, value: T) -> ValueBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::Integer32>,
                {
                    ValueBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Double` variant](Value#variant.Double).
                #[inline]
                pub fn double<T>(self, value: T) -> ValueBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::Double>,
                {
                    ValueBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`String` variant](Value#variant.String).
                #[inline]
                pub fn string<T>(self, value: T) -> ValueBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<self::String>,
                {
                    ValueBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Integer32Array` variant](Value#variant.Integer32Array).
                #[inline]
                pub fn integer32_array<T>(
                    self,
                    value: T,
                ) -> ValueBuilder<::planus::Initialized<5, T>>
                where
                    T: ::planus::WriteAsOffset<self::Integer32Array>,
                {
                    ValueBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> ValueBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [Value].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Value>
                where
                    Self: ::planus::WriteAsUnion<Value>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<Value> for ValueBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::Boolean>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Value> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Value> for ValueBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::Boolean>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Value>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Value> for ValueBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::Integer32>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Value> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Value> for ValueBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::Integer32>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Value>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Value> for ValueBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::Double>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Value> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Value> for ValueBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::Double>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Value>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Value> for ValueBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::String>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Value> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Value> for ValueBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::String>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Value>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Value> for ValueBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::Integer32Array>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Value> {
                    ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Value> for ValueBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::Integer32Array>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Value>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [Value].
            #[derive(Copy, Clone, Debug)]
            pub enum ValueRef<'a> {
                Boolean(self::BooleanRef<'a>),
                Integer32(self::Integer32Ref<'a>),
                Double(self::DoubleRef<'a>),
                String(self::StringRef<'a>),
                Integer32Array(self::Integer32ArrayRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<ValueRef<'a>> for Value {
                type Error = ::planus::Error;

                fn try_from(value: ValueRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        ValueRef::Boolean(value) => {
                            Self::Boolean(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        ValueRef::Integer32(value) => {
                            Self::Integer32(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        ValueRef::Double(value) => Self::Double(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        ValueRef::String(value) => Self::String(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        ValueRef::Integer32Array(value) => {
                            Self::Integer32Array(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for ValueRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::Boolean(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Integer32(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::Double(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::String(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::Integer32Array(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Parameter` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `Parameter` in the file `../worker/fbs/rtpParameters.fbs:44`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Parameter {
                /// The field `name` in the table `Parameter`
                pub name: ::planus::alloc::string::String,
                /// The field `value` in the table `Parameter`
                pub value: self::Value,
            }

            impl Parameter {
                /// Creates a [ParameterBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ParameterBuilder<()> {
                    ParameterBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAsUnion<self::Value>,
                ) -> ::planus::Offset<Self> {
                    let prepared_name = field_name.prepare(builder);
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<self::Value>>(2);
                    table_writer.write_entry::<u8>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_name);
                            object_writer.write::<_, _, 4>(&prepared_value.offset());
                            object_writer.write::<_, _, 1>(&prepared_value.tag());
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Parameter>> for Parameter {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Parameter>> for Parameter {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Parameter>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Parameter> for Parameter {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter> {
                    Parameter::create(builder, &self.name, &self.value)
                }
            }

            /// Builder for serializing an instance of the [Parameter] type.
            ///
            /// Can be created using the [Parameter::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ParameterBuilder<State>(State);

            impl ParameterBuilder<()> {
                /// Setter for the [`name` field](Parameter#structfield.name).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn name<T0>(self, value: T0) -> ParameterBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ParameterBuilder((value,))
                }
            }

            impl<T0> ParameterBuilder<(T0,)> {
                /// Setter for the [`value` field](Parameter#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T1>(self, value: T1) -> ParameterBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsUnion<self::Value>,
                {
                    let (v0,) = self.0;
                    ParameterBuilder((v0, value))
                }
            }

            impl<T0, T1> ParameterBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Parameter].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter>
                where
                    Self: ::planus::WriteAsOffset<Parameter>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsUnion<self::Value>,
                > ::planus::WriteAs<::planus::Offset<Parameter>> for ParameterBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Parameter>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsUnion<self::Value>,
                > ::planus::WriteAsOptional<::planus::Offset<Parameter>>
                for ParameterBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Parameter>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Parameter>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsUnion<self::Value>,
                > ::planus::WriteAsOffset<Parameter> for ParameterBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter> {
                    let (v0, v1) = &self.0;
                    Parameter::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [Parameter].
            #[derive(Copy, Clone)]
            pub struct ParameterRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ParameterRef<'a> {
                /// Getter for the [`name` field](Parameter#structfield.name).
                #[inline]
                pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Parameter", "name")
                }

                /// Getter for the [`value` field](Parameter#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<self::ValueRef<'a>> {
                    self.0.access_union_required(1, "Parameter", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for ParameterRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ParameterRef");
                    f.field("name", &self.name());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ParameterRef<'a>> for Parameter {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ParameterRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        name: ::core::convert::TryInto::try_into(value.name()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ParameterRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ParameterRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ParameterRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Parameter>> for Parameter {
                type Value = ::planus::Offset<Parameter>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Parameter>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ParameterRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ParameterRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtcpFeedback` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtcpFeedback` in the file `../worker/fbs/rtpParameters.fbs:49`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpFeedback {
                /// The field `type` in the table `RtcpFeedback`
                pub type_: ::planus::alloc::string::String,
                /// The field `parameter` in the table `RtcpFeedback`
                pub parameter: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl RtcpFeedback {
                /// Creates a [RtcpFeedbackBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtcpFeedbackBuilder<()> {
                    RtcpFeedbackBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_parameter: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder);
                    let prepared_parameter = field_parameter.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_parameter.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_type_);
                            if let ::core::option::Option::Some(prepared_parameter) =
                                prepared_parameter
                            {
                                object_writer.write::<_, _, 4>(&prepared_parameter);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpFeedback>> for RtcpFeedback {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpFeedback>> for RtcpFeedback {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpFeedback>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpFeedback> for RtcpFeedback {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback> {
                    RtcpFeedback::create(builder, &self.type_, &self.parameter)
                }
            }

            /// Builder for serializing an instance of the [RtcpFeedback] type.
            ///
            /// Can be created using the [RtcpFeedback::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtcpFeedbackBuilder<State>(State);

            impl RtcpFeedbackBuilder<()> {
                /// Setter for the [`type` field](RtcpFeedback#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T0>(self, value: T0) -> RtcpFeedbackBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    RtcpFeedbackBuilder((value,))
                }
            }

            impl<T0> RtcpFeedbackBuilder<(T0,)> {
                /// Setter for the [`parameter` field](RtcpFeedback#structfield.parameter).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn parameter<T1>(self, value: T1) -> RtcpFeedbackBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0,) = self.0;
                    RtcpFeedbackBuilder((v0, value))
                }

                /// Sets the [`parameter` field](RtcpFeedback#structfield.parameter) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn parameter_as_null(self) -> RtcpFeedbackBuilder<(T0, ())> {
                    self.parameter(())
                }
            }

            impl<T0, T1> RtcpFeedbackBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtcpFeedback].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback>
                where
                    Self: ::planus::WriteAsOffset<RtcpFeedback>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAs<::planus::Offset<RtcpFeedback>>
                for RtcpFeedbackBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtcpFeedback>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAsOptional<::planus::Offset<RtcpFeedback>>
                for RtcpFeedbackBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtcpFeedback>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpFeedback>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAsOffset<RtcpFeedback> for RtcpFeedbackBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback> {
                    let (v0, v1) = &self.0;
                    RtcpFeedback::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RtcpFeedback].
            #[derive(Copy, Clone)]
            pub struct RtcpFeedbackRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpFeedbackRef<'a> {
                /// Getter for the [`type` field](RtcpFeedback#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "RtcpFeedback", "type_")
                }

                /// Getter for the [`parameter` field](RtcpFeedback#structfield.parameter).
                #[inline]
                pub fn parameter(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "RtcpFeedback", "parameter")
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpFeedbackRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpFeedbackRef");
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_parameter) =
                        self.parameter().transpose()
                    {
                        f.field("parameter", &field_parameter);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpFeedbackRef<'a>> for RtcpFeedback {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpFeedbackRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        parameter: if let ::core::option::Option::Some(parameter) =
                            value.parameter()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                parameter,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpFeedbackRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpFeedbackRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpFeedbackRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpFeedback>> for RtcpFeedback {
                type Value = ::planus::Offset<RtcpFeedback>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpFeedback>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpFeedbackRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtcpFeedbackRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpCodecParameters` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtpCodecParameters` in the file `../worker/fbs/rtpParameters.fbs:55`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RtpCodecParameters {
                /// The field `mime_type` in the table `RtpCodecParameters`
                pub mime_type: ::planus::alloc::string::String,
                /// The field `payload_type` in the table `RtpCodecParameters`
                pub payload_type: u8,
                /// The field `clock_rate` in the table `RtpCodecParameters`
                pub clock_rate: u32,
                /// The field `channels` in the table `RtpCodecParameters`
                pub channels: ::core::option::Option<u8>,
                /// The field `parameters` in the table `RtpCodecParameters`
                pub parameters: ::core::option::Option<::planus::alloc::vec::Vec<self::Parameter>>,
                /// The field `rtcp_feedback` in the table `RtpCodecParameters`
                pub rtcp_feedback:
                    ::core::option::Option<::planus::alloc::vec::Vec<self::RtcpFeedback>>,
            }

            impl RtpCodecParameters {
                /// Creates a [RtpCodecParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpCodecParametersBuilder<()> {
                    RtpCodecParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_clock_rate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_channels: impl ::planus::WriteAsOptional<u8>,
                    field_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                    field_rtcp_feedback: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_mime_type = field_mime_type.prepare(builder);
                    let prepared_payload_type = field_payload_type.prepare(builder, &0);
                    let prepared_clock_rate = field_clock_rate.prepare(builder, &0);
                    let prepared_channels = field_channels.prepare(builder);
                    let prepared_parameters = field_parameters.prepare(builder);
                    let prepared_rtcp_feedback = field_rtcp_feedback.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_clock_rate.is_some() {
                        table_writer.write_entry::<u32>(2);
                    }
                    if prepared_parameters.is_some() {
                        table_writer
                            .write_entry::<::planus::Offset<[::planus::Offset<self::Parameter>]>>(
                                4,
                            );
                    }
                    if prepared_rtcp_feedback.is_some() {
                        table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>>(5);
                    }
                    if prepared_payload_type.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }
                    if prepared_channels.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_mime_type);
                            if let ::core::option::Option::Some(prepared_clock_rate) =
                                prepared_clock_rate
                            {
                                object_writer.write::<_, _, 4>(&prepared_clock_rate);
                            }
                            if let ::core::option::Option::Some(prepared_parameters) =
                                prepared_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_rtcp_feedback) =
                                prepared_rtcp_feedback
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtcp_feedback);
                            }
                            if let ::core::option::Option::Some(prepared_payload_type) =
                                prepared_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_payload_type);
                            }
                            if let ::core::option::Option::Some(prepared_channels) =
                                prepared_channels
                            {
                                object_writer.write::<_, _, 1>(&prepared_channels);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpCodecParameters>> for RtpCodecParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpCodecParameters>> for RtpCodecParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpCodecParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpCodecParameters> for RtpCodecParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters> {
                    RtpCodecParameters::create(
                        builder,
                        &self.mime_type,
                        self.payload_type,
                        self.clock_rate,
                        self.channels,
                        &self.parameters,
                        &self.rtcp_feedback,
                    )
                }
            }

            /// Builder for serializing an instance of the [RtpCodecParameters] type.
            ///
            /// Can be created using the [RtpCodecParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpCodecParametersBuilder<State>(State);

            impl RtpCodecParametersBuilder<()> {
                /// Setter for the [`mime_type` field](RtpCodecParameters#structfield.mime_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mime_type<T0>(self, value: T0) -> RtpCodecParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    RtpCodecParametersBuilder((value,))
                }
            }

            impl<T0> RtpCodecParametersBuilder<(T0,)> {
                /// Setter for the [`payload_type` field](RtpCodecParameters#structfield.payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type<T1>(self, value: T1) -> RtpCodecParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    RtpCodecParametersBuilder((v0, value))
                }

                /// Sets the [`payload_type` field](RtpCodecParameters#structfield.payload_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type_as_default(
                    self,
                ) -> RtpCodecParametersBuilder<(T0, ::planus::DefaultValue)> {
                    self.payload_type(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RtpCodecParametersBuilder<(T0, T1)> {
                /// Setter for the [`clock_rate` field](RtpCodecParameters#structfield.clock_rate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn clock_rate<T2>(self, value: T2) -> RtpCodecParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1) = self.0;
                    RtpCodecParametersBuilder((v0, v1, value))
                }

                /// Sets the [`clock_rate` field](RtpCodecParameters#structfield.clock_rate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn clock_rate_as_default(
                    self,
                ) -> RtpCodecParametersBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.clock_rate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> RtpCodecParametersBuilder<(T0, T1, T2)> {
                /// Setter for the [`channels` field](RtpCodecParameters#structfield.channels).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn channels<T3>(self, value: T3) -> RtpCodecParametersBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<u8>,
                {
                    let (v0, v1, v2) = self.0;
                    RtpCodecParametersBuilder((v0, v1, v2, value))
                }

                /// Sets the [`channels` field](RtpCodecParameters#structfield.channels) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn channels_as_null(self) -> RtpCodecParametersBuilder<(T0, T1, T2, ())> {
                    self.channels(())
                }
            }

            impl<T0, T1, T2, T3> RtpCodecParametersBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`parameters` field](RtpCodecParameters#structfield.parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn parameters<T4>(
                    self,
                    value: T4,
                ) -> RtpCodecParametersBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    RtpCodecParametersBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`parameters` field](RtpCodecParameters#structfield.parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn parameters_as_null(self) -> RtpCodecParametersBuilder<(T0, T1, T2, T3, ())> {
                    self.parameters(())
                }
            }

            impl<T0, T1, T2, T3, T4> RtpCodecParametersBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`rtcp_feedback` field](RtpCodecParameters#structfield.rtcp_feedback).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_feedback<T5>(
                    self,
                    value: T5,
                ) -> RtpCodecParametersBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    RtpCodecParametersBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`rtcp_feedback` field](RtpCodecParameters#structfield.rtcp_feedback) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_feedback_as_null(
                    self,
                ) -> RtpCodecParametersBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.rtcp_feedback(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> RtpCodecParametersBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpCodecParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters>
                where
                    Self: ::planus::WriteAsOffset<RtpCodecParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsOptional<u8>,
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<RtpCodecParameters>>
                for RtpCodecParametersBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<RtpCodecParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsOptional<u8>,
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<RtpCodecParameters>>
                for RtpCodecParametersBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<RtpCodecParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpCodecParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsOptional<u8>,
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>,
                    >,
                > ::planus::WriteAsOffset<RtpCodecParameters>
                for RtpCodecParametersBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    RtpCodecParameters::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [RtpCodecParameters].
            #[derive(Copy, Clone)]
            pub struct RtpCodecParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpCodecParametersRef<'a> {
                /// Getter for the [`mime_type` field](RtpCodecParameters#structfield.mime_type).
                #[inline]
                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "RtpCodecParameters", "mime_type")
                }

                /// Getter for the [`payload_type` field](RtpCodecParameters#structfield.payload_type).
                #[inline]
                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "RtpCodecParameters", "payload_type")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`clock_rate` field](RtpCodecParameters#structfield.clock_rate).
                #[inline]
                pub fn clock_rate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "RtpCodecParameters", "clock_rate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`channels` field](RtpCodecParameters#structfield.channels).
                #[inline]
                pub fn channels(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(3, "RtpCodecParameters", "channels")
                }

                /// Getter for the [`parameters` field](RtpCodecParameters#structfield.parameters).
                #[inline]
                pub fn parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::ParameterRef<'a>>>,
                    >,
                > {
                    self.0.access(4, "RtpCodecParameters", "parameters")
                }

                /// Getter for the [`rtcp_feedback` field](RtpCodecParameters#structfield.rtcp_feedback).
                #[inline]
                pub fn rtcp_feedback(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::RtcpFeedbackRef<'a>>>,
                    >,
                > {
                    self.0.access(5, "RtpCodecParameters", "rtcp_feedback")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpCodecParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpCodecParametersRef");
                    f.field("mime_type", &self.mime_type());
                    f.field("payload_type", &self.payload_type());
                    f.field("clock_rate", &self.clock_rate());
                    if let ::core::option::Option::Some(field_channels) =
                        self.channels().transpose()
                    {
                        f.field("channels", &field_channels);
                    }
                    if let ::core::option::Option::Some(field_parameters) =
                        self.parameters().transpose()
                    {
                        f.field("parameters", &field_parameters);
                    }
                    if let ::core::option::Option::Some(field_rtcp_feedback) =
                        self.rtcp_feedback().transpose()
                    {
                        f.field("rtcp_feedback", &field_rtcp_feedback);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpCodecParametersRef<'a>> for RtpCodecParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpCodecParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        clock_rate: ::core::convert::TryInto::try_into(value.clock_rate()?)?,
                        channels: if let ::core::option::Option::Some(channels) =
                            value.channels()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                channels,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        parameters: if let ::core::option::Option::Some(parameters) =
                            value.parameters()?
                        {
                            ::core::option::Option::Some(parameters.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp_feedback: if let ::core::option::Option::Some(rtcp_feedback) =
                            value.rtcp_feedback()?
                        {
                            ::core::option::Option::Some(rtcp_feedback.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpCodecParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpCodecParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpCodecParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpCodecParameters>> for RtpCodecParameters {
                type Value = ::planus::Offset<RtpCodecParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpCodecParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpCodecParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpCodecParametersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `RtpHeaderExtensionUri` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Enum `RtpHeaderExtensionUri` in the file `../worker/fbs/rtpParameters.fbs:64`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum RtpHeaderExtensionUri {
                /// The variant `Mid` in the enum `RtpHeaderExtensionUri`
                Mid = 0,

                /// The variant `RtpStreamId` in the enum `RtpHeaderExtensionUri`
                RtpStreamId = 1,

                /// The variant `RepairRtpStreamId` in the enum `RtpHeaderExtensionUri`
                RepairRtpStreamId = 2,

                /// The variant `FrameMarkingDraft07` in the enum `RtpHeaderExtensionUri`
                FrameMarkingDraft07 = 3,

                /// The variant `FrameMarking` in the enum `RtpHeaderExtensionUri`
                FrameMarking = 4,

                /// The variant `AudioLevel` in the enum `RtpHeaderExtensionUri`
                AudioLevel = 5,

                /// The variant `VideoOrientation` in the enum `RtpHeaderExtensionUri`
                VideoOrientation = 6,

                /// The variant `TimeOffset` in the enum `RtpHeaderExtensionUri`
                TimeOffset = 7,

                /// The variant `TransportWideCcDraft01` in the enum `RtpHeaderExtensionUri`
                TransportWideCcDraft01 = 8,

                /// The variant `AbsSendTime` in the enum `RtpHeaderExtensionUri`
                AbsSendTime = 9,

                /// The variant `AbsCaptureTime` in the enum `RtpHeaderExtensionUri`
                AbsCaptureTime = 10,
            }

            impl RtpHeaderExtensionUri {
                /// Array containing all valid variants of RtpHeaderExtensionUri
                pub const ENUM_VALUES: [Self; 11] = [
                    Self::Mid,
                    Self::RtpStreamId,
                    Self::RepairRtpStreamId,
                    Self::FrameMarkingDraft07,
                    Self::FrameMarking,
                    Self::AudioLevel,
                    Self::VideoOrientation,
                    Self::TimeOffset,
                    Self::TransportWideCcDraft01,
                    Self::AbsSendTime,
                    Self::AbsCaptureTime,
                ];
            }

            impl ::core::convert::TryFrom<u8> for RtpHeaderExtensionUri {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(RtpHeaderExtensionUri::Mid),
                        1 => ::core::result::Result::Ok(RtpHeaderExtensionUri::RtpStreamId),
                        2 => ::core::result::Result::Ok(RtpHeaderExtensionUri::RepairRtpStreamId),
                        3 => ::core::result::Result::Ok(RtpHeaderExtensionUri::FrameMarkingDraft07),
                        4 => ::core::result::Result::Ok(RtpHeaderExtensionUri::FrameMarking),
                        5 => ::core::result::Result::Ok(RtpHeaderExtensionUri::AudioLevel),
                        6 => ::core::result::Result::Ok(RtpHeaderExtensionUri::VideoOrientation),
                        7 => ::core::result::Result::Ok(RtpHeaderExtensionUri::TimeOffset),
                        8 => ::core::result::Result::Ok(
                            RtpHeaderExtensionUri::TransportWideCcDraft01,
                        ),
                        9 => ::core::result::Result::Ok(RtpHeaderExtensionUri::AbsSendTime),
                        10 => ::core::result::Result::Ok(RtpHeaderExtensionUri::AbsCaptureTime),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<RtpHeaderExtensionUri> for u8 {
                #[inline]
                fn from(value: RtpHeaderExtensionUri) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for RtpHeaderExtensionUri {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<RtpHeaderExtensionUri> for RtpHeaderExtensionUri {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<RtpHeaderExtensionUri> for RtpHeaderExtensionUri {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> RtpHeaderExtensionUri {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<RtpHeaderExtensionUri, RtpHeaderExtensionUri>
                for RtpHeaderExtensionUri
            {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &RtpHeaderExtensionUri,
                ) -> ::core::option::Option<RtpHeaderExtensionUri> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<RtpHeaderExtensionUri> for RtpHeaderExtensionUri {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<RtpHeaderExtensionUri> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for RtpHeaderExtensionUri {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for RtpHeaderExtensionUri {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "RtpHeaderExtensionUri",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<RtpHeaderExtensionUri> for RtpHeaderExtensionUri {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `RtpHeaderExtensionParameters` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtpHeaderExtensionParameters` in the file `../worker/fbs/rtpParameters.fbs:78`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RtpHeaderExtensionParameters {
                /// The field `uri` in the table `RtpHeaderExtensionParameters`
                pub uri: self::RtpHeaderExtensionUri,
                /// The field `id` in the table `RtpHeaderExtensionParameters`
                pub id: u8,
                /// The field `encrypt` in the table `RtpHeaderExtensionParameters`
                pub encrypt: bool,
                /// The field `parameters` in the table `RtpHeaderExtensionParameters`
                pub parameters: ::core::option::Option<::planus::alloc::vec::Vec<self::Parameter>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpHeaderExtensionParameters {
                fn default() -> Self {
                    Self {
                        uri: self::RtpHeaderExtensionUri::Mid,
                        id: 0,
                        encrypt: false,
                        parameters: ::core::default::Default::default(),
                    }
                }
            }

            impl RtpHeaderExtensionParameters {
                /// Creates a [RtpHeaderExtensionParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpHeaderExtensionParametersBuilder<()> {
                    RtpHeaderExtensionParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_uri: impl ::planus::WriteAsDefault<
                        self::RtpHeaderExtensionUri,
                        self::RtpHeaderExtensionUri,
                    >,
                    field_id: impl ::planus::WriteAsDefault<u8, u8>,
                    field_encrypt: impl ::planus::WriteAsDefault<bool, bool>,
                    field_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_uri =
                        field_uri.prepare(builder, &self::RtpHeaderExtensionUri::Mid);
                    let prepared_id = field_id.prepare(builder, &0);
                    let prepared_encrypt = field_encrypt.prepare(builder, &false);
                    let prepared_parameters = field_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_parameters.is_some() {
                        table_writer
                            .write_entry::<::planus::Offset<[::planus::Offset<self::Parameter>]>>(
                                3,
                            );
                    }
                    if prepared_uri.is_some() {
                        table_writer.write_entry::<self::RtpHeaderExtensionUri>(0);
                    }
                    if prepared_id.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }
                    if prepared_encrypt.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_parameters) =
                                prepared_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_uri) = prepared_uri {
                                object_writer.write::<_, _, 1>(&prepared_uri);
                            }
                            if let ::core::option::Option::Some(prepared_id) = prepared_id {
                                object_writer.write::<_, _, 1>(&prepared_id);
                            }
                            if let ::core::option::Option::Some(prepared_encrypt) = prepared_encrypt
                            {
                                object_writer.write::<_, _, 1>(&prepared_encrypt);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParameters
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParameters
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpHeaderExtensionParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpHeaderExtensionParameters> for RtpHeaderExtensionParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters> {
                    RtpHeaderExtensionParameters::create(
                        builder,
                        self.uri,
                        self.id,
                        self.encrypt,
                        &self.parameters,
                    )
                }
            }

            /// Builder for serializing an instance of the [RtpHeaderExtensionParameters] type.
            ///
            /// Can be created using the [RtpHeaderExtensionParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpHeaderExtensionParametersBuilder<State>(State);

            impl RtpHeaderExtensionParametersBuilder<()> {
                /// Setter for the [`uri` field](RtpHeaderExtensionParameters#structfield.uri).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn uri<T0>(self, value: T0) -> RtpHeaderExtensionParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<
                        self::RtpHeaderExtensionUri,
                        self::RtpHeaderExtensionUri,
                    >,
                {
                    RtpHeaderExtensionParametersBuilder((value,))
                }

                /// Sets the [`uri` field](RtpHeaderExtensionParameters#structfield.uri) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn uri_as_default(
                    self,
                ) -> RtpHeaderExtensionParametersBuilder<(::planus::DefaultValue,)>
                {
                    self.uri(::planus::DefaultValue)
                }
            }

            impl<T0> RtpHeaderExtensionParametersBuilder<(T0,)> {
                /// Setter for the [`id` field](RtpHeaderExtensionParameters#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T1>(self, value: T1) -> RtpHeaderExtensionParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    RtpHeaderExtensionParametersBuilder((v0, value))
                }

                /// Sets the [`id` field](RtpHeaderExtensionParameters#structfield.id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id_as_default(
                    self,
                ) -> RtpHeaderExtensionParametersBuilder<(T0, ::planus::DefaultValue)>
                {
                    self.id(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RtpHeaderExtensionParametersBuilder<(T0, T1)> {
                /// Setter for the [`encrypt` field](RtpHeaderExtensionParameters#structfield.encrypt).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encrypt<T2>(
                    self,
                    value: T2,
                ) -> RtpHeaderExtensionParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    RtpHeaderExtensionParametersBuilder((v0, v1, value))
                }

                /// Sets the [`encrypt` field](RtpHeaderExtensionParameters#structfield.encrypt) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encrypt_as_default(
                    self,
                ) -> RtpHeaderExtensionParametersBuilder<(T0, T1, ::planus::DefaultValue)>
                {
                    self.encrypt(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> RtpHeaderExtensionParametersBuilder<(T0, T1, T2)> {
                /// Setter for the [`parameters` field](RtpHeaderExtensionParameters#structfield.parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn parameters<T3>(
                    self,
                    value: T3,
                ) -> RtpHeaderExtensionParametersBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    RtpHeaderExtensionParametersBuilder((v0, v1, v2, value))
                }

                /// Sets the [`parameters` field](RtpHeaderExtensionParameters#structfield.parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn parameters_as_null(
                    self,
                ) -> RtpHeaderExtensionParametersBuilder<(T0, T1, T2, ())> {
                    self.parameters(())
                }
            }

            impl<T0, T1, T2, T3> RtpHeaderExtensionParametersBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpHeaderExtensionParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters>
                where
                    Self: ::planus::WriteAsOffset<RtpHeaderExtensionParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        self::RtpHeaderExtensionUri,
                        self::RtpHeaderExtensionUri,
                    >,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParametersBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<RtpHeaderExtensionParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        self::RtpHeaderExtensionUri,
                        self::RtpHeaderExtensionUri,
                    >,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParametersBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<RtpHeaderExtensionParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpHeaderExtensionParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        self::RtpHeaderExtensionUri,
                        self::RtpHeaderExtensionUri,
                    >,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                > ::planus::WriteAsOffset<RtpHeaderExtensionParameters>
                for RtpHeaderExtensionParametersBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters> {
                    let (v0, v1, v2, v3) = &self.0;
                    RtpHeaderExtensionParameters::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [RtpHeaderExtensionParameters].
            #[derive(Copy, Clone)]
            pub struct RtpHeaderExtensionParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpHeaderExtensionParametersRef<'a> {
                /// Getter for the [`uri` field](RtpHeaderExtensionParameters#structfield.uri).
                #[inline]
                pub fn uri(&self) -> ::planus::Result<self::RtpHeaderExtensionUri> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "RtpHeaderExtensionParameters", "uri")?
                            .unwrap_or(self::RtpHeaderExtensionUri::Mid),
                    )
                }

                /// Getter for the [`id` field](RtpHeaderExtensionParameters#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "RtpHeaderExtensionParameters", "id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`encrypt` field](RtpHeaderExtensionParameters#structfield.encrypt).
                #[inline]
                pub fn encrypt(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "RtpHeaderExtensionParameters", "encrypt")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`parameters` field](RtpHeaderExtensionParameters#structfield.parameters).
                #[inline]
                pub fn parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::ParameterRef<'a>>>,
                    >,
                > {
                    self.0
                        .access(3, "RtpHeaderExtensionParameters", "parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpHeaderExtensionParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpHeaderExtensionParametersRef");
                    f.field("uri", &self.uri());
                    f.field("id", &self.id());
                    f.field("encrypt", &self.encrypt());
                    if let ::core::option::Option::Some(field_parameters) =
                        self.parameters().transpose()
                    {
                        f.field("parameters", &field_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpHeaderExtensionParametersRef<'a>>
                for RtpHeaderExtensionParameters
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpHeaderExtensionParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        uri: ::core::convert::TryInto::try_into(value.uri()?)?,
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        encrypt: ::core::convert::TryInto::try_into(value.encrypt()?)?,
                        parameters: if let ::core::option::Option::Some(parameters) =
                            value.parameters()?
                        {
                            ::core::option::Option::Some(parameters.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpHeaderExtensionParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpHeaderExtensionParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpHeaderExtensionParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParameters
            {
                type Value = ::planus::Offset<RtpHeaderExtensionParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpHeaderExtensionParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpHeaderExtensionParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpHeaderExtensionParametersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `Rtx` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `Rtx` in the file `../worker/fbs/rtpParameters.fbs:85`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Rtx {
                /// The field `ssrc` in the table `Rtx`
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Rtx {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl Rtx {
                /// Creates a [RtxBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtxBuilder<()> {
                    RtxBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Rtx>> for Rtx {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Rtx>> for Rtx {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rtx>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Rtx> for Rtx {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx> {
                    Rtx::create(builder, self.ssrc)
                }
            }

            /// Builder for serializing an instance of the [Rtx] type.
            ///
            /// Can be created using the [Rtx::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtxBuilder<State>(State);

            impl RtxBuilder<()> {
                /// Setter for the [`ssrc` field](Rtx#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> RtxBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    RtxBuilder((value,))
                }

                /// Sets the [`ssrc` field](Rtx#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> RtxBuilder<(::planus::DefaultValue,)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0> RtxBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Rtx].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx>
                where
                    Self: ::planus::WriteAsOffset<Rtx>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>> ::planus::WriteAs<::planus::Offset<Rtx>>
                for RtxBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Rtx>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<Rtx>> for RtxBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Rtx>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rtx>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>> ::planus::WriteAsOffset<Rtx> for RtxBuilder<(T0,)> {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx> {
                    let (v0,) = &self.0;
                    Rtx::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Rtx].
            #[derive(Copy, Clone)]
            pub struct RtxRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtxRef<'a> {
                /// Getter for the [`ssrc` field](Rtx#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Rtx", "ssrc")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for RtxRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtxRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtxRef<'a>> for Rtx {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtxRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtxRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtxRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[RtxRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Rtx>> for Rtx {
                type Value = ::planus::Offset<Rtx>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Rtx>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtxRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtxRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpEncodingParameters` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtpEncodingParameters` in the file `../worker/fbs/rtpParameters.fbs:89`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpEncodingParameters {
                /// The field `ssrc` in the table `RtpEncodingParameters`
                pub ssrc: ::core::option::Option<u32>,
                /// The field `rid` in the table `RtpEncodingParameters`
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `codec_payload_type` in the table `RtpEncodingParameters`
                pub codec_payload_type: ::core::option::Option<u8>,
                /// The field `rtx` in the table `RtpEncodingParameters`
                pub rtx: ::core::option::Option<::planus::alloc::boxed::Box<self::Rtx>>,
                /// The field `dtx` in the table `RtpEncodingParameters`
                pub dtx: bool,
                /// The field `scalability_mode` in the table `RtpEncodingParameters`
                pub scalability_mode: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `max_bitrate` in the table `RtpEncodingParameters`
                pub max_bitrate: ::core::option::Option<u32>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpEncodingParameters {
                fn default() -> Self {
                    Self {
                        ssrc: ::core::default::Default::default(),
                        rid: ::core::default::Default::default(),
                        codec_payload_type: ::core::default::Default::default(),
                        rtx: ::core::default::Default::default(),
                        dtx: false,
                        scalability_mode: ::core::default::Default::default(),
                        max_bitrate: ::core::default::Default::default(),
                    }
                }
            }

            impl RtpEncodingParameters {
                /// Creates a [RtpEncodingParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpEncodingParametersBuilder<()> {
                    RtpEncodingParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_codec_payload_type: impl ::planus::WriteAsOptional<u8>,
                    field_rtx: impl ::planus::WriteAsOptional<::planus::Offset<self::Rtx>>,
                    field_dtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_scalability_mode: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_max_bitrate: impl ::planus::WriteAsOptional<u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder);
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_codec_payload_type = field_codec_payload_type.prepare(builder);
                    let prepared_rtx = field_rtx.prepare(builder);
                    let prepared_dtx = field_dtx.prepare(builder, &false);
                    let prepared_scalability_mode = field_scalability_mode.prepare(builder);
                    let prepared_max_bitrate = field_max_bitrate.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<18> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(1);
                    }
                    if prepared_rtx.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Rtx>>(3);
                    }
                    if prepared_scalability_mode.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(5);
                    }
                    if prepared_max_bitrate.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    if prepared_codec_payload_type.is_some() {
                        table_writer.write_entry::<u8>(2);
                    }
                    if prepared_dtx.is_some() {
                        table_writer.write_entry::<bool>(4);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 4>(&prepared_rid);
                            }
                            if let ::core::option::Option::Some(prepared_rtx) = prepared_rtx {
                                object_writer.write::<_, _, 4>(&prepared_rtx);
                            }
                            if let ::core::option::Option::Some(prepared_scalability_mode) =
                                prepared_scalability_mode
                            {
                                object_writer.write::<_, _, 4>(&prepared_scalability_mode);
                            }
                            if let ::core::option::Option::Some(prepared_max_bitrate) =
                                prepared_max_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_codec_payload_type) =
                                prepared_codec_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_codec_payload_type);
                            }
                            if let ::core::option::Option::Some(prepared_dtx) = prepared_dtx {
                                object_writer.write::<_, _, 1>(&prepared_dtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpEncodingParameters>> for RtpEncodingParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpEncodingParameters>> for RtpEncodingParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpEncodingParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpEncodingParameters> for RtpEncodingParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters> {
                    RtpEncodingParameters::create(
                        builder,
                        self.ssrc,
                        &self.rid,
                        self.codec_payload_type,
                        &self.rtx,
                        self.dtx,
                        &self.scalability_mode,
                        self.max_bitrate,
                    )
                }
            }

            /// Builder for serializing an instance of the [RtpEncodingParameters] type.
            ///
            /// Can be created using the [RtpEncodingParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpEncodingParametersBuilder<State>(State);

            impl RtpEncodingParametersBuilder<()> {
                /// Setter for the [`ssrc` field](RtpEncodingParameters#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> RtpEncodingParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<u32>,
                {
                    RtpEncodingParametersBuilder((value,))
                }

                /// Sets the [`ssrc` field](RtpEncodingParameters#structfield.ssrc) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_null(self) -> RtpEncodingParametersBuilder<((),)> {
                    self.ssrc(())
                }
            }

            impl<T0> RtpEncodingParametersBuilder<(T0,)> {
                /// Setter for the [`rid` field](RtpEncodingParameters#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T1>(self, value: T1) -> RtpEncodingParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0,) = self.0;
                    RtpEncodingParametersBuilder((v0, value))
                }

                /// Sets the [`rid` field](RtpEncodingParameters#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(self) -> RtpEncodingParametersBuilder<(T0, ())> {
                    self.rid(())
                }
            }

            impl<T0, T1> RtpEncodingParametersBuilder<(T0, T1)> {
                /// Setter for the [`codec_payload_type` field](RtpEncodingParameters#structfield.codec_payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn codec_payload_type<T2>(
                    self,
                    value: T2,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<u8>,
                {
                    let (v0, v1) = self.0;
                    RtpEncodingParametersBuilder((v0, v1, value))
                }

                /// Sets the [`codec_payload_type` field](RtpEncodingParameters#structfield.codec_payload_type) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn codec_payload_type_as_null(
                    self,
                ) -> RtpEncodingParametersBuilder<(T0, T1, ())> {
                    self.codec_payload_type(())
                }
            }

            impl<T0, T1, T2> RtpEncodingParametersBuilder<(T0, T1, T2)> {
                /// Setter for the [`rtx` field](RtpEncodingParameters#structfield.rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx<T3>(self, value: T3) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Rtx>>,
                {
                    let (v0, v1, v2) = self.0;
                    RtpEncodingParametersBuilder((v0, v1, v2, value))
                }

                /// Sets the [`rtx` field](RtpEncodingParameters#structfield.rtx) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_as_null(self) -> RtpEncodingParametersBuilder<(T0, T1, T2, ())> {
                    self.rtx(())
                }
            }

            impl<T0, T1, T2, T3> RtpEncodingParametersBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`dtx` field](RtpEncodingParameters#structfield.dtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtx<T4>(
                    self,
                    value: T4,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    RtpEncodingParametersBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`dtx` field](RtpEncodingParameters#structfield.dtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtx_as_default(
                    self,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.dtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`scalability_mode` field](RtpEncodingParameters#structfield.scalability_mode).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scalability_mode<T5>(
                    self,
                    value: T5,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    RtpEncodingParametersBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`scalability_mode` field](RtpEncodingParameters#structfield.scalability_mode) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scalability_mode_as_null(
                    self,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.scalability_mode(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`max_bitrate` field](RtpEncodingParameters#structfield.max_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_bitrate<T6>(
                    self,
                    value: T6,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsOptional<u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    RtpEncodingParametersBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`max_bitrate` field](RtpEncodingParameters#structfield.max_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_bitrate_as_null(
                    self,
                ) -> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5, ())> {
                    self.max_bitrate(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpEncodingParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters>
                where
                    Self: ::planus::WriteAsOffset<RtpEncodingParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<u32>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T2: ::planus::WriteAsOptional<u8>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Rtx>>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAsOptional<u32>,
                > ::planus::WriteAs<::planus::Offset<RtpEncodingParameters>>
                for RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<RtpEncodingParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<u32>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T2: ::planus::WriteAsOptional<u8>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Rtx>>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAsOptional<u32>,
                > ::planus::WriteAsOptional<::planus::Offset<RtpEncodingParameters>>
                for RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<RtpEncodingParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpEncodingParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<u32>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T2: ::planus::WriteAsOptional<u8>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Rtx>>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAsOptional<u32>,
                > ::planus::WriteAsOffset<RtpEncodingParameters>
                for RtpEncodingParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters> {
                    let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                    RtpEncodingParameters::create(builder, v0, v1, v2, v3, v4, v5, v6)
                }
            }

            /// Reference to a deserialized [RtpEncodingParameters].
            #[derive(Copy, Clone)]
            pub struct RtpEncodingParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpEncodingParametersRef<'a> {
                /// Getter for the [`ssrc` field](RtpEncodingParameters#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(0, "RtpEncodingParameters", "ssrc")
                }

                /// Getter for the [`rid` field](RtpEncodingParameters#structfield.rid).
                #[inline]
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "RtpEncodingParameters", "rid")
                }

                /// Getter for the [`codec_payload_type` field](RtpEncodingParameters#structfield.codec_payload_type).
                #[inline]
                pub fn codec_payload_type(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0
                        .access(2, "RtpEncodingParameters", "codec_payload_type")
                }

                /// Getter for the [`rtx` field](RtpEncodingParameters#structfield.rtx).
                #[inline]
                pub fn rtx(&self) -> ::planus::Result<::core::option::Option<self::RtxRef<'a>>> {
                    self.0.access(3, "RtpEncodingParameters", "rtx")
                }

                /// Getter for the [`dtx` field](RtpEncodingParameters#structfield.dtx).
                #[inline]
                pub fn dtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "RtpEncodingParameters", "dtx")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`scalability_mode` field](RtpEncodingParameters#structfield.scalability_mode).
                #[inline]
                pub fn scalability_mode(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0
                        .access(5, "RtpEncodingParameters", "scalability_mode")
                }

                /// Getter for the [`max_bitrate` field](RtpEncodingParameters#structfield.max_bitrate).
                #[inline]
                pub fn max_bitrate(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(6, "RtpEncodingParameters", "max_bitrate")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpEncodingParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpEncodingParametersRef");
                    if let ::core::option::Option::Some(field_ssrc) = self.ssrc().transpose() {
                        f.field("ssrc", &field_ssrc);
                    }
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_codec_payload_type) =
                        self.codec_payload_type().transpose()
                    {
                        f.field("codec_payload_type", &field_codec_payload_type);
                    }
                    if let ::core::option::Option::Some(field_rtx) = self.rtx().transpose() {
                        f.field("rtx", &field_rtx);
                    }
                    f.field("dtx", &self.dtx());
                    if let ::core::option::Option::Some(field_scalability_mode) =
                        self.scalability_mode().transpose()
                    {
                        f.field("scalability_mode", &field_scalability_mode);
                    }
                    if let ::core::option::Option::Some(field_max_bitrate) =
                        self.max_bitrate().transpose()
                    {
                        f.field("max_bitrate", &field_max_bitrate);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpEncodingParametersRef<'a>> for RtpEncodingParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpEncodingParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: if let ::core::option::Option::Some(ssrc) = value.ssrc()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(ssrc)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        codec_payload_type: if let ::core::option::Option::Some(
                            codec_payload_type,
                        ) = value.codec_payload_type()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                codec_payload_type,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx: if let ::core::option::Option::Some(rtx) = value.rtx()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtx)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        dtx: ::core::convert::TryInto::try_into(value.dtx()?)?,
                        scalability_mode: if let ::core::option::Option::Some(scalability_mode) =
                            value.scalability_mode()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                scalability_mode,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_bitrate: if let ::core::option::Option::Some(max_bitrate) =
                            value.max_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpEncodingParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpEncodingParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpEncodingParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpEncodingParameters>> for RtpEncodingParameters {
                type Value = ::planus::Offset<RtpEncodingParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpEncodingParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpEncodingParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpEncodingParametersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `RtcpParameters` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtcpParameters` in the file `../worker/fbs/rtpParameters.fbs:99`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpParameters {
                /// The field `cname` in the table `RtcpParameters`
                pub cname: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `reduced_size` in the table `RtcpParameters`
                pub reduced_size: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtcpParameters {
                fn default() -> Self {
                    Self {
                        cname: ::core::default::Default::default(),
                        reduced_size: true,
                    }
                }
            }

            impl RtcpParameters {
                /// Creates a [RtcpParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtcpParametersBuilder<()> {
                    RtcpParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_cname: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_reduced_size: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_cname = field_cname.prepare(builder);
                    let prepared_reduced_size = field_reduced_size.prepare(builder, &true);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_cname.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(0);
                    }
                    if prepared_reduced_size.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_cname) = prepared_cname {
                                object_writer.write::<_, _, 4>(&prepared_cname);
                            }
                            if let ::core::option::Option::Some(prepared_reduced_size) =
                                prepared_reduced_size
                            {
                                object_writer.write::<_, _, 1>(&prepared_reduced_size);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpParameters>> for RtcpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpParameters>> for RtcpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpParameters> for RtcpParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters> {
                    RtcpParameters::create(builder, &self.cname, self.reduced_size)
                }
            }

            /// Builder for serializing an instance of the [RtcpParameters] type.
            ///
            /// Can be created using the [RtcpParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtcpParametersBuilder<State>(State);

            impl RtcpParametersBuilder<()> {
                /// Setter for the [`cname` field](RtcpParameters#structfield.cname).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn cname<T0>(self, value: T0) -> RtcpParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    RtcpParametersBuilder((value,))
                }

                /// Sets the [`cname` field](RtcpParameters#structfield.cname) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn cname_as_null(self) -> RtcpParametersBuilder<((),)> {
                    self.cname(())
                }
            }

            impl<T0> RtcpParametersBuilder<(T0,)> {
                /// Setter for the [`reduced_size` field](RtcpParameters#structfield.reduced_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn reduced_size<T1>(self, value: T1) -> RtcpParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    RtcpParametersBuilder((v0, value))
                }

                /// Sets the [`reduced_size` field](RtcpParameters#structfield.reduced_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn reduced_size_as_default(
                    self,
                ) -> RtcpParametersBuilder<(T0, ::planus::DefaultValue)> {
                    self.reduced_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RtcpParametersBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtcpParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters>
                where
                    Self: ::planus::WriteAsOffset<RtcpParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<RtcpParameters>>
                for RtcpParametersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtcpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<RtcpParameters>>
                for RtcpParametersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtcpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<RtcpParameters> for RtcpParametersBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters> {
                    let (v0, v1) = &self.0;
                    RtcpParameters::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RtcpParameters].
            #[derive(Copy, Clone)]
            pub struct RtcpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpParametersRef<'a> {
                /// Getter for the [`cname` field](RtcpParameters#structfield.cname).
                #[inline]
                pub fn cname(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "RtcpParameters", "cname")
                }

                /// Getter for the [`reduced_size` field](RtcpParameters#structfield.reduced_size).
                #[inline]
                pub fn reduced_size(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "RtcpParameters", "reduced_size")?
                            .unwrap_or(true),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpParametersRef");
                    if let ::core::option::Option::Some(field_cname) = self.cname().transpose() {
                        f.field("cname", &field_cname);
                    }
                    f.field("reduced_size", &self.reduced_size());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpParametersRef<'a>> for RtcpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        cname: if let ::core::option::Option::Some(cname) = value.cname()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(cname)?)
                        } else {
                            ::core::option::Option::None
                        },
                        reduced_size: ::core::convert::TryInto::try_into(value.reduced_size()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpParameters>> for RtcpParameters {
                type Value = ::planus::Offset<RtcpParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtcpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpParameters` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtpParameters` in the file `../worker/fbs/rtpParameters.fbs:104`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RtpParameters {
                /// The field `mid` in the table `RtpParameters`
                pub mid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `codecs` in the table `RtpParameters`
                pub codecs: ::planus::alloc::vec::Vec<self::RtpCodecParameters>,
                /// The field `header_extensions` in the table `RtpParameters`
                pub header_extensions:
                    ::planus::alloc::vec::Vec<self::RtpHeaderExtensionParameters>,
                /// The field `encodings` in the table `RtpParameters`
                pub encodings: ::planus::alloc::vec::Vec<self::RtpEncodingParameters>,
                /// The field `rtcp` in the table `RtpParameters`
                pub rtcp: ::planus::alloc::boxed::Box<self::RtcpParameters>,
            }

            impl RtpParameters {
                /// Creates a [RtpParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpParametersBuilder<()> {
                    RtpParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_mid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_codecs: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>,
                    >,
                    field_header_extensions: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpHeaderExtensionParameters>]>,
                    >,
                    field_encodings: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>,
                    >,
                    field_rtcp: impl ::planus::WriteAs<::planus::Offset<self::RtcpParameters>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_mid = field_mid.prepare(builder);
                    let prepared_codecs = field_codecs.prepare(builder);
                    let prepared_header_extensions = field_header_extensions.prepare(builder);
                    let prepared_encodings = field_encodings.prepare(builder);
                    let prepared_rtcp = field_rtcp.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_mid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>>(1);
                    table_writer.write_entry::<::planus::Offset<
                        [::planus::Offset<self::RtpHeaderExtensionParameters>],
                    >>(2);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>>(3);
                    table_writer.write_entry::<::planus::Offset<self::RtcpParameters>>(4);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_mid) = prepared_mid {
                                object_writer.write::<_, _, 4>(&prepared_mid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_codecs);
                            object_writer.write::<_, _, 4>(&prepared_header_extensions);
                            object_writer.write::<_, _, 4>(&prepared_encodings);
                            object_writer.write::<_, _, 4>(&prepared_rtcp);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpParameters>> for RtpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpParameters>> for RtpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpParameters> for RtpParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters> {
                    RtpParameters::create(
                        builder,
                        &self.mid,
                        &self.codecs,
                        &self.header_extensions,
                        &self.encodings,
                        &self.rtcp,
                    )
                }
            }

            /// Builder for serializing an instance of the [RtpParameters] type.
            ///
            /// Can be created using the [RtpParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpParametersBuilder<State>(State);

            impl RtpParametersBuilder<()> {
                /// Setter for the [`mid` field](RtpParameters#structfield.mid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid<T0>(self, value: T0) -> RtpParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    RtpParametersBuilder((value,))
                }

                /// Sets the [`mid` field](RtpParameters#structfield.mid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid_as_null(self) -> RtpParametersBuilder<((),)> {
                    self.mid(())
                }
            }

            impl<T0> RtpParametersBuilder<(T0,)> {
                /// Setter for the [`codecs` field](RtpParameters#structfield.codecs).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn codecs<T1>(self, value: T1) -> RtpParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>,
                    >,
                {
                    let (v0,) = self.0;
                    RtpParametersBuilder((v0, value))
                }
            }

            impl<T0, T1> RtpParametersBuilder<(T0, T1)> {
                /// Setter for the [`header_extensions` field](RtpParameters#structfield.header_extensions).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn header_extensions<T2>(self, value: T2) -> RtpParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpHeaderExtensionParameters>]>,
                    >,
                {
                    let (v0, v1) = self.0;
                    RtpParametersBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> RtpParametersBuilder<(T0, T1, T2)> {
                /// Setter for the [`encodings` field](RtpParameters#structfield.encodings).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encodings<T3>(self, value: T3) -> RtpParametersBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    RtpParametersBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> RtpParametersBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`rtcp` field](RtpParameters#structfield.rtcp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp<T4>(self, value: T4) -> RtpParametersBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<self::RtcpParameters>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    RtpParametersBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> RtpParametersBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters>
                where
                    Self: ::planus::WriteAsOffset<RtpParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>,
                    >,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpHeaderExtensionParameters>]>,
                    >,
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<self::RtcpParameters>>,
                > ::planus::WriteAs<::planus::Offset<RtpParameters>>
                for RtpParametersBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<RtpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>,
                    >,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpHeaderExtensionParameters>]>,
                    >,
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<self::RtcpParameters>>,
                > ::planus::WriteAsOptional<::planus::Offset<RtpParameters>>
                for RtpParametersBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<RtpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>,
                    >,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpHeaderExtensionParameters>]>,
                    >,
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<self::RtcpParameters>>,
                > ::planus::WriteAsOffset<RtpParameters>
                for RtpParametersBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    RtpParameters::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [RtpParameters].
            #[derive(Copy, Clone)]
            pub struct RtpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpParametersRef<'a> {
                /// Getter for the [`mid` field](RtpParameters#structfield.mid).
                #[inline]
                pub fn mid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "RtpParameters", "mid")
                }

                /// Getter for the [`codecs` field](RtpParameters#structfield.codecs).
                #[inline]
                pub fn codecs(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::RtpCodecParametersRef<'a>>>,
                > {
                    self.0.access_required(1, "RtpParameters", "codecs")
                }

                /// Getter for the [`header_extensions` field](RtpParameters#structfield.header_extensions).
                #[inline]
                pub fn header_extensions(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::planus::Result<self::RtpHeaderExtensionParametersRef<'a>>,
                    >,
                > {
                    self.0
                        .access_required(2, "RtpParameters", "header_extensions")
                }

                /// Getter for the [`encodings` field](RtpParameters#structfield.encodings).
                #[inline]
                pub fn encodings(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::RtpEncodingParametersRef<'a>>>,
                > {
                    self.0.access_required(3, "RtpParameters", "encodings")
                }

                /// Getter for the [`rtcp` field](RtpParameters#structfield.rtcp).
                #[inline]
                pub fn rtcp(&self) -> ::planus::Result<self::RtcpParametersRef<'a>> {
                    self.0.access_required(4, "RtpParameters", "rtcp")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpParametersRef");
                    if let ::core::option::Option::Some(field_mid) = self.mid().transpose() {
                        f.field("mid", &field_mid);
                    }
                    f.field("codecs", &self.codecs());
                    f.field("header_extensions", &self.header_extensions());
                    f.field("encodings", &self.encodings());
                    f.field("rtcp", &self.rtcp());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpParametersRef<'a>> for RtpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        mid: if let ::core::option::Option::Some(mid) = value.mid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(mid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        codecs: value.codecs()?.to_vec_result()?,
                        header_extensions: value.header_extensions()?.to_vec_result()?,
                        encodings: value.encodings()?.to_vec_result()?,
                        rtcp: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.rtcp()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpParameters>> for RtpParameters {
                type Value = ::planus::Offset<RtpParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `CodecMapping` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `CodecMapping` in the file `../worker/fbs/rtpParameters.fbs:112`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CodecMapping {
                /// The field `payload_type` in the table `CodecMapping`
                pub payload_type: u8,
                /// The field `mapped_payload_type` in the table `CodecMapping`
                pub mapped_payload_type: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for CodecMapping {
                fn default() -> Self {
                    Self {
                        payload_type: 0,
                        mapped_payload_type: 0,
                    }
                }
            }

            impl CodecMapping {
                /// Creates a [CodecMappingBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CodecMappingBuilder<()> {
                    CodecMappingBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mapped_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_payload_type = field_payload_type.prepare(builder, &0);
                    let prepared_mapped_payload_type =
                        field_mapped_payload_type.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_payload_type.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }
                    if prepared_mapped_payload_type.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_payload_type) =
                                prepared_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_payload_type);
                            }
                            if let ::core::option::Option::Some(prepared_mapped_payload_type) =
                                prepared_mapped_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_mapped_payload_type);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CodecMapping>> for CodecMapping {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CodecMapping>> for CodecMapping {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CodecMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CodecMapping> for CodecMapping {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping> {
                    CodecMapping::create(builder, self.payload_type, self.mapped_payload_type)
                }
            }

            /// Builder for serializing an instance of the [CodecMapping] type.
            ///
            /// Can be created using the [CodecMapping::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CodecMappingBuilder<State>(State);

            impl CodecMappingBuilder<()> {
                /// Setter for the [`payload_type` field](CodecMapping#structfield.payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type<T0>(self, value: T0) -> CodecMappingBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u8, u8>,
                {
                    CodecMappingBuilder((value,))
                }

                /// Sets the [`payload_type` field](CodecMapping#structfield.payload_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type_as_default(
                    self,
                ) -> CodecMappingBuilder<(::planus::DefaultValue,)> {
                    self.payload_type(::planus::DefaultValue)
                }
            }

            impl<T0> CodecMappingBuilder<(T0,)> {
                /// Setter for the [`mapped_payload_type` field](CodecMapping#structfield.mapped_payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mapped_payload_type<T1>(self, value: T1) -> CodecMappingBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    CodecMappingBuilder((v0, value))
                }

                /// Sets the [`mapped_payload_type` field](CodecMapping#structfield.mapped_payload_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mapped_payload_type_as_default(
                    self,
                ) -> CodecMappingBuilder<(T0, ::planus::DefaultValue)> {
                    self.mapped_payload_type(::planus::DefaultValue)
                }
            }

            impl<T0, T1> CodecMappingBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CodecMapping].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping>
                where
                    Self: ::planus::WriteAsOffset<CodecMapping>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>, T1: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAs<::planus::Offset<CodecMapping>>
                for CodecMappingBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CodecMapping>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>, T1: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAsOptional<::planus::Offset<CodecMapping>>
                for CodecMappingBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CodecMapping>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CodecMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u8, u8>, T1: ::planus::WriteAsDefault<u8, u8>>
                ::planus::WriteAsOffset<CodecMapping> for CodecMappingBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping> {
                    let (v0, v1) = &self.0;
                    CodecMapping::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CodecMapping].
            #[derive(Copy, Clone)]
            pub struct CodecMappingRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CodecMappingRef<'a> {
                /// Getter for the [`payload_type` field](CodecMapping#structfield.payload_type).
                #[inline]
                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "CodecMapping", "payload_type")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`mapped_payload_type` field](CodecMapping#structfield.mapped_payload_type).
                #[inline]
                pub fn mapped_payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "CodecMapping", "mapped_payload_type")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for CodecMappingRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CodecMappingRef");
                    f.field("payload_type", &self.payload_type());
                    f.field("mapped_payload_type", &self.mapped_payload_type());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CodecMappingRef<'a>> for CodecMapping {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CodecMappingRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        mapped_payload_type: ::core::convert::TryInto::try_into(
                            value.mapped_payload_type()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CodecMappingRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CodecMappingRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CodecMappingRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CodecMapping>> for CodecMapping {
                type Value = ::planus::Offset<CodecMapping>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CodecMapping>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CodecMappingRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[CodecMappingRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `EncodingMapping` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `EncodingMapping` in the file `../worker/fbs/rtpParameters.fbs:117`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EncodingMapping {
                /// The field `rid` in the table `EncodingMapping`
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `ssrc` in the table `EncodingMapping`
                pub ssrc: ::core::option::Option<u32>,
                /// The field `scalability_mode` in the table `EncodingMapping`
                pub scalability_mode: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `mapped_ssrc` in the table `EncodingMapping`
                pub mapped_ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for EncodingMapping {
                fn default() -> Self {
                    Self {
                        rid: ::core::default::Default::default(),
                        ssrc: ::core::default::Default::default(),
                        scalability_mode: ::core::default::Default::default(),
                        mapped_ssrc: 0,
                    }
                }
            }

            impl EncodingMapping {
                /// Creates a [EncodingMappingBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> EncodingMappingBuilder<()> {
                    EncodingMappingBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_scalability_mode: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_mapped_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_ssrc = field_ssrc.prepare(builder);
                    let prepared_scalability_mode = field_scalability_mode.prepare(builder);
                    let prepared_mapped_ssrc = field_mapped_ssrc.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(0);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_scalability_mode.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(2);
                    }
                    if prepared_mapped_ssrc.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 4>(&prepared_rid);
                            }
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            if let ::core::option::Option::Some(prepared_scalability_mode) =
                                prepared_scalability_mode
                            {
                                object_writer.write::<_, _, 4>(&prepared_scalability_mode);
                            }
                            if let ::core::option::Option::Some(prepared_mapped_ssrc) =
                                prepared_mapped_ssrc
                            {
                                object_writer.write::<_, _, 4>(&prepared_mapped_ssrc);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EncodingMapping>> for EncodingMapping {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EncodingMapping>> for EncodingMapping {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EncodingMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EncodingMapping> for EncodingMapping {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping> {
                    EncodingMapping::create(
                        builder,
                        &self.rid,
                        self.ssrc,
                        &self.scalability_mode,
                        self.mapped_ssrc,
                    )
                }
            }

            /// Builder for serializing an instance of the [EncodingMapping] type.
            ///
            /// Can be created using the [EncodingMapping::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct EncodingMappingBuilder<State>(State);

            impl EncodingMappingBuilder<()> {
                /// Setter for the [`rid` field](EncodingMapping#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T0>(self, value: T0) -> EncodingMappingBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    EncodingMappingBuilder((value,))
                }

                /// Sets the [`rid` field](EncodingMapping#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(self) -> EncodingMappingBuilder<((),)> {
                    self.rid(())
                }
            }

            impl<T0> EncodingMappingBuilder<(T0,)> {
                /// Setter for the [`ssrc` field](EncodingMapping#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T1>(self, value: T1) -> EncodingMappingBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<u32>,
                {
                    let (v0,) = self.0;
                    EncodingMappingBuilder((v0, value))
                }

                /// Sets the [`ssrc` field](EncodingMapping#structfield.ssrc) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_null(self) -> EncodingMappingBuilder<(T0, ())> {
                    self.ssrc(())
                }
            }

            impl<T0, T1> EncodingMappingBuilder<(T0, T1)> {
                /// Setter for the [`scalability_mode` field](EncodingMapping#structfield.scalability_mode).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scalability_mode<T2>(self, value: T2) -> EncodingMappingBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1) = self.0;
                    EncodingMappingBuilder((v0, v1, value))
                }

                /// Sets the [`scalability_mode` field](EncodingMapping#structfield.scalability_mode) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scalability_mode_as_null(self) -> EncodingMappingBuilder<(T0, T1, ())> {
                    self.scalability_mode(())
                }
            }

            impl<T0, T1, T2> EncodingMappingBuilder<(T0, T1, T2)> {
                /// Setter for the [`mapped_ssrc` field](EncodingMapping#structfield.mapped_ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mapped_ssrc<T3>(self, value: T3) -> EncodingMappingBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    EncodingMappingBuilder((v0, v1, v2, value))
                }

                /// Sets the [`mapped_ssrc` field](EncodingMapping#structfield.mapped_ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mapped_ssrc_as_default(
                    self,
                ) -> EncodingMappingBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.mapped_ssrc(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> EncodingMappingBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [EncodingMapping].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping>
                where
                    Self: ::planus::WriteAsOffset<EncodingMapping>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<u32>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<EncodingMapping>>
                for EncodingMappingBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<EncodingMapping>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<u32>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<EncodingMapping>>
                for EncodingMappingBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<EncodingMapping>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EncodingMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<u32>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<EncodingMapping>
                for EncodingMappingBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping> {
                    let (v0, v1, v2, v3) = &self.0;
                    EncodingMapping::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [EncodingMapping].
            #[derive(Copy, Clone)]
            pub struct EncodingMappingRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EncodingMappingRef<'a> {
                /// Getter for the [`rid` field](EncodingMapping#structfield.rid).
                #[inline]
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "EncodingMapping", "rid")
                }

                /// Getter for the [`ssrc` field](EncodingMapping#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(1, "EncodingMapping", "ssrc")
                }

                /// Getter for the [`scalability_mode` field](EncodingMapping#structfield.scalability_mode).
                #[inline]
                pub fn scalability_mode(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "EncodingMapping", "scalability_mode")
                }

                /// Getter for the [`mapped_ssrc` field](EncodingMapping#structfield.mapped_ssrc).
                #[inline]
                pub fn mapped_ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "EncodingMapping", "mapped_ssrc")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for EncodingMappingRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EncodingMappingRef");
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_ssrc) = self.ssrc().transpose() {
                        f.field("ssrc", &field_ssrc);
                    }
                    if let ::core::option::Option::Some(field_scalability_mode) =
                        self.scalability_mode().transpose()
                    {
                        f.field("scalability_mode", &field_scalability_mode);
                    }
                    f.field("mapped_ssrc", &self.mapped_ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EncodingMappingRef<'a>> for EncodingMapping {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EncodingMappingRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        ssrc: if let ::core::option::Option::Some(ssrc) = value.ssrc()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(ssrc)?)
                        } else {
                            ::core::option::Option::None
                        },
                        scalability_mode: if let ::core::option::Option::Some(scalability_mode) =
                            value.scalability_mode()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                scalability_mode,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        mapped_ssrc: ::core::convert::TryInto::try_into(value.mapped_ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EncodingMappingRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EncodingMappingRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EncodingMappingRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EncodingMapping>> for EncodingMapping {
                type Value = ::planus::Offset<EncodingMapping>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EncodingMapping>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EncodingMappingRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[EncodingMappingRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpMapping` in the namespace `FBS.RtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `RtpMapping` in the file `../worker/fbs/rtpParameters.fbs:124`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpMapping {
                /// The field `codecs` in the table `RtpMapping`
                pub codecs: ::planus::alloc::vec::Vec<self::CodecMapping>,
                /// The field `encodings` in the table `RtpMapping`
                pub encodings: ::planus::alloc::vec::Vec<self::EncodingMapping>,
            }

            impl RtpMapping {
                /// Creates a [RtpMappingBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpMappingBuilder<()> {
                    RtpMappingBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_codecs: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::CodecMapping>]>,
                    >,
                    field_encodings: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::EncodingMapping>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_codecs = field_codecs.prepare(builder);
                    let prepared_encodings = field_encodings.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::CodecMapping>]>>(0);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::EncodingMapping>]>>(
                            1,
                        );

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_codecs);
                            object_writer.write::<_, _, 4>(&prepared_encodings);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpMapping>> for RtpMapping {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpMapping>> for RtpMapping {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpMapping> for RtpMapping {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping> {
                    RtpMapping::create(builder, &self.codecs, &self.encodings)
                }
            }

            /// Builder for serializing an instance of the [RtpMapping] type.
            ///
            /// Can be created using the [RtpMapping::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpMappingBuilder<State>(State);

            impl RtpMappingBuilder<()> {
                /// Setter for the [`codecs` field](RtpMapping#structfield.codecs).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn codecs<T0>(self, value: T0) -> RtpMappingBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CodecMapping>]>>,
                {
                    RtpMappingBuilder((value,))
                }
            }

            impl<T0> RtpMappingBuilder<(T0,)> {
                /// Setter for the [`encodings` field](RtpMapping#structfield.encodings).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encodings<T1>(self, value: T1) -> RtpMappingBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::EncodingMapping>]>,
                    >,
                {
                    let (v0,) = self.0;
                    RtpMappingBuilder((v0, value))
                }
            }

            impl<T0, T1> RtpMappingBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpMapping].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping>
                where
                    Self: ::planus::WriteAsOffset<RtpMapping>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CodecMapping>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::EncodingMapping>]>>,
                > ::planus::WriteAs<::planus::Offset<RtpMapping>> for RtpMappingBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtpMapping>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CodecMapping>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::EncodingMapping>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<RtpMapping>>
                for RtpMappingBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtpMapping>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::CodecMapping>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::EncodingMapping>]>>,
                > ::planus::WriteAsOffset<RtpMapping> for RtpMappingBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping> {
                    let (v0, v1) = &self.0;
                    RtpMapping::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RtpMapping].
            #[derive(Copy, Clone)]
            pub struct RtpMappingRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpMappingRef<'a> {
                /// Getter for the [`codecs` field](RtpMapping#structfield.codecs).
                #[inline]
                pub fn codecs(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::CodecMappingRef<'a>>>,
                > {
                    self.0.access_required(0, "RtpMapping", "codecs")
                }

                /// Getter for the [`encodings` field](RtpMapping#structfield.encodings).
                #[inline]
                pub fn encodings(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::EncodingMappingRef<'a>>>,
                > {
                    self.0.access_required(1, "RtpMapping", "encodings")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpMappingRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpMappingRef");
                    f.field("codecs", &self.codecs());
                    f.field("encodings", &self.encodings());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpMappingRef<'a>> for RtpMapping {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpMappingRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        codecs: value.codecs()?.to_vec_result()?,
                        encodings: value.encodings()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpMappingRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpMappingRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpMappingRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpMapping>> for RtpMapping {
                type Value = ::planus::Offset<RtpMapping>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpMapping>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpMappingRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpMappingRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.RtpStream`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/rtpStream.fbs`
        pub mod rtp_stream {
            /// The table `Params` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `Params` in the file `../worker/fbs/rtpStream.fbs:6`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Params {
                /// The field `encoding_idx` in the table `Params`
                pub encoding_idx: u32,
                /// The field `ssrc` in the table `Params`
                pub ssrc: u32,
                /// The field `payload_type` in the table `Params`
                pub payload_type: u8,
                /// The field `mime_type` in the table `Params`
                pub mime_type: ::planus::alloc::string::String,
                /// The field `clock_rate` in the table `Params`
                pub clock_rate: u32,
                /// The field `rid` in the table `Params`
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `cname` in the table `Params`
                pub cname: ::planus::alloc::string::String,
                /// The field `rtx_ssrc` in the table `Params`
                pub rtx_ssrc: ::core::option::Option<u32>,
                /// The field `rtx_payload_type` in the table `Params`
                pub rtx_payload_type: ::core::option::Option<u8>,
                /// The field `use_nack` in the table `Params`
                pub use_nack: bool,
                /// The field `use_pli` in the table `Params`
                pub use_pli: bool,
                /// The field `use_fir` in the table `Params`
                pub use_fir: bool,
                /// The field `use_in_band_fec` in the table `Params`
                pub use_in_band_fec: bool,
                /// The field `use_dtx` in the table `Params`
                pub use_dtx: bool,
                /// The field `spatial_layers` in the table `Params`
                pub spatial_layers: u8,
                /// The field `temporal_layers` in the table `Params`
                pub temporal_layers: u8,
            }

            impl Params {
                /// Creates a [ParamsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ParamsBuilder<()> {
                    ParamsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_encoding_idx: impl ::planus::WriteAsDefault<u32, u32>,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_clock_rate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_cname: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_rtx_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_rtx_payload_type: impl ::planus::WriteAsOptional<u8>,
                    field_use_nack: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_pli: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_fir: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_in_band_fec: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_dtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_spatial_layers: impl ::planus::WriteAsDefault<u8, u8>,
                    field_temporal_layers: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_encoding_idx = field_encoding_idx.prepare(builder, &0);
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);
                    let prepared_payload_type = field_payload_type.prepare(builder, &0);
                    let prepared_mime_type = field_mime_type.prepare(builder);
                    let prepared_clock_rate = field_clock_rate.prepare(builder, &0);
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_cname = field_cname.prepare(builder);
                    let prepared_rtx_ssrc = field_rtx_ssrc.prepare(builder);
                    let prepared_rtx_payload_type = field_rtx_payload_type.prepare(builder);
                    let prepared_use_nack = field_use_nack.prepare(builder, &false);
                    let prepared_use_pli = field_use_pli.prepare(builder, &false);
                    let prepared_use_fir = field_use_fir.prepare(builder, &false);
                    let prepared_use_in_band_fec = field_use_in_band_fec.prepare(builder, &false);
                    let prepared_use_dtx = field_use_dtx.prepare(builder, &false);
                    let prepared_spatial_layers = field_spatial_layers.prepare(builder, &0);
                    let prepared_temporal_layers = field_temporal_layers.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<36> =
                        ::core::default::Default::default();
                    if prepared_encoding_idx.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(3);
                    if prepared_clock_rate.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(5);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(6);
                    if prepared_rtx_ssrc.is_some() {
                        table_writer.write_entry::<u32>(7);
                    }
                    if prepared_payload_type.is_some() {
                        table_writer.write_entry::<u8>(2);
                    }
                    if prepared_rtx_payload_type.is_some() {
                        table_writer.write_entry::<u8>(8);
                    }
                    if prepared_use_nack.is_some() {
                        table_writer.write_entry::<bool>(9);
                    }
                    if prepared_use_pli.is_some() {
                        table_writer.write_entry::<bool>(10);
                    }
                    if prepared_use_fir.is_some() {
                        table_writer.write_entry::<bool>(11);
                    }
                    if prepared_use_in_band_fec.is_some() {
                        table_writer.write_entry::<bool>(12);
                    }
                    if prepared_use_dtx.is_some() {
                        table_writer.write_entry::<bool>(13);
                    }
                    if prepared_spatial_layers.is_some() {
                        table_writer.write_entry::<u8>(14);
                    }
                    if prepared_temporal_layers.is_some() {
                        table_writer.write_entry::<u8>(15);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_encoding_idx) =
                                prepared_encoding_idx
                            {
                                object_writer.write::<_, _, 4>(&prepared_encoding_idx);
                            }
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            object_writer.write::<_, _, 4>(&prepared_mime_type);
                            if let ::core::option::Option::Some(prepared_clock_rate) =
                                prepared_clock_rate
                            {
                                object_writer.write::<_, _, 4>(&prepared_clock_rate);
                            }
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 4>(&prepared_rid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_cname);
                            if let ::core::option::Option::Some(prepared_rtx_ssrc) =
                                prepared_rtx_ssrc
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtx_ssrc);
                            }
                            if let ::core::option::Option::Some(prepared_payload_type) =
                                prepared_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_payload_type);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_payload_type) =
                                prepared_rtx_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_rtx_payload_type);
                            }
                            if let ::core::option::Option::Some(prepared_use_nack) =
                                prepared_use_nack
                            {
                                object_writer.write::<_, _, 1>(&prepared_use_nack);
                            }
                            if let ::core::option::Option::Some(prepared_use_pli) = prepared_use_pli
                            {
                                object_writer.write::<_, _, 1>(&prepared_use_pli);
                            }
                            if let ::core::option::Option::Some(prepared_use_fir) = prepared_use_fir
                            {
                                object_writer.write::<_, _, 1>(&prepared_use_fir);
                            }
                            if let ::core::option::Option::Some(prepared_use_in_band_fec) =
                                prepared_use_in_band_fec
                            {
                                object_writer.write::<_, _, 1>(&prepared_use_in_band_fec);
                            }
                            if let ::core::option::Option::Some(prepared_use_dtx) = prepared_use_dtx
                            {
                                object_writer.write::<_, _, 1>(&prepared_use_dtx);
                            }
                            if let ::core::option::Option::Some(prepared_spatial_layers) =
                                prepared_spatial_layers
                            {
                                object_writer.write::<_, _, 1>(&prepared_spatial_layers);
                            }
                            if let ::core::option::Option::Some(prepared_temporal_layers) =
                                prepared_temporal_layers
                            {
                                object_writer.write::<_, _, 1>(&prepared_temporal_layers);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Params>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Params> for Params {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    Params::create(
                        builder,
                        self.encoding_idx,
                        self.ssrc,
                        self.payload_type,
                        &self.mime_type,
                        self.clock_rate,
                        &self.rid,
                        &self.cname,
                        self.rtx_ssrc,
                        self.rtx_payload_type,
                        self.use_nack,
                        self.use_pli,
                        self.use_fir,
                        self.use_in_band_fec,
                        self.use_dtx,
                        self.spatial_layers,
                        self.temporal_layers,
                    )
                }
            }

            /// Builder for serializing an instance of the [Params] type.
            ///
            /// Can be created using the [Params::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ParamsBuilder<State>(State);

            impl ParamsBuilder<()> {
                /// Setter for the [`encoding_idx` field](Params#structfield.encoding_idx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encoding_idx<T0>(self, value: T0) -> ParamsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    ParamsBuilder((value,))
                }

                /// Sets the [`encoding_idx` field](Params#structfield.encoding_idx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encoding_idx_as_default(self) -> ParamsBuilder<(::planus::DefaultValue,)> {
                    self.encoding_idx(::planus::DefaultValue)
                }
            }

            impl<T0> ParamsBuilder<(T0,)> {
                /// Setter for the [`ssrc` field](Params#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T1>(self, value: T1) -> ParamsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    ParamsBuilder((v0, value))
                }

                /// Sets the [`ssrc` field](Params#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> ParamsBuilder<(T0, ::planus::DefaultValue)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ParamsBuilder<(T0, T1)> {
                /// Setter for the [`payload_type` field](Params#structfield.payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type<T2>(self, value: T2) -> ParamsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1) = self.0;
                    ParamsBuilder((v0, v1, value))
                }

                /// Sets the [`payload_type` field](Params#structfield.payload_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type_as_default(
                    self,
                ) -> ParamsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.payload_type(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> ParamsBuilder<(T0, T1, T2)> {
                /// Setter for the [`mime_type` field](Params#structfield.mime_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mime_type<T3>(self, value: T3) -> ParamsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2) = self.0;
                    ParamsBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> ParamsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`clock_rate` field](Params#structfield.clock_rate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn clock_rate<T4>(self, value: T4) -> ParamsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`clock_rate` field](Params#structfield.clock_rate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn clock_rate_as_default(
                    self,
                ) -> ParamsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.clock_rate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> ParamsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`rid` field](Params#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T5>(self, value: T5) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`rid` field](Params#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(self) -> ParamsBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.rid(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ParamsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`cname` field](Params#structfield.cname).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn cname<T6>(self, value: T6) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`rtx_ssrc` field](Params#structfield.rtx_ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_ssrc<T7>(
                    self,
                    value: T7,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsOptional<u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`rtx_ssrc` field](Params#structfield.rtx_ssrc) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_ssrc_as_null(self) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, ())> {
                    self.rtx_ssrc(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`rtx_payload_type` field](Params#structfield.rtx_payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_payload_type<T8>(
                    self,
                    value: T8,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsOptional<u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`rtx_payload_type` field](Params#structfield.rtx_payload_type) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_payload_type_as_null(
                    self,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ())> {
                    self.rtx_payload_type(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`use_nack` field](Params#structfield.use_nack).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_nack<T9>(
                    self,
                    value: T9,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`use_nack` field](Params#structfield.use_nack) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_nack_as_default(
                    self,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ::planus::DefaultValue)>
                {
                    self.use_nack(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`use_pli` field](Params#structfield.use_pli).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_pli<T10>(
                    self,
                    value: T10,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`use_pli` field](Params#structfield.use_pli) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_pli_as_default(
                    self,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.use_pli(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`use_fir` field](Params#structfield.use_fir).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_fir<T11>(
                    self,
                    value: T11,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`use_fir` field](Params#structfield.use_fir) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_fir_as_default(
                    self,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.use_fir(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`use_in_band_fec` field](Params#structfield.use_in_band_fec).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_in_band_fec<T12>(
                    self,
                    value: T12,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`use_in_band_fec` field](Params#structfield.use_in_band_fec) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_in_band_fec_as_default(
                    self,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.use_in_band_fec(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`use_dtx` field](Params#structfield.use_dtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_dtx<T13>(
                    self,
                    value: T13,
                ) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
                where
                    T13: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value))
                }

                /// Sets the [`use_dtx` field](Params#structfield.use_dtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn use_dtx_as_default(
                    self,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.use_dtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                ParamsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`spatial_layers` field](Params#structfield.spatial_layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spatial_layers<T14>(
                    self,
                    value: T14,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    ParamsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`spatial_layers` field](Params#structfield.spatial_layers) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spatial_layers_as_default(
                    self,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    ::planus::DefaultValue,
                )> {
                    self.spatial_layers(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`temporal_layers` field](Params#structfield.temporal_layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn temporal_layers<T15>(
                    self,
                    value: T15,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    ParamsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }

                /// Sets the [`temporal_layers` field](Params#structfield.temporal_layers) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn temporal_layers_as_default(
                    self,
                ) -> ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    ::planus::DefaultValue,
                )> {
                    self.temporal_layers(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Params].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params>
                where
                    Self: ::planus::WriteAsOffset<Params>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u8, u8>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAs<::planus::Offset<str>>,
                    T7: ::planus::WriteAsOptional<u32>,
                    T8: ::planus::WriteAsOptional<u8>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAsDefault<bool, bool>,
                    T11: ::planus::WriteAsDefault<bool, bool>,
                    T12: ::planus::WriteAsDefault<bool, bool>,
                    T13: ::planus::WriteAsDefault<bool, bool>,
                    T14: ::planus::WriteAsDefault<u8, u8>,
                    T15: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAs<::planus::Offset<Params>>
                for ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                type Prepared = ::planus::Offset<Params>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u8, u8>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAs<::planus::Offset<str>>,
                    T7: ::planus::WriteAsOptional<u32>,
                    T8: ::planus::WriteAsOptional<u8>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAsDefault<bool, bool>,
                    T11: ::planus::WriteAsDefault<bool, bool>,
                    T12: ::planus::WriteAsDefault<bool, bool>,
                    T13: ::planus::WriteAsDefault<bool, bool>,
                    T14: ::planus::WriteAsDefault<u8, u8>,
                    T15: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOptional<::planus::Offset<Params>>
                for ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                type Prepared = ::planus::Offset<Params>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Params>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u8, u8>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAs<::planus::Offset<str>>,
                    T7: ::planus::WriteAsOptional<u32>,
                    T8: ::planus::WriteAsOptional<u8>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAsDefault<bool, bool>,
                    T11: ::planus::WriteAsDefault<bool, bool>,
                    T12: ::planus::WriteAsDefault<bool, bool>,
                    T13: ::planus::WriteAsDefault<bool, bool>,
                    T14: ::planus::WriteAsDefault<u8, u8>,
                    T15: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOffset<Params>
                for ParamsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        &self.0;
                    Params::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15,
                    )
                }
            }

            /// Reference to a deserialized [Params].
            #[derive(Copy, Clone)]
            pub struct ParamsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ParamsRef<'a> {
                /// Getter for the [`encoding_idx` field](Params#structfield.encoding_idx).
                #[inline]
                pub fn encoding_idx(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Params", "encoding_idx")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`ssrc` field](Params#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(1, "Params", "ssrc")?.unwrap_or(0))
                }

                /// Getter for the [`payload_type` field](Params#structfield.payload_type).
                #[inline]
                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "Params", "payload_type")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`mime_type` field](Params#structfield.mime_type).
                #[inline]
                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "Params", "mime_type")
                }

                /// Getter for the [`clock_rate` field](Params#structfield.clock_rate).
                #[inline]
                pub fn clock_rate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "Params", "clock_rate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rid` field](Params#structfield.rid).
                #[inline]
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "Params", "rid")
                }

                /// Getter for the [`cname` field](Params#structfield.cname).
                #[inline]
                pub fn cname(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(6, "Params", "cname")
                }

                /// Getter for the [`rtx_ssrc` field](Params#structfield.rtx_ssrc).
                #[inline]
                pub fn rtx_ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(7, "Params", "rtx_ssrc")
                }

                /// Getter for the [`rtx_payload_type` field](Params#structfield.rtx_payload_type).
                #[inline]
                pub fn rtx_payload_type(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(8, "Params", "rtx_payload_type")
                }

                /// Getter for the [`use_nack` field](Params#structfield.use_nack).
                #[inline]
                pub fn use_nack(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "Params", "use_nack")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`use_pli` field](Params#structfield.use_pli).
                #[inline]
                pub fn use_pli(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(10, "Params", "use_pli")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`use_fir` field](Params#structfield.use_fir).
                #[inline]
                pub fn use_fir(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(11, "Params", "use_fir")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`use_in_band_fec` field](Params#structfield.use_in_band_fec).
                #[inline]
                pub fn use_in_band_fec(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "Params", "use_in_band_fec")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`use_dtx` field](Params#structfield.use_dtx).
                #[inline]
                pub fn use_dtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "Params", "use_dtx")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`spatial_layers` field](Params#structfield.spatial_layers).
                #[inline]
                pub fn spatial_layers(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(14, "Params", "spatial_layers")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`temporal_layers` field](Params#structfield.temporal_layers).
                #[inline]
                pub fn temporal_layers(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(15, "Params", "temporal_layers")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ParamsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ParamsRef");
                    f.field("encoding_idx", &self.encoding_idx());
                    f.field("ssrc", &self.ssrc());
                    f.field("payload_type", &self.payload_type());
                    f.field("mime_type", &self.mime_type());
                    f.field("clock_rate", &self.clock_rate());
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    f.field("cname", &self.cname());
                    if let ::core::option::Option::Some(field_rtx_ssrc) =
                        self.rtx_ssrc().transpose()
                    {
                        f.field("rtx_ssrc", &field_rtx_ssrc);
                    }
                    if let ::core::option::Option::Some(field_rtx_payload_type) =
                        self.rtx_payload_type().transpose()
                    {
                        f.field("rtx_payload_type", &field_rtx_payload_type);
                    }
                    f.field("use_nack", &self.use_nack());
                    f.field("use_pli", &self.use_pli());
                    f.field("use_fir", &self.use_fir());
                    f.field("use_in_band_fec", &self.use_in_band_fec());
                    f.field("use_dtx", &self.use_dtx());
                    f.field("spatial_layers", &self.spatial_layers());
                    f.field("temporal_layers", &self.temporal_layers());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ParamsRef<'a>> for Params {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ParamsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        encoding_idx: ::core::convert::TryInto::try_into(value.encoding_idx()?)?,
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        clock_rate: ::core::convert::TryInto::try_into(value.clock_rate()?)?,
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        cname: ::core::convert::TryInto::try_into(value.cname()?)?,
                        rtx_ssrc: if let ::core::option::Option::Some(rtx_ssrc) =
                            value.rtx_ssrc()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtx_ssrc,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx_payload_type: if let ::core::option::Option::Some(rtx_payload_type) =
                            value.rtx_payload_type()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtx_payload_type,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        use_nack: ::core::convert::TryInto::try_into(value.use_nack()?)?,
                        use_pli: ::core::convert::TryInto::try_into(value.use_pli()?)?,
                        use_fir: ::core::convert::TryInto::try_into(value.use_fir()?)?,
                        use_in_band_fec: ::core::convert::TryInto::try_into(
                            value.use_in_band_fec()?,
                        )?,
                        use_dtx: ::core::convert::TryInto::try_into(value.use_dtx()?)?,
                        spatial_layers: ::core::convert::TryInto::try_into(
                            value.spatial_layers()?,
                        )?,
                        temporal_layers: ::core::convert::TryInto::try_into(
                            value.temporal_layers()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ParamsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ParamsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ParamsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Params>> for Params {
                type Value = ::planus::Offset<Params>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Params>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ParamsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ParamsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Dump` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `Dump` in the file `../worker/fbs/rtpStream.fbs:25`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Dump {
                /// The field `params` in the table `Dump`
                pub params: ::planus::alloc::boxed::Box<self::Params>,
                /// The field `score` in the table `Dump`
                pub score: u8,
                /// The field `rtx_stream` in the table `Dump`
                pub rtx_stream:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::rtx_stream::RtxDump>>,
            }

            impl Dump {
                /// Creates a [DumpBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpBuilder<()> {
                    DumpBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_params: impl ::planus::WriteAs<::planus::Offset<self::Params>>,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_rtx_stream: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::rtx_stream::RtxDump>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_params = field_params.prepare(builder);
                    let prepared_score = field_score.prepare(builder, &0);
                    let prepared_rtx_stream = field_rtx_stream.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::Params>>(0);
                    if prepared_rtx_stream.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::rtx_stream::RtxDump>>(2);
                    }
                    if prepared_score.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_params);
                            if let ::core::option::Option::Some(prepared_rtx_stream) =
                                prepared_rtx_stream
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtx_stream);
                            }
                            if let ::core::option::Option::Some(prepared_score) = prepared_score {
                                object_writer.write::<_, _, 1>(&prepared_score);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Dump> for Dump {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    Dump::create(builder, &self.params, self.score, &self.rtx_stream)
                }
            }

            /// Builder for serializing an instance of the [Dump] type.
            ///
            /// Can be created using the [Dump::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpBuilder<State>(State);

            impl DumpBuilder<()> {
                /// Setter for the [`params` field](Dump#structfield.params).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn params<T0>(self, value: T0) -> DumpBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::Params>>,
                {
                    DumpBuilder((value,))
                }
            }

            impl<T0> DumpBuilder<(T0,)> {
                /// Setter for the [`score` field](Dump#structfield.score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score<T1>(self, value: T1) -> DumpBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    DumpBuilder((v0, value))
                }

                /// Sets the [`score` field](Dump#structfield.score) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score_as_default(self) -> DumpBuilder<(T0, ::planus::DefaultValue)> {
                    self.score(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpBuilder<(T0, T1)> {
                /// Setter for the [`rtx_stream` field](Dump#structfield.rtx_stream).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_stream<T2>(self, value: T2) -> DumpBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::rtx_stream::RtxDump>>,
                {
                    let (v0, v1) = self.0;
                    DumpBuilder((v0, v1, value))
                }

                /// Sets the [`rtx_stream` field](Dump#structfield.rtx_stream) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_stream_as_null(self) -> DumpBuilder<(T0, T1, ())> {
                    self.rtx_stream(())
                }
            }

            impl<T0, T1, T2> DumpBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Dump].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump>
                where
                    Self: ::planus::WriteAsOffset<Dump>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Params>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::rtx_stream::RtxDump>>,
                > ::planus::WriteAs<::planus::Offset<Dump>> for DumpBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Dump>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Params>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::rtx_stream::RtxDump>>,
                > ::planus::WriteAsOptional<::planus::Offset<Dump>> for DumpBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Dump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Params>>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::rtx_stream::RtxDump>>,
                > ::planus::WriteAsOffset<Dump> for DumpBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    let (v0, v1, v2) = &self.0;
                    Dump::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [Dump].
            #[derive(Copy, Clone)]
            pub struct DumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpRef<'a> {
                /// Getter for the [`params` field](Dump#structfield.params).
                #[inline]
                pub fn params(&self) -> ::planus::Result<self::ParamsRef<'a>> {
                    self.0.access_required(0, "Dump", "params")
                }

                /// Getter for the [`score` field](Dump#structfield.score).
                #[inline]
                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(self.0.access(1, "Dump", "score")?.unwrap_or(0))
                }

                /// Getter for the [`rtx_stream` field](Dump#structfield.rtx_stream).
                #[inline]
                pub fn rtx_stream(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::rtx_stream::RtxDumpRef<'a>>>
                {
                    self.0.access(2, "Dump", "rtx_stream")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpRef");
                    f.field("params", &self.params());
                    f.field("score", &self.score());
                    if let ::core::option::Option::Some(field_rtx_stream) =
                        self.rtx_stream().transpose()
                    {
                        f.field("rtx_stream", &field_rtx_stream);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpRef<'a>> for Dump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        params: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.params()?)?,
                        ),
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                        rtx_stream: if let ::core::option::Option::Some(rtx_stream) =
                            value.rtx_stream()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtx_stream)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Dump>> for Dump {
                type Value = ::planus::Offset<Dump>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Dump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `BitrateByLayer` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `BitrateByLayer` in the file `../worker/fbs/rtpStream.fbs:31`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BitrateByLayer {
                /// The field `layer` in the table `BitrateByLayer`
                pub layer: ::planus::alloc::string::String,
                /// The field `bitrate` in the table `BitrateByLayer`
                pub bitrate: u32,
            }

            impl BitrateByLayer {
                /// Creates a [BitrateByLayerBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BitrateByLayerBuilder<()> {
                    BitrateByLayerBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_layer: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_layer = field_layer.prepare(builder);
                    let prepared_bitrate = field_bitrate.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_bitrate.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_layer);
                            if let ::core::option::Option::Some(prepared_bitrate) = prepared_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_bitrate);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BitrateByLayer>> for BitrateByLayer {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BitrateByLayer>> for BitrateByLayer {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BitrateByLayer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BitrateByLayer> for BitrateByLayer {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer> {
                    BitrateByLayer::create(builder, &self.layer, self.bitrate)
                }
            }

            /// Builder for serializing an instance of the [BitrateByLayer] type.
            ///
            /// Can be created using the [BitrateByLayer::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BitrateByLayerBuilder<State>(State);

            impl BitrateByLayerBuilder<()> {
                /// Setter for the [`layer` field](BitrateByLayer#structfield.layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn layer<T0>(self, value: T0) -> BitrateByLayerBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    BitrateByLayerBuilder((value,))
                }
            }

            impl<T0> BitrateByLayerBuilder<(T0,)> {
                /// Setter for the [`bitrate` field](BitrateByLayer#structfield.bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate<T1>(self, value: T1) -> BitrateByLayerBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    BitrateByLayerBuilder((v0, value))
                }

                /// Sets the [`bitrate` field](BitrateByLayer#structfield.bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate_as_default(
                    self,
                ) -> BitrateByLayerBuilder<(T0, ::planus::DefaultValue)> {
                    self.bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1> BitrateByLayerBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BitrateByLayer].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer>
                where
                    Self: ::planus::WriteAsOffset<BitrateByLayer>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<BitrateByLayer>>
                for BitrateByLayerBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BitrateByLayer>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<BitrateByLayer>>
                for BitrateByLayerBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BitrateByLayer>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BitrateByLayer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<BitrateByLayer> for BitrateByLayerBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer> {
                    let (v0, v1) = &self.0;
                    BitrateByLayer::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [BitrateByLayer].
            #[derive(Copy, Clone)]
            pub struct BitrateByLayerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BitrateByLayerRef<'a> {
                /// Getter for the [`layer` field](BitrateByLayer#structfield.layer).
                #[inline]
                pub fn layer(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "BitrateByLayer", "layer")
                }

                /// Getter for the [`bitrate` field](BitrateByLayer#structfield.bitrate).
                #[inline]
                pub fn bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "BitrateByLayer", "bitrate")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BitrateByLayerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BitrateByLayerRef");
                    f.field("layer", &self.layer());
                    f.field("bitrate", &self.bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BitrateByLayerRef<'a>> for BitrateByLayer {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BitrateByLayerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        layer: ::core::convert::TryInto::try_into(value.layer()?)?,
                        bitrate: ::core::convert::TryInto::try_into(value.bitrate()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BitrateByLayerRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BitrateByLayerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BitrateByLayerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BitrateByLayer>> for BitrateByLayer {
                type Value = ::planus::Offset<BitrateByLayer>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BitrateByLayer>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BitrateByLayerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BitrateByLayerRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `StatsData` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Union `StatsData` in the file `../worker/fbs/rtpStream.fbs:36`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum StatsData {
                /// The variant of type `BaseStats` in the union `StatsData`
                BaseStats(::planus::alloc::boxed::Box<self::BaseStats>),

                /// The variant of type `RecvStats` in the union `StatsData`
                RecvStats(::planus::alloc::boxed::Box<self::RecvStats>),

                /// The variant of type `SendStats` in the union `StatsData`
                SendStats(::planus::alloc::boxed::Box<self::SendStats>),
            }

            impl StatsData {
                /// Creates a [StatsDataBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StatsDataBuilder<::planus::Uninitialized> {
                    StatsDataBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_base_stats(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::BaseStats>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_recv_stats(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RecvStats>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_send_stats(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::SendStats>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<StatsData> for StatsData {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::BaseStats(value) => Self::create_base_stats(builder, value),
                        Self::RecvStats(value) => Self::create_recv_stats(builder, value),
                        Self::SendStats(value) => Self::create_send_stats(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<StatsData> for StatsData {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [StatsData] type.
            ///
            /// Can be created using the [StatsData::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StatsDataBuilder<T>(T);

            impl StatsDataBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`BaseStats` variant](StatsData#variant.BaseStats).
                #[inline]
                pub fn base_stats<T>(
                    self,
                    value: T,
                ) -> StatsDataBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::BaseStats>,
                {
                    StatsDataBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`RecvStats` variant](StatsData#variant.RecvStats).
                #[inline]
                pub fn recv_stats<T>(
                    self,
                    value: T,
                ) -> StatsDataBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::RecvStats>,
                {
                    StatsDataBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`SendStats` variant](StatsData#variant.SendStats).
                #[inline]
                pub fn send_stats<T>(
                    self,
                    value: T,
                ) -> StatsDataBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::SendStats>,
                {
                    StatsDataBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> StatsDataBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [StatsData].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<StatsData>
                where
                    Self: ::planus::WriteAsUnion<StatsData>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<StatsData> for StatsDataBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BaseStats>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<StatsData> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<StatsData> for StatsDataBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BaseStats>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<StatsData>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<StatsData> for StatsDataBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::RecvStats>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<StatsData> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<StatsData> for StatsDataBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::RecvStats>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<StatsData>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<StatsData> for StatsDataBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::SendStats>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<StatsData> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<StatsData> for StatsDataBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::SendStats>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<StatsData>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [StatsData].
            #[derive(Copy, Clone, Debug)]
            pub enum StatsDataRef<'a> {
                BaseStats(self::BaseStatsRef<'a>),
                RecvStats(self::RecvStatsRef<'a>),
                SendStats(self::SendStatsRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<StatsDataRef<'a>> for StatsData {
                type Error = ::planus::Error;

                fn try_from(value: StatsDataRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        StatsDataRef::BaseStats(value) => {
                            Self::BaseStats(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        StatsDataRef::RecvStats(value) => {
                            Self::RecvStats(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        StatsDataRef::SendStats(value) => {
                            Self::SendStats(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for StatsDataRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::BaseStats(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::RecvStats(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::SendStats(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Stats` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `Stats` in the file `../worker/fbs/rtpStream.fbs:42`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Stats {
                /// The field `data` in the table `Stats`
                pub data: self::StatsData,
            }

            impl Stats {
                /// Creates a [StatsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StatsBuilder<()> {
                    StatsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAsUnion<self::StatsData>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::StatsData>>(1);
                    table_writer.write_entry::<u8>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data.offset());
                            object_writer.write::<_, _, 1>(&prepared_data.tag());
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Stats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Stats> for Stats {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    Stats::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [Stats] type.
            ///
            /// Can be created using the [Stats::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StatsBuilder<State>(State);

            impl StatsBuilder<()> {
                /// Setter for the [`data` field](Stats#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> StatsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsUnion<self::StatsData>,
                {
                    StatsBuilder((value,))
                }
            }

            impl<T0> StatsBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Stats].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats>
                where
                    Self: ::planus::WriteAsOffset<Stats>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsUnion<self::StatsData>>
                ::planus::WriteAs<::planus::Offset<Stats>> for StatsBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Stats>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsUnion<self::StatsData>>
                ::planus::WriteAsOptional<::planus::Offset<Stats>> for StatsBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Stats>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Stats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsUnion<self::StatsData>> ::planus::WriteAsOffset<Stats>
                for StatsBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    let (v0,) = &self.0;
                    Stats::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Stats].
            #[derive(Copy, Clone)]
            pub struct StatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StatsRef<'a> {
                /// Getter for the [`data` field](Stats#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<self::StatsDataRef<'a>> {
                    self.0.access_union_required(0, "Stats", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for StatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StatsRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StatsRef<'a>> for Stats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StatsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Stats>> for Stats {
                type Value = ::planus::Offset<Stats>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Stats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StatsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `BaseStats` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `BaseStats` in the file `../worker/fbs/rtpStream.fbs:46`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BaseStats {
                /// The field `timestamp` in the table `BaseStats`
                pub timestamp: u64,
                /// The field `ssrc` in the table `BaseStats`
                pub ssrc: u32,
                /// The field `kind` in the table `BaseStats`
                pub kind: super::rtp_parameters::MediaKind,
                /// The field `mime_type` in the table `BaseStats`
                pub mime_type: ::planus::alloc::string::String,
                /// The field `packets_lost` in the table `BaseStats`
                pub packets_lost: u64,
                /// The field `fraction_lost` in the table `BaseStats`
                pub fraction_lost: u8,
                /// The field `packets_discarded` in the table `BaseStats`
                pub packets_discarded: u64,
                /// The field `packets_retransmitted` in the table `BaseStats`
                pub packets_retransmitted: u64,
                /// The field `packets_repaired` in the table `BaseStats`
                pub packets_repaired: u64,
                /// The field `nack_count` in the table `BaseStats`
                pub nack_count: u64,
                /// The field `nack_packet_count` in the table `BaseStats`
                pub nack_packet_count: u64,
                /// The field `pli_count` in the table `BaseStats`
                pub pli_count: u64,
                /// The field `fir_count` in the table `BaseStats`
                pub fir_count: u64,
                /// The field `score` in the table `BaseStats`
                pub score: u8,
                /// The field `rid` in the table `BaseStats`
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `rtx_ssrc` in the table `BaseStats`
                pub rtx_ssrc: ::core::option::Option<u32>,
                /// The field `rtx_packets_discarded` in the table `BaseStats`
                pub rtx_packets_discarded: u64,
                /// The field `round_trip_time` in the table `BaseStats`
                pub round_trip_time: f32,
            }

            impl BaseStats {
                /// Creates a [BaseStatsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BaseStatsBuilder<()> {
                    BaseStatsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_packets_lost: impl ::planus::WriteAsDefault<u64, u64>,
                    field_fraction_lost: impl ::planus::WriteAsDefault<u8, u8>,
                    field_packets_discarded: impl ::planus::WriteAsDefault<u64, u64>,
                    field_packets_retransmitted: impl ::planus::WriteAsDefault<u64, u64>,
                    field_packets_repaired: impl ::planus::WriteAsDefault<u64, u64>,
                    field_nack_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_nack_packet_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_pli_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_fir_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_rtx_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_rtx_packets_discarded: impl ::planus::WriteAsDefault<u64, u64>,
                    field_round_trip_time: impl ::planus::WriteAsDefault<f32, f32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);
                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::Audio);
                    let prepared_mime_type = field_mime_type.prepare(builder);
                    let prepared_packets_lost = field_packets_lost.prepare(builder, &0);
                    let prepared_fraction_lost = field_fraction_lost.prepare(builder, &0);
                    let prepared_packets_discarded = field_packets_discarded.prepare(builder, &0);
                    let prepared_packets_retransmitted =
                        field_packets_retransmitted.prepare(builder, &0);
                    let prepared_packets_repaired = field_packets_repaired.prepare(builder, &0);
                    let prepared_nack_count = field_nack_count.prepare(builder, &0);
                    let prepared_nack_packet_count = field_nack_packet_count.prepare(builder, &0);
                    let prepared_pli_count = field_pli_count.prepare(builder, &0);
                    let prepared_fir_count = field_fir_count.prepare(builder, &0);
                    let prepared_score = field_score.prepare(builder, &0);
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_rtx_ssrc = field_rtx_ssrc.prepare(builder);
                    let prepared_rtx_packets_discarded =
                        field_rtx_packets_discarded.prepare(builder, &0);
                    let prepared_round_trip_time = field_round_trip_time.prepare(builder, &0.0);

                    let mut table_writer: ::planus::table_writer::TableWriter<40> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(0);
                    }
                    if prepared_packets_lost.is_some() {
                        table_writer.write_entry::<u64>(4);
                    }
                    if prepared_packets_discarded.is_some() {
                        table_writer.write_entry::<u64>(6);
                    }
                    if prepared_packets_retransmitted.is_some() {
                        table_writer.write_entry::<u64>(7);
                    }
                    if prepared_packets_repaired.is_some() {
                        table_writer.write_entry::<u64>(8);
                    }
                    if prepared_nack_count.is_some() {
                        table_writer.write_entry::<u64>(9);
                    }
                    if prepared_nack_packet_count.is_some() {
                        table_writer.write_entry::<u64>(10);
                    }
                    if prepared_pli_count.is_some() {
                        table_writer.write_entry::<u64>(11);
                    }
                    if prepared_fir_count.is_some() {
                        table_writer.write_entry::<u64>(12);
                    }
                    if prepared_rtx_packets_discarded.is_some() {
                        table_writer.write_entry::<u64>(16);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(3);
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(14);
                    }
                    if prepared_rtx_ssrc.is_some() {
                        table_writer.write_entry::<u32>(15);
                    }
                    if prepared_round_trip_time.is_some() {
                        table_writer.write_entry::<f32>(17);
                    }
                    if prepared_kind.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::MediaKind>(2);
                    }
                    if prepared_fraction_lost.is_some() {
                        table_writer.write_entry::<u8>(5);
                    }
                    if prepared_score.is_some() {
                        table_writer.write_entry::<u8>(13);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_packets_lost) =
                                prepared_packets_lost
                            {
                                object_writer.write::<_, _, 8>(&prepared_packets_lost);
                            }
                            if let ::core::option::Option::Some(prepared_packets_discarded) =
                                prepared_packets_discarded
                            {
                                object_writer.write::<_, _, 8>(&prepared_packets_discarded);
                            }
                            if let ::core::option::Option::Some(prepared_packets_retransmitted) =
                                prepared_packets_retransmitted
                            {
                                object_writer.write::<_, _, 8>(&prepared_packets_retransmitted);
                            }
                            if let ::core::option::Option::Some(prepared_packets_repaired) =
                                prepared_packets_repaired
                            {
                                object_writer.write::<_, _, 8>(&prepared_packets_repaired);
                            }
                            if let ::core::option::Option::Some(prepared_nack_count) =
                                prepared_nack_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_nack_count);
                            }
                            if let ::core::option::Option::Some(prepared_nack_packet_count) =
                                prepared_nack_packet_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_nack_packet_count);
                            }
                            if let ::core::option::Option::Some(prepared_pli_count) =
                                prepared_pli_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_pli_count);
                            }
                            if let ::core::option::Option::Some(prepared_fir_count) =
                                prepared_fir_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_fir_count);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_packets_discarded) =
                                prepared_rtx_packets_discarded
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtx_packets_discarded);
                            }
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            object_writer.write::<_, _, 4>(&prepared_mime_type);
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 4>(&prepared_rid);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_ssrc) =
                                prepared_rtx_ssrc
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtx_ssrc);
                            }
                            if let ::core::option::Option::Some(prepared_round_trip_time) =
                                prepared_round_trip_time
                            {
                                object_writer.write::<_, _, 4>(&prepared_round_trip_time);
                            }
                            if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                                object_writer.write::<_, _, 1>(&prepared_kind);
                            }
                            if let ::core::option::Option::Some(prepared_fraction_lost) =
                                prepared_fraction_lost
                            {
                                object_writer.write::<_, _, 1>(&prepared_fraction_lost);
                            }
                            if let ::core::option::Option::Some(prepared_score) = prepared_score {
                                object_writer.write::<_, _, 1>(&prepared_score);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BaseStats>> for BaseStats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BaseStats>> for BaseStats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BaseStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BaseStats> for BaseStats {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats> {
                    BaseStats::create(
                        builder,
                        self.timestamp,
                        self.ssrc,
                        self.kind,
                        &self.mime_type,
                        self.packets_lost,
                        self.fraction_lost,
                        self.packets_discarded,
                        self.packets_retransmitted,
                        self.packets_repaired,
                        self.nack_count,
                        self.nack_packet_count,
                        self.pli_count,
                        self.fir_count,
                        self.score,
                        &self.rid,
                        self.rtx_ssrc,
                        self.rtx_packets_discarded,
                        self.round_trip_time,
                    )
                }
            }

            /// Builder for serializing an instance of the [BaseStats] type.
            ///
            /// Can be created using the [BaseStats::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BaseStatsBuilder<State>(State);

            impl BaseStatsBuilder<()> {
                /// Setter for the [`timestamp` field](BaseStats#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T0>(self, value: T0) -> BaseStatsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u64, u64>,
                {
                    BaseStatsBuilder((value,))
                }

                /// Sets the [`timestamp` field](BaseStats#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(self) -> BaseStatsBuilder<(::planus::DefaultValue,)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0> BaseStatsBuilder<(T0,)> {
                /// Setter for the [`ssrc` field](BaseStats#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T1>(self, value: T1) -> BaseStatsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    BaseStatsBuilder((v0, value))
                }

                /// Sets the [`ssrc` field](BaseStats#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> BaseStatsBuilder<(T0, ::planus::DefaultValue)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0, T1> BaseStatsBuilder<(T0, T1)> {
                /// Setter for the [`kind` field](BaseStats#structfield.kind).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind<T2>(self, value: T2) -> BaseStatsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                {
                    let (v0, v1) = self.0;
                    BaseStatsBuilder((v0, v1, value))
                }

                /// Sets the [`kind` field](BaseStats#structfield.kind) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind_as_default(self) -> BaseStatsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.kind(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> BaseStatsBuilder<(T0, T1, T2)> {
                /// Setter for the [`mime_type` field](BaseStats#structfield.mime_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mime_type<T3>(self, value: T3) -> BaseStatsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2) = self.0;
                    BaseStatsBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> BaseStatsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`packets_lost` field](BaseStats#structfield.packets_lost).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_lost<T4>(self, value: T4) -> BaseStatsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`packets_lost` field](BaseStats#structfield.packets_lost) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_lost_as_default(
                    self,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.packets_lost(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> BaseStatsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`fraction_lost` field](BaseStats#structfield.fraction_lost).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn fraction_lost<T5>(
                    self,
                    value: T5,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`fraction_lost` field](BaseStats#structfield.fraction_lost) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn fraction_lost_as_default(
                    self,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.fraction_lost(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`packets_discarded` field](BaseStats#structfield.packets_discarded).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_discarded<T6>(
                    self,
                    value: T6,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`packets_discarded` field](BaseStats#structfield.packets_discarded) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_discarded_as_default(
                    self,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.packets_discarded(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`packets_retransmitted` field](BaseStats#structfield.packets_retransmitted).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_retransmitted<T7>(
                    self,
                    value: T7,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`packets_retransmitted` field](BaseStats#structfield.packets_retransmitted) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_retransmitted_as_default(
                    self,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.packets_retransmitted(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`packets_repaired` field](BaseStats#structfield.packets_repaired).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_repaired<T8>(
                    self,
                    value: T8,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`packets_repaired` field](BaseStats#structfield.packets_repaired) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packets_repaired_as_default(
                    self,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.packets_repaired(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`nack_count` field](BaseStats#structfield.nack_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn nack_count<T9>(
                    self,
                    value: T9,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`nack_count` field](BaseStats#structfield.nack_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn nack_count_as_default(
                    self,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ::planus::DefaultValue)>
                {
                    self.nack_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`nack_packet_count` field](BaseStats#structfield.nack_packet_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn nack_packet_count<T10>(
                    self,
                    value: T10,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`nack_packet_count` field](BaseStats#structfield.nack_packet_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn nack_packet_count_as_default(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.nack_packet_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`pli_count` field](BaseStats#structfield.pli_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn pli_count<T11>(
                    self,
                    value: T11,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`pli_count` field](BaseStats#structfield.pli_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn pli_count_as_default(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.pli_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`fir_count` field](BaseStats#structfield.fir_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn fir_count<T12>(
                    self,
                    value: T12,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`fir_count` field](BaseStats#structfield.fir_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn fir_count_as_default(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.fir_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`score` field](BaseStats#structfield.score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score<T13>(
                    self,
                    value: T13,
                ) -> BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
                where
                    T13: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    BaseStatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value))
                }

                /// Sets the [`score` field](BaseStats#structfield.score) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score_as_default(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.score(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                BaseStatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`rid` field](BaseStats#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T14>(
                    self,
                    value: T14,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    BaseStatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`rid` field](BaseStats#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    (),
                )> {
                    self.rid(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`rtx_ssrc` field](BaseStats#structfield.rtx_ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_ssrc<T15>(
                    self,
                    value: T15,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAsOptional<u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    BaseStatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }

                /// Sets the [`rtx_ssrc` field](BaseStats#structfield.rtx_ssrc) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_ssrc_as_null(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    (),
                )> {
                    self.rtx_ssrc(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Setter for the [`rtx_packets_discarded` field](BaseStats#structfield.rtx_packets_discarded).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_packets_discarded<T16>(
                    self,
                    value: T16,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
                where
                    T16: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        self.0;
                    BaseStatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, value,
                    ))
                }

                /// Sets the [`rtx_packets_discarded` field](BaseStats#structfield.rtx_packets_discarded) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_packets_discarded_as_default(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    ::planus::DefaultValue,
                )> {
                    self.rtx_packets_discarded(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
                BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
            {
                /// Setter for the [`round_trip_time` field](BaseStats#structfield.round_trip_time).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn round_trip_time<T17>(
                    self,
                    value: T17,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
                where
                    T17: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) =
                        self.0;
                    BaseStatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        value,
                    ))
                }

                /// Sets the [`round_trip_time` field](BaseStats#structfield.round_trip_time) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn round_trip_time_as_default(
                    self,
                ) -> BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    ::planus::DefaultValue,
                )> {
                    self.round_trip_time(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                >
                BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BaseStats].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats>
                where
                    Self: ::planus::WriteAsOffset<BaseStats>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u8, u8>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u64, u64>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u64, u64>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u64, u64>,
                    T13: ::planus::WriteAsDefault<u8, u8>,
                    T14: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T15: ::planus::WriteAsOptional<u32>,
                    T16: ::planus::WriteAsDefault<u64, u64>,
                    T17: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAs<::planus::Offset<BaseStats>>
                for BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                type Prepared = ::planus::Offset<BaseStats>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u8, u8>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u64, u64>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u64, u64>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u64, u64>,
                    T13: ::planus::WriteAsDefault<u8, u8>,
                    T14: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T15: ::planus::WriteAsOptional<u32>,
                    T16: ::planus::WriteAsDefault<u64, u64>,
                    T17: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOptional<::planus::Offset<BaseStats>>
                for BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                type Prepared = ::planus::Offset<BaseStats>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BaseStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u8, u8>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u64, u64>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u64, u64>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u64, u64>,
                    T13: ::planus::WriteAsDefault<u8, u8>,
                    T14: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T15: ::planus::WriteAsOptional<u32>,
                    T16: ::planus::WriteAsDefault<u64, u64>,
                    T17: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOffset<BaseStats>
                for BaseStatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats> {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                    ) = &self.0;
                    BaseStats::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15, v16, v17,
                    )
                }
            }

            /// Reference to a deserialized [BaseStats].
            #[derive(Copy, Clone)]
            pub struct BaseStatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BaseStatsRef<'a> {
                /// Getter for the [`timestamp` field](BaseStats#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "BaseStats", "timestamp")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`ssrc` field](BaseStats#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(1, "BaseStats", "ssrc")?.unwrap_or(0))
                }

                /// Getter for the [`kind` field](BaseStats#structfield.kind).
                #[inline]
                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "BaseStats", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::Audio),
                    )
                }

                /// Getter for the [`mime_type` field](BaseStats#structfield.mime_type).
                #[inline]
                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "BaseStats", "mime_type")
                }

                /// Getter for the [`packets_lost` field](BaseStats#structfield.packets_lost).
                #[inline]
                pub fn packets_lost(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "BaseStats", "packets_lost")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`fraction_lost` field](BaseStats#structfield.fraction_lost).
                #[inline]
                pub fn fraction_lost(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "BaseStats", "fraction_lost")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`packets_discarded` field](BaseStats#structfield.packets_discarded).
                #[inline]
                pub fn packets_discarded(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "BaseStats", "packets_discarded")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`packets_retransmitted` field](BaseStats#structfield.packets_retransmitted).
                #[inline]
                pub fn packets_retransmitted(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "BaseStats", "packets_retransmitted")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`packets_repaired` field](BaseStats#structfield.packets_repaired).
                #[inline]
                pub fn packets_repaired(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "BaseStats", "packets_repaired")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`nack_count` field](BaseStats#structfield.nack_count).
                #[inline]
                pub fn nack_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "BaseStats", "nack_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`nack_packet_count` field](BaseStats#structfield.nack_packet_count).
                #[inline]
                pub fn nack_packet_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "BaseStats", "nack_packet_count")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`pli_count` field](BaseStats#structfield.pli_count).
                #[inline]
                pub fn pli_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(11, "BaseStats", "pli_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`fir_count` field](BaseStats#structfield.fir_count).
                #[inline]
                pub fn fir_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(12, "BaseStats", "fir_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`score` field](BaseStats#structfield.score).
                #[inline]
                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "BaseStats", "score")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rid` field](BaseStats#structfield.rid).
                #[inline]
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(14, "BaseStats", "rid")
                }

                /// Getter for the [`rtx_ssrc` field](BaseStats#structfield.rtx_ssrc).
                #[inline]
                pub fn rtx_ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(15, "BaseStats", "rtx_ssrc")
                }

                /// Getter for the [`rtx_packets_discarded` field](BaseStats#structfield.rtx_packets_discarded).
                #[inline]
                pub fn rtx_packets_discarded(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(16, "BaseStats", "rtx_packets_discarded")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`round_trip_time` field](BaseStats#structfield.round_trip_time).
                #[inline]
                pub fn round_trip_time(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(17, "BaseStats", "round_trip_time")?
                            .unwrap_or(0.0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BaseStatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BaseStatsRef");
                    f.field("timestamp", &self.timestamp());
                    f.field("ssrc", &self.ssrc());
                    f.field("kind", &self.kind());
                    f.field("mime_type", &self.mime_type());
                    f.field("packets_lost", &self.packets_lost());
                    f.field("fraction_lost", &self.fraction_lost());
                    f.field("packets_discarded", &self.packets_discarded());
                    f.field("packets_retransmitted", &self.packets_retransmitted());
                    f.field("packets_repaired", &self.packets_repaired());
                    f.field("nack_count", &self.nack_count());
                    f.field("nack_packet_count", &self.nack_packet_count());
                    f.field("pli_count", &self.pli_count());
                    f.field("fir_count", &self.fir_count());
                    f.field("score", &self.score());
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_rtx_ssrc) =
                        self.rtx_ssrc().transpose()
                    {
                        f.field("rtx_ssrc", &field_rtx_ssrc);
                    }
                    f.field("rtx_packets_discarded", &self.rtx_packets_discarded());
                    f.field("round_trip_time", &self.round_trip_time());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BaseStatsRef<'a>> for BaseStats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BaseStatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        packets_lost: ::core::convert::TryInto::try_into(value.packets_lost()?)?,
                        fraction_lost: ::core::convert::TryInto::try_into(value.fraction_lost()?)?,
                        packets_discarded: ::core::convert::TryInto::try_into(
                            value.packets_discarded()?,
                        )?,
                        packets_retransmitted: ::core::convert::TryInto::try_into(
                            value.packets_retransmitted()?,
                        )?,
                        packets_repaired: ::core::convert::TryInto::try_into(
                            value.packets_repaired()?,
                        )?,
                        nack_count: ::core::convert::TryInto::try_into(value.nack_count()?)?,
                        nack_packet_count: ::core::convert::TryInto::try_into(
                            value.nack_packet_count()?,
                        )?,
                        pli_count: ::core::convert::TryInto::try_into(value.pli_count()?)?,
                        fir_count: ::core::convert::TryInto::try_into(value.fir_count()?)?,
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx_ssrc: if let ::core::option::Option::Some(rtx_ssrc) =
                            value.rtx_ssrc()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtx_ssrc,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx_packets_discarded: ::core::convert::TryInto::try_into(
                            value.rtx_packets_discarded()?,
                        )?,
                        round_trip_time: ::core::convert::TryInto::try_into(
                            value.round_trip_time()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BaseStatsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BaseStatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BaseStatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BaseStats>> for BaseStats {
                type Value = ::planus::Offset<BaseStats>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BaseStats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BaseStatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BaseStatsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RecvStats` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `RecvStats` in the file `../worker/fbs/rtpStream.fbs:67`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RecvStats {
                /// The field `base` in the table `RecvStats`
                pub base: ::planus::alloc::boxed::Box<self::Stats>,
                /// The field `jitter` in the table `RecvStats`
                pub jitter: u32,
                /// The field `packet_count` in the table `RecvStats`
                pub packet_count: u64,
                /// The field `byte_count` in the table `RecvStats`
                pub byte_count: u64,
                /// The field `bitrate` in the table `RecvStats`
                pub bitrate: u32,
                /// The field `bitrate_by_layer` in the table `RecvStats`
                pub bitrate_by_layer: ::planus::alloc::vec::Vec<self::BitrateByLayer>,
            }

            impl RecvStats {
                /// Creates a [RecvStatsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RecvStatsBuilder<()> {
                    RecvStatsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    field_jitter: impl ::planus::WriteAsDefault<u32, u32>,
                    field_packet_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_byte_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_bitrate_by_layer: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_jitter = field_jitter.prepare(builder, &0);
                    let prepared_packet_count = field_packet_count.prepare(builder, &0);
                    let prepared_byte_count = field_byte_count.prepare(builder, &0);
                    let prepared_bitrate = field_bitrate.prepare(builder, &0);
                    let prepared_bitrate_by_layer = field_bitrate_by_layer.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    if prepared_packet_count.is_some() {
                        table_writer.write_entry::<u64>(2);
                    }
                    if prepared_byte_count.is_some() {
                        table_writer.write_entry::<u64>(3);
                    }
                    table_writer.write_entry::<::planus::Offset<self::Stats>>(0);
                    if prepared_jitter.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_bitrate.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>>(
                            5,
                        );

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_packet_count) =
                                prepared_packet_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_packet_count);
                            }
                            if let ::core::option::Option::Some(prepared_byte_count) =
                                prepared_byte_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_byte_count);
                            }
                            object_writer.write::<_, _, 4>(&prepared_base);
                            if let ::core::option::Option::Some(prepared_jitter) = prepared_jitter {
                                object_writer.write::<_, _, 4>(&prepared_jitter);
                            }
                            if let ::core::option::Option::Some(prepared_bitrate) = prepared_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_bitrate);
                            }
                            object_writer.write::<_, _, 4>(&prepared_bitrate_by_layer);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RecvStats>> for RecvStats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RecvStats>> for RecvStats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RecvStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RecvStats> for RecvStats {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats> {
                    RecvStats::create(
                        builder,
                        &self.base,
                        self.jitter,
                        self.packet_count,
                        self.byte_count,
                        self.bitrate,
                        &self.bitrate_by_layer,
                    )
                }
            }

            /// Builder for serializing an instance of the [RecvStats] type.
            ///
            /// Can be created using the [RecvStats::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RecvStatsBuilder<State>(State);

            impl RecvStatsBuilder<()> {
                /// Setter for the [`base` field](RecvStats#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> RecvStatsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                {
                    RecvStatsBuilder((value,))
                }
            }

            impl<T0> RecvStatsBuilder<(T0,)> {
                /// Setter for the [`jitter` field](RecvStats#structfield.jitter).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn jitter<T1>(self, value: T1) -> RecvStatsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    RecvStatsBuilder((v0, value))
                }

                /// Sets the [`jitter` field](RecvStats#structfield.jitter) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn jitter_as_default(self) -> RecvStatsBuilder<(T0, ::planus::DefaultValue)> {
                    self.jitter(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RecvStatsBuilder<(T0, T1)> {
                /// Setter for the [`packet_count` field](RecvStats#structfield.packet_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packet_count<T2>(self, value: T2) -> RecvStatsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1) = self.0;
                    RecvStatsBuilder((v0, v1, value))
                }

                /// Sets the [`packet_count` field](RecvStats#structfield.packet_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packet_count_as_default(
                    self,
                ) -> RecvStatsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.packet_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> RecvStatsBuilder<(T0, T1, T2)> {
                /// Setter for the [`byte_count` field](RecvStats#structfield.byte_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn byte_count<T3>(self, value: T3) -> RecvStatsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2) = self.0;
                    RecvStatsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`byte_count` field](RecvStats#structfield.byte_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn byte_count_as_default(
                    self,
                ) -> RecvStatsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.byte_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> RecvStatsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`bitrate` field](RecvStats#structfield.bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate<T4>(self, value: T4) -> RecvStatsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    RecvStatsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`bitrate` field](RecvStats#structfield.bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate_as_default(
                    self,
                ) -> RecvStatsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> RecvStatsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`bitrate_by_layer` field](RecvStats#structfield.bitrate_by_layer).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate_by_layer<T5>(
                    self,
                    value: T5,
                ) -> RecvStatsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    RecvStatsBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> RecvStatsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RecvStats].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats>
                where
                    Self: ::planus::WriteAsOffset<RecvStats>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>>,
                > ::planus::WriteAs<::planus::Offset<RecvStats>>
                for RecvStatsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<RecvStats>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<RecvStats>>
                for RecvStatsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<RecvStats>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RecvStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>>,
                > ::planus::WriteAsOffset<RecvStats>
                for RecvStatsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    RecvStats::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [RecvStats].
            #[derive(Copy, Clone)]
            pub struct RecvStatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RecvStatsRef<'a> {
                /// Getter for the [`base` field](RecvStats#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<self::StatsRef<'a>> {
                    self.0.access_required(0, "RecvStats", "base")
                }

                /// Getter for the [`jitter` field](RecvStats#structfield.jitter).
                #[inline]
                pub fn jitter(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "RecvStats", "jitter")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`packet_count` field](RecvStats#structfield.packet_count).
                #[inline]
                pub fn packet_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "RecvStats", "packet_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`byte_count` field](RecvStats#structfield.byte_count).
                #[inline]
                pub fn byte_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "RecvStats", "byte_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`bitrate` field](RecvStats#structfield.bitrate).
                #[inline]
                pub fn bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "RecvStats", "bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`bitrate_by_layer` field](RecvStats#structfield.bitrate_by_layer).
                #[inline]
                pub fn bitrate_by_layer(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::BitrateByLayerRef<'a>>>,
                > {
                    self.0.access_required(5, "RecvStats", "bitrate_by_layer")
                }
            }

            impl<'a> ::core::fmt::Debug for RecvStatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RecvStatsRef");
                    f.field("base", &self.base());
                    f.field("jitter", &self.jitter());
                    f.field("packet_count", &self.packet_count());
                    f.field("byte_count", &self.byte_count());
                    f.field("bitrate", &self.bitrate());
                    f.field("bitrate_by_layer", &self.bitrate_by_layer());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RecvStatsRef<'a>> for RecvStats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RecvStatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        jitter: ::core::convert::TryInto::try_into(value.jitter()?)?,
                        packet_count: ::core::convert::TryInto::try_into(value.packet_count()?)?,
                        byte_count: ::core::convert::TryInto::try_into(value.byte_count()?)?,
                        bitrate: ::core::convert::TryInto::try_into(value.bitrate()?)?,
                        bitrate_by_layer: value.bitrate_by_layer()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RecvStatsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RecvStatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RecvStatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RecvStats>> for RecvStats {
                type Value = ::planus::Offset<RecvStats>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RecvStats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RecvStatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RecvStatsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SendStats` in the namespace `FBS.RtpStream`
            ///
            /// Generated from these locations:
            /// * Table `SendStats` in the file `../worker/fbs/rtpStream.fbs:76`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct SendStats {
                /// The field `base` in the table `SendStats`
                pub base: ::planus::alloc::boxed::Box<self::Stats>,
                /// The field `packet_count` in the table `SendStats`
                pub packet_count: u64,
                /// The field `byte_count` in the table `SendStats`
                pub byte_count: u64,
                /// The field `bitrate` in the table `SendStats`
                pub bitrate: u32,
            }

            impl SendStats {
                /// Creates a [SendStatsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SendStatsBuilder<()> {
                    SendStatsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    field_packet_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_byte_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_packet_count = field_packet_count.prepare(builder, &0);
                    let prepared_byte_count = field_byte_count.prepare(builder, &0);
                    let prepared_bitrate = field_bitrate.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_packet_count.is_some() {
                        table_writer.write_entry::<u64>(1);
                    }
                    if prepared_byte_count.is_some() {
                        table_writer.write_entry::<u64>(2);
                    }
                    table_writer.write_entry::<::planus::Offset<self::Stats>>(0);
                    if prepared_bitrate.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_packet_count) =
                                prepared_packet_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_packet_count);
                            }
                            if let ::core::option::Option::Some(prepared_byte_count) =
                                prepared_byte_count
                            {
                                object_writer.write::<_, _, 8>(&prepared_byte_count);
                            }
                            object_writer.write::<_, _, 4>(&prepared_base);
                            if let ::core::option::Option::Some(prepared_bitrate) = prepared_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_bitrate);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendStats>> for SendStats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendStats>> for SendStats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendStats> for SendStats {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats> {
                    SendStats::create(
                        builder,
                        &self.base,
                        self.packet_count,
                        self.byte_count,
                        self.bitrate,
                    )
                }
            }

            /// Builder for serializing an instance of the [SendStats] type.
            ///
            /// Can be created using the [SendStats::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SendStatsBuilder<State>(State);

            impl SendStatsBuilder<()> {
                /// Setter for the [`base` field](SendStats#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> SendStatsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                {
                    SendStatsBuilder((value,))
                }
            }

            impl<T0> SendStatsBuilder<(T0,)> {
                /// Setter for the [`packet_count` field](SendStats#structfield.packet_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packet_count<T1>(self, value: T1) -> SendStatsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0,) = self.0;
                    SendStatsBuilder((v0, value))
                }

                /// Sets the [`packet_count` field](SendStats#structfield.packet_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn packet_count_as_default(
                    self,
                ) -> SendStatsBuilder<(T0, ::planus::DefaultValue)> {
                    self.packet_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1> SendStatsBuilder<(T0, T1)> {
                /// Setter for the [`byte_count` field](SendStats#structfield.byte_count).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn byte_count<T2>(self, value: T2) -> SendStatsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1) = self.0;
                    SendStatsBuilder((v0, v1, value))
                }

                /// Sets the [`byte_count` field](SendStats#structfield.byte_count) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn byte_count_as_default(
                    self,
                ) -> SendStatsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.byte_count(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> SendStatsBuilder<(T0, T1, T2)> {
                /// Setter for the [`bitrate` field](SendStats#structfield.bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate<T3>(self, value: T3) -> SendStatsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    SendStatsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`bitrate` field](SendStats#structfield.bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bitrate_as_default(
                    self,
                ) -> SendStatsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> SendStatsBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SendStats].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats>
                where
                    Self: ::planus::WriteAsOffset<SendStats>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<SendStats>>
                for SendStatsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<SendStats>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<SendStats>>
                for SendStatsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<SendStats>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<SendStats> for SendStatsBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats> {
                    let (v0, v1, v2, v3) = &self.0;
                    SendStats::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [SendStats].
            #[derive(Copy, Clone)]
            pub struct SendStatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendStatsRef<'a> {
                /// Getter for the [`base` field](SendStats#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<self::StatsRef<'a>> {
                    self.0.access_required(0, "SendStats", "base")
                }

                /// Getter for the [`packet_count` field](SendStats#structfield.packet_count).
                #[inline]
                pub fn packet_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "SendStats", "packet_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`byte_count` field](SendStats#structfield.byte_count).
                #[inline]
                pub fn byte_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "SendStats", "byte_count")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`bitrate` field](SendStats#structfield.bitrate).
                #[inline]
                pub fn bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "SendStats", "bitrate")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SendStatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendStatsRef");
                    f.field("base", &self.base());
                    f.field("packet_count", &self.packet_count());
                    f.field("byte_count", &self.byte_count());
                    f.field("bitrate", &self.bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendStatsRef<'a>> for SendStats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendStatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        packet_count: ::core::convert::TryInto::try_into(value.packet_count()?)?,
                        byte_count: ::core::convert::TryInto::try_into(value.byte_count()?)?,
                        bitrate: ::core::convert::TryInto::try_into(value.bitrate()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendStatsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendStatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendStatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendStats>> for SendStats {
                type Value = ::planus::Offset<SendStats>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendStats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendStatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendStatsRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.RtxStream`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/rtxStream.fbs`
        pub mod rtx_stream {
            /// The table `Params` in the namespace `FBS.RtxStream`
            ///
            /// Generated from these locations:
            /// * Table `Params` in the file `../worker/fbs/rtxStream.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Params {
                /// The field `ssrc` in the table `Params`
                pub ssrc: u32,
                /// The field `payload_type` in the table `Params`
                pub payload_type: u8,
                /// The field `mime_type` in the table `Params`
                pub mime_type: ::planus::alloc::string::String,
                /// The field `clock_rate` in the table `Params`
                pub clock_rate: u32,
                /// The field `rrid` in the table `Params`
                pub rrid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `cname` in the table `Params`
                pub cname: ::planus::alloc::string::String,
            }

            impl Params {
                /// Creates a [ParamsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ParamsBuilder<()> {
                    ParamsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_clock_rate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rrid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_cname: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);
                    let prepared_payload_type = field_payload_type.prepare(builder, &0);
                    let prepared_mime_type = field_mime_type.prepare(builder);
                    let prepared_clock_rate = field_clock_rate.prepare(builder, &0);
                    let prepared_rrid = field_rrid.prepare(builder);
                    let prepared_cname = field_cname.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_clock_rate.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }
                    if prepared_rrid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(4);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(5);
                    if prepared_payload_type.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            object_writer.write::<_, _, 4>(&prepared_mime_type);
                            if let ::core::option::Option::Some(prepared_clock_rate) =
                                prepared_clock_rate
                            {
                                object_writer.write::<_, _, 4>(&prepared_clock_rate);
                            }
                            if let ::core::option::Option::Some(prepared_rrid) = prepared_rrid {
                                object_writer.write::<_, _, 4>(&prepared_rrid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_cname);
                            if let ::core::option::Option::Some(prepared_payload_type) =
                                prepared_payload_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_payload_type);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Params>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Params> for Params {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    Params::create(
                        builder,
                        self.ssrc,
                        self.payload_type,
                        &self.mime_type,
                        self.clock_rate,
                        &self.rrid,
                        &self.cname,
                    )
                }
            }

            /// Builder for serializing an instance of the [Params] type.
            ///
            /// Can be created using the [Params::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ParamsBuilder<State>(State);

            impl ParamsBuilder<()> {
                /// Setter for the [`ssrc` field](Params#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> ParamsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    ParamsBuilder((value,))
                }

                /// Sets the [`ssrc` field](Params#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> ParamsBuilder<(::planus::DefaultValue,)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0> ParamsBuilder<(T0,)> {
                /// Setter for the [`payload_type` field](Params#structfield.payload_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type<T1>(self, value: T1) -> ParamsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0,) = self.0;
                    ParamsBuilder((v0, value))
                }

                /// Sets the [`payload_type` field](Params#structfield.payload_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn payload_type_as_default(
                    self,
                ) -> ParamsBuilder<(T0, ::planus::DefaultValue)> {
                    self.payload_type(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ParamsBuilder<(T0, T1)> {
                /// Setter for the [`mime_type` field](Params#structfield.mime_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mime_type<T2>(self, value: T2) -> ParamsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    ParamsBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> ParamsBuilder<(T0, T1, T2)> {
                /// Setter for the [`clock_rate` field](Params#structfield.clock_rate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn clock_rate<T3>(self, value: T3) -> ParamsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    ParamsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`clock_rate` field](Params#structfield.clock_rate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn clock_rate_as_default(
                    self,
                ) -> ParamsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.clock_rate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> ParamsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`rrid` field](Params#structfield.rrid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rrid<T4>(self, value: T4) -> ParamsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`rrid` field](Params#structfield.rrid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rrid_as_null(self) -> ParamsBuilder<(T0, T1, T2, T3, ())> {
                    self.rrid(())
                }
            }

            impl<T0, T1, T2, T3, T4> ParamsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`cname` field](Params#structfield.cname).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn cname<T5>(self, value: T5) -> ParamsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ParamsBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ParamsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Params].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params>
                where
                    Self: ::planus::WriteAsOffset<Params>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<Params>>
                for ParamsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<Params>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<Params>>
                for ParamsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<Params>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Params>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u8, u8>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<Params> for ParamsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    Params::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [Params].
            #[derive(Copy, Clone)]
            pub struct ParamsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ParamsRef<'a> {
                /// Getter for the [`ssrc` field](Params#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Params", "ssrc")?.unwrap_or(0))
                }

                /// Getter for the [`payload_type` field](Params#structfield.payload_type).
                #[inline]
                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Params", "payload_type")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`mime_type` field](Params#structfield.mime_type).
                #[inline]
                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "Params", "mime_type")
                }

                /// Getter for the [`clock_rate` field](Params#structfield.clock_rate).
                #[inline]
                pub fn clock_rate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Params", "clock_rate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rrid` field](Params#structfield.rrid).
                #[inline]
                pub fn rrid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "Params", "rrid")
                }

                /// Getter for the [`cname` field](Params#structfield.cname).
                #[inline]
                pub fn cname(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(5, "Params", "cname")
                }
            }

            impl<'a> ::core::fmt::Debug for ParamsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ParamsRef");
                    f.field("ssrc", &self.ssrc());
                    f.field("payload_type", &self.payload_type());
                    f.field("mime_type", &self.mime_type());
                    f.field("clock_rate", &self.clock_rate());
                    if let ::core::option::Option::Some(field_rrid) = self.rrid().transpose() {
                        f.field("rrid", &field_rrid);
                    }
                    f.field("cname", &self.cname());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ParamsRef<'a>> for Params {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ParamsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        clock_rate: ::core::convert::TryInto::try_into(value.clock_rate()?)?,
                        rrid: if let ::core::option::Option::Some(rrid) = value.rrid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rrid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        cname: ::core::convert::TryInto::try_into(value.cname()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ParamsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ParamsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ParamsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Params>> for Params {
                type Value = ::planus::Offset<Params>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Params>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ParamsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ParamsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtxDump` in the namespace `FBS.RtxStream`
            ///
            /// Generated from these locations:
            /// * Table `RtxDump` in the file `../worker/fbs/rtxStream.fbs:13`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtxDump {
                /// The field `params` in the table `RtxDump`
                pub params: ::planus::alloc::boxed::Box<self::Params>,
            }

            impl RtxDump {
                /// Creates a [RtxDumpBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtxDumpBuilder<()> {
                    RtxDumpBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_params: impl ::planus::WriteAs<::planus::Offset<self::Params>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_params = field_params.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::Params>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_params);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtxDump>> for RtxDump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtxDump>> for RtxDump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtxDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtxDump> for RtxDump {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump> {
                    RtxDump::create(builder, &self.params)
                }
            }

            /// Builder for serializing an instance of the [RtxDump] type.
            ///
            /// Can be created using the [RtxDump::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtxDumpBuilder<State>(State);

            impl RtxDumpBuilder<()> {
                /// Setter for the [`params` field](RtxDump#structfield.params).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn params<T0>(self, value: T0) -> RtxDumpBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::Params>>,
                {
                    RtxDumpBuilder((value,))
                }
            }

            impl<T0> RtxDumpBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtxDump].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump>
                where
                    Self: ::planus::WriteAsOffset<RtxDump>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::Params>>>
                ::planus::WriteAs<::planus::Offset<RtxDump>> for RtxDumpBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtxDump>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::Params>>>
                ::planus::WriteAsOptional<::planus::Offset<RtxDump>> for RtxDumpBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtxDump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtxDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::Params>>>
                ::planus::WriteAsOffset<RtxDump> for RtxDumpBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump> {
                    let (v0,) = &self.0;
                    RtxDump::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RtxDump].
            #[derive(Copy, Clone)]
            pub struct RtxDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtxDumpRef<'a> {
                /// Getter for the [`params` field](RtxDump#structfield.params).
                #[inline]
                pub fn params(&self) -> ::planus::Result<self::ParamsRef<'a>> {
                    self.0.access_required(0, "RtxDump", "params")
                }
            }

            impl<'a> ::core::fmt::Debug for RtxDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtxDumpRef");
                    f.field("params", &self.params());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtxDumpRef<'a>> for RtxDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtxDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        params: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.params()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtxDumpRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtxDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtxDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtxDump>> for RtxDump {
                type Value = ::planus::Offset<RtxDump>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtxDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtxDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtxDumpRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.DataConsumer`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/dataConsumer.fbs`
        pub mod data_consumer {
            /// The table `GetBufferedAmountResponse` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `GetBufferedAmountResponse` in the file `../worker/fbs/dataConsumer.fbs:7`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetBufferedAmountResponse {
                /// The field `buffered_amount` in the table `GetBufferedAmountResponse`
                pub buffered_amount: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GetBufferedAmountResponse {
                fn default() -> Self {
                    Self { buffered_amount: 0 }
                }
            }

            impl GetBufferedAmountResponse {
                /// Creates a [GetBufferedAmountResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetBufferedAmountResponseBuilder<()> {
                    GetBufferedAmountResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_buffered_amount.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_buffered_amount) =
                                prepared_buffered_amount
                            {
                                object_writer.write::<_, _, 4>(&prepared_buffered_amount);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetBufferedAmountResponse>> for GetBufferedAmountResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetBufferedAmountResponse>>
                for GetBufferedAmountResponse
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetBufferedAmountResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetBufferedAmountResponse> for GetBufferedAmountResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse> {
                    GetBufferedAmountResponse::create(builder, self.buffered_amount)
                }
            }

            /// Builder for serializing an instance of the [GetBufferedAmountResponse] type.
            ///
            /// Can be created using the [GetBufferedAmountResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetBufferedAmountResponseBuilder<State>(State);

            impl GetBufferedAmountResponseBuilder<()> {
                /// Setter for the [`buffered_amount` field](GetBufferedAmountResponse#structfield.buffered_amount).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount<T0>(
                    self,
                    value: T0,
                ) -> GetBufferedAmountResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    GetBufferedAmountResponseBuilder((value,))
                }

                /// Sets the [`buffered_amount` field](GetBufferedAmountResponse#structfield.buffered_amount) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount_as_default(
                    self,
                ) -> GetBufferedAmountResponseBuilder<(::planus::DefaultValue,)> {
                    self.buffered_amount(::planus::DefaultValue)
                }
            }

            impl<T0> GetBufferedAmountResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetBufferedAmountResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse>
                where
                    Self: ::planus::WriteAsOffset<GetBufferedAmountResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<GetBufferedAmountResponse>>
                for GetBufferedAmountResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetBufferedAmountResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<GetBufferedAmountResponse>>
                for GetBufferedAmountResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetBufferedAmountResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetBufferedAmountResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOffset<GetBufferedAmountResponse>
                for GetBufferedAmountResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse> {
                    let (v0,) = &self.0;
                    GetBufferedAmountResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [GetBufferedAmountResponse].
            #[derive(Copy, Clone)]
            pub struct GetBufferedAmountResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetBufferedAmountResponseRef<'a> {
                /// Getter for the [`buffered_amount` field](GetBufferedAmountResponse#structfield.buffered_amount).
                #[inline]
                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GetBufferedAmountResponse", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetBufferedAmountResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetBufferedAmountResponseRef");
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetBufferedAmountResponseRef<'a>> for GetBufferedAmountResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetBufferedAmountResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetBufferedAmountResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetBufferedAmountResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetBufferedAmountResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetBufferedAmountResponse>>
                for GetBufferedAmountResponse
            {
                type Value = ::planus::Offset<GetBufferedAmountResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetBufferedAmountResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetBufferedAmountResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetBufferedAmountResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SetBufferedAmountLowThresholdRequest` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `SetBufferedAmountLowThresholdRequest` in the file `../worker/fbs/dataConsumer.fbs:11`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetBufferedAmountLowThresholdRequest {
                /// The field `threshold` in the table `SetBufferedAmountLowThresholdRequest`
                pub threshold: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetBufferedAmountLowThresholdRequest {
                fn default() -> Self {
                    Self { threshold: 0 }
                }
            }

            impl SetBufferedAmountLowThresholdRequest {
                /// Creates a [SetBufferedAmountLowThresholdRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetBufferedAmountLowThresholdRequestBuilder<()> {
                    SetBufferedAmountLowThresholdRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_threshold: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_threshold = field_threshold.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_threshold.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_threshold) =
                                prepared_threshold
                            {
                                object_writer.write::<_, _, 4>(&prepared_threshold);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetBufferedAmountLowThresholdRequest>
                for SetBufferedAmountLowThresholdRequest
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest> {
                    SetBufferedAmountLowThresholdRequest::create(builder, self.threshold)
                }
            }

            /// Builder for serializing an instance of the [SetBufferedAmountLowThresholdRequest] type.
            ///
            /// Can be created using the [SetBufferedAmountLowThresholdRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetBufferedAmountLowThresholdRequestBuilder<State>(State);

            impl SetBufferedAmountLowThresholdRequestBuilder<()> {
                /// Setter for the [`threshold` field](SetBufferedAmountLowThresholdRequest#structfield.threshold).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn threshold<T0>(
                    self,
                    value: T0,
                ) -> SetBufferedAmountLowThresholdRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SetBufferedAmountLowThresholdRequestBuilder((value,))
                }

                /// Sets the [`threshold` field](SetBufferedAmountLowThresholdRequest#structfield.threshold) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn threshold_as_default(
                    self,
                ) -> SetBufferedAmountLowThresholdRequestBuilder<(::planus::DefaultValue,)>
                {
                    self.threshold(::planus::DefaultValue)
                }
            }

            impl<T0> SetBufferedAmountLowThresholdRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetBufferedAmountLowThresholdRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest>
                where
                    Self: ::planus::WriteAsOffset<SetBufferedAmountLowThresholdRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetBufferedAmountLowThresholdRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetBufferedAmountLowThresholdRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOffset<SetBufferedAmountLowThresholdRequest>
                for SetBufferedAmountLowThresholdRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest> {
                    let (v0,) = &self.0;
                    SetBufferedAmountLowThresholdRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetBufferedAmountLowThresholdRequest].
            #[derive(Copy, Clone)]
            pub struct SetBufferedAmountLowThresholdRequestRef<'a>(
                ::planus::table_reader::Table<'a>,
            );

            impl<'a> SetBufferedAmountLowThresholdRequestRef<'a> {
                /// Getter for the [`threshold` field](SetBufferedAmountLowThresholdRequest#structfield.threshold).
                #[inline]
                pub fn threshold(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetBufferedAmountLowThresholdRequest", "threshold")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetBufferedAmountLowThresholdRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetBufferedAmountLowThresholdRequestRef");
                    f.field("threshold", &self.threshold());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetBufferedAmountLowThresholdRequestRef<'a>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: SetBufferedAmountLowThresholdRequestRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        threshold: ::core::convert::TryInto::try_into(value.threshold()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetBufferedAmountLowThresholdRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetBufferedAmountLowThresholdRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetBufferedAmountLowThresholdRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Value = ::planus::Offset<SetBufferedAmountLowThresholdRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetBufferedAmountLowThresholdRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetBufferedAmountLowThresholdRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetBufferedAmountLowThresholdRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/dataConsumer.fbs:15`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `id` in the table `DumpResponse`
                pub id: ::planus::alloc::string::String,
                /// The field `data_producer_id` in the table `DumpResponse`
                pub data_producer_id: ::planus::alloc::string::String,
                /// The field `type` in the table `DumpResponse`
                pub type_: super::data_producer::Type,
                /// The field `sctp_stream_parameters` in the table `DumpResponse`
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                /// The field `label` in the table `DumpResponse`
                pub label: ::planus::alloc::string::String,
                /// The field `protocol` in the table `DumpResponse`
                pub protocol: ::planus::alloc::string::String,
                /// The field `buffered_amount_low_threshold` in the table `DumpResponse`
                pub buffered_amount_low_threshold: u32,
                /// The field `paused` in the table `DumpResponse`
                pub paused: bool,
                /// The field `data_producer_paused` in the table `DumpResponse`
                pub data_producer_paused: bool,
                /// The field `subchannels` in the table `DumpResponse`
                pub subchannels: ::planus::alloc::vec::Vec<u16>,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_buffered_amount_low_threshold: impl ::planus::WriteAsDefault<u32, u32>,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_data_producer_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_subchannels: impl ::planus::WriteAs<::planus::Offset<[u16]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::data_producer::Type::Sctp);
                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);
                    let prepared_label = field_label.prepare(builder);
                    let prepared_protocol = field_protocol.prepare(builder);
                    let prepared_buffered_amount_low_threshold =
                        field_buffered_amount_low_threshold.prepare(builder, &0);
                    let prepared_paused = field_paused.prepare(builder, &false);
                    let prepared_data_producer_paused =
                        field_data_producer_paused.prepare(builder, &false);
                    let prepared_subchannels = field_subchannels.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<24> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(3);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(4);
                    table_writer.write_entry::<::planus::Offset<str>>(5);
                    if prepared_buffered_amount_low_threshold.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    table_writer.write_entry::<::planus::Offset<[u16]>>(9);
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::data_producer::Type>(2);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(7);
                    }
                    if prepared_data_producer_paused.is_some() {
                        table_writer.write_entry::<bool>(8);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            object_writer.write::<_, _, 4>(&prepared_data_producer_id);
                            if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                                prepared_sctp_stream_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_stream_parameters);
                            }
                            object_writer.write::<_, _, 4>(&prepared_label);
                            object_writer.write::<_, _, 4>(&prepared_protocol);
                            if let ::core::option::Option::Some(
                                prepared_buffered_amount_low_threshold,
                            ) = prepared_buffered_amount_low_threshold
                            {
                                object_writer
                                    .write::<_, _, 4>(&prepared_buffered_amount_low_threshold);
                            }
                            object_writer.write::<_, _, 4>(&prepared_subchannels);
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                            if let ::core::option::Option::Some(prepared_data_producer_paused) =
                                prepared_data_producer_paused
                            {
                                object_writer.write::<_, _, 1>(&prepared_data_producer_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.data_producer_id,
                        self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                        self.buffered_amount_low_threshold,
                        self.paused,
                        self.data_producer_paused,
                        &self.subchannels,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`data_producer_id` field](DumpResponse#structfield.data_producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_id<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`type` field](DumpResponse#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }

                /// Sets the [`type` field](DumpResponse#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`sctp_stream_parameters` field](DumpResponse#structfield.sctp_stream_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters<T3>(
                    self,
                    value: T3,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`sctp_stream_parameters` field](DumpResponse#structfield.sctp_stream_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters_as_null(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, ())> {
                    self.sctp_stream_parameters(())
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`label` field](DumpResponse#structfield.label).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label<T4>(self, value: T4) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`protocol` field](DumpResponse#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T5>(
                    self,
                    value: T5,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`buffered_amount_low_threshold` field](DumpResponse#structfield.buffered_amount_low_threshold).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount_low_threshold<T6>(
                    self,
                    value: T6,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`buffered_amount_low_threshold` field](DumpResponse#structfield.buffered_amount_low_threshold) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount_low_threshold_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.buffered_amount_low_threshold(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`paused` field](DumpResponse#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T7>(
                    self,
                    value: T7,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`paused` field](DumpResponse#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`data_producer_paused` field](DumpResponse#structfield.data_producer_paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_paused<T8>(
                    self,
                    value: T8,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`data_producer_paused` field](DumpResponse#structfield.data_producer_paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_paused_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.data_producer_paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`subchannels` field](DumpResponse#structfield.subchannels).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels<T9>(
                    self,
                    value: T9,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAs<::planus::Offset<[u16]>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAs<::planus::Offset<[u16]>>,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAs<::planus::Offset<[u16]>>,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAs<::planus::Offset<str>>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAs<::planus::Offset<[u16]>>,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                /// Getter for the [`data_producer_id` field](DumpResponse#structfield.data_producer_id).
                #[inline]
                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "DumpResponse", "data_producer_id")
                }

                /// Getter for the [`type` field](DumpResponse#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::data_producer::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "DumpResponse", "type_")?
                            .unwrap_or(super::data_producer::Type::Sctp),
                    )
                }

                /// Getter for the [`sctp_stream_parameters` field](DumpResponse#structfield.sctp_stream_parameters).
                #[inline]
                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0.access(3, "DumpResponse", "sctp_stream_parameters")
                }

                /// Getter for the [`label` field](DumpResponse#structfield.label).
                #[inline]
                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "DumpResponse", "label")
                }

                /// Getter for the [`protocol` field](DumpResponse#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(5, "DumpResponse", "protocol")
                }

                /// Getter for the [`buffered_amount_low_threshold` field](DumpResponse#structfield.buffered_amount_low_threshold).
                #[inline]
                pub fn buffered_amount_low_threshold(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "DumpResponse", "buffered_amount_low_threshold")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`paused` field](DumpResponse#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(7, "DumpResponse", "paused")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`data_producer_paused` field](DumpResponse#structfield.data_producer_paused).
                #[inline]
                pub fn data_producer_paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "DumpResponse", "data_producer_paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`subchannels` field](DumpResponse#structfield.subchannels).
                #[inline]
                pub fn subchannels(&self) -> ::planus::Result<::planus::Vector<'a, u16>> {
                    self.0.access_required(9, "DumpResponse", "subchannels")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("data_producer_id", &self.data_producer_id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.field(
                        "buffered_amount_low_threshold",
                        &self.buffered_amount_low_threshold(),
                    );
                    f.field("paused", &self.paused());
                    f.field("data_producer_paused", &self.data_producer_paused());
                    f.field("subchannels", &self.subchannels());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        buffered_amount_low_threshold: ::core::convert::TryInto::try_into(
                            value.buffered_amount_low_threshold()?,
                        )?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        data_producer_paused: ::core::convert::TryInto::try_into(
                            value.data_producer_paused()?,
                        )?,
                        subchannels: value.subchannels()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/dataConsumer.fbs:28`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `timestamp` in the table `GetStatsResponse`
                pub timestamp: u64,
                /// The field `label` in the table `GetStatsResponse`
                pub label: ::planus::alloc::string::String,
                /// The field `protocol` in the table `GetStatsResponse`
                pub protocol: ::planus::alloc::string::String,
                /// The field `messages_sent` in the table `GetStatsResponse`
                pub messages_sent: u64,
                /// The field `bytes_sent` in the table `GetStatsResponse`
                pub bytes_sent: u64,
                /// The field `buffered_amount` in the table `GetStatsResponse`
                pub buffered_amount: u32,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_messages_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_label = field_label.prepare(builder);
                    let prepared_protocol = field_protocol.prepare(builder);
                    let prepared_messages_sent = field_messages_sent.prepare(builder, &0);
                    let prepared_bytes_sent = field_bytes_sent.prepare(builder, &0);
                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(0);
                    }
                    if prepared_messages_sent.is_some() {
                        table_writer.write_entry::<u64>(3);
                    }
                    if prepared_bytes_sent.is_some() {
                        table_writer.write_entry::<u64>(4);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_buffered_amount.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_messages_sent) =
                                prepared_messages_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_messages_sent);
                            }
                            if let ::core::option::Option::Some(prepared_bytes_sent) =
                                prepared_bytes_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_bytes_sent);
                            }
                            object_writer.write::<_, _, 4>(&prepared_label);
                            object_writer.write::<_, _, 4>(&prepared_protocol);
                            if let ::core::option::Option::Some(prepared_buffered_amount) =
                                prepared_buffered_amount
                            {
                                object_writer.write::<_, _, 4>(&prepared_buffered_amount);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        self.timestamp,
                        &self.label,
                        &self.protocol,
                        self.messages_sent,
                        self.bytes_sent,
                        self.buffered_amount,
                    )
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`timestamp` field](GetStatsResponse#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u64, u64>,
                {
                    GetStatsResponseBuilder((value,))
                }

                /// Sets the [`timestamp` field](GetStatsResponse#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(::planus::DefaultValue,)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Setter for the [`label` field](GetStatsResponse#structfield.label).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label<T1>(self, value: T1) -> GetStatsResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    GetStatsResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> GetStatsResponseBuilder<(T0, T1)> {
                /// Setter for the [`protocol` field](GetStatsResponse#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T2>(self, value: T2) -> GetStatsResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    GetStatsResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> GetStatsResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`messages_sent` field](GetStatsResponse#structfield.messages_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn messages_sent<T3>(
                    self,
                    value: T3,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`messages_sent` field](GetStatsResponse#structfield.messages_sent) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn messages_sent_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.messages_sent(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> GetStatsResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`bytes_sent` field](GetStatsResponse#structfield.bytes_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_sent<T4>(
                    self,
                    value: T4,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`bytes_sent` field](GetStatsResponse#structfield.bytes_sent) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_sent_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.bytes_sent(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`buffered_amount` field](GetStatsResponse#structfield.buffered_amount).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount<T5>(
                    self,
                    value: T5,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`buffered_amount` field](GetStatsResponse#structfield.buffered_amount) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.buffered_amount(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<GetStatsResponse>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    GetStatsResponse::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`timestamp` field](GetStatsResponse#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GetStatsResponse", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`label` field](GetStatsResponse#structfield.label).
                #[inline]
                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "GetStatsResponse", "label")
                }

                /// Getter for the [`protocol` field](GetStatsResponse#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "GetStatsResponse", "protocol")
                }

                /// Getter for the [`messages_sent` field](GetStatsResponse#structfield.messages_sent).
                #[inline]
                pub fn messages_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "GetStatsResponse", "messages_sent")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`bytes_sent` field](GetStatsResponse#structfield.bytes_sent).
                #[inline]
                pub fn bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "GetStatsResponse", "bytes_sent")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`buffered_amount` field](GetStatsResponse#structfield.buffered_amount).
                #[inline]
                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "GetStatsResponse", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("timestamp", &self.timestamp());
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.field("messages_sent", &self.messages_sent());
                    f.field("bytes_sent", &self.bytes_sent());
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        messages_sent: ::core::convert::TryInto::try_into(value.messages_sent()?)?,
                        bytes_sent: ::core::convert::TryInto::try_into(value.bytes_sent()?)?,
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `String` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `String` in the file `../worker/fbs/dataConsumer.fbs:37`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct String {
                /// The field `value` in the table `String`
                pub value: ::planus::alloc::string::String,
            }

            impl String {
                /// Creates a [StringBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StringBuilder<()> {
                    StringBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_value);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String> for String {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    String::create(builder, &self.value)
                }
            }

            /// Builder for serializing an instance of the [String] type.
            ///
            /// Can be created using the [String::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StringBuilder<State>(State);

            impl StringBuilder<()> {
                /// Setter for the [`value` field](String#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T0>(self, value: T0) -> StringBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StringBuilder((value,))
                }
            }

            impl<T0> StringBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [String].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<String>
                where
                    Self: ::planus::WriteAsOffset<String>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<String>> for StringBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<String>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<String>> for StringBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<String>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<String>
                for StringBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    let (v0,) = &self.0;
                    String::create(builder, v0)
                }
            }

            /// Reference to a deserialized [String].
            #[derive(Copy, Clone)]
            pub struct StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringRef<'a> {
                /// Getter for the [`value` field](String#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringRef<'a>> for String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String>> for String {
                type Value = ::planus::Offset<String>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SendRequest` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `SendRequest` in the file `../worker/fbs/dataConsumer.fbs:41`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendRequest {
                /// The field `ppid` in the table `SendRequest`
                pub ppid: u32,
                /// The field `data` in the table `SendRequest`
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl SendRequest {
                /// Creates a [SendRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SendRequestBuilder<()> {
                    SendRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ppid: impl ::planus::WriteAsDefault<u32, u32>,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ppid = field_ppid.prepare(builder, &0);
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_ppid.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<[u8]>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ppid) = prepared_ppid {
                                object_writer.write::<_, _, 4>(&prepared_ppid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendRequest>> for SendRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendRequest>> for SendRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendRequest> for SendRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest> {
                    SendRequest::create(builder, self.ppid, &self.data)
                }
            }

            /// Builder for serializing an instance of the [SendRequest] type.
            ///
            /// Can be created using the [SendRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SendRequestBuilder<State>(State);

            impl SendRequestBuilder<()> {
                /// Setter for the [`ppid` field](SendRequest#structfield.ppid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ppid<T0>(self, value: T0) -> SendRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SendRequestBuilder((value,))
                }

                /// Sets the [`ppid` field](SendRequest#structfield.ppid) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ppid_as_default(self) -> SendRequestBuilder<(::planus::DefaultValue,)> {
                    self.ppid(::planus::DefaultValue)
                }
            }

            impl<T0> SendRequestBuilder<(T0,)> {
                /// Setter for the [`data` field](SendRequest#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T1>(self, value: T1) -> SendRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    let (v0,) = self.0;
                    SendRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> SendRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SendRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest>
                where
                    Self: ::planus::WriteAsOffset<SendRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAs<::planus::Offset<SendRequest>>
                for SendRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<SendRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOptional<::planus::Offset<SendRequest>>
                for SendRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<SendRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOffset<SendRequest> for SendRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest> {
                    let (v0, v1) = &self.0;
                    SendRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [SendRequest].
            #[derive(Copy, Clone)]
            pub struct SendRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendRequestRef<'a> {
                /// Getter for the [`ppid` field](SendRequest#structfield.ppid).
                #[inline]
                pub fn ppid(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SendRequest", "ppid")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`data` field](SendRequest#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(1, "SendRequest", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendRequestRef");
                    f.field("ppid", &self.ppid());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendRequestRef<'a>> for SendRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ppid: ::core::convert::TryInto::try_into(value.ppid()?)?,
                        data: value.data()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendRequest>> for SendRequest {
                type Value = ::planus::Offset<SendRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SetSubchannelsRequest` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `SetSubchannelsRequest` in the file `../worker/fbs/dataConsumer.fbs:46`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetSubchannelsRequest {
                /// The field `subchannels` in the table `SetSubchannelsRequest`
                pub subchannels: ::planus::alloc::vec::Vec<u16>,
            }

            impl SetSubchannelsRequest {
                /// Creates a [SetSubchannelsRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetSubchannelsRequestBuilder<()> {
                    SetSubchannelsRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_subchannels: impl ::planus::WriteAs<::planus::Offset<[u16]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_subchannels = field_subchannels.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u16]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_subchannels);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetSubchannelsRequest>> for SetSubchannelsRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetSubchannelsRequest>> for SetSubchannelsRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetSubchannelsRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetSubchannelsRequest> for SetSubchannelsRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsRequest> {
                    SetSubchannelsRequest::create(builder, &self.subchannels)
                }
            }

            /// Builder for serializing an instance of the [SetSubchannelsRequest] type.
            ///
            /// Can be created using the [SetSubchannelsRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetSubchannelsRequestBuilder<State>(State);

            impl SetSubchannelsRequestBuilder<()> {
                /// Setter for the [`subchannels` field](SetSubchannelsRequest#structfield.subchannels).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels<T0>(self, value: T0) -> SetSubchannelsRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[u16]>>,
                {
                    SetSubchannelsRequestBuilder((value,))
                }
            }

            impl<T0> SetSubchannelsRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetSubchannelsRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsRequest>
                where
                    Self: ::planus::WriteAsOffset<SetSubchannelsRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u16]>>>
                ::planus::WriteAs<::planus::Offset<SetSubchannelsRequest>>
                for SetSubchannelsRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetSubchannelsRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u16]>>>
                ::planus::WriteAsOptional<::planus::Offset<SetSubchannelsRequest>>
                for SetSubchannelsRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetSubchannelsRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetSubchannelsRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u16]>>>
                ::planus::WriteAsOffset<SetSubchannelsRequest>
                for SetSubchannelsRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsRequest> {
                    let (v0,) = &self.0;
                    SetSubchannelsRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetSubchannelsRequest].
            #[derive(Copy, Clone)]
            pub struct SetSubchannelsRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetSubchannelsRequestRef<'a> {
                /// Getter for the [`subchannels` field](SetSubchannelsRequest#structfield.subchannels).
                #[inline]
                pub fn subchannels(&self) -> ::planus::Result<::planus::Vector<'a, u16>> {
                    self.0
                        .access_required(0, "SetSubchannelsRequest", "subchannels")
                }
            }

            impl<'a> ::core::fmt::Debug for SetSubchannelsRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetSubchannelsRequestRef");
                    f.field("subchannels", &self.subchannels());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetSubchannelsRequestRef<'a>> for SetSubchannelsRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetSubchannelsRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        subchannels: value.subchannels()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetSubchannelsRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetSubchannelsRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetSubchannelsRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetSubchannelsRequest>> for SetSubchannelsRequest {
                type Value = ::planus::Offset<SetSubchannelsRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetSubchannelsRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetSubchannelsRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetSubchannelsRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SetSubchannelsResponse` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `SetSubchannelsResponse` in the file `../worker/fbs/dataConsumer.fbs:50`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetSubchannelsResponse {
                /// The field `subchannels` in the table `SetSubchannelsResponse`
                pub subchannels: ::planus::alloc::vec::Vec<u16>,
            }

            impl SetSubchannelsResponse {
                /// Creates a [SetSubchannelsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetSubchannelsResponseBuilder<()> {
                    SetSubchannelsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_subchannels: impl ::planus::WriteAs<::planus::Offset<[u16]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_subchannels = field_subchannels.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u16]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_subchannels);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetSubchannelsResponse>> for SetSubchannelsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetSubchannelsResponse>>
                for SetSubchannelsResponse
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetSubchannelsResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetSubchannelsResponse> for SetSubchannelsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsResponse> {
                    SetSubchannelsResponse::create(builder, &self.subchannels)
                }
            }

            /// Builder for serializing an instance of the [SetSubchannelsResponse] type.
            ///
            /// Can be created using the [SetSubchannelsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetSubchannelsResponseBuilder<State>(State);

            impl SetSubchannelsResponseBuilder<()> {
                /// Setter for the [`subchannels` field](SetSubchannelsResponse#structfield.subchannels).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels<T0>(self, value: T0) -> SetSubchannelsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[u16]>>,
                {
                    SetSubchannelsResponseBuilder((value,))
                }
            }

            impl<T0> SetSubchannelsResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetSubchannelsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsResponse>
                where
                    Self: ::planus::WriteAsOffset<SetSubchannelsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u16]>>>
                ::planus::WriteAs<::planus::Offset<SetSubchannelsResponse>>
                for SetSubchannelsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetSubchannelsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u16]>>>
                ::planus::WriteAsOptional<::planus::Offset<SetSubchannelsResponse>>
                for SetSubchannelsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetSubchannelsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetSubchannelsResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u16]>>>
                ::planus::WriteAsOffset<SetSubchannelsResponse>
                for SetSubchannelsResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetSubchannelsResponse> {
                    let (v0,) = &self.0;
                    SetSubchannelsResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetSubchannelsResponse].
            #[derive(Copy, Clone)]
            pub struct SetSubchannelsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetSubchannelsResponseRef<'a> {
                /// Getter for the [`subchannels` field](SetSubchannelsResponse#structfield.subchannels).
                #[inline]
                pub fn subchannels(&self) -> ::planus::Result<::planus::Vector<'a, u16>> {
                    self.0
                        .access_required(0, "SetSubchannelsResponse", "subchannels")
                }
            }

            impl<'a> ::core::fmt::Debug for SetSubchannelsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetSubchannelsResponseRef");
                    f.field("subchannels", &self.subchannels());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetSubchannelsResponseRef<'a>> for SetSubchannelsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetSubchannelsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        subchannels: value.subchannels()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetSubchannelsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetSubchannelsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetSubchannelsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetSubchannelsResponse>> for SetSubchannelsResponse {
                type Value = ::planus::Offset<SetSubchannelsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetSubchannelsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetSubchannelsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetSubchannelsResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `BufferedAmountLowNotification` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `BufferedAmountLowNotification` in the file `../worker/fbs/dataConsumer.fbs:56`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BufferedAmountLowNotification {
                /// The field `buffered_amount` in the table `BufferedAmountLowNotification`
                pub buffered_amount: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BufferedAmountLowNotification {
                fn default() -> Self {
                    Self { buffered_amount: 0 }
                }
            }

            impl BufferedAmountLowNotification {
                /// Creates a [BufferedAmountLowNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BufferedAmountLowNotificationBuilder<()> {
                    BufferedAmountLowNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_buffered_amount.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_buffered_amount) =
                                prepared_buffered_amount
                            {
                                object_writer.write::<_, _, 4>(&prepared_buffered_amount);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BufferedAmountLowNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BufferedAmountLowNotification> for BufferedAmountLowNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification> {
                    BufferedAmountLowNotification::create(builder, self.buffered_amount)
                }
            }

            /// Builder for serializing an instance of the [BufferedAmountLowNotification] type.
            ///
            /// Can be created using the [BufferedAmountLowNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BufferedAmountLowNotificationBuilder<State>(State);

            impl BufferedAmountLowNotificationBuilder<()> {
                /// Setter for the [`buffered_amount` field](BufferedAmountLowNotification#structfield.buffered_amount).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount<T0>(
                    self,
                    value: T0,
                ) -> BufferedAmountLowNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    BufferedAmountLowNotificationBuilder((value,))
                }

                /// Sets the [`buffered_amount` field](BufferedAmountLowNotification#structfield.buffered_amount) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount_as_default(
                    self,
                ) -> BufferedAmountLowNotificationBuilder<(::planus::DefaultValue,)>
                {
                    self.buffered_amount(::planus::DefaultValue)
                }
            }

            impl<T0> BufferedAmountLowNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BufferedAmountLowNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification>
                where
                    Self: ::planus::WriteAsOffset<BufferedAmountLowNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<BufferedAmountLowNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<BufferedAmountLowNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BufferedAmountLowNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOffset<BufferedAmountLowNotification>
                for BufferedAmountLowNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification> {
                    let (v0,) = &self.0;
                    BufferedAmountLowNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [BufferedAmountLowNotification].
            #[derive(Copy, Clone)]
            pub struct BufferedAmountLowNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BufferedAmountLowNotificationRef<'a> {
                /// Getter for the [`buffered_amount` field](BufferedAmountLowNotification#structfield.buffered_amount).
                #[inline]
                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "BufferedAmountLowNotification", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BufferedAmountLowNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BufferedAmountLowNotificationRef");
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BufferedAmountLowNotificationRef<'a>>
                for BufferedAmountLowNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BufferedAmountLowNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BufferedAmountLowNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BufferedAmountLowNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BufferedAmountLowNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotification
            {
                type Value = ::planus::Offset<BufferedAmountLowNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BufferedAmountLowNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BufferedAmountLowNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BufferedAmountLowNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `MessageNotification` in the namespace `FBS.DataConsumer`
            ///
            /// Generated from these locations:
            /// * Table `MessageNotification` in the file `../worker/fbs/dataConsumer.fbs:60`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct MessageNotification {
                /// The field `ppid` in the table `MessageNotification`
                pub ppid: u32,
                /// The field `data` in the table `MessageNotification`
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl MessageNotification {
                /// Creates a [MessageNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> MessageNotificationBuilder<()> {
                    MessageNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ppid: impl ::planus::WriteAsDefault<u32, u32>,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ppid = field_ppid.prepare(builder, &0);
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_ppid.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<[u8]>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ppid) = prepared_ppid {
                                object_writer.write::<_, _, 4>(&prepared_ppid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<MessageNotification>> for MessageNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<MessageNotification>> for MessageNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MessageNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<MessageNotification> for MessageNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification> {
                    MessageNotification::create(builder, self.ppid, &self.data)
                }
            }

            /// Builder for serializing an instance of the [MessageNotification] type.
            ///
            /// Can be created using the [MessageNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct MessageNotificationBuilder<State>(State);

            impl MessageNotificationBuilder<()> {
                /// Setter for the [`ppid` field](MessageNotification#structfield.ppid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ppid<T0>(self, value: T0) -> MessageNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    MessageNotificationBuilder((value,))
                }

                /// Sets the [`ppid` field](MessageNotification#structfield.ppid) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ppid_as_default(
                    self,
                ) -> MessageNotificationBuilder<(::planus::DefaultValue,)> {
                    self.ppid(::planus::DefaultValue)
                }
            }

            impl<T0> MessageNotificationBuilder<(T0,)> {
                /// Setter for the [`data` field](MessageNotification#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T1>(self, value: T1) -> MessageNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    let (v0,) = self.0;
                    MessageNotificationBuilder((v0, value))
                }
            }

            impl<T0, T1> MessageNotificationBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [MessageNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification>
                where
                    Self: ::planus::WriteAsOffset<MessageNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAs<::planus::Offset<MessageNotification>>
                for MessageNotificationBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<MessageNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOptional<::planus::Offset<MessageNotification>>
                for MessageNotificationBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<MessageNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MessageNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOffset<MessageNotification>
                for MessageNotificationBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification> {
                    let (v0, v1) = &self.0;
                    MessageNotification::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [MessageNotification].
            #[derive(Copy, Clone)]
            pub struct MessageNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MessageNotificationRef<'a> {
                /// Getter for the [`ppid` field](MessageNotification#structfield.ppid).
                #[inline]
                pub fn ppid(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "MessageNotification", "ppid")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`data` field](MessageNotification#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(1, "MessageNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for MessageNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MessageNotificationRef");
                    f.field("ppid", &self.ppid());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MessageNotificationRef<'a>> for MessageNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MessageNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ppid: ::core::convert::TryInto::try_into(value.ppid()?)?,
                        data: value.data()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MessageNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MessageNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MessageNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<MessageNotification>> for MessageNotification {
                type Value = ::planus::Offset<MessageNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<MessageNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MessageNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MessageNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.DataProducer`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/dataProducer.fbs`
        pub mod data_producer {
            /// The enum `Type` in the namespace `FBS.DataProducer`
            ///
            /// Generated from these locations:
            /// * Enum `Type` in the file `../worker/fbs/dataProducer.fbs:5`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Type {
                /// The variant `SCTP` in the enum `Type`
                Sctp = 0,

                /// The variant `DIRECT` in the enum `Type`
                Direct = 1,
            }

            impl Type {
                /// Array containing all valid variants of Type
                pub const ENUM_VALUES: [Self; 2] = [Self::Sctp, Self::Direct];
            }

            impl ::core::convert::TryFrom<u8> for Type {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Type::Sctp),
                        1 => ::core::result::Result::Ok(Type::Direct),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Type> for u8 {
                #[inline]
                fn from(value: Type) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Type {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Type> for Type {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Type {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Type, Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Type,
                ) -> ::core::option::Option<Type> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Type> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Type {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Type {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Type",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Type> for Type {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.DataProducer`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/dataProducer.fbs:10`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `id` in the table `DumpResponse`
                pub id: ::planus::alloc::string::String,
                /// The field `type` in the table `DumpResponse`
                pub type_: self::Type,
                /// The field `sctp_stream_parameters` in the table `DumpResponse`
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                /// The field `label` in the table `DumpResponse`
                pub label: ::planus::alloc::string::String,
                /// The field `protocol` in the table `DumpResponse`
                pub protocol: ::planus::alloc::string::String,
                /// The field `paused` in the table `DumpResponse`
                pub paused: bool,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAsDefault<self::Type, self::Type>,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_type_ = field_type_.prepare(builder, &self::Type::Sctp);
                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);
                    let prepared_label = field_label.prepare(builder);
                    let prepared_protocol = field_protocol.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(2);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(3);
                    table_writer.write_entry::<::planus::Offset<str>>(4);
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<self::Type>(1);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                                prepared_sctp_stream_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_stream_parameters);
                            }
                            object_writer.write::<_, _, 4>(&prepared_label);
                            object_writer.write::<_, _, 4>(&prepared_protocol);
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                        self.paused,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`type` field](DumpResponse#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::Type, self::Type>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }

                /// Sets the [`type` field](DumpResponse#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(self) -> DumpResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`sctp_stream_parameters` field](DumpResponse#structfield.sctp_stream_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters<T2>(
                    self,
                    value: T2,
                ) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }

                /// Sets the [`sctp_stream_parameters` field](DumpResponse#structfield.sctp_stream_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters_as_null(self) -> DumpResponseBuilder<(T0, T1, ())> {
                    self.sctp_stream_parameters(())
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`label` field](DumpResponse#structfield.label).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label<T3>(self, value: T3) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`protocol` field](DumpResponse#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T4>(self, value: T4) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`paused` field](DumpResponse#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T5>(self, value: T5) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`paused` field](DumpResponse#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<self::Type, self::Type>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<self::Type, self::Type>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<self::Type, self::Type>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                /// Getter for the [`type` field](DumpResponse#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<self::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DumpResponse", "type_")?
                            .unwrap_or(self::Type::Sctp),
                    )
                }

                /// Getter for the [`sctp_stream_parameters` field](DumpResponse#structfield.sctp_stream_parameters).
                #[inline]
                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0.access(2, "DumpResponse", "sctp_stream_parameters")
                }

                /// Getter for the [`label` field](DumpResponse#structfield.label).
                #[inline]
                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "DumpResponse", "label")
                }

                /// Getter for the [`protocol` field](DumpResponse#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "DumpResponse", "protocol")
                }

                /// Getter for the [`paused` field](DumpResponse#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "DumpResponse", "paused")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.field("paused", &self.paused());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.DataProducer`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/dataProducer.fbs:19`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `timestamp` in the table `GetStatsResponse`
                pub timestamp: u64,
                /// The field `label` in the table `GetStatsResponse`
                pub label: ::planus::alloc::string::String,
                /// The field `protocol` in the table `GetStatsResponse`
                pub protocol: ::planus::alloc::string::String,
                /// The field `messages_received` in the table `GetStatsResponse`
                pub messages_received: u64,
                /// The field `bytes_received` in the table `GetStatsResponse`
                pub bytes_received: u64,
                /// The field `buffered_amount` in the table `GetStatsResponse`
                pub buffered_amount: u32,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_messages_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_label = field_label.prepare(builder);
                    let prepared_protocol = field_protocol.prepare(builder);
                    let prepared_messages_received = field_messages_received.prepare(builder, &0);
                    let prepared_bytes_received = field_bytes_received.prepare(builder, &0);
                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(0);
                    }
                    if prepared_messages_received.is_some() {
                        table_writer.write_entry::<u64>(3);
                    }
                    if prepared_bytes_received.is_some() {
                        table_writer.write_entry::<u64>(4);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_buffered_amount.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_messages_received) =
                                prepared_messages_received
                            {
                                object_writer.write::<_, _, 8>(&prepared_messages_received);
                            }
                            if let ::core::option::Option::Some(prepared_bytes_received) =
                                prepared_bytes_received
                            {
                                object_writer.write::<_, _, 8>(&prepared_bytes_received);
                            }
                            object_writer.write::<_, _, 4>(&prepared_label);
                            object_writer.write::<_, _, 4>(&prepared_protocol);
                            if let ::core::option::Option::Some(prepared_buffered_amount) =
                                prepared_buffered_amount
                            {
                                object_writer.write::<_, _, 4>(&prepared_buffered_amount);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        self.timestamp,
                        &self.label,
                        &self.protocol,
                        self.messages_received,
                        self.bytes_received,
                        self.buffered_amount,
                    )
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`timestamp` field](GetStatsResponse#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u64, u64>,
                {
                    GetStatsResponseBuilder((value,))
                }

                /// Sets the [`timestamp` field](GetStatsResponse#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(::planus::DefaultValue,)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Setter for the [`label` field](GetStatsResponse#structfield.label).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label<T1>(self, value: T1) -> GetStatsResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    GetStatsResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> GetStatsResponseBuilder<(T0, T1)> {
                /// Setter for the [`protocol` field](GetStatsResponse#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T2>(self, value: T2) -> GetStatsResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    GetStatsResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> GetStatsResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`messages_received` field](GetStatsResponse#structfield.messages_received).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn messages_received<T3>(
                    self,
                    value: T3,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`messages_received` field](GetStatsResponse#structfield.messages_received) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn messages_received_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.messages_received(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> GetStatsResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`bytes_received` field](GetStatsResponse#structfield.bytes_received).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_received<T4>(
                    self,
                    value: T4,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`bytes_received` field](GetStatsResponse#structfield.bytes_received) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_received_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.bytes_received(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`buffered_amount` field](GetStatsResponse#structfield.buffered_amount).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount<T5>(
                    self,
                    value: T5,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`buffered_amount` field](GetStatsResponse#structfield.buffered_amount) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn buffered_amount_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.buffered_amount(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<GetStatsResponse>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    GetStatsResponse::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`timestamp` field](GetStatsResponse#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GetStatsResponse", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`label` field](GetStatsResponse#structfield.label).
                #[inline]
                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "GetStatsResponse", "label")
                }

                /// Getter for the [`protocol` field](GetStatsResponse#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "GetStatsResponse", "protocol")
                }

                /// Getter for the [`messages_received` field](GetStatsResponse#structfield.messages_received).
                #[inline]
                pub fn messages_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "GetStatsResponse", "messages_received")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`bytes_received` field](GetStatsResponse#structfield.bytes_received).
                #[inline]
                pub fn bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "GetStatsResponse", "bytes_received")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`buffered_amount` field](GetStatsResponse#structfield.buffered_amount).
                #[inline]
                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "GetStatsResponse", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("timestamp", &self.timestamp());
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.field("messages_received", &self.messages_received());
                    f.field("bytes_received", &self.bytes_received());
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        messages_received: ::core::convert::TryInto::try_into(
                            value.messages_received()?,
                        )?,
                        bytes_received: ::core::convert::TryInto::try_into(
                            value.bytes_received()?,
                        )?,
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SendNotification` in the namespace `FBS.DataProducer`
            ///
            /// Generated from these locations:
            /// * Table `SendNotification` in the file `../worker/fbs/dataProducer.fbs:28`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendNotification {
                /// The field `ppid` in the table `SendNotification`
                pub ppid: u32,
                /// The field `data` in the table `SendNotification`
                pub data: ::planus::alloc::vec::Vec<u8>,
                /// The field `subchannels` in the table `SendNotification`
                pub subchannels: ::core::option::Option<::planus::alloc::vec::Vec<u16>>,
                /// The field `required_subchannel` in the table `SendNotification`
                pub required_subchannel: ::core::option::Option<u16>,
            }

            impl SendNotification {
                /// Creates a [SendNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SendNotificationBuilder<()> {
                    SendNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ppid: impl ::planus::WriteAsDefault<u32, u32>,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                    field_subchannels: impl ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                    field_required_subchannel: impl ::planus::WriteAsOptional<u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ppid = field_ppid.prepare(builder, &0);
                    let prepared_data = field_data.prepare(builder);
                    let prepared_subchannels = field_subchannels.prepare(builder);
                    let prepared_required_subchannel = field_required_subchannel.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_ppid.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<[u8]>>(1);
                    if prepared_subchannels.is_some() {
                        table_writer.write_entry::<::planus::Offset<[u16]>>(2);
                    }
                    if prepared_required_subchannel.is_some() {
                        table_writer.write_entry::<u16>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ppid) = prepared_ppid {
                                object_writer.write::<_, _, 4>(&prepared_ppid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_data);
                            if let ::core::option::Option::Some(prepared_subchannels) =
                                prepared_subchannels
                            {
                                object_writer.write::<_, _, 4>(&prepared_subchannels);
                            }
                            if let ::core::option::Option::Some(prepared_required_subchannel) =
                                prepared_required_subchannel
                            {
                                object_writer.write::<_, _, 2>(&prepared_required_subchannel);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendNotification> for SendNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    SendNotification::create(
                        builder,
                        self.ppid,
                        &self.data,
                        &self.subchannels,
                        self.required_subchannel,
                    )
                }
            }

            /// Builder for serializing an instance of the [SendNotification] type.
            ///
            /// Can be created using the [SendNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SendNotificationBuilder<State>(State);

            impl SendNotificationBuilder<()> {
                /// Setter for the [`ppid` field](SendNotification#structfield.ppid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ppid<T0>(self, value: T0) -> SendNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SendNotificationBuilder((value,))
                }

                /// Sets the [`ppid` field](SendNotification#structfield.ppid) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ppid_as_default(self) -> SendNotificationBuilder<(::planus::DefaultValue,)> {
                    self.ppid(::planus::DefaultValue)
                }
            }

            impl<T0> SendNotificationBuilder<(T0,)> {
                /// Setter for the [`data` field](SendNotification#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T1>(self, value: T1) -> SendNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    let (v0,) = self.0;
                    SendNotificationBuilder((v0, value))
                }
            }

            impl<T0, T1> SendNotificationBuilder<(T0, T1)> {
                /// Setter for the [`subchannels` field](SendNotification#structfield.subchannels).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels<T2>(self, value: T2) -> SendNotificationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                {
                    let (v0, v1) = self.0;
                    SendNotificationBuilder((v0, v1, value))
                }

                /// Sets the [`subchannels` field](SendNotification#structfield.subchannels) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels_as_null(self) -> SendNotificationBuilder<(T0, T1, ())> {
                    self.subchannels(())
                }
            }

            impl<T0, T1, T2> SendNotificationBuilder<(T0, T1, T2)> {
                /// Setter for the [`required_subchannel` field](SendNotification#structfield.required_subchannel).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn required_subchannel<T3>(
                    self,
                    value: T3,
                ) -> SendNotificationBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<u16>,
                {
                    let (v0, v1, v2) = self.0;
                    SendNotificationBuilder((v0, v1, v2, value))
                }

                /// Sets the [`required_subchannel` field](SendNotification#structfield.required_subchannel) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn required_subchannel_as_null(
                    self,
                ) -> SendNotificationBuilder<(T0, T1, T2, ())> {
                    self.required_subchannel(())
                }
            }

            impl<T0, T1, T2, T3> SendNotificationBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SendNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification>
                where
                    Self: ::planus::WriteAsOffset<SendNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                    T3: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAs<::planus::Offset<SendNotification>>
                for SendNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<SendNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                    T3: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAsOptional<::planus::Offset<SendNotification>>
                for SendNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<SendNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[u8]>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                    T3: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAsOffset<SendNotification>
                for SendNotificationBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    let (v0, v1, v2, v3) = &self.0;
                    SendNotification::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [SendNotification].
            #[derive(Copy, Clone)]
            pub struct SendNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendNotificationRef<'a> {
                /// Getter for the [`ppid` field](SendNotification#structfield.ppid).
                #[inline]
                pub fn ppid(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SendNotification", "ppid")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`data` field](SendNotification#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(1, "SendNotification", "data")
                }

                /// Getter for the [`subchannels` field](SendNotification#structfield.subchannels).
                #[inline]
                pub fn subchannels(
                    &self,
                ) -> ::planus::Result<::core::option::Option<::planus::Vector<'a, u16>>>
                {
                    self.0.access(2, "SendNotification", "subchannels")
                }

                /// Getter for the [`required_subchannel` field](SendNotification#structfield.required_subchannel).
                #[inline]
                pub fn required_subchannel(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(3, "SendNotification", "required_subchannel")
                }
            }

            impl<'a> ::core::fmt::Debug for SendNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendNotificationRef");
                    f.field("ppid", &self.ppid());
                    f.field("data", &self.data());
                    if let ::core::option::Option::Some(field_subchannels) =
                        self.subchannels().transpose()
                    {
                        f.field("subchannels", &field_subchannels);
                    }
                    if let ::core::option::Option::Some(field_required_subchannel) =
                        self.required_subchannel().transpose()
                    {
                        f.field("required_subchannel", &field_required_subchannel);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendNotificationRef<'a>> for SendNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ppid: ::core::convert::TryInto::try_into(value.ppid()?)?,
                        data: value.data()?.to_vec(),
                        subchannels: if let ::core::option::Option::Some(subchannels) =
                            value.subchannels()?
                        {
                            ::core::option::Option::Some(subchannels.to_vec()?)
                        } else {
                            ::core::option::Option::None
                        },
                        required_subchannel: if let ::core::option::Option::Some(
                            required_subchannel,
                        ) = value.required_subchannel()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                required_subchannel,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendNotification>> for SendNotification {
                type Value = ::planus::Offset<SendNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.SctpParameters`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/sctpParameters.fbs`
        pub mod sctp_parameters {
            /// The table `NumSctpStreams` in the namespace `FBS.SctpParameters`
            ///
            /// Generated from these locations:
            /// * Table `NumSctpStreams` in the file `../worker/fbs/sctpParameters.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct NumSctpStreams {
                /// The field `os` in the table `NumSctpStreams`
                pub os: u16,
                /// The field `mis` in the table `NumSctpStreams`
                pub mis: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for NumSctpStreams {
                fn default() -> Self {
                    Self {
                        os: 1024,
                        mis: 1024,
                    }
                }
            }

            impl NumSctpStreams {
                /// Creates a [NumSctpStreamsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> NumSctpStreamsBuilder<()> {
                    NumSctpStreamsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_os: impl ::planus::WriteAsDefault<u16, u16>,
                    field_mis: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_os = field_os.prepare(builder, &1024);
                    let prepared_mis = field_mis.prepare(builder, &1024);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_os.is_some() {
                        table_writer.write_entry::<u16>(0);
                    }
                    if prepared_mis.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_os) = prepared_os {
                                object_writer.write::<_, _, 2>(&prepared_os);
                            }
                            if let ::core::option::Option::Some(prepared_mis) = prepared_mis {
                                object_writer.write::<_, _, 2>(&prepared_mis);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<NumSctpStreams>> for NumSctpStreams {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<NumSctpStreams>> for NumSctpStreams {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<NumSctpStreams>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<NumSctpStreams> for NumSctpStreams {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams> {
                    NumSctpStreams::create(builder, self.os, self.mis)
                }
            }

            /// Builder for serializing an instance of the [NumSctpStreams] type.
            ///
            /// Can be created using the [NumSctpStreams::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct NumSctpStreamsBuilder<State>(State);

            impl NumSctpStreamsBuilder<()> {
                /// Setter for the [`os` field](NumSctpStreams#structfield.os).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn os<T0>(self, value: T0) -> NumSctpStreamsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u16, u16>,
                {
                    NumSctpStreamsBuilder((value,))
                }

                /// Sets the [`os` field](NumSctpStreams#structfield.os) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn os_as_default(self) -> NumSctpStreamsBuilder<(::planus::DefaultValue,)> {
                    self.os(::planus::DefaultValue)
                }
            }

            impl<T0> NumSctpStreamsBuilder<(T0,)> {
                /// Setter for the [`mis` field](NumSctpStreams#structfield.mis).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mis<T1>(self, value: T1) -> NumSctpStreamsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0,) = self.0;
                    NumSctpStreamsBuilder((v0, value))
                }

                /// Sets the [`mis` field](NumSctpStreams#structfield.mis) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mis_as_default(self) -> NumSctpStreamsBuilder<(T0, ::planus::DefaultValue)> {
                    self.mis(::planus::DefaultValue)
                }
            }

            impl<T0, T1> NumSctpStreamsBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [NumSctpStreams].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams>
                where
                    Self: ::planus::WriteAsOffset<NumSctpStreams>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAs<::planus::Offset<NumSctpStreams>>
                for NumSctpStreamsBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<NumSctpStreams>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOptional<::planus::Offset<NumSctpStreams>>
                for NumSctpStreamsBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<NumSctpStreams>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<NumSctpStreams>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOffset<NumSctpStreams> for NumSctpStreamsBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams> {
                    let (v0, v1) = &self.0;
                    NumSctpStreams::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [NumSctpStreams].
            #[derive(Copy, Clone)]
            pub struct NumSctpStreamsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> NumSctpStreamsRef<'a> {
                /// Getter for the [`os` field](NumSctpStreams#structfield.os).
                #[inline]
                pub fn os(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "NumSctpStreams", "os")?.unwrap_or(1024),
                    )
                }

                /// Getter for the [`mis` field](NumSctpStreams#structfield.mis).
                #[inline]
                pub fn mis(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "NumSctpStreams", "mis")?.unwrap_or(1024),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for NumSctpStreamsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("NumSctpStreamsRef");
                    f.field("os", &self.os());
                    f.field("mis", &self.mis());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<NumSctpStreamsRef<'a>> for NumSctpStreams {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: NumSctpStreamsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        os: ::core::convert::TryInto::try_into(value.os()?)?,
                        mis: ::core::convert::TryInto::try_into(value.mis()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for NumSctpStreamsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for NumSctpStreamsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[NumSctpStreamsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<NumSctpStreams>> for NumSctpStreams {
                type Value = ::planus::Offset<NumSctpStreams>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<NumSctpStreams>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for NumSctpStreamsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[NumSctpStreamsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SctpParameters` in the namespace `FBS.SctpParameters`
            ///
            /// Generated from these locations:
            /// * Table `SctpParameters` in the file `../worker/fbs/sctpParameters.fbs:8`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpParameters {
                /// The field `port` in the table `SctpParameters`
                pub port: u16,
                /// The field `os` in the table `SctpParameters`
                pub os: u16,
                /// The field `mis` in the table `SctpParameters`
                pub mis: u16,
                /// The field `max_message_size` in the table `SctpParameters`
                pub max_message_size: u32,
                /// The field `send_buffer_size` in the table `SctpParameters`
                pub send_buffer_size: u32,
                /// The field `sctp_buffered_amount` in the table `SctpParameters`
                pub sctp_buffered_amount: u32,
                /// The field `is_data_channel` in the table `SctpParameters`
                pub is_data_channel: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SctpParameters {
                fn default() -> Self {
                    Self {
                        port: 5000,
                        os: 0,
                        mis: 0,
                        max_message_size: 0,
                        send_buffer_size: 0,
                        sctp_buffered_amount: 0,
                        is_data_channel: false,
                    }
                }
            }

            impl SctpParameters {
                /// Creates a [SctpParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SctpParametersBuilder<()> {
                    SctpParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_os: impl ::planus::WriteAsDefault<u16, u16>,
                    field_mis: impl ::planus::WriteAsDefault<u16, u16>,
                    field_max_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_send_buffer_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_sctp_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                    field_is_data_channel: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_port = field_port.prepare(builder, &5000);
                    let prepared_os = field_os.prepare(builder, &0);
                    let prepared_mis = field_mis.prepare(builder, &0);
                    let prepared_max_message_size = field_max_message_size.prepare(builder, &0);
                    let prepared_send_buffer_size = field_send_buffer_size.prepare(builder, &0);
                    let prepared_sctp_buffered_amount =
                        field_sctp_buffered_amount.prepare(builder, &0);
                    let prepared_is_data_channel = field_is_data_channel.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<18> =
                        ::core::default::Default::default();
                    if prepared_max_message_size.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }
                    if prepared_send_buffer_size.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_sctp_buffered_amount.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }
                    if prepared_port.is_some() {
                        table_writer.write_entry::<u16>(0);
                    }
                    if prepared_os.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }
                    if prepared_mis.is_some() {
                        table_writer.write_entry::<u16>(2);
                    }
                    if prepared_is_data_channel.is_some() {
                        table_writer.write_entry::<bool>(6);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_max_message_size) =
                                prepared_max_message_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_message_size);
                            }
                            if let ::core::option::Option::Some(prepared_send_buffer_size) =
                                prepared_send_buffer_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_send_buffer_size);
                            }
                            if let ::core::option::Option::Some(prepared_sctp_buffered_amount) =
                                prepared_sctp_buffered_amount
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_buffered_amount);
                            }
                            if let ::core::option::Option::Some(prepared_port) = prepared_port {
                                object_writer.write::<_, _, 2>(&prepared_port);
                            }
                            if let ::core::option::Option::Some(prepared_os) = prepared_os {
                                object_writer.write::<_, _, 2>(&prepared_os);
                            }
                            if let ::core::option::Option::Some(prepared_mis) = prepared_mis {
                                object_writer.write::<_, _, 2>(&prepared_mis);
                            }
                            if let ::core::option::Option::Some(prepared_is_data_channel) =
                                prepared_is_data_channel
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_data_channel);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpParameters>> for SctpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpParameters>> for SctpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpParameters> for SctpParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters> {
                    SctpParameters::create(
                        builder,
                        self.port,
                        self.os,
                        self.mis,
                        self.max_message_size,
                        self.send_buffer_size,
                        self.sctp_buffered_amount,
                        self.is_data_channel,
                    )
                }
            }

            /// Builder for serializing an instance of the [SctpParameters] type.
            ///
            /// Can be created using the [SctpParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SctpParametersBuilder<State>(State);

            impl SctpParametersBuilder<()> {
                /// Setter for the [`port` field](SctpParameters#structfield.port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port<T0>(self, value: T0) -> SctpParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u16, u16>,
                {
                    SctpParametersBuilder((value,))
                }

                /// Sets the [`port` field](SctpParameters#structfield.port) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port_as_default(self) -> SctpParametersBuilder<(::planus::DefaultValue,)> {
                    self.port(::planus::DefaultValue)
                }
            }

            impl<T0> SctpParametersBuilder<(T0,)> {
                /// Setter for the [`os` field](SctpParameters#structfield.os).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn os<T1>(self, value: T1) -> SctpParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0,) = self.0;
                    SctpParametersBuilder((v0, value))
                }

                /// Sets the [`os` field](SctpParameters#structfield.os) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn os_as_default(self) -> SctpParametersBuilder<(T0, ::planus::DefaultValue)> {
                    self.os(::planus::DefaultValue)
                }
            }

            impl<T0, T1> SctpParametersBuilder<(T0, T1)> {
                /// Setter for the [`mis` field](SctpParameters#structfield.mis).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mis<T2>(self, value: T2) -> SctpParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0, v1) = self.0;
                    SctpParametersBuilder((v0, v1, value))
                }

                /// Sets the [`mis` field](SctpParameters#structfield.mis) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mis_as_default(
                    self,
                ) -> SctpParametersBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.mis(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> SctpParametersBuilder<(T0, T1, T2)> {
                /// Setter for the [`max_message_size` field](SctpParameters#structfield.max_message_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_message_size<T3>(
                    self,
                    value: T3,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    SctpParametersBuilder((v0, v1, v2, value))
                }

                /// Sets the [`max_message_size` field](SctpParameters#structfield.max_message_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_message_size_as_default(
                    self,
                ) -> SctpParametersBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.max_message_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> SctpParametersBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`send_buffer_size` field](SctpParameters#structfield.send_buffer_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn send_buffer_size<T4>(
                    self,
                    value: T4,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    SctpParametersBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`send_buffer_size` field](SctpParameters#structfield.send_buffer_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn send_buffer_size_as_default(
                    self,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.send_buffer_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> SctpParametersBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`sctp_buffered_amount` field](SctpParameters#structfield.sctp_buffered_amount).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_buffered_amount<T5>(
                    self,
                    value: T5,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    SctpParametersBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`sctp_buffered_amount` field](SctpParameters#structfield.sctp_buffered_amount) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_buffered_amount_as_default(
                    self,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.sctp_buffered_amount(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> SctpParametersBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`is_data_channel` field](SctpParameters#structfield.is_data_channel).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_data_channel<T6>(
                    self,
                    value: T6,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    SctpParametersBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`is_data_channel` field](SctpParameters#structfield.is_data_channel) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_data_channel_as_default(
                    self,
                ) -> SctpParametersBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.is_data_channel(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> SctpParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SctpParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters>
                where
                    Self: ::planus::WriteAsOffset<SctpParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<SctpParameters>>
                for SctpParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<SctpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<SctpParameters>>
                for SctpParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<SctpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<SctpParameters>
                for SctpParametersBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters> {
                    let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                    SctpParameters::create(builder, v0, v1, v2, v3, v4, v5, v6)
                }
            }

            /// Reference to a deserialized [SctpParameters].
            #[derive(Copy, Clone)]
            pub struct SctpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpParametersRef<'a> {
                /// Getter for the [`port` field](SctpParameters#structfield.port).
                #[inline]
                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SctpParameters", "port")?.unwrap_or(5000),
                    )
                }

                /// Getter for the [`os` field](SctpParameters#structfield.os).
                #[inline]
                pub fn os(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "SctpParameters", "os")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`mis` field](SctpParameters#structfield.mis).
                #[inline]
                pub fn mis(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "SctpParameters", "mis")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`max_message_size` field](SctpParameters#structfield.max_message_size).
                #[inline]
                pub fn max_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "SctpParameters", "max_message_size")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`send_buffer_size` field](SctpParameters#structfield.send_buffer_size).
                #[inline]
                pub fn send_buffer_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "SctpParameters", "send_buffer_size")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`sctp_buffered_amount` field](SctpParameters#structfield.sctp_buffered_amount).
                #[inline]
                pub fn sctp_buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "SctpParameters", "sctp_buffered_amount")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`is_data_channel` field](SctpParameters#structfield.is_data_channel).
                #[inline]
                pub fn is_data_channel(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "SctpParameters", "is_data_channel")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SctpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpParametersRef");
                    f.field("port", &self.port());
                    f.field("os", &self.os());
                    f.field("mis", &self.mis());
                    f.field("max_message_size", &self.max_message_size());
                    f.field("send_buffer_size", &self.send_buffer_size());
                    f.field("sctp_buffered_amount", &self.sctp_buffered_amount());
                    f.field("is_data_channel", &self.is_data_channel());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpParametersRef<'a>> for SctpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        os: ::core::convert::TryInto::try_into(value.os()?)?,
                        mis: ::core::convert::TryInto::try_into(value.mis()?)?,
                        max_message_size: ::core::convert::TryInto::try_into(
                            value.max_message_size()?,
                        )?,
                        send_buffer_size: ::core::convert::TryInto::try_into(
                            value.send_buffer_size()?,
                        )?,
                        sctp_buffered_amount: ::core::convert::TryInto::try_into(
                            value.sctp_buffered_amount()?,
                        )?,
                        is_data_channel: ::core::convert::TryInto::try_into(
                            value.is_data_channel()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpParameters>> for SctpParameters {
                type Value = ::planus::Offset<SctpParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SctpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SctpStreamParameters` in the namespace `FBS.SctpParameters`
            ///
            /// Generated from these locations:
            /// * Table `SctpStreamParameters` in the file `../worker/fbs/sctpParameters.fbs:19`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpStreamParameters {
                /// The field `stream_id` in the table `SctpStreamParameters`
                pub stream_id: u16,
                /// The field `ordered` in the table `SctpStreamParameters`
                pub ordered: ::core::option::Option<bool>,
                /// The field `max_packet_life_time` in the table `SctpStreamParameters`
                pub max_packet_life_time: ::core::option::Option<u16>,
                /// The field `max_retransmits` in the table `SctpStreamParameters`
                pub max_retransmits: ::core::option::Option<u16>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SctpStreamParameters {
                fn default() -> Self {
                    Self {
                        stream_id: 0,
                        ordered: ::core::default::Default::default(),
                        max_packet_life_time: ::core::default::Default::default(),
                        max_retransmits: ::core::default::Default::default(),
                    }
                }
            }

            impl SctpStreamParameters {
                /// Creates a [SctpStreamParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SctpStreamParametersBuilder<()> {
                    SctpStreamParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stream_id: impl ::planus::WriteAsDefault<u16, u16>,
                    field_ordered: impl ::planus::WriteAsOptional<bool>,
                    field_max_packet_life_time: impl ::planus::WriteAsOptional<u16>,
                    field_max_retransmits: impl ::planus::WriteAsOptional<u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_stream_id = field_stream_id.prepare(builder, &0);
                    let prepared_ordered = field_ordered.prepare(builder);
                    let prepared_max_packet_life_time = field_max_packet_life_time.prepare(builder);
                    let prepared_max_retransmits = field_max_retransmits.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_stream_id.is_some() {
                        table_writer.write_entry::<u16>(0);
                    }
                    if prepared_max_packet_life_time.is_some() {
                        table_writer.write_entry::<u16>(2);
                    }
                    if prepared_max_retransmits.is_some() {
                        table_writer.write_entry::<u16>(3);
                    }
                    if prepared_ordered.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_stream_id) =
                                prepared_stream_id
                            {
                                object_writer.write::<_, _, 2>(&prepared_stream_id);
                            }
                            if let ::core::option::Option::Some(prepared_max_packet_life_time) =
                                prepared_max_packet_life_time
                            {
                                object_writer.write::<_, _, 2>(&prepared_max_packet_life_time);
                            }
                            if let ::core::option::Option::Some(prepared_max_retransmits) =
                                prepared_max_retransmits
                            {
                                object_writer.write::<_, _, 2>(&prepared_max_retransmits);
                            }
                            if let ::core::option::Option::Some(prepared_ordered) = prepared_ordered
                            {
                                object_writer.write::<_, _, 1>(&prepared_ordered);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpStreamParameters>> for SctpStreamParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpStreamParameters>> for SctpStreamParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpStreamParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpStreamParameters> for SctpStreamParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters> {
                    SctpStreamParameters::create(
                        builder,
                        self.stream_id,
                        self.ordered,
                        self.max_packet_life_time,
                        self.max_retransmits,
                    )
                }
            }

            /// Builder for serializing an instance of the [SctpStreamParameters] type.
            ///
            /// Can be created using the [SctpStreamParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SctpStreamParametersBuilder<State>(State);

            impl SctpStreamParametersBuilder<()> {
                /// Setter for the [`stream_id` field](SctpStreamParameters#structfield.stream_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn stream_id<T0>(self, value: T0) -> SctpStreamParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u16, u16>,
                {
                    SctpStreamParametersBuilder((value,))
                }

                /// Sets the [`stream_id` field](SctpStreamParameters#structfield.stream_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn stream_id_as_default(
                    self,
                ) -> SctpStreamParametersBuilder<(::planus::DefaultValue,)> {
                    self.stream_id(::planus::DefaultValue)
                }
            }

            impl<T0> SctpStreamParametersBuilder<(T0,)> {
                /// Setter for the [`ordered` field](SctpStreamParameters#structfield.ordered).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ordered<T1>(self, value: T1) -> SctpStreamParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<bool>,
                {
                    let (v0,) = self.0;
                    SctpStreamParametersBuilder((v0, value))
                }

                /// Sets the [`ordered` field](SctpStreamParameters#structfield.ordered) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ordered_as_null(self) -> SctpStreamParametersBuilder<(T0, ())> {
                    self.ordered(())
                }
            }

            impl<T0, T1> SctpStreamParametersBuilder<(T0, T1)> {
                /// Setter for the [`max_packet_life_time` field](SctpStreamParameters#structfield.max_packet_life_time).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_packet_life_time<T2>(
                    self,
                    value: T2,
                ) -> SctpStreamParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<u16>,
                {
                    let (v0, v1) = self.0;
                    SctpStreamParametersBuilder((v0, v1, value))
                }

                /// Sets the [`max_packet_life_time` field](SctpStreamParameters#structfield.max_packet_life_time) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_packet_life_time_as_null(
                    self,
                ) -> SctpStreamParametersBuilder<(T0, T1, ())> {
                    self.max_packet_life_time(())
                }
            }

            impl<T0, T1, T2> SctpStreamParametersBuilder<(T0, T1, T2)> {
                /// Setter for the [`max_retransmits` field](SctpStreamParameters#structfield.max_retransmits).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_retransmits<T3>(
                    self,
                    value: T3,
                ) -> SctpStreamParametersBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<u16>,
                {
                    let (v0, v1, v2) = self.0;
                    SctpStreamParametersBuilder((v0, v1, v2, value))
                }

                /// Sets the [`max_retransmits` field](SctpStreamParameters#structfield.max_retransmits) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_retransmits_as_null(
                    self,
                ) -> SctpStreamParametersBuilder<(T0, T1, T2, ())> {
                    self.max_retransmits(())
                }
            }

            impl<T0, T1, T2, T3> SctpStreamParametersBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SctpStreamParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters>
                where
                    Self: ::planus::WriteAsOffset<SctpStreamParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsOptional<bool>,
                    T2: ::planus::WriteAsOptional<u16>,
                    T3: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAs<::planus::Offset<SctpStreamParameters>>
                for SctpStreamParametersBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<SctpStreamParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsOptional<bool>,
                    T2: ::planus::WriteAsOptional<u16>,
                    T3: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAsOptional<::planus::Offset<SctpStreamParameters>>
                for SctpStreamParametersBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<SctpStreamParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpStreamParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u16, u16>,
                    T1: ::planus::WriteAsOptional<bool>,
                    T2: ::planus::WriteAsOptional<u16>,
                    T3: ::planus::WriteAsOptional<u16>,
                > ::planus::WriteAsOffset<SctpStreamParameters>
                for SctpStreamParametersBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters> {
                    let (v0, v1, v2, v3) = &self.0;
                    SctpStreamParameters::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [SctpStreamParameters].
            #[derive(Copy, Clone)]
            pub struct SctpStreamParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpStreamParametersRef<'a> {
                /// Getter for the [`stream_id` field](SctpStreamParameters#structfield.stream_id).
                #[inline]
                pub fn stream_id(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SctpStreamParameters", "stream_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ordered` field](SctpStreamParameters#structfield.ordered).
                #[inline]
                pub fn ordered(&self) -> ::planus::Result<::core::option::Option<bool>> {
                    self.0.access(1, "SctpStreamParameters", "ordered")
                }

                /// Getter for the [`max_packet_life_time` field](SctpStreamParameters#structfield.max_packet_life_time).
                #[inline]
                pub fn max_packet_life_time(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0
                        .access(2, "SctpStreamParameters", "max_packet_life_time")
                }

                /// Getter for the [`max_retransmits` field](SctpStreamParameters#structfield.max_retransmits).
                #[inline]
                pub fn max_retransmits(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(3, "SctpStreamParameters", "max_retransmits")
                }
            }

            impl<'a> ::core::fmt::Debug for SctpStreamParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpStreamParametersRef");
                    f.field("stream_id", &self.stream_id());
                    if let ::core::option::Option::Some(field_ordered) = self.ordered().transpose()
                    {
                        f.field("ordered", &field_ordered);
                    }
                    if let ::core::option::Option::Some(field_max_packet_life_time) =
                        self.max_packet_life_time().transpose()
                    {
                        f.field("max_packet_life_time", &field_max_packet_life_time);
                    }
                    if let ::core::option::Option::Some(field_max_retransmits) =
                        self.max_retransmits().transpose()
                    {
                        f.field("max_retransmits", &field_max_retransmits);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpStreamParametersRef<'a>> for SctpStreamParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpStreamParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stream_id: ::core::convert::TryInto::try_into(value.stream_id()?)?,
                        ordered: if let ::core::option::Option::Some(ordered) = value.ordered()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                ordered,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_packet_life_time: if let ::core::option::Option::Some(
                            max_packet_life_time,
                        ) = value.max_packet_life_time()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_packet_life_time,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_retransmits: if let ::core::option::Option::Some(max_retransmits) =
                            value.max_retransmits()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_retransmits,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpStreamParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpStreamParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStreamParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpStreamParameters>> for SctpStreamParameters {
                type Value = ::planus::Offset<SctpStreamParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpStreamParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpStreamParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStreamParametersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.DirectTransport`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/directTransport.fbs`
        pub mod direct_transport {
            /// The table `DirectTransportOptions` in the namespace `FBS.DirectTransport`
            ///
            /// Generated from these locations:
            /// * Table `DirectTransportOptions` in the file `../worker/fbs/directTransport.fbs:5`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DirectTransportOptions {
                /// The field `base` in the table `DirectTransportOptions`
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DirectTransportOptions {
                fn default() -> Self {
                    Self {
                        base: ::core::default::Default::default(),
                    }
                }
            }

            impl DirectTransportOptions {
                /// Creates a [DirectTransportOptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DirectTransportOptionsBuilder<()> {
                    DirectTransportOptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Options>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DirectTransportOptions>> for DirectTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DirectTransportOptions>>
                for DirectTransportOptions
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DirectTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DirectTransportOptions> for DirectTransportOptions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions> {
                    DirectTransportOptions::create(builder, &self.base)
                }
            }

            /// Builder for serializing an instance of the [DirectTransportOptions] type.
            ///
            /// Can be created using the [DirectTransportOptions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DirectTransportOptionsBuilder<State>(State);

            impl DirectTransportOptionsBuilder<()> {
                /// Setter for the [`base` field](DirectTransportOptions#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> DirectTransportOptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                {
                    DirectTransportOptionsBuilder((value,))
                }
            }

            impl<T0> DirectTransportOptionsBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DirectTransportOptions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions>
                where
                    Self: ::planus::WriteAsOffset<DirectTransportOptions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>>
                ::planus::WriteAs<::planus::Offset<DirectTransportOptions>>
                for DirectTransportOptionsBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DirectTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>>
                ::planus::WriteAsOptional<::planus::Offset<DirectTransportOptions>>
                for DirectTransportOptionsBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DirectTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DirectTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>>
                ::planus::WriteAsOffset<DirectTransportOptions>
                for DirectTransportOptionsBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions> {
                    let (v0,) = &self.0;
                    DirectTransportOptions::create(builder, v0)
                }
            }

            /// Reference to a deserialized [DirectTransportOptions].
            #[derive(Copy, Clone)]
            pub struct DirectTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DirectTransportOptionsRef<'a> {
                /// Getter for the [`base` field](DirectTransportOptions#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "DirectTransportOptions", "base")
                }
            }

            impl<'a> ::core::fmt::Debug for DirectTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DirectTransportOptionsRef");
                    f.field("base", &self.base());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DirectTransportOptionsRef<'a>> for DirectTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DirectTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DirectTransportOptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DirectTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DirectTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DirectTransportOptions>> for DirectTransportOptions {
                type Value = ::planus::Offset<DirectTransportOptions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DirectTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DirectTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DirectTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.DirectTransport`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/directTransport.fbs:9`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `base` in the table `DumpResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Dump>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(builder, &self.base)
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>>
                ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>>
                ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>>
                ::planus::WriteAsOffset<DumpResponse> for DumpResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0,) = &self.0;
                    DumpResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.DirectTransport`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/directTransport.fbs:13`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `base` in the table `GetStatsResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Stats>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.base)
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                {
                    GetStatsResponseBuilder((value,))
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>>
                ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>>
                ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>>
                ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0,) = &self.0;
                    GetStatsResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtcpNotification` in the namespace `FBS.DirectTransport`
            ///
            /// Generated from these locations:
            /// * Table `RtcpNotification` in the file `../worker/fbs/directTransport.fbs:19`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpNotification {
                /// The field `data` in the table `RtcpNotification`
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl RtcpNotification {
                /// Creates a [RtcpNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtcpNotificationBuilder<()> {
                    RtcpNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpNotification>> for RtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpNotification>> for RtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpNotification> for RtcpNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification> {
                    RtcpNotification::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [RtcpNotification] type.
            ///
            /// Can be created using the [RtcpNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtcpNotificationBuilder<State>(State);

            impl RtcpNotificationBuilder<()> {
                /// Setter for the [`data` field](RtcpNotification#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> RtcpNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    RtcpNotificationBuilder((value,))
                }
            }

            impl<T0> RtcpNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtcpNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification>
                where
                    Self: ::planus::WriteAsOffset<RtcpNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAs<::planus::Offset<RtcpNotification>>
                for RtcpNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtcpNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOptional<::planus::Offset<RtcpNotification>>
                for RtcpNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtcpNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOffset<RtcpNotification> for RtcpNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification> {
                    let (v0,) = &self.0;
                    RtcpNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RtcpNotification].
            #[derive(Copy, Clone)]
            pub struct RtcpNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpNotificationRef<'a> {
                /// Getter for the [`data` field](RtcpNotification#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(0, "RtcpNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpNotificationRef<'a>> for RtcpNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpNotification>> for RtcpNotification {
                type Value = ::planus::Offset<RtcpNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtcpNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Transport`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/transport.fbs`
        pub mod transport {
            /// The enum `Protocol` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Enum `Protocol` in the file `../worker/fbs/transport.fbs:11`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Protocol {
                /// The variant `UDP` in the enum `Protocol`
                Udp = 1,

                /// The variant `TCP` in the enum `Protocol`
                Tcp = 2,
            }

            impl Protocol {
                /// Array containing all valid variants of Protocol
                pub const ENUM_VALUES: [Self; 2] = [Self::Udp, Self::Tcp];
            }

            impl ::core::convert::TryFrom<u8> for Protocol {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        1 => ::core::result::Result::Ok(Protocol::Udp),
                        2 => ::core::result::Result::Ok(Protocol::Tcp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Protocol> for u8 {
                #[inline]
                fn from(value: Protocol) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Protocol {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Protocol> for Protocol {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Protocol> for Protocol {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Protocol {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Protocol, Protocol> for Protocol {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Protocol,
                ) -> ::core::option::Option<Protocol> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Protocol> for Protocol {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Protocol> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Protocol {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Protocol {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Protocol",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Protocol> for Protocol {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `ListenInfo` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ListenInfo` in the file `../worker/fbs/transport.fbs:16`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenInfo {
                /// The field `protocol` in the table `ListenInfo`
                pub protocol: self::Protocol,
                /// The field `ip` in the table `ListenInfo`
                pub ip: ::planus::alloc::string::String,
                /// The field `announced_ip` in the table `ListenInfo`
                pub announced_ip: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `port` in the table `ListenInfo`
                pub port: u16,
                /// The field `send_buffer_size` in the table `ListenInfo`
                pub send_buffer_size: u32,
                /// The field `recv_buffer_size` in the table `ListenInfo`
                pub recv_buffer_size: u32,
            }

            impl ListenInfo {
                /// Creates a [ListenInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ListenInfoBuilder<()> {
                    ListenInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_protocol: impl ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_announced_ip: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_send_buffer_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_recv_buffer_size: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_protocol = field_protocol.prepare(builder, &self::Protocol::Udp);
                    let prepared_ip = field_ip.prepare(builder);
                    let prepared_announced_ip = field_announced_ip.prepare(builder);
                    let prepared_port = field_port.prepare(builder, &0);
                    let prepared_send_buffer_size = field_send_buffer_size.prepare(builder, &0);
                    let prepared_recv_buffer_size = field_recv_buffer_size.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_announced_ip.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(2);
                    }
                    if prepared_send_buffer_size.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_recv_buffer_size.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }
                    if prepared_port.is_some() {
                        table_writer.write_entry::<u16>(3);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.write_entry::<self::Protocol>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_ip);
                            if let ::core::option::Option::Some(prepared_announced_ip) =
                                prepared_announced_ip
                            {
                                object_writer.write::<_, _, 4>(&prepared_announced_ip);
                            }
                            if let ::core::option::Option::Some(prepared_send_buffer_size) =
                                prepared_send_buffer_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_send_buffer_size);
                            }
                            if let ::core::option::Option::Some(prepared_recv_buffer_size) =
                                prepared_recv_buffer_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_recv_buffer_size);
                            }
                            if let ::core::option::Option::Some(prepared_port) = prepared_port {
                                object_writer.write::<_, _, 2>(&prepared_port);
                            }
                            if let ::core::option::Option::Some(prepared_protocol) =
                                prepared_protocol
                            {
                                object_writer.write::<_, _, 1>(&prepared_protocol);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenInfo>> for ListenInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenInfo>> for ListenInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenInfo> for ListenInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo> {
                    ListenInfo::create(
                        builder,
                        self.protocol,
                        &self.ip,
                        &self.announced_ip,
                        self.port,
                        self.send_buffer_size,
                        self.recv_buffer_size,
                    )
                }
            }

            /// Builder for serializing an instance of the [ListenInfo] type.
            ///
            /// Can be created using the [ListenInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ListenInfoBuilder<State>(State);

            impl ListenInfoBuilder<()> {
                /// Setter for the [`protocol` field](ListenInfo#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T0>(self, value: T0) -> ListenInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                {
                    ListenInfoBuilder((value,))
                }

                /// Sets the [`protocol` field](ListenInfo#structfield.protocol) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol_as_default(self) -> ListenInfoBuilder<(::planus::DefaultValue,)> {
                    self.protocol(::planus::DefaultValue)
                }
            }

            impl<T0> ListenInfoBuilder<(T0,)> {
                /// Setter for the [`ip` field](ListenInfo#structfield.ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ip<T1>(self, value: T1) -> ListenInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    ListenInfoBuilder((v0, value))
                }
            }

            impl<T0, T1> ListenInfoBuilder<(T0, T1)> {
                /// Setter for the [`announced_ip` field](ListenInfo#structfield.announced_ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn announced_ip<T2>(self, value: T2) -> ListenInfoBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1) = self.0;
                    ListenInfoBuilder((v0, v1, value))
                }

                /// Sets the [`announced_ip` field](ListenInfo#structfield.announced_ip) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn announced_ip_as_null(self) -> ListenInfoBuilder<(T0, T1, ())> {
                    self.announced_ip(())
                }
            }

            impl<T0, T1, T2> ListenInfoBuilder<(T0, T1, T2)> {
                /// Setter for the [`port` field](ListenInfo#structfield.port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port<T3>(self, value: T3) -> ListenInfoBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0, v1, v2) = self.0;
                    ListenInfoBuilder((v0, v1, v2, value))
                }

                /// Sets the [`port` field](ListenInfo#structfield.port) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port_as_default(
                    self,
                ) -> ListenInfoBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.port(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> ListenInfoBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`send_buffer_size` field](ListenInfo#structfield.send_buffer_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn send_buffer_size<T4>(
                    self,
                    value: T4,
                ) -> ListenInfoBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ListenInfoBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`send_buffer_size` field](ListenInfo#structfield.send_buffer_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn send_buffer_size_as_default(
                    self,
                ) -> ListenInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.send_buffer_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> ListenInfoBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`recv_buffer_size` field](ListenInfo#structfield.recv_buffer_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn recv_buffer_size<T5>(
                    self,
                    value: T5,
                ) -> ListenInfoBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ListenInfoBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`recv_buffer_size` field](ListenInfo#structfield.recv_buffer_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn recv_buffer_size_as_default(
                    self,
                ) -> ListenInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.recv_buffer_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ListenInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ListenInfo].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo>
                where
                    Self: ::planus::WriteAsOffset<ListenInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u16, u16>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<ListenInfo>>
                for ListenInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<ListenInfo>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u16, u16>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<ListenInfo>>
                for ListenInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<ListenInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u16, u16>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<ListenInfo>
                for ListenInfoBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    ListenInfo::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [ListenInfo].
            #[derive(Copy, Clone)]
            pub struct ListenInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenInfoRef<'a> {
                /// Getter for the [`protocol` field](ListenInfo#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<self::Protocol> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ListenInfo", "protocol")?
                            .unwrap_or(self::Protocol::Udp),
                    )
                }

                /// Getter for the [`ip` field](ListenInfo#structfield.ip).
                #[inline]
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "ListenInfo", "ip")
                }

                /// Getter for the [`announced_ip` field](ListenInfo#structfield.announced_ip).
                #[inline]
                pub fn announced_ip(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "ListenInfo", "announced_ip")
                }

                /// Getter for the [`port` field](ListenInfo#structfield.port).
                #[inline]
                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(self.0.access(3, "ListenInfo", "port")?.unwrap_or(0))
                }

                /// Getter for the [`send_buffer_size` field](ListenInfo#structfield.send_buffer_size).
                #[inline]
                pub fn send_buffer_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ListenInfo", "send_buffer_size")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`recv_buffer_size` field](ListenInfo#structfield.recv_buffer_size).
                #[inline]
                pub fn recv_buffer_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "ListenInfo", "recv_buffer_size")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ListenInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenInfoRef");
                    f.field("protocol", &self.protocol());
                    f.field("ip", &self.ip());
                    if let ::core::option::Option::Some(field_announced_ip) =
                        self.announced_ip().transpose()
                    {
                        f.field("announced_ip", &field_announced_ip);
                    }
                    f.field("port", &self.port());
                    f.field("send_buffer_size", &self.send_buffer_size());
                    f.field("recv_buffer_size", &self.recv_buffer_size());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenInfoRef<'a>> for ListenInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        announced_ip: if let ::core::option::Option::Some(announced_ip) =
                            value.announced_ip()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                announced_ip,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        send_buffer_size: ::core::convert::TryInto::try_into(
                            value.send_buffer_size()?,
                        )?,
                        recv_buffer_size: ::core::convert::TryInto::try_into(
                            value.recv_buffer_size()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenInfo>> for ListenInfo {
                type Value = ::planus::Offset<ListenInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RestartIceResponse` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `RestartIceResponse` in the file `../worker/fbs/transport.fbs:25`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RestartIceResponse {
                /// The field `username_fragment` in the table `RestartIceResponse`
                pub username_fragment: ::planus::alloc::string::String,
                /// The field `password` in the table `RestartIceResponse`
                pub password: ::planus::alloc::string::String,
                /// The field `ice_lite` in the table `RestartIceResponse`
                pub ice_lite: bool,
            }

            impl RestartIceResponse {
                /// Creates a [RestartIceResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RestartIceResponseBuilder<()> {
                    RestartIceResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_username_fragment: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_password: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_lite: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_username_fragment = field_username_fragment.prepare(builder);
                    let prepared_password = field_password.prepare(builder);
                    let prepared_ice_lite = field_ice_lite.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_ice_lite.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_username_fragment);
                            object_writer.write::<_, _, 4>(&prepared_password);
                            if let ::core::option::Option::Some(prepared_ice_lite) =
                                prepared_ice_lite
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_lite);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RestartIceResponse>> for RestartIceResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RestartIceResponse>> for RestartIceResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RestartIceResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RestartIceResponse> for RestartIceResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse> {
                    RestartIceResponse::create(
                        builder,
                        &self.username_fragment,
                        &self.password,
                        self.ice_lite,
                    )
                }
            }

            /// Builder for serializing an instance of the [RestartIceResponse] type.
            ///
            /// Can be created using the [RestartIceResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RestartIceResponseBuilder<State>(State);

            impl RestartIceResponseBuilder<()> {
                /// Setter for the [`username_fragment` field](RestartIceResponse#structfield.username_fragment).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn username_fragment<T0>(self, value: T0) -> RestartIceResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    RestartIceResponseBuilder((value,))
                }
            }

            impl<T0> RestartIceResponseBuilder<(T0,)> {
                /// Setter for the [`password` field](RestartIceResponse#structfield.password).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn password<T1>(self, value: T1) -> RestartIceResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    RestartIceResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> RestartIceResponseBuilder<(T0, T1)> {
                /// Setter for the [`ice_lite` field](RestartIceResponse#structfield.ice_lite).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_lite<T2>(self, value: T2) -> RestartIceResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    RestartIceResponseBuilder((v0, v1, value))
                }

                /// Sets the [`ice_lite` field](RestartIceResponse#structfield.ice_lite) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_lite_as_default(
                    self,
                ) -> RestartIceResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.ice_lite(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> RestartIceResponseBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RestartIceResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse>
                where
                    Self: ::planus::WriteAsOffset<RestartIceResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<RestartIceResponse>>
                for RestartIceResponseBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<RestartIceResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<RestartIceResponse>>
                for RestartIceResponseBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<RestartIceResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RestartIceResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<RestartIceResponse>
                for RestartIceResponseBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse> {
                    let (v0, v1, v2) = &self.0;
                    RestartIceResponse::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [RestartIceResponse].
            #[derive(Copy, Clone)]
            pub struct RestartIceResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RestartIceResponseRef<'a> {
                /// Getter for the [`username_fragment` field](RestartIceResponse#structfield.username_fragment).
                #[inline]
                pub fn username_fragment(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "RestartIceResponse", "username_fragment")
                }

                /// Getter for the [`password` field](RestartIceResponse#structfield.password).
                #[inline]
                pub fn password(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "RestartIceResponse", "password")
                }

                /// Getter for the [`ice_lite` field](RestartIceResponse#structfield.ice_lite).
                #[inline]
                pub fn ice_lite(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "RestartIceResponse", "ice_lite")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RestartIceResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RestartIceResponseRef");
                    f.field("username_fragment", &self.username_fragment());
                    f.field("password", &self.password());
                    f.field("ice_lite", &self.ice_lite());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RestartIceResponseRef<'a>> for RestartIceResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RestartIceResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        username_fragment: ::core::convert::TryInto::try_into(
                            value.username_fragment()?,
                        )?,
                        password: ::core::convert::TryInto::try_into(value.password()?)?,
                        ice_lite: ::core::convert::TryInto::try_into(value.ice_lite()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RestartIceResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RestartIceResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RestartIceResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RestartIceResponse>> for RestartIceResponse {
                type Value = ::planus::Offset<RestartIceResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RestartIceResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RestartIceResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RestartIceResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ProduceRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ProduceRequest` in the file `../worker/fbs/transport.fbs:31`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct ProduceRequest {
                /// The field `producer_id` in the table `ProduceRequest`
                pub producer_id: ::planus::alloc::string::String,
                /// The field `kind` in the table `ProduceRequest`
                pub kind: super::rtp_parameters::MediaKind,
                /// The field `rtp_parameters` in the table `ProduceRequest`
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                /// The field `rtp_mapping` in the table `ProduceRequest`
                pub rtp_mapping: ::planus::alloc::boxed::Box<super::rtp_parameters::RtpMapping>,
                /// The field `key_frame_request_delay` in the table `ProduceRequest`
                pub key_frame_request_delay: u32,
                /// The field `paused` in the table `ProduceRequest`
                pub paused: bool,
            }

            impl ProduceRequest {
                /// Creates a [ProduceRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ProduceRequestBuilder<()> {
                    ProduceRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_rtp_mapping: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpMapping>,
                    >,
                    field_key_frame_request_delay: impl ::planus::WriteAsDefault<u32, u32>,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);
                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::Audio);
                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);
                    let prepared_rtp_mapping = field_rtp_mapping.prepare(builder);
                    let prepared_key_frame_request_delay =
                        field_key_frame_request_delay.prepare(builder, &0);
                    let prepared_paused = field_paused.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer
                        .write_entry::<::planus::Offset<super::rtp_parameters::RtpParameters>>(2);
                    table_writer
                        .write_entry::<::planus::Offset<super::rtp_parameters::RtpMapping>>(3);
                    if prepared_key_frame_request_delay.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_kind.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::MediaKind>(1);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                            object_writer.write::<_, _, 4>(&prepared_rtp_parameters);
                            object_writer.write::<_, _, 4>(&prepared_rtp_mapping);
                            if let ::core::option::Option::Some(prepared_key_frame_request_delay) =
                                prepared_key_frame_request_delay
                            {
                                object_writer.write::<_, _, 4>(&prepared_key_frame_request_delay);
                            }
                            if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                                object_writer.write::<_, _, 1>(&prepared_kind);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ProduceRequest>> for ProduceRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ProduceRequest>> for ProduceRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ProduceRequest> for ProduceRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest> {
                    ProduceRequest::create(
                        builder,
                        &self.producer_id,
                        self.kind,
                        &self.rtp_parameters,
                        &self.rtp_mapping,
                        self.key_frame_request_delay,
                        self.paused,
                    )
                }
            }

            /// Builder for serializing an instance of the [ProduceRequest] type.
            ///
            /// Can be created using the [ProduceRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ProduceRequestBuilder<State>(State);

            impl ProduceRequestBuilder<()> {
                /// Setter for the [`producer_id` field](ProduceRequest#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T0>(self, value: T0) -> ProduceRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ProduceRequestBuilder((value,))
                }
            }

            impl<T0> ProduceRequestBuilder<(T0,)> {
                /// Setter for the [`kind` field](ProduceRequest#structfield.kind).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind<T1>(self, value: T1) -> ProduceRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                {
                    let (v0,) = self.0;
                    ProduceRequestBuilder((v0, value))
                }

                /// Sets the [`kind` field](ProduceRequest#structfield.kind) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind_as_default(
                    self,
                ) -> ProduceRequestBuilder<(T0, ::planus::DefaultValue)> {
                    self.kind(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ProduceRequestBuilder<(T0, T1)> {
                /// Setter for the [`rtp_parameters` field](ProduceRequest#structfield.rtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_parameters<T2>(self, value: T2) -> ProduceRequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                {
                    let (v0, v1) = self.0;
                    ProduceRequestBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> ProduceRequestBuilder<(T0, T1, T2)> {
                /// Setter for the [`rtp_mapping` field](ProduceRequest#structfield.rtp_mapping).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_mapping<T3>(self, value: T3) -> ProduceRequestBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                {
                    let (v0, v1, v2) = self.0;
                    ProduceRequestBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> ProduceRequestBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`key_frame_request_delay` field](ProduceRequest#structfield.key_frame_request_delay).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key_frame_request_delay<T4>(
                    self,
                    value: T4,
                ) -> ProduceRequestBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ProduceRequestBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`key_frame_request_delay` field](ProduceRequest#structfield.key_frame_request_delay) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key_frame_request_delay_as_default(
                    self,
                ) -> ProduceRequestBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.key_frame_request_delay(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> ProduceRequestBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`paused` field](ProduceRequest#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T5>(
                    self,
                    value: T5,
                ) -> ProduceRequestBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ProduceRequestBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`paused` field](ProduceRequest#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> ProduceRequestBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ProduceRequestBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ProduceRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest>
                where
                    Self: ::planus::WriteAsOffset<ProduceRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T2: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<ProduceRequest>>
                for ProduceRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<ProduceRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T2: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<ProduceRequest>>
                for ProduceRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<ProduceRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T2: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<ProduceRequest>
                for ProduceRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    ProduceRequest::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [ProduceRequest].
            #[derive(Copy, Clone)]
            pub struct ProduceRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ProduceRequestRef<'a> {
                /// Getter for the [`producer_id` field](ProduceRequest#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ProduceRequest", "producer_id")
                }

                /// Getter for the [`kind` field](ProduceRequest#structfield.kind).
                #[inline]
                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ProduceRequest", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::Audio),
                    )
                }

                /// Getter for the [`rtp_parameters` field](ProduceRequest#structfield.rtp_parameters).
                #[inline]
                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0
                        .access_required(2, "ProduceRequest", "rtp_parameters")
                }

                /// Getter for the [`rtp_mapping` field](ProduceRequest#structfield.rtp_mapping).
                #[inline]
                pub fn rtp_mapping(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpMappingRef<'a>> {
                    self.0.access_required(3, "ProduceRequest", "rtp_mapping")
                }

                /// Getter for the [`key_frame_request_delay` field](ProduceRequest#structfield.key_frame_request_delay).
                #[inline]
                pub fn key_frame_request_delay(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ProduceRequest", "key_frame_request_delay")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`paused` field](ProduceRequest#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "ProduceRequest", "paused")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ProduceRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ProduceRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.field("kind", &self.kind());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("rtp_mapping", &self.rtp_mapping());
                    f.field("key_frame_request_delay", &self.key_frame_request_delay());
                    f.field("paused", &self.paused());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ProduceRequestRef<'a>> for ProduceRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ProduceRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        rtp_mapping: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_mapping()?)?,
                        ),
                        key_frame_request_delay: ::core::convert::TryInto::try_into(
                            value.key_frame_request_delay()?,
                        )?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ProduceRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ProduceRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ProduceRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ProduceRequest>> for ProduceRequest {
                type Value = ::planus::Offset<ProduceRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ProduceRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ProduceRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ProduceRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ProduceResponse` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ProduceResponse` in the file `../worker/fbs/transport.fbs:40`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ProduceResponse {
                /// The field `type` in the table `ProduceResponse`
                pub type_: super::rtp_parameters::Type,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ProduceResponse {
                fn default() -> Self {
                    Self {
                        type_: super::rtp_parameters::Type::Simple,
                    }
                }
            }

            impl ProduceResponse {
                /// Creates a [ProduceResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ProduceResponseBuilder<()> {
                    ProduceResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::Simple);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::Type>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ProduceResponse>> for ProduceResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ProduceResponse>> for ProduceResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ProduceResponse> for ProduceResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse> {
                    ProduceResponse::create(builder, self.type_)
                }
            }

            /// Builder for serializing an instance of the [ProduceResponse] type.
            ///
            /// Can be created using the [ProduceResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ProduceResponseBuilder<State>(State);

            impl ProduceResponseBuilder<()> {
                /// Setter for the [`type` field](ProduceResponse#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T0>(self, value: T0) -> ProduceResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                {
                    ProduceResponseBuilder((value,))
                }

                /// Sets the [`type` field](ProduceResponse#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(self) -> ProduceResponseBuilder<(::planus::DefaultValue,)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0> ProduceResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ProduceResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse>
                where
                    Self: ::planus::WriteAsOffset<ProduceResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                > ::planus::WriteAs<::planus::Offset<ProduceResponse>>
                for ProduceResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ProduceResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<ProduceResponse>>
                for ProduceResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ProduceResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                > ::planus::WriteAsOffset<ProduceResponse> for ProduceResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse> {
                    let (v0,) = &self.0;
                    ProduceResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ProduceResponse].
            #[derive(Copy, Clone)]
            pub struct ProduceResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ProduceResponseRef<'a> {
                /// Getter for the [`type` field](ProduceResponse#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ProduceResponse", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::Simple),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ProduceResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ProduceResponseRef");
                    f.field("type_", &self.type_());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ProduceResponseRef<'a>> for ProduceResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ProduceResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ProduceResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ProduceResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ProduceResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ProduceResponse>> for ProduceResponse {
                type Value = ::planus::Offset<ProduceResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ProduceResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ProduceResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ProduceResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConsumeRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ConsumeRequest` in the file `../worker/fbs/transport.fbs:44`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct ConsumeRequest {
                /// The field `consumer_id` in the table `ConsumeRequest`
                pub consumer_id: ::planus::alloc::string::String,
                /// The field `producer_id` in the table `ConsumeRequest`
                pub producer_id: ::planus::alloc::string::String,
                /// The field `kind` in the table `ConsumeRequest`
                pub kind: super::rtp_parameters::MediaKind,
                /// The field `rtp_parameters` in the table `ConsumeRequest`
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                /// The field `type` in the table `ConsumeRequest`
                pub type_: super::rtp_parameters::Type,
                /// The field `consumable_rtp_encodings` in the table `ConsumeRequest`
                pub consumable_rtp_encodings:
                    ::planus::alloc::vec::Vec<super::rtp_parameters::RtpEncodingParameters>,
                /// The field `paused` in the table `ConsumeRequest`
                pub paused: bool,
                /// The field `preferred_layers` in the table `ConsumeRequest`
                pub preferred_layers: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::consumer::ConsumerLayers>,
                >,
                /// The field `ignore_dtx` in the table `ConsumeRequest`
                pub ignore_dtx: bool,
            }

            impl ConsumeRequest {
                /// Creates a [ConsumeRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsumeRequestBuilder<()> {
                    ConsumeRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    field_consumable_rtp_encodings: impl ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_preferred_layers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerLayers>,
                    >,
                    field_ignore_dtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_consumer_id = field_consumer_id.prepare(builder);
                    let prepared_producer_id = field_producer_id.prepare(builder);
                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::Audio);
                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::Simple);
                    let prepared_consumable_rtp_encodings =
                        field_consumable_rtp_encodings.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder, &false);
                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);
                    let prepared_ignore_dtx = field_ignore_dtx.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<22> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    table_writer
                        .write_entry::<::planus::Offset<super::rtp_parameters::RtpParameters>>(3);
                    table_writer.write_entry::<::planus::Offset<
                        [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                    >>(5);
                    if prepared_preferred_layers.is_some() {
                        table_writer
                            .write_entry::<::planus::Offset<super::consumer::ConsumerLayers>>(7);
                    }
                    if prepared_kind.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::MediaKind>(2);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::Type>(4);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(6);
                    }
                    if prepared_ignore_dtx.is_some() {
                        table_writer.write_entry::<bool>(8);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_consumer_id);
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                            object_writer.write::<_, _, 4>(&prepared_rtp_parameters);
                            object_writer.write::<_, _, 4>(&prepared_consumable_rtp_encodings);
                            if let ::core::option::Option::Some(prepared_preferred_layers) =
                                prepared_preferred_layers
                            {
                                object_writer.write::<_, _, 4>(&prepared_preferred_layers);
                            }
                            if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                                object_writer.write::<_, _, 1>(&prepared_kind);
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                            if let ::core::option::Option::Some(prepared_ignore_dtx) =
                                prepared_ignore_dtx
                            {
                                object_writer.write::<_, _, 1>(&prepared_ignore_dtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumeRequest>> for ConsumeRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumeRequest>> for ConsumeRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumeRequest> for ConsumeRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest> {
                    ConsumeRequest::create(
                        builder,
                        &self.consumer_id,
                        &self.producer_id,
                        self.kind,
                        &self.rtp_parameters,
                        self.type_,
                        &self.consumable_rtp_encodings,
                        self.paused,
                        &self.preferred_layers,
                        self.ignore_dtx,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConsumeRequest] type.
            ///
            /// Can be created using the [ConsumeRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsumeRequestBuilder<State>(State);

            impl ConsumeRequestBuilder<()> {
                /// Setter for the [`consumer_id` field](ConsumeRequest#structfield.consumer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn consumer_id<T0>(self, value: T0) -> ConsumeRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ConsumeRequestBuilder((value,))
                }
            }

            impl<T0> ConsumeRequestBuilder<(T0,)> {
                /// Setter for the [`producer_id` field](ConsumeRequest#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T1>(self, value: T1) -> ConsumeRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    ConsumeRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> ConsumeRequestBuilder<(T0, T1)> {
                /// Setter for the [`kind` field](ConsumeRequest#structfield.kind).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind<T2>(self, value: T2) -> ConsumeRequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                {
                    let (v0, v1) = self.0;
                    ConsumeRequestBuilder((v0, v1, value))
                }

                /// Sets the [`kind` field](ConsumeRequest#structfield.kind) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind_as_default(
                    self,
                ) -> ConsumeRequestBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.kind(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> ConsumeRequestBuilder<(T0, T1, T2)> {
                /// Setter for the [`rtp_parameters` field](ConsumeRequest#structfield.rtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_parameters<T3>(
                    self,
                    value: T3,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                {
                    let (v0, v1, v2) = self.0;
                    ConsumeRequestBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> ConsumeRequestBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`type` field](ConsumeRequest#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T4>(self, value: T4) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ConsumeRequestBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`type` field](ConsumeRequest#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> ConsumeRequestBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`consumable_rtp_encodings` field](ConsumeRequest#structfield.consumable_rtp_encodings).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn consumable_rtp_encodings<T5>(
                    self,
                    value: T5,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ConsumeRequestBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`paused` field](ConsumeRequest#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T6>(
                    self,
                    value: T6,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    ConsumeRequestBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`paused` field](ConsumeRequest#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`preferred_layers` field](ConsumeRequest#structfield.preferred_layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers<T7>(
                    self,
                    value: T7,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerLayers>,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    ConsumeRequestBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`preferred_layers` field](ConsumeRequest#structfield.preferred_layers) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers_as_null(
                    self,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, ())> {
                    self.preferred_layers(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`ignore_dtx` field](ConsumeRequest#structfield.ignore_dtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ignore_dtx<T8>(
                    self,
                    value: T8,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    ConsumeRequestBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`ignore_dtx` field](ConsumeRequest#structfield.ignore_dtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ignore_dtx_as_default(
                    self,
                ) -> ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.ignore_dtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsumeRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest>
                where
                    Self: ::planus::WriteAsOffset<ConsumeRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T4: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                    T7: ::planus::WriteAsOptional<::planus::Offset<super::consumer::ConsumerLayers>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<ConsumeRequest>>
                for ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                type Prepared = ::planus::Offset<ConsumeRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T4: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                    T7: ::planus::WriteAsOptional<::planus::Offset<super::consumer::ConsumerLayers>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<ConsumeRequest>>
                for ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                type Prepared = ::planus::Offset<ConsumeRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T4: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                    T7: ::planus::WriteAsOptional<::planus::Offset<super::consumer::ConsumerLayers>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<ConsumeRequest>
                for ConsumeRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = &self.0;
                    ConsumeRequest::create(builder, v0, v1, v2, v3, v4, v5, v6, v7, v8)
                }
            }

            /// Reference to a deserialized [ConsumeRequest].
            #[derive(Copy, Clone)]
            pub struct ConsumeRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumeRequestRef<'a> {
                /// Getter for the [`consumer_id` field](ConsumeRequest#structfield.consumer_id).
                #[inline]
                pub fn consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ConsumeRequest", "consumer_id")
                }

                /// Getter for the [`producer_id` field](ConsumeRequest#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "ConsumeRequest", "producer_id")
                }

                /// Getter for the [`kind` field](ConsumeRequest#structfield.kind).
                #[inline]
                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "ConsumeRequest", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::Audio),
                    )
                }

                /// Getter for the [`rtp_parameters` field](ConsumeRequest#structfield.rtp_parameters).
                #[inline]
                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0
                        .access_required(3, "ConsumeRequest", "rtp_parameters")
                }

                /// Getter for the [`type` field](ConsumeRequest#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ConsumeRequest", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::Simple),
                    )
                }

                /// Getter for the [`consumable_rtp_encodings` field](ConsumeRequest#structfield.consumable_rtp_encodings).
                #[inline]
                pub fn consumable_rtp_encodings(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::planus::Result<super::rtp_parameters::RtpEncodingParametersRef<'a>>,
                    >,
                > {
                    self.0
                        .access_required(5, "ConsumeRequest", "consumable_rtp_encodings")
                }

                /// Getter for the [`paused` field](ConsumeRequest#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "ConsumeRequest", "paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`preferred_layers` field](ConsumeRequest#structfield.preferred_layers).
                #[inline]
                pub fn preferred_layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::consumer::ConsumerLayersRef<'a>>>
                {
                    self.0.access(7, "ConsumeRequest", "preferred_layers")
                }

                /// Getter for the [`ignore_dtx` field](ConsumeRequest#structfield.ignore_dtx).
                #[inline]
                pub fn ignore_dtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "ConsumeRequest", "ignore_dtx")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumeRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumeRequestRef");
                    f.field("consumer_id", &self.consumer_id());
                    f.field("producer_id", &self.producer_id());
                    f.field("kind", &self.kind());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("type_", &self.type_());
                    f.field("consumable_rtp_encodings", &self.consumable_rtp_encodings());
                    f.field("paused", &self.paused());
                    if let ::core::option::Option::Some(field_preferred_layers) =
                        self.preferred_layers().transpose()
                    {
                        f.field("preferred_layers", &field_preferred_layers);
                    }
                    f.field("ignore_dtx", &self.ignore_dtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumeRequestRef<'a>> for ConsumeRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumeRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        consumer_id: ::core::convert::TryInto::try_into(value.consumer_id()?)?,
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        consumable_rtp_encodings: value
                            .consumable_rtp_encodings()?
                            .to_vec_result()?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        preferred_layers: if let ::core::option::Option::Some(preferred_layers) =
                            value.preferred_layers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(preferred_layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        ignore_dtx: ::core::convert::TryInto::try_into(value.ignore_dtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumeRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumeRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumeRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumeRequest>> for ConsumeRequest {
                type Value = ::planus::Offset<ConsumeRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumeRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumeRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumeRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConsumeResponse` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ConsumeResponse` in the file `../worker/fbs/transport.fbs:56`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumeResponse {
                /// The field `paused` in the table `ConsumeResponse`
                pub paused: bool,
                /// The field `producer_paused` in the table `ConsumeResponse`
                pub producer_paused: bool,
                /// The field `score` in the table `ConsumeResponse`
                pub score: ::planus::alloc::boxed::Box<super::consumer::ConsumerScore>,
                /// The field `preferred_layers` in the table `ConsumeResponse`
                pub preferred_layers: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::consumer::ConsumerLayers>,
                >,
            }

            impl ConsumeResponse {
                /// Creates a [ConsumeResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsumeResponseBuilder<()> {
                    ConsumeResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_producer_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_score: impl ::planus::WriteAs<
                        ::planus::Offset<super::consumer::ConsumerScore>,
                    >,
                    field_preferred_layers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerLayers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_paused = field_paused.prepare(builder, &false);
                    let prepared_producer_paused = field_producer_paused.prepare(builder, &false);
                    let prepared_score = field_score.prepare(builder);
                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::consumer::ConsumerScore>>(2);
                    if prepared_preferred_layers.is_some() {
                        table_writer
                            .write_entry::<::planus::Offset<super::consumer::ConsumerLayers>>(3);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(0);
                    }
                    if prepared_producer_paused.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_score);
                            if let ::core::option::Option::Some(prepared_preferred_layers) =
                                prepared_preferred_layers
                            {
                                object_writer.write::<_, _, 4>(&prepared_preferred_layers);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                            if let ::core::option::Option::Some(prepared_producer_paused) =
                                prepared_producer_paused
                            {
                                object_writer.write::<_, _, 1>(&prepared_producer_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumeResponse>> for ConsumeResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumeResponse>> for ConsumeResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumeResponse> for ConsumeResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse> {
                    ConsumeResponse::create(
                        builder,
                        self.paused,
                        self.producer_paused,
                        &self.score,
                        &self.preferred_layers,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConsumeResponse] type.
            ///
            /// Can be created using the [ConsumeResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsumeResponseBuilder<State>(State);

            impl ConsumeResponseBuilder<()> {
                /// Setter for the [`paused` field](ConsumeResponse#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T0>(self, value: T0) -> ConsumeResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<bool, bool>,
                {
                    ConsumeResponseBuilder((value,))
                }

                /// Sets the [`paused` field](ConsumeResponse#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> ConsumeResponseBuilder<(::planus::DefaultValue,)> {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0> ConsumeResponseBuilder<(T0,)> {
                /// Setter for the [`producer_paused` field](ConsumeResponse#structfield.producer_paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_paused<T1>(self, value: T1) -> ConsumeResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    ConsumeResponseBuilder((v0, value))
                }

                /// Sets the [`producer_paused` field](ConsumeResponse#structfield.producer_paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_paused_as_default(
                    self,
                ) -> ConsumeResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.producer_paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ConsumeResponseBuilder<(T0, T1)> {
                /// Setter for the [`score` field](ConsumeResponse#structfield.score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score<T2>(self, value: T2) -> ConsumeResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<super::consumer::ConsumerScore>>,
                {
                    let (v0, v1) = self.0;
                    ConsumeResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> ConsumeResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`preferred_layers` field](ConsumeResponse#structfield.preferred_layers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers<T3>(
                    self,
                    value: T3,
                ) -> ConsumeResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerLayers>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    ConsumeResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`preferred_layers` field](ConsumeResponse#structfield.preferred_layers) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn preferred_layers_as_null(self) -> ConsumeResponseBuilder<(T0, T1, T2, ())> {
                    self.preferred_layers(())
                }
            }

            impl<T0, T1, T2, T3> ConsumeResponseBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsumeResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse>
                where
                    Self: ::planus::WriteAsOffset<ConsumeResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAs<::planus::Offset<super::consumer::ConsumerScore>>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::consumer::ConsumerLayers>>,
                > ::planus::WriteAs<::planus::Offset<ConsumeResponse>>
                for ConsumeResponseBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<ConsumeResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAs<::planus::Offset<super::consumer::ConsumerScore>>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::consumer::ConsumerLayers>>,
                > ::planus::WriteAsOptional<::planus::Offset<ConsumeResponse>>
                for ConsumeResponseBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<ConsumeResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAs<::planus::Offset<super::consumer::ConsumerScore>>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::consumer::ConsumerLayers>>,
                > ::planus::WriteAsOffset<ConsumeResponse>
                for ConsumeResponseBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse> {
                    let (v0, v1, v2, v3) = &self.0;
                    ConsumeResponse::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [ConsumeResponse].
            #[derive(Copy, Clone)]
            pub struct ConsumeResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumeResponseRef<'a> {
                /// Getter for the [`paused` field](ConsumeResponse#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ConsumeResponse", "paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`producer_paused` field](ConsumeResponse#structfield.producer_paused).
                #[inline]
                pub fn producer_paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ConsumeResponse", "producer_paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`score` field](ConsumeResponse#structfield.score).
                #[inline]
                pub fn score(&self) -> ::planus::Result<super::consumer::ConsumerScoreRef<'a>> {
                    self.0.access_required(2, "ConsumeResponse", "score")
                }

                /// Getter for the [`preferred_layers` field](ConsumeResponse#structfield.preferred_layers).
                #[inline]
                pub fn preferred_layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::consumer::ConsumerLayersRef<'a>>>
                {
                    self.0.access(3, "ConsumeResponse", "preferred_layers")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumeResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumeResponseRef");
                    f.field("paused", &self.paused());
                    f.field("producer_paused", &self.producer_paused());
                    f.field("score", &self.score());
                    if let ::core::option::Option::Some(field_preferred_layers) =
                        self.preferred_layers().transpose()
                    {
                        f.field("preferred_layers", &field_preferred_layers);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumeResponseRef<'a>> for ConsumeResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumeResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        producer_paused: ::core::convert::TryInto::try_into(
                            value.producer_paused()?,
                        )?,
                        score: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.score()?)?,
                        ),
                        preferred_layers: if let ::core::option::Option::Some(preferred_layers) =
                            value.preferred_layers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(preferred_layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumeResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumeResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumeResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumeResponse>> for ConsumeResponse {
                type Value = ::planus::Offset<ConsumeResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumeResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumeResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumeResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ProduceDataRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ProduceDataRequest` in the file `../worker/fbs/transport.fbs:63`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ProduceDataRequest {
                /// The field `data_producer_id` in the table `ProduceDataRequest`
                pub data_producer_id: ::planus::alloc::string::String,
                /// The field `type` in the table `ProduceDataRequest`
                pub type_: super::data_producer::Type,
                /// The field `sctp_stream_parameters` in the table `ProduceDataRequest`
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                /// The field `label` in the table `ProduceDataRequest`
                pub label: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `protocol` in the table `ProduceDataRequest`
                pub protocol: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `paused` in the table `ProduceDataRequest`
                pub paused: bool,
            }

            impl ProduceDataRequest {
                /// Creates a [ProduceDataRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ProduceDataRequestBuilder<()> {
                    ProduceDataRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_protocol: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::data_producer::Type::Sctp);
                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);
                    let prepared_label = field_label.prepare(builder);
                    let prepared_protocol = field_protocol.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(2);
                    }
                    if prepared_label.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(3);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(4);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::data_producer::Type>(1);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data_producer_id);
                            if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                                prepared_sctp_stream_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_stream_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_label) = prepared_label {
                                object_writer.write::<_, _, 4>(&prepared_label);
                            }
                            if let ::core::option::Option::Some(prepared_protocol) =
                                prepared_protocol
                            {
                                object_writer.write::<_, _, 4>(&prepared_protocol);
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ProduceDataRequest>> for ProduceDataRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ProduceDataRequest>> for ProduceDataRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceDataRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ProduceDataRequest> for ProduceDataRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest> {
                    ProduceDataRequest::create(
                        builder,
                        &self.data_producer_id,
                        self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                        self.paused,
                    )
                }
            }

            /// Builder for serializing an instance of the [ProduceDataRequest] type.
            ///
            /// Can be created using the [ProduceDataRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ProduceDataRequestBuilder<State>(State);

            impl ProduceDataRequestBuilder<()> {
                /// Setter for the [`data_producer_id` field](ProduceDataRequest#structfield.data_producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_id<T0>(self, value: T0) -> ProduceDataRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ProduceDataRequestBuilder((value,))
                }
            }

            impl<T0> ProduceDataRequestBuilder<(T0,)> {
                /// Setter for the [`type` field](ProduceDataRequest#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T1>(self, value: T1) -> ProduceDataRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                {
                    let (v0,) = self.0;
                    ProduceDataRequestBuilder((v0, value))
                }

                /// Sets the [`type` field](ProduceDataRequest#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> ProduceDataRequestBuilder<(T0, ::planus::DefaultValue)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ProduceDataRequestBuilder<(T0, T1)> {
                /// Setter for the [`sctp_stream_parameters` field](ProduceDataRequest#structfield.sctp_stream_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters<T2>(
                    self,
                    value: T2,
                ) -> ProduceDataRequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                {
                    let (v0, v1) = self.0;
                    ProduceDataRequestBuilder((v0, v1, value))
                }

                /// Sets the [`sctp_stream_parameters` field](ProduceDataRequest#structfield.sctp_stream_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters_as_null(
                    self,
                ) -> ProduceDataRequestBuilder<(T0, T1, ())> {
                    self.sctp_stream_parameters(())
                }
            }

            impl<T0, T1, T2> ProduceDataRequestBuilder<(T0, T1, T2)> {
                /// Setter for the [`label` field](ProduceDataRequest#structfield.label).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label<T3>(self, value: T3) -> ProduceDataRequestBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2) = self.0;
                    ProduceDataRequestBuilder((v0, v1, v2, value))
                }

                /// Sets the [`label` field](ProduceDataRequest#structfield.label) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label_as_null(self) -> ProduceDataRequestBuilder<(T0, T1, T2, ())> {
                    self.label(())
                }
            }

            impl<T0, T1, T2, T3> ProduceDataRequestBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`protocol` field](ProduceDataRequest#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T4>(
                    self,
                    value: T4,
                ) -> ProduceDataRequestBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ProduceDataRequestBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`protocol` field](ProduceDataRequest#structfield.protocol) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol_as_null(self) -> ProduceDataRequestBuilder<(T0, T1, T2, T3, ())> {
                    self.protocol(())
                }
            }

            impl<T0, T1, T2, T3, T4> ProduceDataRequestBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`paused` field](ProduceDataRequest#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T5>(
                    self,
                    value: T5,
                ) -> ProduceDataRequestBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ProduceDataRequestBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`paused` field](ProduceDataRequest#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> ProduceDataRequestBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ProduceDataRequestBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ProduceDataRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest>
                where
                    Self: ::planus::WriteAsOffset<ProduceDataRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<ProduceDataRequest>>
                for ProduceDataRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<ProduceDataRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<ProduceDataRequest>>
                for ProduceDataRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<ProduceDataRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceDataRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<ProduceDataRequest>
                for ProduceDataRequestBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    ProduceDataRequest::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [ProduceDataRequest].
            #[derive(Copy, Clone)]
            pub struct ProduceDataRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ProduceDataRequestRef<'a> {
                /// Getter for the [`data_producer_id` field](ProduceDataRequest#structfield.data_producer_id).
                #[inline]
                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ProduceDataRequest", "data_producer_id")
                }

                /// Getter for the [`type` field](ProduceDataRequest#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::data_producer::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ProduceDataRequest", "type_")?
                            .unwrap_or(super::data_producer::Type::Sctp),
                    )
                }

                /// Getter for the [`sctp_stream_parameters` field](ProduceDataRequest#structfield.sctp_stream_parameters).
                #[inline]
                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0
                        .access(2, "ProduceDataRequest", "sctp_stream_parameters")
                }

                /// Getter for the [`label` field](ProduceDataRequest#structfield.label).
                #[inline]
                pub fn label(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(3, "ProduceDataRequest", "label")
                }

                /// Getter for the [`protocol` field](ProduceDataRequest#structfield.protocol).
                #[inline]
                pub fn protocol(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "ProduceDataRequest", "protocol")
                }

                /// Getter for the [`paused` field](ProduceDataRequest#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "ProduceDataRequest", "paused")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ProduceDataRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ProduceDataRequestRef");
                    f.field("data_producer_id", &self.data_producer_id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    if let ::core::option::Option::Some(field_label) = self.label().transpose() {
                        f.field("label", &field_label);
                    }
                    if let ::core::option::Option::Some(field_protocol) =
                        self.protocol().transpose()
                    {
                        f.field("protocol", &field_protocol);
                    }
                    f.field("paused", &self.paused());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ProduceDataRequestRef<'a>> for ProduceDataRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ProduceDataRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: if let ::core::option::Option::Some(label) = value.label()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(label)?)
                        } else {
                            ::core::option::Option::None
                        },
                        protocol: if let ::core::option::Option::Some(protocol) =
                            value.protocol()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                protocol,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ProduceDataRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ProduceDataRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ProduceDataRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ProduceDataRequest>> for ProduceDataRequest {
                type Value = ::planus::Offset<ProduceDataRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ProduceDataRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ProduceDataRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ProduceDataRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConsumeDataRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `ConsumeDataRequest` in the file `../worker/fbs/transport.fbs:72`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumeDataRequest {
                /// The field `data_consumer_id` in the table `ConsumeDataRequest`
                pub data_consumer_id: ::planus::alloc::string::String,
                /// The field `data_producer_id` in the table `ConsumeDataRequest`
                pub data_producer_id: ::planus::alloc::string::String,
                /// The field `type` in the table `ConsumeDataRequest`
                pub type_: super::data_producer::Type,
                /// The field `sctp_stream_parameters` in the table `ConsumeDataRequest`
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                /// The field `label` in the table `ConsumeDataRequest`
                pub label: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `protocol` in the table `ConsumeDataRequest`
                pub protocol: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `paused` in the table `ConsumeDataRequest`
                pub paused: bool,
                /// The field `subchannels` in the table `ConsumeDataRequest`
                pub subchannels: ::core::option::Option<::planus::alloc::vec::Vec<u16>>,
            }

            impl ConsumeDataRequest {
                /// Creates a [ConsumeDataRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsumeDataRequestBuilder<()> {
                    ConsumeDataRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_protocol: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_subchannels: impl ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_consumer_id = field_data_consumer_id.prepare(builder);
                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::data_producer::Type::Sctp);
                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);
                    let prepared_label = field_label.prepare(builder);
                    let prepared_protocol = field_protocol.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder, &false);
                    let prepared_subchannels = field_subchannels.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(3);
                    }
                    if prepared_label.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(4);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(5);
                    }
                    if prepared_subchannels.is_some() {
                        table_writer.write_entry::<::planus::Offset<[u16]>>(7);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::data_producer::Type>(2);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(6);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data_consumer_id);
                            object_writer.write::<_, _, 4>(&prepared_data_producer_id);
                            if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                                prepared_sctp_stream_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_stream_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_label) = prepared_label {
                                object_writer.write::<_, _, 4>(&prepared_label);
                            }
                            if let ::core::option::Option::Some(prepared_protocol) =
                                prepared_protocol
                            {
                                object_writer.write::<_, _, 4>(&prepared_protocol);
                            }
                            if let ::core::option::Option::Some(prepared_subchannels) =
                                prepared_subchannels
                            {
                                object_writer.write::<_, _, 4>(&prepared_subchannels);
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumeDataRequest>> for ConsumeDataRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumeDataRequest>> for ConsumeDataRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeDataRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumeDataRequest> for ConsumeDataRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest> {
                    ConsumeDataRequest::create(
                        builder,
                        &self.data_consumer_id,
                        &self.data_producer_id,
                        self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                        self.paused,
                        &self.subchannels,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConsumeDataRequest] type.
            ///
            /// Can be created using the [ConsumeDataRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsumeDataRequestBuilder<State>(State);

            impl ConsumeDataRequestBuilder<()> {
                /// Setter for the [`data_consumer_id` field](ConsumeDataRequest#structfield.data_consumer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_consumer_id<T0>(self, value: T0) -> ConsumeDataRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ConsumeDataRequestBuilder((value,))
                }
            }

            impl<T0> ConsumeDataRequestBuilder<(T0,)> {
                /// Setter for the [`data_producer_id` field](ConsumeDataRequest#structfield.data_producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_id<T1>(self, value: T1) -> ConsumeDataRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    ConsumeDataRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> ConsumeDataRequestBuilder<(T0, T1)> {
                /// Setter for the [`type` field](ConsumeDataRequest#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T2>(self, value: T2) -> ConsumeDataRequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                {
                    let (v0, v1) = self.0;
                    ConsumeDataRequestBuilder((v0, v1, value))
                }

                /// Sets the [`type` field](ConsumeDataRequest#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> ConsumeDataRequestBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> ConsumeDataRequestBuilder<(T0, T1, T2)> {
                /// Setter for the [`sctp_stream_parameters` field](ConsumeDataRequest#structfield.sctp_stream_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters<T3>(
                    self,
                    value: T3,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    ConsumeDataRequestBuilder((v0, v1, v2, value))
                }

                /// Sets the [`sctp_stream_parameters` field](ConsumeDataRequest#structfield.sctp_stream_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_stream_parameters_as_null(
                    self,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, ())> {
                    self.sctp_stream_parameters(())
                }
            }

            impl<T0, T1, T2, T3> ConsumeDataRequestBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`label` field](ConsumeDataRequest#structfield.label).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label<T4>(self, value: T4) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ConsumeDataRequestBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`label` field](ConsumeDataRequest#structfield.label) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn label_as_null(self) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, ())> {
                    self.label(())
                }
            }

            impl<T0, T1, T2, T3, T4> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`protocol` field](ConsumeDataRequest#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T5>(
                    self,
                    value: T5,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ConsumeDataRequestBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`protocol` field](ConsumeDataRequest#structfield.protocol) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol_as_null(
                    self,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.protocol(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`paused` field](ConsumeDataRequest#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T6>(
                    self,
                    value: T6,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    ConsumeDataRequestBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`paused` field](ConsumeDataRequest#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`subchannels` field](ConsumeDataRequest#structfield.subchannels).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels<T7>(
                    self,
                    value: T7,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    ConsumeDataRequestBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`subchannels` field](ConsumeDataRequest#structfield.subchannels) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn subchannels_as_null(
                    self,
                ) -> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, ())> {
                    self.subchannels(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsumeDataRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest>
                where
                    Self: ::planus::WriteAsOffset<ConsumeDataRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                    T7: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                > ::planus::WriteAs<::planus::Offset<ConsumeDataRequest>>
                for ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<ConsumeDataRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                    T7: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                > ::planus::WriteAsOptional<::planus::Offset<ConsumeDataRequest>>
                for ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<ConsumeDataRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeDataRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<
                        super::data_producer::Type,
                        super::data_producer::Type,
                    >,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T6: ::planus::WriteAsDefault<bool, bool>,
                    T7: ::planus::WriteAsOptional<::planus::Offset<[u16]>>,
                > ::planus::WriteAsOffset<ConsumeDataRequest>
                for ConsumeDataRequestBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    ConsumeDataRequest::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [ConsumeDataRequest].
            #[derive(Copy, Clone)]
            pub struct ConsumeDataRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumeDataRequestRef<'a> {
                /// Getter for the [`data_consumer_id` field](ConsumeDataRequest#structfield.data_consumer_id).
                #[inline]
                pub fn data_consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ConsumeDataRequest", "data_consumer_id")
                }

                /// Getter for the [`data_producer_id` field](ConsumeDataRequest#structfield.data_producer_id).
                #[inline]
                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "ConsumeDataRequest", "data_producer_id")
                }

                /// Getter for the [`type` field](ConsumeDataRequest#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::data_producer::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "ConsumeDataRequest", "type_")?
                            .unwrap_or(super::data_producer::Type::Sctp),
                    )
                }

                /// Getter for the [`sctp_stream_parameters` field](ConsumeDataRequest#structfield.sctp_stream_parameters).
                #[inline]
                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0
                        .access(3, "ConsumeDataRequest", "sctp_stream_parameters")
                }

                /// Getter for the [`label` field](ConsumeDataRequest#structfield.label).
                #[inline]
                pub fn label(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "ConsumeDataRequest", "label")
                }

                /// Getter for the [`protocol` field](ConsumeDataRequest#structfield.protocol).
                #[inline]
                pub fn protocol(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "ConsumeDataRequest", "protocol")
                }

                /// Getter for the [`paused` field](ConsumeDataRequest#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "ConsumeDataRequest", "paused")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`subchannels` field](ConsumeDataRequest#structfield.subchannels).
                #[inline]
                pub fn subchannels(
                    &self,
                ) -> ::planus::Result<::core::option::Option<::planus::Vector<'a, u16>>>
                {
                    self.0.access(7, "ConsumeDataRequest", "subchannels")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumeDataRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumeDataRequestRef");
                    f.field("data_consumer_id", &self.data_consumer_id());
                    f.field("data_producer_id", &self.data_producer_id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    if let ::core::option::Option::Some(field_label) = self.label().transpose() {
                        f.field("label", &field_label);
                    }
                    if let ::core::option::Option::Some(field_protocol) =
                        self.protocol().transpose()
                    {
                        f.field("protocol", &field_protocol);
                    }
                    f.field("paused", &self.paused());
                    if let ::core::option::Option::Some(field_subchannels) =
                        self.subchannels().transpose()
                    {
                        f.field("subchannels", &field_subchannels);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumeDataRequestRef<'a>> for ConsumeDataRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumeDataRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_consumer_id: ::core::convert::TryInto::try_into(
                            value.data_consumer_id()?,
                        )?,
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: if let ::core::option::Option::Some(label) = value.label()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(label)?)
                        } else {
                            ::core::option::Option::None
                        },
                        protocol: if let ::core::option::Option::Some(protocol) =
                            value.protocol()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                protocol,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        subchannels: if let ::core::option::Option::Some(subchannels) =
                            value.subchannels()?
                        {
                            ::core::option::Option::Some(subchannels.to_vec()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumeDataRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumeDataRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumeDataRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumeDataRequest>> for ConsumeDataRequest {
                type Value = ::planus::Offset<ConsumeDataRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumeDataRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumeDataRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumeDataRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Tuple` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `Tuple` in the file `../worker/fbs/transport.fbs:83`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Tuple {
                /// The field `local_ip` in the table `Tuple`
                pub local_ip: ::planus::alloc::string::String,
                /// The field `local_port` in the table `Tuple`
                pub local_port: u16,
                /// The field `remote_ip` in the table `Tuple`
                pub remote_ip: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `remote_port` in the table `Tuple`
                pub remote_port: u16,
                /// The field `protocol` in the table `Tuple`
                pub protocol: self::Protocol,
            }

            impl Tuple {
                /// Creates a [TupleBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TupleBuilder<()> {
                    TupleBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_local_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_local_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_remote_ip: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_remote_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_protocol: impl ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                ) -> ::planus::Offset<Self> {
                    let prepared_local_ip = field_local_ip.prepare(builder);
                    let prepared_local_port = field_local_port.prepare(builder, &0);
                    let prepared_remote_ip = field_remote_ip.prepare(builder);
                    let prepared_remote_port = field_remote_port.prepare(builder, &0);
                    let prepared_protocol = field_protocol.prepare(builder, &self::Protocol::Udp);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_remote_ip.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(2);
                    }
                    if prepared_local_port.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }
                    if prepared_remote_port.is_some() {
                        table_writer.write_entry::<u16>(3);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.write_entry::<self::Protocol>(4);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_local_ip);
                            if let ::core::option::Option::Some(prepared_remote_ip) =
                                prepared_remote_ip
                            {
                                object_writer.write::<_, _, 4>(&prepared_remote_ip);
                            }
                            if let ::core::option::Option::Some(prepared_local_port) =
                                prepared_local_port
                            {
                                object_writer.write::<_, _, 2>(&prepared_local_port);
                            }
                            if let ::core::option::Option::Some(prepared_remote_port) =
                                prepared_remote_port
                            {
                                object_writer.write::<_, _, 2>(&prepared_remote_port);
                            }
                            if let ::core::option::Option::Some(prepared_protocol) =
                                prepared_protocol
                            {
                                object_writer.write::<_, _, 1>(&prepared_protocol);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Tuple>> for Tuple {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Tuple>> for Tuple {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Tuple>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Tuple> for Tuple {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple> {
                    Tuple::create(
                        builder,
                        &self.local_ip,
                        self.local_port,
                        &self.remote_ip,
                        self.remote_port,
                        self.protocol,
                    )
                }
            }

            /// Builder for serializing an instance of the [Tuple] type.
            ///
            /// Can be created using the [Tuple::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TupleBuilder<State>(State);

            impl TupleBuilder<()> {
                /// Setter for the [`local_ip` field](Tuple#structfield.local_ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_ip<T0>(self, value: T0) -> TupleBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    TupleBuilder((value,))
                }
            }

            impl<T0> TupleBuilder<(T0,)> {
                /// Setter for the [`local_port` field](Tuple#structfield.local_port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_port<T1>(self, value: T1) -> TupleBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0,) = self.0;
                    TupleBuilder((v0, value))
                }

                /// Sets the [`local_port` field](Tuple#structfield.local_port) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_port_as_default(self) -> TupleBuilder<(T0, ::planus::DefaultValue)> {
                    self.local_port(::planus::DefaultValue)
                }
            }

            impl<T0, T1> TupleBuilder<(T0, T1)> {
                /// Setter for the [`remote_ip` field](Tuple#structfield.remote_ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn remote_ip<T2>(self, value: T2) -> TupleBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1) = self.0;
                    TupleBuilder((v0, v1, value))
                }

                /// Sets the [`remote_ip` field](Tuple#structfield.remote_ip) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn remote_ip_as_null(self) -> TupleBuilder<(T0, T1, ())> {
                    self.remote_ip(())
                }
            }

            impl<T0, T1, T2> TupleBuilder<(T0, T1, T2)> {
                /// Setter for the [`remote_port` field](Tuple#structfield.remote_port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn remote_port<T3>(self, value: T3) -> TupleBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0, v1, v2) = self.0;
                    TupleBuilder((v0, v1, v2, value))
                }

                /// Sets the [`remote_port` field](Tuple#structfield.remote_port) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn remote_port_as_default(
                    self,
                ) -> TupleBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.remote_port(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> TupleBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`protocol` field](Tuple#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T4>(self, value: T4) -> TupleBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    TupleBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`protocol` field](Tuple#structfield.protocol) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol_as_default(
                    self,
                ) -> TupleBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.protocol(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> TupleBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Tuple].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple>
                where
                    Self: ::planus::WriteAsOffset<Tuple>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u16, u16>,
                    T4: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                > ::planus::WriteAs<::planus::Offset<Tuple>>
                for TupleBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<Tuple>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u16, u16>,
                    T4: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                > ::planus::WriteAsOptional<::planus::Offset<Tuple>>
                for TupleBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<Tuple>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Tuple>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u16, u16>,
                    T4: ::planus::WriteAsDefault<self::Protocol, self::Protocol>,
                > ::planus::WriteAsOffset<Tuple> for TupleBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    Tuple::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [Tuple].
            #[derive(Copy, Clone)]
            pub struct TupleRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TupleRef<'a> {
                /// Getter for the [`local_ip` field](Tuple#structfield.local_ip).
                #[inline]
                pub fn local_ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Tuple", "local_ip")
                }

                /// Getter for the [`local_port` field](Tuple#structfield.local_port).
                #[inline]
                pub fn local_port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Tuple", "local_port")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`remote_ip` field](Tuple#structfield.remote_ip).
                #[inline]
                pub fn remote_ip(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "Tuple", "remote_ip")
                }

                /// Getter for the [`remote_port` field](Tuple#structfield.remote_port).
                #[inline]
                pub fn remote_port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Tuple", "remote_port")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`protocol` field](Tuple#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<self::Protocol> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "Tuple", "protocol")?
                            .unwrap_or(self::Protocol::Udp),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for TupleRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TupleRef");
                    f.field("local_ip", &self.local_ip());
                    f.field("local_port", &self.local_port());
                    if let ::core::option::Option::Some(field_remote_ip) =
                        self.remote_ip().transpose()
                    {
                        f.field("remote_ip", &field_remote_ip);
                    }
                    f.field("remote_port", &self.remote_port());
                    f.field("protocol", &self.protocol());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TupleRef<'a>> for Tuple {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TupleRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        local_ip: ::core::convert::TryInto::try_into(value.local_ip()?)?,
                        local_port: ::core::convert::TryInto::try_into(value.local_port()?)?,
                        remote_ip: if let ::core::option::Option::Some(remote_ip) =
                            value.remote_ip()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                remote_ip,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        remote_port: ::core::convert::TryInto::try_into(value.remote_port()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TupleRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TupleRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TupleRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Tuple>> for Tuple {
                type Value = ::planus::Offset<Tuple>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Tuple>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TupleRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TupleRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpListener` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `RtpListener` in the file `../worker/fbs/transport.fbs:91`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpListener {
                /// The field `ssrc_table` in the table `RtpListener`
                pub ssrc_table: ::planus::alloc::vec::Vec<super::common::Uint32String>,
                /// The field `mid_table` in the table `RtpListener`
                pub mid_table: ::planus::alloc::vec::Vec<super::common::StringString>,
                /// The field `rid_table` in the table `RtpListener`
                pub rid_table: ::planus::alloc::vec::Vec<super::common::StringString>,
            }

            impl RtpListener {
                /// Creates a [RtpListenerBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpListenerBuilder<()> {
                    RtpListenerBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    field_mid_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    field_rid_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc_table = field_ssrc_table.prepare(builder);
                    let prepared_mid_table = field_mid_table.prepare(builder);
                    let prepared_rid_table = field_rid_table.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::Uint32String>]>>(0);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::StringString>]>>(1);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::StringString>]>>(2);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_ssrc_table);
                            object_writer.write::<_, _, 4>(&prepared_mid_table);
                            object_writer.write::<_, _, 4>(&prepared_rid_table);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpListener>> for RtpListener {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpListener>> for RtpListener {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpListener>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpListener> for RtpListener {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener> {
                    RtpListener::create(builder, &self.ssrc_table, &self.mid_table, &self.rid_table)
                }
            }

            /// Builder for serializing an instance of the [RtpListener] type.
            ///
            /// Can be created using the [RtpListener::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpListenerBuilder<State>(State);

            impl RtpListenerBuilder<()> {
                /// Setter for the [`ssrc_table` field](RtpListener#structfield.ssrc_table).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_table<T0>(self, value: T0) -> RtpListenerBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                {
                    RtpListenerBuilder((value,))
                }
            }

            impl<T0> RtpListenerBuilder<(T0,)> {
                /// Setter for the [`mid_table` field](RtpListener#structfield.mid_table).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid_table<T1>(self, value: T1) -> RtpListenerBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                {
                    let (v0,) = self.0;
                    RtpListenerBuilder((v0, value))
                }
            }

            impl<T0, T1> RtpListenerBuilder<(T0, T1)> {
                /// Setter for the [`rid_table` field](RtpListener#structfield.rid_table).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_table<T2>(self, value: T2) -> RtpListenerBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                {
                    let (v0, v1) = self.0;
                    RtpListenerBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> RtpListenerBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpListener].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener>
                where
                    Self: ::planus::WriteAsOffset<RtpListener>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<RtpListener>>
                for RtpListenerBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<RtpListener>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<RtpListener>>
                for RtpListenerBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<RtpListener>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpListener>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                > ::planus::WriteAsOffset<RtpListener> for RtpListenerBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener> {
                    let (v0, v1, v2) = &self.0;
                    RtpListener::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [RtpListener].
            #[derive(Copy, Clone)]
            pub struct RtpListenerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpListenerRef<'a> {
                /// Getter for the [`ssrc_table` field](RtpListener#structfield.ssrc_table).
                #[inline]
                pub fn ssrc_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint32StringRef<'a>>>,
                > {
                    self.0.access_required(0, "RtpListener", "ssrc_table")
                }

                /// Getter for the [`mid_table` field](RtpListener#structfield.mid_table).
                #[inline]
                pub fn mid_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                > {
                    self.0.access_required(1, "RtpListener", "mid_table")
                }

                /// Getter for the [`rid_table` field](RtpListener#structfield.rid_table).
                #[inline]
                pub fn rid_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                > {
                    self.0.access_required(2, "RtpListener", "rid_table")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpListenerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpListenerRef");
                    f.field("ssrc_table", &self.ssrc_table());
                    f.field("mid_table", &self.mid_table());
                    f.field("rid_table", &self.rid_table());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpListenerRef<'a>> for RtpListener {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpListenerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc_table: value.ssrc_table()?.to_vec_result()?,
                        mid_table: value.mid_table()?.to_vec_result()?,
                        rid_table: value.rid_table()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpListenerRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpListenerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpListenerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpListener>> for RtpListener {
                type Value = ::planus::Offset<RtpListener>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpListener>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpListenerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpListenerRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SctpListener` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `SctpListener` in the file `../worker/fbs/transport.fbs:97`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpListener {
                /// The field `stream_id_table` in the table `SctpListener`
                pub stream_id_table: ::planus::alloc::vec::Vec<super::common::Uint16String>,
            }

            impl SctpListener {
                /// Creates a [SctpListenerBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SctpListenerBuilder<()> {
                    SctpListenerBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stream_id_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint16String>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_stream_id_table = field_stream_id_table.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::Uint16String>]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_stream_id_table);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpListener>> for SctpListener {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpListener>> for SctpListener {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpListener>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpListener> for SctpListener {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener> {
                    SctpListener::create(builder, &self.stream_id_table)
                }
            }

            /// Builder for serializing an instance of the [SctpListener] type.
            ///
            /// Can be created using the [SctpListener::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SctpListenerBuilder<State>(State);

            impl SctpListenerBuilder<()> {
                /// Setter for the [`stream_id_table` field](SctpListener#structfield.stream_id_table).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn stream_id_table<T0>(self, value: T0) -> SctpListenerBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint16String>]>,
                    >,
                {
                    SctpListenerBuilder((value,))
                }
            }

            impl<T0> SctpListenerBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SctpListener].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener>
                where
                    Self: ::planus::WriteAsOffset<SctpListener>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint16String>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<SctpListener>> for SctpListenerBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SctpListener>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint16String>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<SctpListener>>
                for SctpListenerBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SctpListener>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpListener>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint16String>]>,
                    >,
                > ::planus::WriteAsOffset<SctpListener> for SctpListenerBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener> {
                    let (v0,) = &self.0;
                    SctpListener::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SctpListener].
            #[derive(Copy, Clone)]
            pub struct SctpListenerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpListenerRef<'a> {
                /// Getter for the [`stream_id_table` field](SctpListener#structfield.stream_id_table).
                #[inline]
                pub fn stream_id_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint16StringRef<'a>>>,
                > {
                    self.0.access_required(0, "SctpListener", "stream_id_table")
                }
            }

            impl<'a> ::core::fmt::Debug for SctpListenerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpListenerRef");
                    f.field("stream_id_table", &self.stream_id_table());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpListenerRef<'a>> for SctpListener {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpListenerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stream_id_table: value.stream_id_table()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpListenerRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpListenerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpListenerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpListener>> for SctpListener {
                type Value = ::planus::Offset<SctpListener>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpListener>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpListenerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SctpListenerRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RecvRtpHeaderExtensions` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `RecvRtpHeaderExtensions` in the file `../worker/fbs/transport.fbs:101`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RecvRtpHeaderExtensions {
                /// The field `mid` in the table `RecvRtpHeaderExtensions`
                pub mid: ::core::option::Option<u8>,
                /// The field `rid` in the table `RecvRtpHeaderExtensions`
                pub rid: ::core::option::Option<u8>,
                /// The field `rrid` in the table `RecvRtpHeaderExtensions`
                pub rrid: ::core::option::Option<u8>,
                /// The field `abs_send_time` in the table `RecvRtpHeaderExtensions`
                pub abs_send_time: ::core::option::Option<u8>,
                /// The field `transport_wide_cc01` in the table `RecvRtpHeaderExtensions`
                pub transport_wide_cc01: ::core::option::Option<u8>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RecvRtpHeaderExtensions {
                fn default() -> Self {
                    Self {
                        mid: ::core::default::Default::default(),
                        rid: ::core::default::Default::default(),
                        rrid: ::core::default::Default::default(),
                        abs_send_time: ::core::default::Default::default(),
                        transport_wide_cc01: ::core::default::Default::default(),
                    }
                }
            }

            impl RecvRtpHeaderExtensions {
                /// Creates a [RecvRtpHeaderExtensionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RecvRtpHeaderExtensionsBuilder<()> {
                    RecvRtpHeaderExtensionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_mid: impl ::planus::WriteAsOptional<u8>,
                    field_rid: impl ::planus::WriteAsOptional<u8>,
                    field_rrid: impl ::planus::WriteAsOptional<u8>,
                    field_abs_send_time: impl ::planus::WriteAsOptional<u8>,
                    field_transport_wide_cc01: impl ::planus::WriteAsOptional<u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_mid = field_mid.prepare(builder);
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_rrid = field_rrid.prepare(builder);
                    let prepared_abs_send_time = field_abs_send_time.prepare(builder);
                    let prepared_transport_wide_cc01 = field_transport_wide_cc01.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_mid.is_some() {
                        table_writer.write_entry::<u8>(0);
                    }
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }
                    if prepared_rrid.is_some() {
                        table_writer.write_entry::<u8>(2);
                    }
                    if prepared_abs_send_time.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }
                    if prepared_transport_wide_cc01.is_some() {
                        table_writer.write_entry::<u8>(4);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_mid) = prepared_mid {
                                object_writer.write::<_, _, 1>(&prepared_mid);
                            }
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 1>(&prepared_rid);
                            }
                            if let ::core::option::Option::Some(prepared_rrid) = prepared_rrid {
                                object_writer.write::<_, _, 1>(&prepared_rrid);
                            }
                            if let ::core::option::Option::Some(prepared_abs_send_time) =
                                prepared_abs_send_time
                            {
                                object_writer.write::<_, _, 1>(&prepared_abs_send_time);
                            }
                            if let ::core::option::Option::Some(prepared_transport_wide_cc01) =
                                prepared_transport_wide_cc01
                            {
                                object_writer.write::<_, _, 1>(&prepared_transport_wide_cc01);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RecvRtpHeaderExtensions>> for RecvRtpHeaderExtensions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RecvRtpHeaderExtensions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RecvRtpHeaderExtensions>>
                for RecvRtpHeaderExtensions
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RecvRtpHeaderExtensions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RecvRtpHeaderExtensions> for RecvRtpHeaderExtensions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RecvRtpHeaderExtensions> {
                    RecvRtpHeaderExtensions::create(
                        builder,
                        self.mid,
                        self.rid,
                        self.rrid,
                        self.abs_send_time,
                        self.transport_wide_cc01,
                    )
                }
            }

            /// Builder for serializing an instance of the [RecvRtpHeaderExtensions] type.
            ///
            /// Can be created using the [RecvRtpHeaderExtensions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RecvRtpHeaderExtensionsBuilder<State>(State);

            impl RecvRtpHeaderExtensionsBuilder<()> {
                /// Setter for the [`mid` field](RecvRtpHeaderExtensions#structfield.mid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid<T0>(self, value: T0) -> RecvRtpHeaderExtensionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<u8>,
                {
                    RecvRtpHeaderExtensionsBuilder((value,))
                }

                /// Sets the [`mid` field](RecvRtpHeaderExtensions#structfield.mid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mid_as_null(self) -> RecvRtpHeaderExtensionsBuilder<((),)> {
                    self.mid(())
                }
            }

            impl<T0> RecvRtpHeaderExtensionsBuilder<(T0,)> {
                /// Setter for the [`rid` field](RecvRtpHeaderExtensions#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T1>(self, value: T1) -> RecvRtpHeaderExtensionsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<u8>,
                {
                    let (v0,) = self.0;
                    RecvRtpHeaderExtensionsBuilder((v0, value))
                }

                /// Sets the [`rid` field](RecvRtpHeaderExtensions#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(self) -> RecvRtpHeaderExtensionsBuilder<(T0, ())> {
                    self.rid(())
                }
            }

            impl<T0, T1> RecvRtpHeaderExtensionsBuilder<(T0, T1)> {
                /// Setter for the [`rrid` field](RecvRtpHeaderExtensions#structfield.rrid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rrid<T2>(self, value: T2) -> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<u8>,
                {
                    let (v0, v1) = self.0;
                    RecvRtpHeaderExtensionsBuilder((v0, v1, value))
                }

                /// Sets the [`rrid` field](RecvRtpHeaderExtensions#structfield.rrid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rrid_as_null(self) -> RecvRtpHeaderExtensionsBuilder<(T0, T1, ())> {
                    self.rrid(())
                }
            }

            impl<T0, T1, T2> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2)> {
                /// Setter for the [`abs_send_time` field](RecvRtpHeaderExtensions#structfield.abs_send_time).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn abs_send_time<T3>(
                    self,
                    value: T3,
                ) -> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<u8>,
                {
                    let (v0, v1, v2) = self.0;
                    RecvRtpHeaderExtensionsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`abs_send_time` field](RecvRtpHeaderExtensions#structfield.abs_send_time) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn abs_send_time_as_null(
                    self,
                ) -> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, ())> {
                    self.abs_send_time(())
                }
            }

            impl<T0, T1, T2, T3> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`transport_wide_cc01` field](RecvRtpHeaderExtensions#structfield.transport_wide_cc01).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_wide_cc01<T4>(
                    self,
                    value: T4,
                ) -> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<u8>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    RecvRtpHeaderExtensionsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`transport_wide_cc01` field](RecvRtpHeaderExtensions#structfield.transport_wide_cc01) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_wide_cc01_as_null(
                    self,
                ) -> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3, ())> {
                    self.transport_wide_cc01(())
                }
            }

            impl<T0, T1, T2, T3, T4> RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RecvRtpHeaderExtensions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RecvRtpHeaderExtensions>
                where
                    Self: ::planus::WriteAsOffset<RecvRtpHeaderExtensions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<u8>,
                    T1: ::planus::WriteAsOptional<u8>,
                    T2: ::planus::WriteAsOptional<u8>,
                    T3: ::planus::WriteAsOptional<u8>,
                    T4: ::planus::WriteAsOptional<u8>,
                > ::planus::WriteAs<::planus::Offset<RecvRtpHeaderExtensions>>
                for RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<RecvRtpHeaderExtensions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RecvRtpHeaderExtensions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<u8>,
                    T1: ::planus::WriteAsOptional<u8>,
                    T2: ::planus::WriteAsOptional<u8>,
                    T3: ::planus::WriteAsOptional<u8>,
                    T4: ::planus::WriteAsOptional<u8>,
                > ::planus::WriteAsOptional<::planus::Offset<RecvRtpHeaderExtensions>>
                for RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<RecvRtpHeaderExtensions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RecvRtpHeaderExtensions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<u8>,
                    T1: ::planus::WriteAsOptional<u8>,
                    T2: ::planus::WriteAsOptional<u8>,
                    T3: ::planus::WriteAsOptional<u8>,
                    T4: ::planus::WriteAsOptional<u8>,
                > ::planus::WriteAsOffset<RecvRtpHeaderExtensions>
                for RecvRtpHeaderExtensionsBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RecvRtpHeaderExtensions> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    RecvRtpHeaderExtensions::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [RecvRtpHeaderExtensions].
            #[derive(Copy, Clone)]
            pub struct RecvRtpHeaderExtensionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RecvRtpHeaderExtensionsRef<'a> {
                /// Getter for the [`mid` field](RecvRtpHeaderExtensions#structfield.mid).
                #[inline]
                pub fn mid(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(0, "RecvRtpHeaderExtensions", "mid")
                }

                /// Getter for the [`rid` field](RecvRtpHeaderExtensions#structfield.rid).
                #[inline]
                pub fn rid(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(1, "RecvRtpHeaderExtensions", "rid")
                }

                /// Getter for the [`rrid` field](RecvRtpHeaderExtensions#structfield.rrid).
                #[inline]
                pub fn rrid(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(2, "RecvRtpHeaderExtensions", "rrid")
                }

                /// Getter for the [`abs_send_time` field](RecvRtpHeaderExtensions#structfield.abs_send_time).
                #[inline]
                pub fn abs_send_time(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(3, "RecvRtpHeaderExtensions", "abs_send_time")
                }

                /// Getter for the [`transport_wide_cc01` field](RecvRtpHeaderExtensions#structfield.transport_wide_cc01).
                #[inline]
                pub fn transport_wide_cc01(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0
                        .access(4, "RecvRtpHeaderExtensions", "transport_wide_cc01")
                }
            }

            impl<'a> ::core::fmt::Debug for RecvRtpHeaderExtensionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RecvRtpHeaderExtensionsRef");
                    if let ::core::option::Option::Some(field_mid) = self.mid().transpose() {
                        f.field("mid", &field_mid);
                    }
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_rrid) = self.rrid().transpose() {
                        f.field("rrid", &field_rrid);
                    }
                    if let ::core::option::Option::Some(field_abs_send_time) =
                        self.abs_send_time().transpose()
                    {
                        f.field("abs_send_time", &field_abs_send_time);
                    }
                    if let ::core::option::Option::Some(field_transport_wide_cc01) =
                        self.transport_wide_cc01().transpose()
                    {
                        f.field("transport_wide_cc01", &field_transport_wide_cc01);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RecvRtpHeaderExtensionsRef<'a>> for RecvRtpHeaderExtensions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RecvRtpHeaderExtensionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        mid: if let ::core::option::Option::Some(mid) = value.mid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(mid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rrid: if let ::core::option::Option::Some(rrid) = value.rrid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rrid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        abs_send_time: if let ::core::option::Option::Some(abs_send_time) =
                            value.abs_send_time()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                abs_send_time,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        transport_wide_cc01: if let ::core::option::Option::Some(
                            transport_wide_cc01,
                        ) = value.transport_wide_cc01()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                transport_wide_cc01,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RecvRtpHeaderExtensionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RecvRtpHeaderExtensionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RecvRtpHeaderExtensionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RecvRtpHeaderExtensions>> for RecvRtpHeaderExtensions {
                type Value = ::planus::Offset<RecvRtpHeaderExtensions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RecvRtpHeaderExtensions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RecvRtpHeaderExtensionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RecvRtpHeaderExtensionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `Options` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `Options` in the file `../worker/fbs/transport.fbs:109`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Options {
                /// The field `direct` in the table `Options`
                pub direct: bool,
                ///  Only needed for DirectTransport. This value is handled by base Transport.
                pub max_message_size: ::core::option::Option<u32>,
                /// The field `initial_available_outgoing_bitrate` in the table `Options`
                pub initial_available_outgoing_bitrate: ::core::option::Option<u32>,
                /// The field `enable_sctp` in the table `Options`
                pub enable_sctp: bool,
                /// The field `num_sctp_streams` in the table `Options`
                pub num_sctp_streams: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::NumSctpStreams>,
                >,
                /// The field `max_sctp_message_size` in the table `Options`
                pub max_sctp_message_size: u32,
                /// The field `sctp_send_buffer_size` in the table `Options`
                pub sctp_send_buffer_size: u32,
                /// The field `is_data_channel` in the table `Options`
                pub is_data_channel: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Options {
                fn default() -> Self {
                    Self {
                        direct: false,
                        max_message_size: ::core::default::Default::default(),
                        initial_available_outgoing_bitrate: ::core::default::Default::default(),
                        enable_sctp: false,
                        num_sctp_streams: ::core::default::Default::default(),
                        max_sctp_message_size: 0,
                        sctp_send_buffer_size: 0,
                        is_data_channel: false,
                    }
                }
            }

            impl Options {
                /// Creates a [OptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> OptionsBuilder<()> {
                    OptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_direct: impl ::planus::WriteAsDefault<bool, bool>,
                    field_max_message_size: impl ::planus::WriteAsOptional<u32>,
                    field_initial_available_outgoing_bitrate: impl ::planus::WriteAsOptional<u32>,
                    field_enable_sctp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_num_sctp_streams: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::NumSctpStreams>,
                    >,
                    field_max_sctp_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_sctp_send_buffer_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_is_data_channel: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_direct = field_direct.prepare(builder, &false);
                    let prepared_max_message_size = field_max_message_size.prepare(builder);
                    let prepared_initial_available_outgoing_bitrate =
                        field_initial_available_outgoing_bitrate.prepare(builder);
                    let prepared_enable_sctp = field_enable_sctp.prepare(builder, &false);
                    let prepared_num_sctp_streams = field_num_sctp_streams.prepare(builder);
                    let prepared_max_sctp_message_size =
                        field_max_sctp_message_size.prepare(builder, &0);
                    let prepared_sctp_send_buffer_size =
                        field_sctp_send_buffer_size.prepare(builder, &0);
                    let prepared_is_data_channel = field_is_data_channel.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    if prepared_max_message_size.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_initial_available_outgoing_bitrate.is_some() {
                        table_writer.write_entry::<u32>(2);
                    }
                    if prepared_num_sctp_streams.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::sctp_parameters::NumSctpStreams>>(4);
                    }
                    if prepared_max_sctp_message_size.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }
                    if prepared_sctp_send_buffer_size.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    if prepared_direct.is_some() {
                        table_writer.write_entry::<bool>(0);
                    }
                    if prepared_enable_sctp.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }
                    if prepared_is_data_channel.is_some() {
                        table_writer.write_entry::<bool>(7);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_max_message_size) =
                                prepared_max_message_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_message_size);
                            }
                            if let ::core::option::Option::Some(
                                prepared_initial_available_outgoing_bitrate,
                            ) = prepared_initial_available_outgoing_bitrate
                            {
                                object_writer
                                    .write::<_, _, 4>(&prepared_initial_available_outgoing_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_num_sctp_streams) =
                                prepared_num_sctp_streams
                            {
                                object_writer.write::<_, _, 4>(&prepared_num_sctp_streams);
                            }
                            if let ::core::option::Option::Some(prepared_max_sctp_message_size) =
                                prepared_max_sctp_message_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_sctp_message_size);
                            }
                            if let ::core::option::Option::Some(prepared_sctp_send_buffer_size) =
                                prepared_sctp_send_buffer_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_send_buffer_size);
                            }
                            if let ::core::option::Option::Some(prepared_direct) = prepared_direct {
                                object_writer.write::<_, _, 1>(&prepared_direct);
                            }
                            if let ::core::option::Option::Some(prepared_enable_sctp) =
                                prepared_enable_sctp
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_sctp);
                            }
                            if let ::core::option::Option::Some(prepared_is_data_channel) =
                                prepared_is_data_channel
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_data_channel);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Options>> for Options {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Options>> for Options {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Options>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Options> for Options {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options> {
                    Options::create(
                        builder,
                        self.direct,
                        self.max_message_size,
                        self.initial_available_outgoing_bitrate,
                        self.enable_sctp,
                        &self.num_sctp_streams,
                        self.max_sctp_message_size,
                        self.sctp_send_buffer_size,
                        self.is_data_channel,
                    )
                }
            }

            /// Builder for serializing an instance of the [Options] type.
            ///
            /// Can be created using the [Options::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct OptionsBuilder<State>(State);

            impl OptionsBuilder<()> {
                /// Setter for the [`direct` field](Options#structfield.direct).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direct<T0>(self, value: T0) -> OptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<bool, bool>,
                {
                    OptionsBuilder((value,))
                }

                /// Sets the [`direct` field](Options#structfield.direct) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direct_as_default(self) -> OptionsBuilder<(::planus::DefaultValue,)> {
                    self.direct(::planus::DefaultValue)
                }
            }

            impl<T0> OptionsBuilder<(T0,)> {
                /// Setter for the [`max_message_size` field](Options#structfield.max_message_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_message_size<T1>(self, value: T1) -> OptionsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<u32>,
                {
                    let (v0,) = self.0;
                    OptionsBuilder((v0, value))
                }

                /// Sets the [`max_message_size` field](Options#structfield.max_message_size) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_message_size_as_null(self) -> OptionsBuilder<(T0, ())> {
                    self.max_message_size(())
                }
            }

            impl<T0, T1> OptionsBuilder<(T0, T1)> {
                /// Setter for the [`initial_available_outgoing_bitrate` field](Options#structfield.initial_available_outgoing_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn initial_available_outgoing_bitrate<T2>(
                    self,
                    value: T2,
                ) -> OptionsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<u32>,
                {
                    let (v0, v1) = self.0;
                    OptionsBuilder((v0, v1, value))
                }

                /// Sets the [`initial_available_outgoing_bitrate` field](Options#structfield.initial_available_outgoing_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn initial_available_outgoing_bitrate_as_null(
                    self,
                ) -> OptionsBuilder<(T0, T1, ())> {
                    self.initial_available_outgoing_bitrate(())
                }
            }

            impl<T0, T1, T2> OptionsBuilder<(T0, T1, T2)> {
                /// Setter for the [`enable_sctp` field](Options#structfield.enable_sctp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_sctp<T3>(self, value: T3) -> OptionsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    OptionsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`enable_sctp` field](Options#structfield.enable_sctp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_sctp_as_default(
                    self,
                ) -> OptionsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.enable_sctp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> OptionsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`num_sctp_streams` field](Options#structfield.num_sctp_streams).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn num_sctp_streams<T4>(self, value: T4) -> OptionsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::NumSctpStreams>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    OptionsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`num_sctp_streams` field](Options#structfield.num_sctp_streams) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn num_sctp_streams_as_null(self) -> OptionsBuilder<(T0, T1, T2, T3, ())> {
                    self.num_sctp_streams(())
                }
            }

            impl<T0, T1, T2, T3, T4> OptionsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`max_sctp_message_size` field](Options#structfield.max_sctp_message_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_sctp_message_size<T5>(
                    self,
                    value: T5,
                ) -> OptionsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    OptionsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`max_sctp_message_size` field](Options#structfield.max_sctp_message_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_sctp_message_size_as_default(
                    self,
                ) -> OptionsBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                    self.max_sctp_message_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> OptionsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`sctp_send_buffer_size` field](Options#structfield.sctp_send_buffer_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_send_buffer_size<T6>(
                    self,
                    value: T6,
                ) -> OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    OptionsBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`sctp_send_buffer_size` field](Options#structfield.sctp_send_buffer_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_send_buffer_size_as_default(
                    self,
                ) -> OptionsBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.sctp_send_buffer_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`is_data_channel` field](Options#structfield.is_data_channel).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_data_channel<T7>(
                    self,
                    value: T7,
                ) -> OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    OptionsBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`is_data_channel` field](Options#structfield.is_data_channel) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_data_channel_as_default(
                    self,
                ) -> OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.is_data_channel(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Options].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options>
                where
                    Self: ::planus::WriteAsOffset<Options>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsOptional<u32>,
                    T2: ::planus::WriteAsOptional<u32>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::NumSctpStreams>,
                    >,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<Options>>
                for OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<Options>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsOptional<u32>,
                    T2: ::planus::WriteAsOptional<u32>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::NumSctpStreams>,
                    >,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<Options>>
                for OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<Options>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Options>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsOptional<u32>,
                    T2: ::planus::WriteAsOptional<u32>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::NumSctpStreams>,
                    >,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<Options>
                for OptionsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    Options::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [Options].
            #[derive(Copy, Clone)]
            pub struct OptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> OptionsRef<'a> {
                /// Getter for the [`direct` field](Options#structfield.direct).
                #[inline]
                pub fn direct(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Options", "direct")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`max_message_size` field](Options#structfield.max_message_size).
                #[inline]
                pub fn max_message_size(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(1, "Options", "max_message_size")
                }

                /// Getter for the [`initial_available_outgoing_bitrate` field](Options#structfield.initial_available_outgoing_bitrate).
                #[inline]
                pub fn initial_available_outgoing_bitrate(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0
                        .access(2, "Options", "initial_available_outgoing_bitrate")
                }

                /// Getter for the [`enable_sctp` field](Options#structfield.enable_sctp).
                #[inline]
                pub fn enable_sctp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Options", "enable_sctp")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`num_sctp_streams` field](Options#structfield.num_sctp_streams).
                #[inline]
                pub fn num_sctp_streams(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::NumSctpStreamsRef<'a>>,
                > {
                    self.0.access(4, "Options", "num_sctp_streams")
                }

                /// Getter for the [`max_sctp_message_size` field](Options#structfield.max_sctp_message_size).
                #[inline]
                pub fn max_sctp_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "Options", "max_sctp_message_size")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`sctp_send_buffer_size` field](Options#structfield.sctp_send_buffer_size).
                #[inline]
                pub fn sctp_send_buffer_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "Options", "sctp_send_buffer_size")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`is_data_channel` field](Options#structfield.is_data_channel).
                #[inline]
                pub fn is_data_channel(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "Options", "is_data_channel")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for OptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("OptionsRef");
                    f.field("direct", &self.direct());
                    if let ::core::option::Option::Some(field_max_message_size) =
                        self.max_message_size().transpose()
                    {
                        f.field("max_message_size", &field_max_message_size);
                    }
                    if let ::core::option::Option::Some(field_initial_available_outgoing_bitrate) =
                        self.initial_available_outgoing_bitrate().transpose()
                    {
                        f.field(
                            "initial_available_outgoing_bitrate",
                            &field_initial_available_outgoing_bitrate,
                        );
                    }
                    f.field("enable_sctp", &self.enable_sctp());
                    if let ::core::option::Option::Some(field_num_sctp_streams) =
                        self.num_sctp_streams().transpose()
                    {
                        f.field("num_sctp_streams", &field_num_sctp_streams);
                    }
                    f.field("max_sctp_message_size", &self.max_sctp_message_size());
                    f.field("sctp_send_buffer_size", &self.sctp_send_buffer_size());
                    f.field("is_data_channel", &self.is_data_channel());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<OptionsRef<'a>> for Options {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: OptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        direct: ::core::convert::TryInto::try_into(value.direct()?)?,
                        max_message_size: if let ::core::option::Option::Some(max_message_size) =
                            value.max_message_size()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_message_size,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        initial_available_outgoing_bitrate: if let ::core::option::Option::Some(
                            initial_available_outgoing_bitrate,
                        ) =
                            value.initial_available_outgoing_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                initial_available_outgoing_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        enable_sctp: ::core::convert::TryInto::try_into(value.enable_sctp()?)?,
                        num_sctp_streams: if let ::core::option::Option::Some(num_sctp_streams) =
                            value.num_sctp_streams()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(num_sctp_streams)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        max_sctp_message_size: ::core::convert::TryInto::try_into(
                            value.max_sctp_message_size()?,
                        )?,
                        sctp_send_buffer_size: ::core::convert::TryInto::try_into(
                            value.sctp_send_buffer_size()?,
                        )?,
                        is_data_channel: ::core::convert::TryInto::try_into(
                            value.is_data_channel()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for OptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for OptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[OptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Options>> for Options {
                type Value = ::planus::Offset<Options>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Options>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for OptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[OptionsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `TraceEventType` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Enum `TraceEventType` in the file `../worker/fbs/transport.fbs:122`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceEventType {
                /// The variant `PROBATION` in the enum `TraceEventType`
                Probation = 0,

                /// The variant `BWE` in the enum `TraceEventType`
                Bwe = 1,
            }

            impl TraceEventType {
                /// Array containing all valid variants of TraceEventType
                pub const ENUM_VALUES: [Self; 2] = [Self::Probation, Self::Bwe];
            }

            impl ::core::convert::TryFrom<u8> for TraceEventType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceEventType::Probation),
                        1 => ::core::result::Result::Ok(TraceEventType::Bwe),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceEventType> for u8 {
                #[inline]
                fn from(value: TraceEventType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceEventType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceEventType> for TraceEventType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceEventType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceEventType, TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceEventType,
                ) -> ::core::option::Option<TraceEventType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceEventType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceEventType {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceEventType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceEventType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceEventType> for TraceEventType {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `Dump` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `Dump` in the file `../worker/fbs/transport.fbs:127`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Dump {
                /// The field `id` in the table `Dump`
                pub id: ::planus::alloc::string::String,
                /// The field `direct` in the table `Dump`
                pub direct: bool,
                /// The field `producer_ids` in the table `Dump`
                pub producer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `consumer_ids` in the table `Dump`
                pub consumer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `map_ssrc_consumer_id` in the table `Dump`
                pub map_ssrc_consumer_id: ::planus::alloc::vec::Vec<super::common::Uint32String>,
                /// The field `map_rtx_ssrc_consumer_id` in the table `Dump`
                pub map_rtx_ssrc_consumer_id:
                    ::planus::alloc::vec::Vec<super::common::Uint32String>,
                /// The field `data_producer_ids` in the table `Dump`
                pub data_producer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `data_consumer_ids` in the table `Dump`
                pub data_consumer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `recv_rtp_header_extensions` in the table `Dump`
                pub recv_rtp_header_extensions:
                    ::planus::alloc::boxed::Box<self::RecvRtpHeaderExtensions>,
                /// The field `rtp_listener` in the table `Dump`
                pub rtp_listener: ::planus::alloc::boxed::Box<self::RtpListener>,
                /// The field `max_message_size` in the table `Dump`
                pub max_message_size: u32,
                /// The field `sctp_parameters` in the table `Dump`
                pub sctp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpParameters>,
                >,
                /// The field `sctp_state` in the table `Dump`
                pub sctp_state: ::core::option::Option<super::sctp_association::SctpState>,
                /// The field `sctp_listener` in the table `Dump`
                pub sctp_listener:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::SctpListener>>,
                /// The field `trace_event_types` in the table `Dump`
                pub trace_event_types: ::planus::alloc::vec::Vec<self::TraceEventType>,
            }

            impl Dump {
                /// Creates a [DumpBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpBuilder<()> {
                    DumpBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_direct: impl ::planus::WriteAsDefault<bool, bool>,
                    field_producer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_consumer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_map_ssrc_consumer_id: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    field_map_rtx_ssrc_consumer_id: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    field_data_producer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_data_consumer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_recv_rtp_header_extensions: impl ::planus::WriteAs<
                        ::planus::Offset<self::RecvRtpHeaderExtensions>,
                    >,
                    field_rtp_listener: impl ::planus::WriteAs<::planus::Offset<self::RtpListener>>,
                    field_max_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_sctp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpParameters>,
                    >,
                    field_sctp_state: impl ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    field_sctp_listener: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::SctpListener>,
                    >,
                    field_trace_event_types: impl ::planus::WriteAs<
                        ::planus::Offset<[self::TraceEventType]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_direct = field_direct.prepare(builder, &false);
                    let prepared_producer_ids = field_producer_ids.prepare(builder);
                    let prepared_consumer_ids = field_consumer_ids.prepare(builder);
                    let prepared_map_ssrc_consumer_id = field_map_ssrc_consumer_id.prepare(builder);
                    let prepared_map_rtx_ssrc_consumer_id =
                        field_map_rtx_ssrc_consumer_id.prepare(builder);
                    let prepared_data_producer_ids = field_data_producer_ids.prepare(builder);
                    let prepared_data_consumer_ids = field_data_consumer_ids.prepare(builder);
                    let prepared_recv_rtp_header_extensions =
                        field_recv_rtp_header_extensions.prepare(builder);
                    let prepared_rtp_listener = field_rtp_listener.prepare(builder);
                    let prepared_max_message_size = field_max_message_size.prepare(builder, &0);
                    let prepared_sctp_parameters = field_sctp_parameters.prepare(builder);
                    let prepared_sctp_state = field_sctp_state.prepare(builder);
                    let prepared_sctp_listener = field_sctp_listener.prepare(builder);
                    let prepared_trace_event_types = field_trace_event_types.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<34> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(2);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(3);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::Uint32String>]>>(4);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::Uint32String>]>>(5);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(6);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(7);
                    table_writer.write_entry::<::planus::Offset<self::RecvRtpHeaderExtensions>>(8);
                    table_writer.write_entry::<::planus::Offset<self::RtpListener>>(9);
                    if prepared_max_message_size.is_some() {
                        table_writer.write_entry::<u32>(10);
                    }
                    if prepared_sctp_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::sctp_parameters::SctpParameters>>(11);
                    }
                    if prepared_sctp_listener.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::SctpListener>>(13);
                    }
                    table_writer.write_entry::<::planus::Offset<[self::TraceEventType]>>(14);
                    if prepared_direct.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }
                    if prepared_sctp_state.is_some() {
                        table_writer.write_entry::<super::sctp_association::SctpState>(12);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            object_writer.write::<_, _, 4>(&prepared_producer_ids);
                            object_writer.write::<_, _, 4>(&prepared_consumer_ids);
                            object_writer.write::<_, _, 4>(&prepared_map_ssrc_consumer_id);
                            object_writer.write::<_, _, 4>(&prepared_map_rtx_ssrc_consumer_id);
                            object_writer.write::<_, _, 4>(&prepared_data_producer_ids);
                            object_writer.write::<_, _, 4>(&prepared_data_consumer_ids);
                            object_writer.write::<_, _, 4>(&prepared_recv_rtp_header_extensions);
                            object_writer.write::<_, _, 4>(&prepared_rtp_listener);
                            if let ::core::option::Option::Some(prepared_max_message_size) =
                                prepared_max_message_size
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_message_size);
                            }
                            if let ::core::option::Option::Some(prepared_sctp_parameters) =
                                prepared_sctp_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_sctp_listener) =
                                prepared_sctp_listener
                            {
                                object_writer.write::<_, _, 4>(&prepared_sctp_listener);
                            }
                            object_writer.write::<_, _, 4>(&prepared_trace_event_types);
                            if let ::core::option::Option::Some(prepared_direct) = prepared_direct {
                                object_writer.write::<_, _, 1>(&prepared_direct);
                            }
                            if let ::core::option::Option::Some(prepared_sctp_state) =
                                prepared_sctp_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_sctp_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Dump> for Dump {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    Dump::create(
                        builder,
                        &self.id,
                        self.direct,
                        &self.producer_ids,
                        &self.consumer_ids,
                        &self.map_ssrc_consumer_id,
                        &self.map_rtx_ssrc_consumer_id,
                        &self.data_producer_ids,
                        &self.data_consumer_ids,
                        &self.recv_rtp_header_extensions,
                        &self.rtp_listener,
                        self.max_message_size,
                        &self.sctp_parameters,
                        self.sctp_state,
                        &self.sctp_listener,
                        &self.trace_event_types,
                    )
                }
            }

            /// Builder for serializing an instance of the [Dump] type.
            ///
            /// Can be created using the [Dump::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpBuilder<State>(State);

            impl DumpBuilder<()> {
                /// Setter for the [`id` field](Dump#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> DumpBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DumpBuilder((value,))
                }
            }

            impl<T0> DumpBuilder<(T0,)> {
                /// Setter for the [`direct` field](Dump#structfield.direct).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direct<T1>(self, value: T1) -> DumpBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    DumpBuilder((v0, value))
                }

                /// Sets the [`direct` field](Dump#structfield.direct) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direct_as_default(self) -> DumpBuilder<(T0, ::planus::DefaultValue)> {
                    self.direct(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpBuilder<(T0, T1)> {
                /// Setter for the [`producer_ids` field](Dump#structfield.producer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_ids<T2>(self, value: T2) -> DumpBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1) = self.0;
                    DumpBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> DumpBuilder<(T0, T1, T2)> {
                /// Setter for the [`consumer_ids` field](Dump#structfield.consumer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn consumer_ids<T3>(self, value: T3) -> DumpBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`map_ssrc_consumer_id` field](Dump#structfield.map_ssrc_consumer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_ssrc_consumer_id<T4>(
                    self,
                    value: T4,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DumpBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`map_rtx_ssrc_consumer_id` field](Dump#structfield.map_rtx_ssrc_consumer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_rtx_ssrc_consumer_id<T5>(
                    self,
                    value: T5,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`data_producer_ids` field](Dump#structfield.data_producer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_ids<T6>(
                    self,
                    value: T6,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`data_consumer_ids` field](Dump#structfield.data_consumer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_consumer_ids<T7>(
                    self,
                    value: T7,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`recv_rtp_header_extensions` field](Dump#structfield.recv_rtp_header_extensions).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn recv_rtp_header_extensions<T8>(
                    self,
                    value: T8,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAs<::planus::Offset<self::RecvRtpHeaderExtensions>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`rtp_listener` field](Dump#structfield.rtp_listener).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_listener<T9>(
                    self,
                    value: T9,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAs<::planus::Offset<self::RtpListener>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)> {
                /// Setter for the [`max_message_size` field](Dump#structfield.max_message_size).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_message_size<T10>(
                    self,
                    value: T10,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`max_message_size` field](Dump#structfield.max_message_size) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_message_size_as_default(
                    self,
                ) -> DumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.max_message_size(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`sctp_parameters` field](Dump#structfield.sctp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_parameters<T11>(
                    self,
                    value: T11,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpParameters>,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`sctp_parameters` field](Dump#structfield.sctp_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_parameters_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ())>
                {
                    self.sctp_parameters(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`sctp_state` field](Dump#structfield.sctp_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_state<T12>(
                    self,
                    value: T12,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`sctp_state` field](Dump#structfield.sctp_state) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_state_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ())>
                {
                    self.sctp_state(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`sctp_listener` field](Dump#structfield.sctp_listener).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_listener<T13>(
                    self,
                    value: T13,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
                where
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::SctpListener>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    DumpBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value))
                }

                /// Sets the [`sctp_listener` field](Dump#structfield.sctp_listener) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_listener_as_null(
                    self,
                ) -> DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ())>
                {
                    self.sctp_listener(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                DumpBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`trace_event_types` field](Dump#structfield.trace_event_types).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trace_event_types<T14>(
                    self,
                    value: T14,
                ) -> DumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    DumpBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                DumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Dump].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump>
                where
                    Self: ::planus::WriteAsOffset<Dump>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T8: ::planus::WriteAs<::planus::Offset<self::RecvRtpHeaderExtensions>>,
                    T9: ::planus::WriteAs<::planus::Offset<self::RtpListener>>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpParameters>,
                    >,
                    T12: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::SctpListener>>,
                    T14: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                > ::planus::WriteAs<::planus::Offset<Dump>>
                for DumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                type Prepared = ::planus::Offset<Dump>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T8: ::planus::WriteAs<::planus::Offset<self::RecvRtpHeaderExtensions>>,
                    T9: ::planus::WriteAs<::planus::Offset<self::RtpListener>>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpParameters>,
                    >,
                    T12: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::SctpListener>>,
                    T14: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                > ::planus::WriteAsOptional<::planus::Offset<Dump>>
                for DumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                type Prepared = ::planus::Offset<Dump>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T7: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T8: ::planus::WriteAs<::planus::Offset<self::RecvRtpHeaderExtensions>>,
                    T9: ::planus::WriteAs<::planus::Offset<self::RtpListener>>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpParameters>,
                    >,
                    T12: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::SctpListener>>,
                    T14: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                > ::planus::WriteAsOffset<Dump>
                for DumpBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = &self.0;
                    Dump::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                    )
                }
            }

            /// Reference to a deserialized [Dump].
            #[derive(Copy, Clone)]
            pub struct DumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpRef<'a> {
                /// Getter for the [`id` field](Dump#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Dump", "id")
                }

                /// Getter for the [`direct` field](Dump#structfield.direct).
                #[inline]
                pub fn direct(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(self.0.access(1, "Dump", "direct")?.unwrap_or(false))
                }

                /// Getter for the [`producer_ids` field](Dump#structfield.producer_ids).
                #[inline]
                pub fn producer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(2, "Dump", "producer_ids")
                }

                /// Getter for the [`consumer_ids` field](Dump#structfield.consumer_ids).
                #[inline]
                pub fn consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(3, "Dump", "consumer_ids")
                }

                /// Getter for the [`map_ssrc_consumer_id` field](Dump#structfield.map_ssrc_consumer_id).
                #[inline]
                pub fn map_ssrc_consumer_id(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint32StringRef<'a>>>,
                > {
                    self.0.access_required(4, "Dump", "map_ssrc_consumer_id")
                }

                /// Getter for the [`map_rtx_ssrc_consumer_id` field](Dump#structfield.map_rtx_ssrc_consumer_id).
                #[inline]
                pub fn map_rtx_ssrc_consumer_id(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint32StringRef<'a>>>,
                > {
                    self.0
                        .access_required(5, "Dump", "map_rtx_ssrc_consumer_id")
                }

                /// Getter for the [`data_producer_ids` field](Dump#structfield.data_producer_ids).
                #[inline]
                pub fn data_producer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(6, "Dump", "data_producer_ids")
                }

                /// Getter for the [`data_consumer_ids` field](Dump#structfield.data_consumer_ids).
                #[inline]
                pub fn data_consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(7, "Dump", "data_consumer_ids")
                }

                /// Getter for the [`recv_rtp_header_extensions` field](Dump#structfield.recv_rtp_header_extensions).
                #[inline]
                pub fn recv_rtp_header_extensions(
                    &self,
                ) -> ::planus::Result<self::RecvRtpHeaderExtensionsRef<'a>> {
                    self.0
                        .access_required(8, "Dump", "recv_rtp_header_extensions")
                }

                /// Getter for the [`rtp_listener` field](Dump#structfield.rtp_listener).
                #[inline]
                pub fn rtp_listener(&self) -> ::planus::Result<self::RtpListenerRef<'a>> {
                    self.0.access_required(9, "Dump", "rtp_listener")
                }

                /// Getter for the [`max_message_size` field](Dump#structfield.max_message_size).
                #[inline]
                pub fn max_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(10, "Dump", "max_message_size")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`sctp_parameters` field](Dump#structfield.sctp_parameters).
                #[inline]
                pub fn sctp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpParametersRef<'a>>,
                > {
                    self.0.access(11, "Dump", "sctp_parameters")
                }

                /// Getter for the [`sctp_state` field](Dump#structfield.sctp_state).
                #[inline]
                pub fn sctp_state(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::sctp_association::SctpState>>
                {
                    self.0.access(12, "Dump", "sctp_state")
                }

                /// Getter for the [`sctp_listener` field](Dump#structfield.sctp_listener).
                #[inline]
                pub fn sctp_listener(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::SctpListenerRef<'a>>>
                {
                    self.0.access(13, "Dump", "sctp_listener")
                }

                /// Getter for the [`trace_event_types` field](Dump#structfield.trace_event_types).
                #[inline]
                pub fn trace_event_types(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::core::result::Result<
                            self::TraceEventType,
                            ::planus::errors::UnknownEnumTag,
                        >,
                    >,
                > {
                    self.0.access_required(14, "Dump", "trace_event_types")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpRef");
                    f.field("id", &self.id());
                    f.field("direct", &self.direct());
                    f.field("producer_ids", &self.producer_ids());
                    f.field("consumer_ids", &self.consumer_ids());
                    f.field("map_ssrc_consumer_id", &self.map_ssrc_consumer_id());
                    f.field("map_rtx_ssrc_consumer_id", &self.map_rtx_ssrc_consumer_id());
                    f.field("data_producer_ids", &self.data_producer_ids());
                    f.field("data_consumer_ids", &self.data_consumer_ids());
                    f.field(
                        "recv_rtp_header_extensions",
                        &self.recv_rtp_header_extensions(),
                    );
                    f.field("rtp_listener", &self.rtp_listener());
                    f.field("max_message_size", &self.max_message_size());
                    if let ::core::option::Option::Some(field_sctp_parameters) =
                        self.sctp_parameters().transpose()
                    {
                        f.field("sctp_parameters", &field_sctp_parameters);
                    }
                    if let ::core::option::Option::Some(field_sctp_state) =
                        self.sctp_state().transpose()
                    {
                        f.field("sctp_state", &field_sctp_state);
                    }
                    if let ::core::option::Option::Some(field_sctp_listener) =
                        self.sctp_listener().transpose()
                    {
                        f.field("sctp_listener", &field_sctp_listener);
                    }
                    f.field("trace_event_types", &self.trace_event_types());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpRef<'a>> for Dump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        direct: ::core::convert::TryInto::try_into(value.direct()?)?,
                        producer_ids: value.producer_ids()?.to_vec_result()?,
                        consumer_ids: value.consumer_ids()?.to_vec_result()?,
                        map_ssrc_consumer_id: value.map_ssrc_consumer_id()?.to_vec_result()?,
                        map_rtx_ssrc_consumer_id: value
                            .map_rtx_ssrc_consumer_id()?
                            .to_vec_result()?,
                        data_producer_ids: value.data_producer_ids()?.to_vec_result()?,
                        data_consumer_ids: value.data_consumer_ids()?.to_vec_result()?,
                        recv_rtp_header_extensions: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(
                                value.recv_rtp_header_extensions()?,
                            )?,
                        ),
                        rtp_listener: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_listener()?)?,
                        ),
                        max_message_size: ::core::convert::TryInto::try_into(
                            value.max_message_size()?,
                        )?,
                        sctp_parameters: if let ::core::option::Option::Some(sctp_parameters) =
                            value.sctp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        sctp_state: if let ::core::option::Option::Some(sctp_state) =
                            value.sctp_state()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                sctp_state,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        sctp_listener: if let ::core::option::Option::Some(sctp_listener) =
                            value.sctp_listener()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_listener)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        trace_event_types: value.trace_event_types()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Dump>> for Dump {
                type Value = ::planus::Offset<Dump>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Dump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Stats` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `Stats` in the file `../worker/fbs/transport.fbs:145`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Stats {
                /// The field `transport_id` in the table `Stats`
                pub transport_id: ::planus::alloc::string::String,
                /// The field `timestamp` in the table `Stats`
                pub timestamp: u64,
                /// The field `sctp_state` in the table `Stats`
                pub sctp_state: ::core::option::Option<super::sctp_association::SctpState>,
                /// The field `bytes_received` in the table `Stats`
                pub bytes_received: u64,
                /// The field `recv_bitrate` in the table `Stats`
                pub recv_bitrate: u32,
                /// The field `bytes_sent` in the table `Stats`
                pub bytes_sent: u64,
                /// The field `send_bitrate` in the table `Stats`
                pub send_bitrate: u32,
                /// The field `rtp_bytes_received` in the table `Stats`
                pub rtp_bytes_received: u64,
                /// The field `rtp_recv_bitrate` in the table `Stats`
                pub rtp_recv_bitrate: u32,
                /// The field `rtp_bytes_sent` in the table `Stats`
                pub rtp_bytes_sent: u64,
                /// The field `rtp_send_bitrate` in the table `Stats`
                pub rtp_send_bitrate: u32,
                /// The field `rtx_bytes_received` in the table `Stats`
                pub rtx_bytes_received: u64,
                /// The field `rtx_recv_bitrate` in the table `Stats`
                pub rtx_recv_bitrate: u32,
                /// The field `rtx_bytes_sent` in the table `Stats`
                pub rtx_bytes_sent: u64,
                /// The field `rtx_send_bitrate` in the table `Stats`
                pub rtx_send_bitrate: u32,
                /// The field `probation_bytes_sent` in the table `Stats`
                pub probation_bytes_sent: u64,
                /// The field `probation_send_bitrate` in the table `Stats`
                pub probation_send_bitrate: u32,
                /// The field `available_outgoing_bitrate` in the table `Stats`
                pub available_outgoing_bitrate: ::core::option::Option<u32>,
                /// The field `available_incoming_bitrate` in the table `Stats`
                pub available_incoming_bitrate: ::core::option::Option<u32>,
                /// The field `max_incoming_bitrate` in the table `Stats`
                pub max_incoming_bitrate: ::core::option::Option<u32>,
                /// The field `max_outgoing_bitrate` in the table `Stats`
                pub max_outgoing_bitrate: ::core::option::Option<u32>,
                /// The field `min_outgoing_bitrate` in the table `Stats`
                pub min_outgoing_bitrate: ::core::option::Option<u32>,
                /// The field `rtp_packet_loss_received` in the table `Stats`
                pub rtp_packet_loss_received: ::core::option::Option<f64>,
                /// The field `rtp_packet_loss_sent` in the table `Stats`
                pub rtp_packet_loss_sent: ::core::option::Option<f64>,
            }

            impl Stats {
                /// Creates a [StatsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StatsBuilder<()> {
                    StatsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_sctp_state: impl ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    field_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_recv_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_send_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rtp_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_recv_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rtp_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_send_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rtx_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtx_recv_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rtx_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtx_send_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_probation_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_probation_send_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_available_outgoing_bitrate: impl ::planus::WriteAsOptional<u32>,
                    field_available_incoming_bitrate: impl ::planus::WriteAsOptional<u32>,
                    field_max_incoming_bitrate: impl ::planus::WriteAsOptional<u32>,
                    field_max_outgoing_bitrate: impl ::planus::WriteAsOptional<u32>,
                    field_min_outgoing_bitrate: impl ::planus::WriteAsOptional<u32>,
                    field_rtp_packet_loss_received: impl ::planus::WriteAsOptional<f64>,
                    field_rtp_packet_loss_sent: impl ::planus::WriteAsOptional<f64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_sctp_state = field_sctp_state.prepare(builder);
                    let prepared_bytes_received = field_bytes_received.prepare(builder, &0);
                    let prepared_recv_bitrate = field_recv_bitrate.prepare(builder, &0);
                    let prepared_bytes_sent = field_bytes_sent.prepare(builder, &0);
                    let prepared_send_bitrate = field_send_bitrate.prepare(builder, &0);
                    let prepared_rtp_bytes_received = field_rtp_bytes_received.prepare(builder, &0);
                    let prepared_rtp_recv_bitrate = field_rtp_recv_bitrate.prepare(builder, &0);
                    let prepared_rtp_bytes_sent = field_rtp_bytes_sent.prepare(builder, &0);
                    let prepared_rtp_send_bitrate = field_rtp_send_bitrate.prepare(builder, &0);
                    let prepared_rtx_bytes_received = field_rtx_bytes_received.prepare(builder, &0);
                    let prepared_rtx_recv_bitrate = field_rtx_recv_bitrate.prepare(builder, &0);
                    let prepared_rtx_bytes_sent = field_rtx_bytes_sent.prepare(builder, &0);
                    let prepared_rtx_send_bitrate = field_rtx_send_bitrate.prepare(builder, &0);
                    let prepared_probation_bytes_sent =
                        field_probation_bytes_sent.prepare(builder, &0);
                    let prepared_probation_send_bitrate =
                        field_probation_send_bitrate.prepare(builder, &0);
                    let prepared_available_outgoing_bitrate =
                        field_available_outgoing_bitrate.prepare(builder);
                    let prepared_available_incoming_bitrate =
                        field_available_incoming_bitrate.prepare(builder);
                    let prepared_max_incoming_bitrate = field_max_incoming_bitrate.prepare(builder);
                    let prepared_max_outgoing_bitrate = field_max_outgoing_bitrate.prepare(builder);
                    let prepared_min_outgoing_bitrate = field_min_outgoing_bitrate.prepare(builder);
                    let prepared_rtp_packet_loss_received =
                        field_rtp_packet_loss_received.prepare(builder);
                    let prepared_rtp_packet_loss_sent = field_rtp_packet_loss_sent.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<52> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(1);
                    }
                    if prepared_bytes_received.is_some() {
                        table_writer.write_entry::<u64>(3);
                    }
                    if prepared_bytes_sent.is_some() {
                        table_writer.write_entry::<u64>(5);
                    }
                    if prepared_rtp_bytes_received.is_some() {
                        table_writer.write_entry::<u64>(7);
                    }
                    if prepared_rtp_bytes_sent.is_some() {
                        table_writer.write_entry::<u64>(9);
                    }
                    if prepared_rtx_bytes_received.is_some() {
                        table_writer.write_entry::<u64>(11);
                    }
                    if prepared_rtx_bytes_sent.is_some() {
                        table_writer.write_entry::<u64>(13);
                    }
                    if prepared_probation_bytes_sent.is_some() {
                        table_writer.write_entry::<u64>(15);
                    }
                    if prepared_rtp_packet_loss_received.is_some() {
                        table_writer.write_entry::<f64>(22);
                    }
                    if prepared_rtp_packet_loss_sent.is_some() {
                        table_writer.write_entry::<f64>(23);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_recv_bitrate.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_send_bitrate.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    if prepared_rtp_recv_bitrate.is_some() {
                        table_writer.write_entry::<u32>(8);
                    }
                    if prepared_rtp_send_bitrate.is_some() {
                        table_writer.write_entry::<u32>(10);
                    }
                    if prepared_rtx_recv_bitrate.is_some() {
                        table_writer.write_entry::<u32>(12);
                    }
                    if prepared_rtx_send_bitrate.is_some() {
                        table_writer.write_entry::<u32>(14);
                    }
                    if prepared_probation_send_bitrate.is_some() {
                        table_writer.write_entry::<u32>(16);
                    }
                    if prepared_available_outgoing_bitrate.is_some() {
                        table_writer.write_entry::<u32>(17);
                    }
                    if prepared_available_incoming_bitrate.is_some() {
                        table_writer.write_entry::<u32>(18);
                    }
                    if prepared_max_incoming_bitrate.is_some() {
                        table_writer.write_entry::<u32>(19);
                    }
                    if prepared_max_outgoing_bitrate.is_some() {
                        table_writer.write_entry::<u32>(20);
                    }
                    if prepared_min_outgoing_bitrate.is_some() {
                        table_writer.write_entry::<u32>(21);
                    }
                    if prepared_sctp_state.is_some() {
                        table_writer.write_entry::<super::sctp_association::SctpState>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_bytes_received) =
                                prepared_bytes_received
                            {
                                object_writer.write::<_, _, 8>(&prepared_bytes_received);
                            }
                            if let ::core::option::Option::Some(prepared_bytes_sent) =
                                prepared_bytes_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_bytes_sent);
                            }
                            if let ::core::option::Option::Some(prepared_rtp_bytes_received) =
                                prepared_rtp_bytes_received
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtp_bytes_received);
                            }
                            if let ::core::option::Option::Some(prepared_rtp_bytes_sent) =
                                prepared_rtp_bytes_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtp_bytes_sent);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_bytes_received) =
                                prepared_rtx_bytes_received
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtx_bytes_received);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_bytes_sent) =
                                prepared_rtx_bytes_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtx_bytes_sent);
                            }
                            if let ::core::option::Option::Some(prepared_probation_bytes_sent) =
                                prepared_probation_bytes_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_probation_bytes_sent);
                            }
                            if let ::core::option::Option::Some(prepared_rtp_packet_loss_received) =
                                prepared_rtp_packet_loss_received
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtp_packet_loss_received);
                            }
                            if let ::core::option::Option::Some(prepared_rtp_packet_loss_sent) =
                                prepared_rtp_packet_loss_sent
                            {
                                object_writer.write::<_, _, 8>(&prepared_rtp_packet_loss_sent);
                            }
                            object_writer.write::<_, _, 4>(&prepared_transport_id);
                            if let ::core::option::Option::Some(prepared_recv_bitrate) =
                                prepared_recv_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_recv_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_send_bitrate) =
                                prepared_send_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_send_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_rtp_recv_bitrate) =
                                prepared_rtp_recv_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtp_recv_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_rtp_send_bitrate) =
                                prepared_rtp_send_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtp_send_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_recv_bitrate) =
                                prepared_rtx_recv_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtx_recv_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_rtx_send_bitrate) =
                                prepared_rtx_send_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtx_send_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_probation_send_bitrate) =
                                prepared_probation_send_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_probation_send_bitrate);
                            }
                            if let ::core::option::Option::Some(
                                prepared_available_outgoing_bitrate,
                            ) = prepared_available_outgoing_bitrate
                            {
                                object_writer
                                    .write::<_, _, 4>(&prepared_available_outgoing_bitrate);
                            }
                            if let ::core::option::Option::Some(
                                prepared_available_incoming_bitrate,
                            ) = prepared_available_incoming_bitrate
                            {
                                object_writer
                                    .write::<_, _, 4>(&prepared_available_incoming_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_max_incoming_bitrate) =
                                prepared_max_incoming_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_incoming_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_max_outgoing_bitrate) =
                                prepared_max_outgoing_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_outgoing_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_min_outgoing_bitrate) =
                                prepared_min_outgoing_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_min_outgoing_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_sctp_state) =
                                prepared_sctp_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_sctp_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Stats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Stats> for Stats {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    Stats::create(
                        builder,
                        &self.transport_id,
                        self.timestamp,
                        self.sctp_state,
                        self.bytes_received,
                        self.recv_bitrate,
                        self.bytes_sent,
                        self.send_bitrate,
                        self.rtp_bytes_received,
                        self.rtp_recv_bitrate,
                        self.rtp_bytes_sent,
                        self.rtp_send_bitrate,
                        self.rtx_bytes_received,
                        self.rtx_recv_bitrate,
                        self.rtx_bytes_sent,
                        self.rtx_send_bitrate,
                        self.probation_bytes_sent,
                        self.probation_send_bitrate,
                        self.available_outgoing_bitrate,
                        self.available_incoming_bitrate,
                        self.max_incoming_bitrate,
                        self.max_outgoing_bitrate,
                        self.min_outgoing_bitrate,
                        self.rtp_packet_loss_received,
                        self.rtp_packet_loss_sent,
                    )
                }
            }

            /// Builder for serializing an instance of the [Stats] type.
            ///
            /// Can be created using the [Stats::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StatsBuilder<State>(State);

            impl StatsBuilder<()> {
                /// Setter for the [`transport_id` field](Stats#structfield.transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_id<T0>(self, value: T0) -> StatsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StatsBuilder((value,))
                }
            }

            impl<T0> StatsBuilder<(T0,)> {
                /// Setter for the [`timestamp` field](Stats#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T1>(self, value: T1) -> StatsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0,) = self.0;
                    StatsBuilder((v0, value))
                }

                /// Sets the [`timestamp` field](Stats#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(self) -> StatsBuilder<(T0, ::planus::DefaultValue)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0, T1> StatsBuilder<(T0, T1)> {
                /// Setter for the [`sctp_state` field](Stats#structfield.sctp_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_state<T2>(self, value: T2) -> StatsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                {
                    let (v0, v1) = self.0;
                    StatsBuilder((v0, v1, value))
                }

                /// Sets the [`sctp_state` field](Stats#structfield.sctp_state) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_state_as_null(self) -> StatsBuilder<(T0, T1, ())> {
                    self.sctp_state(())
                }
            }

            impl<T0, T1, T2> StatsBuilder<(T0, T1, T2)> {
                /// Setter for the [`bytes_received` field](Stats#structfield.bytes_received).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_received<T3>(self, value: T3) -> StatsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2) = self.0;
                    StatsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`bytes_received` field](Stats#structfield.bytes_received) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_received_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.bytes_received(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> StatsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`recv_bitrate` field](Stats#structfield.recv_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn recv_bitrate<T4>(self, value: T4) -> StatsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    StatsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`recv_bitrate` field](Stats#structfield.recv_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn recv_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.recv_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> StatsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`bytes_sent` field](Stats#structfield.bytes_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_sent<T5>(self, value: T5) -> StatsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`bytes_sent` field](Stats#structfield.bytes_sent) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bytes_sent_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                    self.bytes_sent(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> StatsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`send_bitrate` field](Stats#structfield.send_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn send_bitrate<T6>(
                    self,
                    value: T6,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`send_bitrate` field](Stats#structfield.send_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn send_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.send_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`rtp_bytes_received` field](Stats#structfield.rtp_bytes_received).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_bytes_received<T7>(
                    self,
                    value: T7,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`rtp_bytes_received` field](Stats#structfield.rtp_bytes_received) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_bytes_received_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.rtp_bytes_received(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`rtp_recv_bitrate` field](Stats#structfield.rtp_recv_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_recv_bitrate<T8>(
                    self,
                    value: T8,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`rtp_recv_bitrate` field](Stats#structfield.rtp_recv_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_recv_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.rtp_recv_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`rtp_bytes_sent` field](Stats#structfield.rtp_bytes_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_bytes_sent<T9>(
                    self,
                    value: T9,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`rtp_bytes_sent` field](Stats#structfield.rtp_bytes_sent) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_bytes_sent_as_default(
                    self,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ::planus::DefaultValue)>
                {
                    self.rtp_bytes_sent(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`rtp_send_bitrate` field](Stats#structfield.rtp_send_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_send_bitrate<T10>(
                    self,
                    value: T10,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`rtp_send_bitrate` field](Stats#structfield.rtp_send_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_send_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.rtp_send_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`rtx_bytes_received` field](Stats#structfield.rtx_bytes_received).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_bytes_received<T11>(
                    self,
                    value: T11,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`rtx_bytes_received` field](Stats#structfield.rtx_bytes_received) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_bytes_received_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.rtx_bytes_received(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`rtx_recv_bitrate` field](Stats#structfield.rtx_recv_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_recv_bitrate<T12>(
                    self,
                    value: T12,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`rtx_recv_bitrate` field](Stats#structfield.rtx_recv_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_recv_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.rtx_recv_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`rtx_bytes_sent` field](Stats#structfield.rtx_bytes_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_bytes_sent<T13>(
                    self,
                    value: T13,
                ) -> StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
                where
                    T13: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    StatsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value))
                }

                /// Sets the [`rtx_bytes_sent` field](Stats#structfield.rtx_bytes_sent) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_bytes_sent_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.rtx_bytes_sent(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                StatsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`rtx_send_bitrate` field](Stats#structfield.rtx_send_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_send_bitrate<T14>(
                    self,
                    value: T14,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`rtx_send_bitrate` field](Stats#structfield.rtx_send_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_send_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    ::planus::DefaultValue,
                )> {
                    self.rtx_send_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`probation_bytes_sent` field](Stats#structfield.probation_bytes_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn probation_bytes_sent<T15>(
                    self,
                    value: T15,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }

                /// Sets the [`probation_bytes_sent` field](Stats#structfield.probation_bytes_sent) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn probation_bytes_sent_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    ::planus::DefaultValue,
                )> {
                    self.probation_bytes_sent(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Setter for the [`probation_send_bitrate` field](Stats#structfield.probation_send_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn probation_send_bitrate<T16>(
                    self,
                    value: T16,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
                where
                    T16: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, value,
                    ))
                }

                /// Sets the [`probation_send_bitrate` field](Stats#structfield.probation_send_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn probation_send_bitrate_as_default(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    ::planus::DefaultValue,
                )> {
                    self.probation_send_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
            {
                /// Setter for the [`available_outgoing_bitrate` field](Stats#structfield.available_outgoing_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn available_outgoing_bitrate<T17>(
                    self,
                    value: T17,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
                where
                    T17: ::planus::WriteAsOptional<u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) =
                        self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        value,
                    ))
                }

                /// Sets the [`available_outgoing_bitrate` field](Stats#structfield.available_outgoing_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn available_outgoing_bitrate_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    (),
                )> {
                    self.available_outgoing_bitrate(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                /// Setter for the [`available_incoming_bitrate` field](Stats#structfield.available_incoming_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn available_incoming_bitrate<T18>(
                    self,
                    value: T18,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                )>
                where
                    T18: ::planus::WriteAsOptional<u32>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                    ) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, value,
                    ))
                }

                /// Sets the [`available_incoming_bitrate` field](Stats#structfield.available_incoming_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn available_incoming_bitrate_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    (),
                )> {
                    self.available_incoming_bitrate(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                )>
            {
                /// Setter for the [`max_incoming_bitrate` field](Stats#structfield.max_incoming_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_incoming_bitrate<T19>(
                    self,
                    value: T19,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
                where
                    T19: ::planus::WriteAsOptional<u32>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                    ) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, value,
                    ))
                }

                /// Sets the [`max_incoming_bitrate` field](Stats#structfield.max_incoming_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_incoming_bitrate_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    (),
                )> {
                    self.max_incoming_bitrate(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
            {
                /// Setter for the [`max_outgoing_bitrate` field](Stats#structfield.max_outgoing_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_outgoing_bitrate<T20>(
                    self,
                    value: T20,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                )>
                where
                    T20: ::planus::WriteAsOptional<u32>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                    ) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, v19, value,
                    ))
                }

                /// Sets the [`max_outgoing_bitrate` field](Stats#structfield.max_outgoing_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_outgoing_bitrate_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    (),
                )> {
                    self.max_outgoing_bitrate(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                )>
            {
                /// Setter for the [`min_outgoing_bitrate` field](Stats#structfield.min_outgoing_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn min_outgoing_bitrate<T21>(
                    self,
                    value: T21,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
                where
                    T21: ::planus::WriteAsOptional<u32>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20,
                    ) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, v19, v20, value,
                    ))
                }

                /// Sets the [`min_outgoing_bitrate` field](Stats#structfield.min_outgoing_bitrate) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn min_outgoing_bitrate_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    (),
                )> {
                    self.min_outgoing_bitrate(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
            {
                /// Setter for the [`rtp_packet_loss_received` field](Stats#structfield.rtp_packet_loss_received).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet_loss_received<T22>(
                    self,
                    value: T22,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                )>
                where
                    T22: ::planus::WriteAsOptional<f64>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20,
                        v21,
                    ) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, v19, v20, v21, value,
                    ))
                }

                /// Sets the [`rtp_packet_loss_received` field](Stats#structfield.rtp_packet_loss_received) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet_loss_received_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    (),
                )> {
                    self.rtp_packet_loss_received(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                )>
            {
                /// Setter for the [`rtp_packet_loss_sent` field](Stats#structfield.rtp_packet_loss_sent).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet_loss_sent<T23>(
                    self,
                    value: T23,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    T23,
                )>
                where
                    T23: ::planus::WriteAsOptional<f64>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20,
                        v21,
                        v22,
                    ) = self.0;
                    StatsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, v19, v20, v21, v22, value,
                    ))
                }

                /// Sets the [`rtp_packet_loss_sent` field](Stats#structfield.rtp_packet_loss_sent) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet_loss_sent_as_null(
                    self,
                ) -> StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    (),
                )> {
                    self.rtp_packet_loss_sent(())
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    T23,
                >
                StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    T23,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Stats].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats>
                where
                    Self: ::planus::WriteAsOffset<Stats>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u64, u64>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u32, u32>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsDefault<u64, u64>,
                    T14: ::planus::WriteAsDefault<u32, u32>,
                    T15: ::planus::WriteAsDefault<u64, u64>,
                    T16: ::planus::WriteAsDefault<u32, u32>,
                    T17: ::planus::WriteAsOptional<u32>,
                    T18: ::planus::WriteAsOptional<u32>,
                    T19: ::planus::WriteAsOptional<u32>,
                    T20: ::planus::WriteAsOptional<u32>,
                    T21: ::planus::WriteAsOptional<u32>,
                    T22: ::planus::WriteAsOptional<f64>,
                    T23: ::planus::WriteAsOptional<f64>,
                > ::planus::WriteAs<::planus::Offset<Stats>>
                for StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    T23,
                )>
            {
                type Prepared = ::planus::Offset<Stats>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u64, u64>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u32, u32>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsDefault<u64, u64>,
                    T14: ::planus::WriteAsDefault<u32, u32>,
                    T15: ::planus::WriteAsDefault<u64, u64>,
                    T16: ::planus::WriteAsDefault<u32, u32>,
                    T17: ::planus::WriteAsOptional<u32>,
                    T18: ::planus::WriteAsOptional<u32>,
                    T19: ::planus::WriteAsOptional<u32>,
                    T20: ::planus::WriteAsOptional<u32>,
                    T21: ::planus::WriteAsOptional<u32>,
                    T22: ::planus::WriteAsOptional<f64>,
                    T23: ::planus::WriteAsOptional<f64>,
                > ::planus::WriteAsOptional<::planus::Offset<Stats>>
                for StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    T23,
                )>
            {
                type Prepared = ::planus::Offset<Stats>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Stats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsOptional<super::sctp_association::SctpState>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u64, u64>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u32, u32>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsDefault<u64, u64>,
                    T14: ::planus::WriteAsDefault<u32, u32>,
                    T15: ::planus::WriteAsDefault<u64, u64>,
                    T16: ::planus::WriteAsDefault<u32, u32>,
                    T17: ::planus::WriteAsOptional<u32>,
                    T18: ::planus::WriteAsOptional<u32>,
                    T19: ::planus::WriteAsOptional<u32>,
                    T20: ::planus::WriteAsOptional<u32>,
                    T21: ::planus::WriteAsOptional<u32>,
                    T22: ::planus::WriteAsOptional<f64>,
                    T23: ::planus::WriteAsOptional<f64>,
                > ::planus::WriteAsOffset<Stats>
                for StatsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                    T22,
                    T23,
                )>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20,
                        v21,
                        v22,
                        v23,
                    ) = &self.0;
                    Stats::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15, v16, v17, v18, v19, v20, v21, v22, v23,
                    )
                }
            }

            /// Reference to a deserialized [Stats].
            #[derive(Copy, Clone)]
            pub struct StatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StatsRef<'a> {
                /// Getter for the [`transport_id` field](Stats#structfield.transport_id).
                #[inline]
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Stats", "transport_id")
                }

                /// Getter for the [`timestamp` field](Stats#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(self.0.access(1, "Stats", "timestamp")?.unwrap_or(0))
                }

                /// Getter for the [`sctp_state` field](Stats#structfield.sctp_state).
                #[inline]
                pub fn sctp_state(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::sctp_association::SctpState>>
                {
                    self.0.access(2, "Stats", "sctp_state")
                }

                /// Getter for the [`bytes_received` field](Stats#structfield.bytes_received).
                #[inline]
                pub fn bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Stats", "bytes_received")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`recv_bitrate` field](Stats#structfield.recv_bitrate).
                #[inline]
                pub fn recv_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "Stats", "recv_bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`bytes_sent` field](Stats#structfield.bytes_sent).
                #[inline]
                pub fn bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "Stats", "bytes_sent")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`send_bitrate` field](Stats#structfield.send_bitrate).
                #[inline]
                pub fn send_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(6, "Stats", "send_bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rtp_bytes_received` field](Stats#structfield.rtp_bytes_received).
                #[inline]
                pub fn rtp_bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "Stats", "rtp_bytes_received")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`rtp_recv_bitrate` field](Stats#structfield.rtp_recv_bitrate).
                #[inline]
                pub fn rtp_recv_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(8, "Stats", "rtp_recv_bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rtp_bytes_sent` field](Stats#structfield.rtp_bytes_sent).
                #[inline]
                pub fn rtp_bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "Stats", "rtp_bytes_sent")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rtp_send_bitrate` field](Stats#structfield.rtp_send_bitrate).
                #[inline]
                pub fn rtp_send_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(10, "Stats", "rtp_send_bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rtx_bytes_received` field](Stats#structfield.rtx_bytes_received).
                #[inline]
                pub fn rtx_bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "Stats", "rtx_bytes_received")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`rtx_recv_bitrate` field](Stats#structfield.rtx_recv_bitrate).
                #[inline]
                pub fn rtx_recv_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(12, "Stats", "rtx_recv_bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rtx_bytes_sent` field](Stats#structfield.rtx_bytes_sent).
                #[inline]
                pub fn rtx_bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "Stats", "rtx_bytes_sent")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`rtx_send_bitrate` field](Stats#structfield.rtx_send_bitrate).
                #[inline]
                pub fn rtx_send_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(14, "Stats", "rtx_send_bitrate")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`probation_bytes_sent` field](Stats#structfield.probation_bytes_sent).
                #[inline]
                pub fn probation_bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(15, "Stats", "probation_bytes_sent")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`probation_send_bitrate` field](Stats#structfield.probation_send_bitrate).
                #[inline]
                pub fn probation_send_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(16, "Stats", "probation_send_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`available_outgoing_bitrate` field](Stats#structfield.available_outgoing_bitrate).
                #[inline]
                pub fn available_outgoing_bitrate(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(17, "Stats", "available_outgoing_bitrate")
                }

                /// Getter for the [`available_incoming_bitrate` field](Stats#structfield.available_incoming_bitrate).
                #[inline]
                pub fn available_incoming_bitrate(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(18, "Stats", "available_incoming_bitrate")
                }

                /// Getter for the [`max_incoming_bitrate` field](Stats#structfield.max_incoming_bitrate).
                #[inline]
                pub fn max_incoming_bitrate(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(19, "Stats", "max_incoming_bitrate")
                }

                /// Getter for the [`max_outgoing_bitrate` field](Stats#structfield.max_outgoing_bitrate).
                #[inline]
                pub fn max_outgoing_bitrate(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(20, "Stats", "max_outgoing_bitrate")
                }

                /// Getter for the [`min_outgoing_bitrate` field](Stats#structfield.min_outgoing_bitrate).
                #[inline]
                pub fn min_outgoing_bitrate(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(21, "Stats", "min_outgoing_bitrate")
                }

                /// Getter for the [`rtp_packet_loss_received` field](Stats#structfield.rtp_packet_loss_received).
                #[inline]
                pub fn rtp_packet_loss_received(
                    &self,
                ) -> ::planus::Result<::core::option::Option<f64>> {
                    self.0.access(22, "Stats", "rtp_packet_loss_received")
                }

                /// Getter for the [`rtp_packet_loss_sent` field](Stats#structfield.rtp_packet_loss_sent).
                #[inline]
                pub fn rtp_packet_loss_sent(
                    &self,
                ) -> ::planus::Result<::core::option::Option<f64>> {
                    self.0.access(23, "Stats", "rtp_packet_loss_sent")
                }
            }

            impl<'a> ::core::fmt::Debug for StatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StatsRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("timestamp", &self.timestamp());
                    if let ::core::option::Option::Some(field_sctp_state) =
                        self.sctp_state().transpose()
                    {
                        f.field("sctp_state", &field_sctp_state);
                    }
                    f.field("bytes_received", &self.bytes_received());
                    f.field("recv_bitrate", &self.recv_bitrate());
                    f.field("bytes_sent", &self.bytes_sent());
                    f.field("send_bitrate", &self.send_bitrate());
                    f.field("rtp_bytes_received", &self.rtp_bytes_received());
                    f.field("rtp_recv_bitrate", &self.rtp_recv_bitrate());
                    f.field("rtp_bytes_sent", &self.rtp_bytes_sent());
                    f.field("rtp_send_bitrate", &self.rtp_send_bitrate());
                    f.field("rtx_bytes_received", &self.rtx_bytes_received());
                    f.field("rtx_recv_bitrate", &self.rtx_recv_bitrate());
                    f.field("rtx_bytes_sent", &self.rtx_bytes_sent());
                    f.field("rtx_send_bitrate", &self.rtx_send_bitrate());
                    f.field("probation_bytes_sent", &self.probation_bytes_sent());
                    f.field("probation_send_bitrate", &self.probation_send_bitrate());
                    if let ::core::option::Option::Some(field_available_outgoing_bitrate) =
                        self.available_outgoing_bitrate().transpose()
                    {
                        f.field(
                            "available_outgoing_bitrate",
                            &field_available_outgoing_bitrate,
                        );
                    }
                    if let ::core::option::Option::Some(field_available_incoming_bitrate) =
                        self.available_incoming_bitrate().transpose()
                    {
                        f.field(
                            "available_incoming_bitrate",
                            &field_available_incoming_bitrate,
                        );
                    }
                    if let ::core::option::Option::Some(field_max_incoming_bitrate) =
                        self.max_incoming_bitrate().transpose()
                    {
                        f.field("max_incoming_bitrate", &field_max_incoming_bitrate);
                    }
                    if let ::core::option::Option::Some(field_max_outgoing_bitrate) =
                        self.max_outgoing_bitrate().transpose()
                    {
                        f.field("max_outgoing_bitrate", &field_max_outgoing_bitrate);
                    }
                    if let ::core::option::Option::Some(field_min_outgoing_bitrate) =
                        self.min_outgoing_bitrate().transpose()
                    {
                        f.field("min_outgoing_bitrate", &field_min_outgoing_bitrate);
                    }
                    if let ::core::option::Option::Some(field_rtp_packet_loss_received) =
                        self.rtp_packet_loss_received().transpose()
                    {
                        f.field("rtp_packet_loss_received", &field_rtp_packet_loss_received);
                    }
                    if let ::core::option::Option::Some(field_rtp_packet_loss_sent) =
                        self.rtp_packet_loss_sent().transpose()
                    {
                        f.field("rtp_packet_loss_sent", &field_rtp_packet_loss_sent);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StatsRef<'a>> for Stats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        sctp_state: if let ::core::option::Option::Some(sctp_state) =
                            value.sctp_state()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                sctp_state,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        bytes_received: ::core::convert::TryInto::try_into(
                            value.bytes_received()?,
                        )?,
                        recv_bitrate: ::core::convert::TryInto::try_into(value.recv_bitrate()?)?,
                        bytes_sent: ::core::convert::TryInto::try_into(value.bytes_sent()?)?,
                        send_bitrate: ::core::convert::TryInto::try_into(value.send_bitrate()?)?,
                        rtp_bytes_received: ::core::convert::TryInto::try_into(
                            value.rtp_bytes_received()?,
                        )?,
                        rtp_recv_bitrate: ::core::convert::TryInto::try_into(
                            value.rtp_recv_bitrate()?,
                        )?,
                        rtp_bytes_sent: ::core::convert::TryInto::try_into(
                            value.rtp_bytes_sent()?,
                        )?,
                        rtp_send_bitrate: ::core::convert::TryInto::try_into(
                            value.rtp_send_bitrate()?,
                        )?,
                        rtx_bytes_received: ::core::convert::TryInto::try_into(
                            value.rtx_bytes_received()?,
                        )?,
                        rtx_recv_bitrate: ::core::convert::TryInto::try_into(
                            value.rtx_recv_bitrate()?,
                        )?,
                        rtx_bytes_sent: ::core::convert::TryInto::try_into(
                            value.rtx_bytes_sent()?,
                        )?,
                        rtx_send_bitrate: ::core::convert::TryInto::try_into(
                            value.rtx_send_bitrate()?,
                        )?,
                        probation_bytes_sent: ::core::convert::TryInto::try_into(
                            value.probation_bytes_sent()?,
                        )?,
                        probation_send_bitrate: ::core::convert::TryInto::try_into(
                            value.probation_send_bitrate()?,
                        )?,
                        available_outgoing_bitrate: if let ::core::option::Option::Some(
                            available_outgoing_bitrate,
                        ) = value.available_outgoing_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                available_outgoing_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        available_incoming_bitrate: if let ::core::option::Option::Some(
                            available_incoming_bitrate,
                        ) = value.available_incoming_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                available_incoming_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_incoming_bitrate: if let ::core::option::Option::Some(
                            max_incoming_bitrate,
                        ) = value.max_incoming_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_incoming_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_outgoing_bitrate: if let ::core::option::Option::Some(
                            max_outgoing_bitrate,
                        ) = value.max_outgoing_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_outgoing_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        min_outgoing_bitrate: if let ::core::option::Option::Some(
                            min_outgoing_bitrate,
                        ) = value.min_outgoing_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                min_outgoing_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtp_packet_loss_received: if let ::core::option::Option::Some(
                            rtp_packet_loss_received,
                        ) = value.rtp_packet_loss_received()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtp_packet_loss_received,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtp_packet_loss_sent: if let ::core::option::Option::Some(
                            rtp_packet_loss_sent,
                        ) = value.rtp_packet_loss_sent()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtp_packet_loss_sent,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StatsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Stats>> for Stats {
                type Value = ::planus::Offset<Stats>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Stats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StatsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SetMaxIncomingBitrateRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `SetMaxIncomingBitrateRequest` in the file `../worker/fbs/transport.fbs:172`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetMaxIncomingBitrateRequest {
                /// The field `max_incoming_bitrate` in the table `SetMaxIncomingBitrateRequest`
                pub max_incoming_bitrate: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetMaxIncomingBitrateRequest {
                fn default() -> Self {
                    Self {
                        max_incoming_bitrate: 0,
                    }
                }
            }

            impl SetMaxIncomingBitrateRequest {
                /// Creates a [SetMaxIncomingBitrateRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetMaxIncomingBitrateRequestBuilder<()> {
                    SetMaxIncomingBitrateRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_max_incoming_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_max_incoming_bitrate =
                        field_max_incoming_bitrate.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_max_incoming_bitrate.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_max_incoming_bitrate) =
                                prepared_max_incoming_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_incoming_bitrate);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMaxIncomingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetMaxIncomingBitrateRequest> for SetMaxIncomingBitrateRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest> {
                    SetMaxIncomingBitrateRequest::create(builder, self.max_incoming_bitrate)
                }
            }

            /// Builder for serializing an instance of the [SetMaxIncomingBitrateRequest] type.
            ///
            /// Can be created using the [SetMaxIncomingBitrateRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetMaxIncomingBitrateRequestBuilder<State>(State);

            impl SetMaxIncomingBitrateRequestBuilder<()> {
                /// Setter for the [`max_incoming_bitrate` field](SetMaxIncomingBitrateRequest#structfield.max_incoming_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_incoming_bitrate<T0>(
                    self,
                    value: T0,
                ) -> SetMaxIncomingBitrateRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SetMaxIncomingBitrateRequestBuilder((value,))
                }

                /// Sets the [`max_incoming_bitrate` field](SetMaxIncomingBitrateRequest#structfield.max_incoming_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_incoming_bitrate_as_default(
                    self,
                ) -> SetMaxIncomingBitrateRequestBuilder<(::planus::DefaultValue,)>
                {
                    self.max_incoming_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0> SetMaxIncomingBitrateRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetMaxIncomingBitrateRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest>
                where
                    Self: ::planus::WriteAsOffset<SetMaxIncomingBitrateRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetMaxIncomingBitrateRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetMaxIncomingBitrateRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMaxIncomingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOffset<SetMaxIncomingBitrateRequest>
                for SetMaxIncomingBitrateRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest> {
                    let (v0,) = &self.0;
                    SetMaxIncomingBitrateRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetMaxIncomingBitrateRequest].
            #[derive(Copy, Clone)]
            pub struct SetMaxIncomingBitrateRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetMaxIncomingBitrateRequestRef<'a> {
                /// Getter for the [`max_incoming_bitrate` field](SetMaxIncomingBitrateRequest#structfield.max_incoming_bitrate).
                #[inline]
                pub fn max_incoming_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetMaxIncomingBitrateRequest", "max_incoming_bitrate")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetMaxIncomingBitrateRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetMaxIncomingBitrateRequestRef");
                    f.field("max_incoming_bitrate", &self.max_incoming_bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetMaxIncomingBitrateRequestRef<'a>>
                for SetMaxIncomingBitrateRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetMaxIncomingBitrateRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        max_incoming_bitrate: ::core::convert::TryInto::try_into(
                            value.max_incoming_bitrate()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetMaxIncomingBitrateRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetMaxIncomingBitrateRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxIncomingBitrateRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequest
            {
                type Value = ::planus::Offset<SetMaxIncomingBitrateRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetMaxIncomingBitrateRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetMaxIncomingBitrateRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxIncomingBitrateRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SetMaxOutgoingBitrateRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `SetMaxOutgoingBitrateRequest` in the file `../worker/fbs/transport.fbs:176`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetMaxOutgoingBitrateRequest {
                /// The field `max_outgoing_bitrate` in the table `SetMaxOutgoingBitrateRequest`
                pub max_outgoing_bitrate: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetMaxOutgoingBitrateRequest {
                fn default() -> Self {
                    Self {
                        max_outgoing_bitrate: 0,
                    }
                }
            }

            impl SetMaxOutgoingBitrateRequest {
                /// Creates a [SetMaxOutgoingBitrateRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetMaxOutgoingBitrateRequestBuilder<()> {
                    SetMaxOutgoingBitrateRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_max_outgoing_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_max_outgoing_bitrate =
                        field_max_outgoing_bitrate.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_max_outgoing_bitrate.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_max_outgoing_bitrate) =
                                prepared_max_outgoing_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_outgoing_bitrate);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetMaxOutgoingBitrateRequest> for SetMaxOutgoingBitrateRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest> {
                    SetMaxOutgoingBitrateRequest::create(builder, self.max_outgoing_bitrate)
                }
            }

            /// Builder for serializing an instance of the [SetMaxOutgoingBitrateRequest] type.
            ///
            /// Can be created using the [SetMaxOutgoingBitrateRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetMaxOutgoingBitrateRequestBuilder<State>(State);

            impl SetMaxOutgoingBitrateRequestBuilder<()> {
                /// Setter for the [`max_outgoing_bitrate` field](SetMaxOutgoingBitrateRequest#structfield.max_outgoing_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_outgoing_bitrate<T0>(
                    self,
                    value: T0,
                ) -> SetMaxOutgoingBitrateRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SetMaxOutgoingBitrateRequestBuilder((value,))
                }

                /// Sets the [`max_outgoing_bitrate` field](SetMaxOutgoingBitrateRequest#structfield.max_outgoing_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_outgoing_bitrate_as_default(
                    self,
                ) -> SetMaxOutgoingBitrateRequestBuilder<(::planus::DefaultValue,)>
                {
                    self.max_outgoing_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0> SetMaxOutgoingBitrateRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetMaxOutgoingBitrateRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest>
                where
                    Self: ::planus::WriteAsOffset<SetMaxOutgoingBitrateRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetMaxOutgoingBitrateRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetMaxOutgoingBitrateRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOffset<SetMaxOutgoingBitrateRequest>
                for SetMaxOutgoingBitrateRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest> {
                    let (v0,) = &self.0;
                    SetMaxOutgoingBitrateRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetMaxOutgoingBitrateRequest].
            #[derive(Copy, Clone)]
            pub struct SetMaxOutgoingBitrateRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetMaxOutgoingBitrateRequestRef<'a> {
                /// Getter for the [`max_outgoing_bitrate` field](SetMaxOutgoingBitrateRequest#structfield.max_outgoing_bitrate).
                #[inline]
                pub fn max_outgoing_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetMaxOutgoingBitrateRequest", "max_outgoing_bitrate")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetMaxOutgoingBitrateRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetMaxOutgoingBitrateRequestRef");
                    f.field("max_outgoing_bitrate", &self.max_outgoing_bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetMaxOutgoingBitrateRequestRef<'a>>
                for SetMaxOutgoingBitrateRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetMaxOutgoingBitrateRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        max_outgoing_bitrate: ::core::convert::TryInto::try_into(
                            value.max_outgoing_bitrate()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetMaxOutgoingBitrateRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetMaxOutgoingBitrateRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxOutgoingBitrateRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequest
            {
                type Value = ::planus::Offset<SetMaxOutgoingBitrateRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetMaxOutgoingBitrateRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetMaxOutgoingBitrateRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxOutgoingBitrateRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SetMinOutgoingBitrateRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `SetMinOutgoingBitrateRequest` in the file `../worker/fbs/transport.fbs:180`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetMinOutgoingBitrateRequest {
                /// The field `min_outgoing_bitrate` in the table `SetMinOutgoingBitrateRequest`
                pub min_outgoing_bitrate: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetMinOutgoingBitrateRequest {
                fn default() -> Self {
                    Self {
                        min_outgoing_bitrate: 0,
                    }
                }
            }

            impl SetMinOutgoingBitrateRequest {
                /// Creates a [SetMinOutgoingBitrateRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetMinOutgoingBitrateRequestBuilder<()> {
                    SetMinOutgoingBitrateRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_min_outgoing_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_min_outgoing_bitrate =
                        field_min_outgoing_bitrate.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_min_outgoing_bitrate.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_min_outgoing_bitrate) =
                                prepared_min_outgoing_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_min_outgoing_bitrate);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetMinOutgoingBitrateRequest>>
                for SetMinOutgoingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMinOutgoingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetMinOutgoingBitrateRequest>>
                for SetMinOutgoingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMinOutgoingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetMinOutgoingBitrateRequest> for SetMinOutgoingBitrateRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMinOutgoingBitrateRequest> {
                    SetMinOutgoingBitrateRequest::create(builder, self.min_outgoing_bitrate)
                }
            }

            /// Builder for serializing an instance of the [SetMinOutgoingBitrateRequest] type.
            ///
            /// Can be created using the [SetMinOutgoingBitrateRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetMinOutgoingBitrateRequestBuilder<State>(State);

            impl SetMinOutgoingBitrateRequestBuilder<()> {
                /// Setter for the [`min_outgoing_bitrate` field](SetMinOutgoingBitrateRequest#structfield.min_outgoing_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn min_outgoing_bitrate<T0>(
                    self,
                    value: T0,
                ) -> SetMinOutgoingBitrateRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SetMinOutgoingBitrateRequestBuilder((value,))
                }

                /// Sets the [`min_outgoing_bitrate` field](SetMinOutgoingBitrateRequest#structfield.min_outgoing_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn min_outgoing_bitrate_as_default(
                    self,
                ) -> SetMinOutgoingBitrateRequestBuilder<(::planus::DefaultValue,)>
                {
                    self.min_outgoing_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0> SetMinOutgoingBitrateRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetMinOutgoingBitrateRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMinOutgoingBitrateRequest>
                where
                    Self: ::planus::WriteAsOffset<SetMinOutgoingBitrateRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<SetMinOutgoingBitrateRequest>>
                for SetMinOutgoingBitrateRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetMinOutgoingBitrateRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMinOutgoingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<SetMinOutgoingBitrateRequest>>
                for SetMinOutgoingBitrateRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SetMinOutgoingBitrateRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMinOutgoingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOffset<SetMinOutgoingBitrateRequest>
                for SetMinOutgoingBitrateRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMinOutgoingBitrateRequest> {
                    let (v0,) = &self.0;
                    SetMinOutgoingBitrateRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SetMinOutgoingBitrateRequest].
            #[derive(Copy, Clone)]
            pub struct SetMinOutgoingBitrateRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetMinOutgoingBitrateRequestRef<'a> {
                /// Getter for the [`min_outgoing_bitrate` field](SetMinOutgoingBitrateRequest#structfield.min_outgoing_bitrate).
                #[inline]
                pub fn min_outgoing_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetMinOutgoingBitrateRequest", "min_outgoing_bitrate")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetMinOutgoingBitrateRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetMinOutgoingBitrateRequestRef");
                    f.field("min_outgoing_bitrate", &self.min_outgoing_bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetMinOutgoingBitrateRequestRef<'a>>
                for SetMinOutgoingBitrateRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetMinOutgoingBitrateRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        min_outgoing_bitrate: ::core::convert::TryInto::try_into(
                            value.min_outgoing_bitrate()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetMinOutgoingBitrateRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetMinOutgoingBitrateRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMinOutgoingBitrateRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetMinOutgoingBitrateRequest>>
                for SetMinOutgoingBitrateRequest
            {
                type Value = ::planus::Offset<SetMinOutgoingBitrateRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetMinOutgoingBitrateRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetMinOutgoingBitrateRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMinOutgoingBitrateRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `EnableTraceEventRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `EnableTraceEventRequest` in the file `../worker/fbs/transport.fbs:184`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EnableTraceEventRequest {
                /// The field `events` in the table `EnableTraceEventRequest`
                pub events: ::planus::alloc::vec::Vec<self::TraceEventType>,
            }

            impl EnableTraceEventRequest {
                /// Creates a [EnableTraceEventRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> EnableTraceEventRequestBuilder<()> {
                    EnableTraceEventRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_events: impl ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_events = field_events.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[self::TraceEventType]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_events);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EnableTraceEventRequest> for EnableTraceEventRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    EnableTraceEventRequest::create(builder, &self.events)
                }
            }

            /// Builder for serializing an instance of the [EnableTraceEventRequest] type.
            ///
            /// Can be created using the [EnableTraceEventRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct EnableTraceEventRequestBuilder<State>(State);

            impl EnableTraceEventRequestBuilder<()> {
                /// Setter for the [`events` field](EnableTraceEventRequest#structfield.events).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn events<T0>(self, value: T0) -> EnableTraceEventRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                {
                    EnableTraceEventRequestBuilder((value,))
                }
            }

            impl<T0> EnableTraceEventRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [EnableTraceEventRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest>
                where
                    Self: ::planus::WriteAsOffset<EnableTraceEventRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<EnableTraceEventRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<EnableTraceEventRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAsOffset<EnableTraceEventRequest>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    let (v0,) = &self.0;
                    EnableTraceEventRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [EnableTraceEventRequest].
            #[derive(Copy, Clone)]
            pub struct EnableTraceEventRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EnableTraceEventRequestRef<'a> {
                /// Getter for the [`events` field](EnableTraceEventRequest#structfield.events).
                #[inline]
                pub fn events(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::core::result::Result<
                            self::TraceEventType,
                            ::planus::errors::UnknownEnumTag,
                        >,
                    >,
                > {
                    self.0
                        .access_required(0, "EnableTraceEventRequest", "events")
                }
            }

            impl<'a> ::core::fmt::Debug for EnableTraceEventRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EnableTraceEventRequestRef");
                    f.field("events", &self.events());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EnableTraceEventRequestRef<'a>> for EnableTraceEventRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EnableTraceEventRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        events: value.events()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EnableTraceEventRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EnableTraceEventRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Value = ::planus::Offset<EnableTraceEventRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EnableTraceEventRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EnableTraceEventRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseProducerRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `CloseProducerRequest` in the file `../worker/fbs/transport.fbs:188`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseProducerRequest {
                /// The field `producer_id` in the table `CloseProducerRequest`
                pub producer_id: ::planus::alloc::string::String,
            }

            impl CloseProducerRequest {
                /// Creates a [CloseProducerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseProducerRequestBuilder<()> {
                    CloseProducerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseProducerRequest>> for CloseProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseProducerRequest>> for CloseProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseProducerRequest> for CloseProducerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest> {
                    CloseProducerRequest::create(builder, &self.producer_id)
                }
            }

            /// Builder for serializing an instance of the [CloseProducerRequest] type.
            ///
            /// Can be created using the [CloseProducerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseProducerRequestBuilder<State>(State);

            impl CloseProducerRequestBuilder<()> {
                /// Setter for the [`producer_id` field](CloseProducerRequest#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T0>(self, value: T0) -> CloseProducerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseProducerRequestBuilder((value,))
                }
            }

            impl<T0> CloseProducerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseProducerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseProducerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseProducerRequest>>
                for CloseProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseProducerRequest>>
                for CloseProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseProducerRequest>
                for CloseProducerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest> {
                    let (v0,) = &self.0;
                    CloseProducerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseProducerRequest].
            #[derive(Copy, Clone)]
            pub struct CloseProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseProducerRequestRef<'a> {
                /// Getter for the [`producer_id` field](CloseProducerRequest#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseProducerRequest", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseProducerRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseProducerRequestRef<'a>> for CloseProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseProducerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseProducerRequest>> for CloseProducerRequest {
                type Value = ::planus::Offset<CloseProducerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseProducerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseConsumerRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `CloseConsumerRequest` in the file `../worker/fbs/transport.fbs:192`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseConsumerRequest {
                /// The field `consumer_id` in the table `CloseConsumerRequest`
                pub consumer_id: ::planus::alloc::string::String,
            }

            impl CloseConsumerRequest {
                /// Creates a [CloseConsumerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseConsumerRequestBuilder<()> {
                    CloseConsumerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_consumer_id = field_consumer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_consumer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseConsumerRequest>> for CloseConsumerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseConsumerRequest>> for CloseConsumerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseConsumerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseConsumerRequest> for CloseConsumerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest> {
                    CloseConsumerRequest::create(builder, &self.consumer_id)
                }
            }

            /// Builder for serializing an instance of the [CloseConsumerRequest] type.
            ///
            /// Can be created using the [CloseConsumerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseConsumerRequestBuilder<State>(State);

            impl CloseConsumerRequestBuilder<()> {
                /// Setter for the [`consumer_id` field](CloseConsumerRequest#structfield.consumer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn consumer_id<T0>(self, value: T0) -> CloseConsumerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseConsumerRequestBuilder((value,))
                }
            }

            impl<T0> CloseConsumerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseConsumerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseConsumerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseConsumerRequest>>
                for CloseConsumerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseConsumerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseConsumerRequest>>
                for CloseConsumerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseConsumerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseConsumerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseConsumerRequest>
                for CloseConsumerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest> {
                    let (v0,) = &self.0;
                    CloseConsumerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseConsumerRequest].
            #[derive(Copy, Clone)]
            pub struct CloseConsumerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseConsumerRequestRef<'a> {
                /// Getter for the [`consumer_id` field](CloseConsumerRequest#structfield.consumer_id).
                #[inline]
                pub fn consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseConsumerRequest", "consumer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseConsumerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseConsumerRequestRef");
                    f.field("consumer_id", &self.consumer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseConsumerRequestRef<'a>> for CloseConsumerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseConsumerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        consumer_id: ::core::convert::TryInto::try_into(value.consumer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseConsumerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseConsumerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseConsumerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseConsumerRequest>> for CloseConsumerRequest {
                type Value = ::planus::Offset<CloseConsumerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseConsumerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseConsumerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseConsumerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseDataProducerRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `CloseDataProducerRequest` in the file `../worker/fbs/transport.fbs:196`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseDataProducerRequest {
                /// The field `data_producer_id` in the table `CloseDataProducerRequest`
                pub data_producer_id: ::planus::alloc::string::String,
            }

            impl CloseDataProducerRequest {
                /// Creates a [CloseDataProducerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseDataProducerRequestBuilder<()> {
                    CloseDataProducerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data_producer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseDataProducerRequest>> for CloseDataProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseDataProducerRequest>>
                for CloseDataProducerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseDataProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseDataProducerRequest> for CloseDataProducerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest> {
                    CloseDataProducerRequest::create(builder, &self.data_producer_id)
                }
            }

            /// Builder for serializing an instance of the [CloseDataProducerRequest] type.
            ///
            /// Can be created using the [CloseDataProducerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseDataProducerRequestBuilder<State>(State);

            impl CloseDataProducerRequestBuilder<()> {
                /// Setter for the [`data_producer_id` field](CloseDataProducerRequest#structfield.data_producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_producer_id<T0>(
                    self,
                    value: T0,
                ) -> CloseDataProducerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseDataProducerRequestBuilder((value,))
                }
            }

            impl<T0> CloseDataProducerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseDataProducerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseDataProducerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseDataProducerRequest>>
                for CloseDataProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseDataProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseDataProducerRequest>>
                for CloseDataProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseDataProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseDataProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseDataProducerRequest>
                for CloseDataProducerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest> {
                    let (v0,) = &self.0;
                    CloseDataProducerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseDataProducerRequest].
            #[derive(Copy, Clone)]
            pub struct CloseDataProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseDataProducerRequestRef<'a> {
                /// Getter for the [`data_producer_id` field](CloseDataProducerRequest#structfield.data_producer_id).
                #[inline]
                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseDataProducerRequest", "data_producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseDataProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseDataProducerRequestRef");
                    f.field("data_producer_id", &self.data_producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseDataProducerRequestRef<'a>> for CloseDataProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseDataProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseDataProducerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseDataProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseDataProducerRequest>>
                for CloseDataProducerRequest
            {
                type Value = ::planus::Offset<CloseDataProducerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseDataProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseDataProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataProducerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseDataConsumerRequest` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `CloseDataConsumerRequest` in the file `../worker/fbs/transport.fbs:200`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseDataConsumerRequest {
                /// The field `data_consumer_id` in the table `CloseDataConsumerRequest`
                pub data_consumer_id: ::planus::alloc::string::String,
            }

            impl CloseDataConsumerRequest {
                /// Creates a [CloseDataConsumerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseDataConsumerRequestBuilder<()> {
                    CloseDataConsumerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_consumer_id = field_data_consumer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data_consumer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseDataConsumerRequest>> for CloseDataConsumerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseDataConsumerRequest>>
                for CloseDataConsumerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseDataConsumerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseDataConsumerRequest> for CloseDataConsumerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest> {
                    CloseDataConsumerRequest::create(builder, &self.data_consumer_id)
                }
            }

            /// Builder for serializing an instance of the [CloseDataConsumerRequest] type.
            ///
            /// Can be created using the [CloseDataConsumerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseDataConsumerRequestBuilder<State>(State);

            impl CloseDataConsumerRequestBuilder<()> {
                /// Setter for the [`data_consumer_id` field](CloseDataConsumerRequest#structfield.data_consumer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data_consumer_id<T0>(
                    self,
                    value: T0,
                ) -> CloseDataConsumerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseDataConsumerRequestBuilder((value,))
                }
            }

            impl<T0> CloseDataConsumerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseDataConsumerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseDataConsumerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseDataConsumerRequest>>
                for CloseDataConsumerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseDataConsumerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseDataConsumerRequest>>
                for CloseDataConsumerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseDataConsumerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseDataConsumerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseDataConsumerRequest>
                for CloseDataConsumerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest> {
                    let (v0,) = &self.0;
                    CloseDataConsumerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseDataConsumerRequest].
            #[derive(Copy, Clone)]
            pub struct CloseDataConsumerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseDataConsumerRequestRef<'a> {
                /// Getter for the [`data_consumer_id` field](CloseDataConsumerRequest#structfield.data_consumer_id).
                #[inline]
                pub fn data_consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseDataConsumerRequest", "data_consumer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseDataConsumerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseDataConsumerRequestRef");
                    f.field("data_consumer_id", &self.data_consumer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseDataConsumerRequestRef<'a>> for CloseDataConsumerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseDataConsumerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_consumer_id: ::core::convert::TryInto::try_into(
                            value.data_consumer_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseDataConsumerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseDataConsumerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataConsumerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseDataConsumerRequest>>
                for CloseDataConsumerRequest
            {
                type Value = ::planus::Offset<CloseDataConsumerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseDataConsumerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseDataConsumerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataConsumerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SendRtcpNotification` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `SendRtcpNotification` in the file `../worker/fbs/transport.fbs:206`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendRtcpNotification {
                /// The field `data` in the table `SendRtcpNotification`
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl SendRtcpNotification {
                /// Creates a [SendRtcpNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SendRtcpNotificationBuilder<()> {
                    SendRtcpNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendRtcpNotification>> for SendRtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendRtcpNotification>> for SendRtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendRtcpNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendRtcpNotification> for SendRtcpNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification> {
                    SendRtcpNotification::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [SendRtcpNotification] type.
            ///
            /// Can be created using the [SendRtcpNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SendRtcpNotificationBuilder<State>(State);

            impl SendRtcpNotificationBuilder<()> {
                /// Setter for the [`data` field](SendRtcpNotification#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> SendRtcpNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    SendRtcpNotificationBuilder((value,))
                }
            }

            impl<T0> SendRtcpNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SendRtcpNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification>
                where
                    Self: ::planus::WriteAsOffset<SendRtcpNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAs<::planus::Offset<SendRtcpNotification>>
                for SendRtcpNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SendRtcpNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOptional<::planus::Offset<SendRtcpNotification>>
                for SendRtcpNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SendRtcpNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendRtcpNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOffset<SendRtcpNotification>
                for SendRtcpNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification> {
                    let (v0,) = &self.0;
                    SendRtcpNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SendRtcpNotification].
            #[derive(Copy, Clone)]
            pub struct SendRtcpNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendRtcpNotificationRef<'a> {
                /// Getter for the [`data` field](SendRtcpNotification#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(0, "SendRtcpNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendRtcpNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendRtcpNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendRtcpNotificationRef<'a>> for SendRtcpNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendRtcpNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendRtcpNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendRtcpNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendRtcpNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendRtcpNotification>> for SendRtcpNotification {
                type Value = ::planus::Offset<SendRtcpNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendRtcpNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendRtcpNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendRtcpNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `SctpStateChangeNotification` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `SctpStateChangeNotification` in the file `../worker/fbs/transport.fbs:212`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpStateChangeNotification {
                /// The field `sctp_state` in the table `SctpStateChangeNotification`
                pub sctp_state: super::sctp_association::SctpState,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SctpStateChangeNotification {
                fn default() -> Self {
                    Self {
                        sctp_state: super::sctp_association::SctpState::New,
                    }
                }
            }

            impl SctpStateChangeNotification {
                /// Creates a [SctpStateChangeNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SctpStateChangeNotificationBuilder<()> {
                    SctpStateChangeNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_sctp_state: impl ::planus::WriteAsDefault<
                        super::sctp_association::SctpState,
                        super::sctp_association::SctpState,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_sctp_state =
                        field_sctp_state.prepare(builder, &super::sctp_association::SctpState::New);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_sctp_state.is_some() {
                        table_writer.write_entry::<super::sctp_association::SctpState>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_sctp_state) =
                                prepared_sctp_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_sctp_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpStateChangeNotification> for SctpStateChangeNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification> {
                    SctpStateChangeNotification::create(builder, self.sctp_state)
                }
            }

            /// Builder for serializing an instance of the [SctpStateChangeNotification] type.
            ///
            /// Can be created using the [SctpStateChangeNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SctpStateChangeNotificationBuilder<State>(State);

            impl SctpStateChangeNotificationBuilder<()> {
                /// Setter for the [`sctp_state` field](SctpStateChangeNotification#structfield.sctp_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_state<T0>(self, value: T0) -> SctpStateChangeNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<
                        super::sctp_association::SctpState,
                        super::sctp_association::SctpState,
                    >,
                {
                    SctpStateChangeNotificationBuilder((value,))
                }

                /// Sets the [`sctp_state` field](SctpStateChangeNotification#structfield.sctp_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn sctp_state_as_default(
                    self,
                ) -> SctpStateChangeNotificationBuilder<(::planus::DefaultValue,)> {
                    self.sctp_state(::planus::DefaultValue)
                }
            }

            impl<T0> SctpStateChangeNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SctpStateChangeNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification>
                where
                    Self: ::planus::WriteAsOffset<SctpStateChangeNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        super::sctp_association::SctpState,
                        super::sctp_association::SctpState,
                    >,
                > ::planus::WriteAs<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SctpStateChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        super::sctp_association::SctpState,
                        super::sctp_association::SctpState,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SctpStateChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        super::sctp_association::SctpState,
                        super::sctp_association::SctpState,
                    >,
                > ::planus::WriteAsOffset<SctpStateChangeNotification>
                for SctpStateChangeNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification> {
                    let (v0,) = &self.0;
                    SctpStateChangeNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SctpStateChangeNotification].
            #[derive(Copy, Clone)]
            pub struct SctpStateChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpStateChangeNotificationRef<'a> {
                /// Getter for the [`sctp_state` field](SctpStateChangeNotification#structfield.sctp_state).
                #[inline]
                pub fn sctp_state(&self) -> ::planus::Result<super::sctp_association::SctpState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SctpStateChangeNotification", "sctp_state")?
                            .unwrap_or(super::sctp_association::SctpState::New),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SctpStateChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpStateChangeNotificationRef");
                    f.field("sctp_state", &self.sctp_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpStateChangeNotificationRef<'a>>
                for SctpStateChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpStateChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        sctp_state: ::core::convert::TryInto::try_into(value.sctp_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpStateChangeNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpStateChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStateChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotification
            {
                type Value = ::planus::Offset<SctpStateChangeNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpStateChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpStateChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStateChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The union `TraceInfo` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Union `TraceInfo` in the file `../worker/fbs/transport.fbs:216`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum TraceInfo {
                /// The variant of type `BweTraceInfo` in the union `TraceInfo`
                BweTraceInfo(::planus::alloc::boxed::Box<self::BweTraceInfo>),
            }

            impl TraceInfo {
                /// Creates a [TraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TraceInfoBuilder<::planus::Uninitialized> {
                    TraceInfoBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_bwe_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::BweTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<TraceInfo> for TraceInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::BweTraceInfo(value) => Self::create_bwe_trace_info(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [TraceInfo] type.
            ///
            /// Can be created using the [TraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TraceInfoBuilder<T>(T);

            impl TraceInfoBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`BweTraceInfo` variant](TraceInfo#variant.BweTraceInfo).
                #[inline]
                pub fn bwe_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::BweTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> TraceInfoBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [TraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo>
                where
                    Self: ::planus::WriteAsUnion<TraceInfo>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BweTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BweTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [TraceInfo].
            #[derive(Copy, Clone, Debug)]
            pub enum TraceInfoRef<'a> {
                BweTraceInfo(self::BweTraceInfoRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<TraceInfoRef<'a>> for TraceInfo {
                type Error = ::planus::Error;

                fn try_from(value: TraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        TraceInfoRef::BweTraceInfo(value) => {
                            Self::BweTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for TraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::BweTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The enum `BweType` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Enum `BweType` in the file `../worker/fbs/transport.fbs:220`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BweType {
                /// The variant `TRANSPORT_CC` in the enum `BweType`
                TransportCc = 0,

                /// The variant `REMB` in the enum `BweType`
                Remb = 1,
            }

            impl BweType {
                /// Array containing all valid variants of BweType
                pub const ENUM_VALUES: [Self; 2] = [Self::TransportCc, Self::Remb];
            }

            impl ::core::convert::TryFrom<u8> for BweType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BweType::TransportCc),
                        1 => ::core::result::Result::Ok(BweType::Remb),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BweType> for u8 {
                #[inline]
                fn from(value: BweType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BweType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BweType> for BweType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BweType> for BweType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BweType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BweType, BweType> for BweType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BweType,
                ) -> ::core::option::Option<BweType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BweType> for BweType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BweType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BweType {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BweType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BweType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BweType> for BweType {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `BweTraceInfo` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `BweTraceInfo` in the file `../worker/fbs/transport.fbs:225`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BweTraceInfo {
                /// The field `bwe_type` in the table `BweTraceInfo`
                pub bwe_type: self::BweType,
                /// The field `desired_bitrate` in the table `BweTraceInfo`
                pub desired_bitrate: u32,
                /// The field `effective_desired_bitrate` in the table `BweTraceInfo`
                pub effective_desired_bitrate: u32,
                /// The field `min_bitrate` in the table `BweTraceInfo`
                pub min_bitrate: u32,
                /// The field `max_bitrate` in the table `BweTraceInfo`
                pub max_bitrate: u32,
                /// The field `start_bitrate` in the table `BweTraceInfo`
                pub start_bitrate: u32,
                /// The field `max_padding_bitrate` in the table `BweTraceInfo`
                pub max_padding_bitrate: u32,
                /// The field `available_bitrate` in the table `BweTraceInfo`
                pub available_bitrate: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BweTraceInfo {
                fn default() -> Self {
                    Self {
                        bwe_type: self::BweType::TransportCc,
                        desired_bitrate: 0,
                        effective_desired_bitrate: 0,
                        min_bitrate: 0,
                        max_bitrate: 0,
                        start_bitrate: 0,
                        max_padding_bitrate: 0,
                        available_bitrate: 0,
                    }
                }
            }

            impl BweTraceInfo {
                /// Creates a [BweTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BweTraceInfoBuilder<()> {
                    BweTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_bwe_type: impl ::planus::WriteAsDefault<self::BweType, self::BweType>,
                    field_desired_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_effective_desired_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_min_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_max_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_start_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_max_padding_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_available_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_bwe_type =
                        field_bwe_type.prepare(builder, &self::BweType::TransportCc);
                    let prepared_desired_bitrate = field_desired_bitrate.prepare(builder, &0);
                    let prepared_effective_desired_bitrate =
                        field_effective_desired_bitrate.prepare(builder, &0);
                    let prepared_min_bitrate = field_min_bitrate.prepare(builder, &0);
                    let prepared_max_bitrate = field_max_bitrate.prepare(builder, &0);
                    let prepared_start_bitrate = field_start_bitrate.prepare(builder, &0);
                    let prepared_max_padding_bitrate =
                        field_max_padding_bitrate.prepare(builder, &0);
                    let prepared_available_bitrate = field_available_bitrate.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    if prepared_desired_bitrate.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_effective_desired_bitrate.is_some() {
                        table_writer.write_entry::<u32>(2);
                    }
                    if prepared_min_bitrate.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }
                    if prepared_max_bitrate.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_start_bitrate.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }
                    if prepared_max_padding_bitrate.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    if prepared_available_bitrate.is_some() {
                        table_writer.write_entry::<u32>(7);
                    }
                    if prepared_bwe_type.is_some() {
                        table_writer.write_entry::<self::BweType>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_desired_bitrate) =
                                prepared_desired_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_desired_bitrate);
                            }
                            if let ::core::option::Option::Some(
                                prepared_effective_desired_bitrate,
                            ) = prepared_effective_desired_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_effective_desired_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_min_bitrate) =
                                prepared_min_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_min_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_max_bitrate) =
                                prepared_max_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_start_bitrate) =
                                prepared_start_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_start_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_max_padding_bitrate) =
                                prepared_max_padding_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_max_padding_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_available_bitrate) =
                                prepared_available_bitrate
                            {
                                object_writer.write::<_, _, 4>(&prepared_available_bitrate);
                            }
                            if let ::core::option::Option::Some(prepared_bwe_type) =
                                prepared_bwe_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_bwe_type);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BweTraceInfo>> for BweTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BweTraceInfo>> for BweTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BweTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BweTraceInfo> for BweTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo> {
                    BweTraceInfo::create(
                        builder,
                        self.bwe_type,
                        self.desired_bitrate,
                        self.effective_desired_bitrate,
                        self.min_bitrate,
                        self.max_bitrate,
                        self.start_bitrate,
                        self.max_padding_bitrate,
                        self.available_bitrate,
                    )
                }
            }

            /// Builder for serializing an instance of the [BweTraceInfo] type.
            ///
            /// Can be created using the [BweTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BweTraceInfoBuilder<State>(State);

            impl BweTraceInfoBuilder<()> {
                /// Setter for the [`bwe_type` field](BweTraceInfo#structfield.bwe_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bwe_type<T0>(self, value: T0) -> BweTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::BweType, self::BweType>,
                {
                    BweTraceInfoBuilder((value,))
                }

                /// Sets the [`bwe_type` field](BweTraceInfo#structfield.bwe_type) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bwe_type_as_default(self) -> BweTraceInfoBuilder<(::planus::DefaultValue,)> {
                    self.bwe_type(::planus::DefaultValue)
                }
            }

            impl<T0> BweTraceInfoBuilder<(T0,)> {
                /// Setter for the [`desired_bitrate` field](BweTraceInfo#structfield.desired_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn desired_bitrate<T1>(self, value: T1) -> BweTraceInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    BweTraceInfoBuilder((v0, value))
                }

                /// Sets the [`desired_bitrate` field](BweTraceInfo#structfield.desired_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn desired_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.desired_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1> BweTraceInfoBuilder<(T0, T1)> {
                /// Setter for the [`effective_desired_bitrate` field](BweTraceInfo#structfield.effective_desired_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn effective_desired_bitrate<T2>(
                    self,
                    value: T2,
                ) -> BweTraceInfoBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1) = self.0;
                    BweTraceInfoBuilder((v0, v1, value))
                }

                /// Sets the [`effective_desired_bitrate` field](BweTraceInfo#structfield.effective_desired_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn effective_desired_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.effective_desired_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> BweTraceInfoBuilder<(T0, T1, T2)> {
                /// Setter for the [`min_bitrate` field](BweTraceInfo#structfield.min_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn min_bitrate<T3>(self, value: T3) -> BweTraceInfoBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    BweTraceInfoBuilder((v0, v1, v2, value))
                }

                /// Sets the [`min_bitrate` field](BweTraceInfo#structfield.min_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn min_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.min_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> BweTraceInfoBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`max_bitrate` field](BweTraceInfo#structfield.max_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_bitrate<T4>(self, value: T4) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    BweTraceInfoBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`max_bitrate` field](BweTraceInfo#structfield.max_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.max_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> BweTraceInfoBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`start_bitrate` field](BweTraceInfo#structfield.start_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn start_bitrate<T5>(
                    self,
                    value: T5,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    BweTraceInfoBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`start_bitrate` field](BweTraceInfo#structfield.start_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn start_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.start_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`max_padding_bitrate` field](BweTraceInfo#structfield.max_padding_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_padding_bitrate<T6>(
                    self,
                    value: T6,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    BweTraceInfoBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`max_padding_bitrate` field](BweTraceInfo#structfield.max_padding_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_padding_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.max_padding_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`available_bitrate` field](BweTraceInfo#structfield.available_bitrate).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn available_bitrate<T7>(
                    self,
                    value: T7,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    BweTraceInfoBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`available_bitrate` field](BweTraceInfo#structfield.available_bitrate) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn available_bitrate_as_default(
                    self,
                ) -> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.available_bitrate(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BweTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<BweTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::BweType, self::BweType>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<BweTraceInfo>>
                for BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<BweTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::BweType, self::BweType>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<BweTraceInfo>>
                for BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<BweTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BweTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::BweType, self::BweType>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<BweTraceInfo>
                for BweTraceInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    BweTraceInfo::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [BweTraceInfo].
            #[derive(Copy, Clone)]
            pub struct BweTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BweTraceInfoRef<'a> {
                /// Getter for the [`bwe_type` field](BweTraceInfo#structfield.bwe_type).
                #[inline]
                pub fn bwe_type(&self) -> ::planus::Result<self::BweType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "BweTraceInfo", "bwe_type")?
                            .unwrap_or(self::BweType::TransportCc),
                    )
                }

                /// Getter for the [`desired_bitrate` field](BweTraceInfo#structfield.desired_bitrate).
                #[inline]
                pub fn desired_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "BweTraceInfo", "desired_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`effective_desired_bitrate` field](BweTraceInfo#structfield.effective_desired_bitrate).
                #[inline]
                pub fn effective_desired_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "BweTraceInfo", "effective_desired_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`min_bitrate` field](BweTraceInfo#structfield.min_bitrate).
                #[inline]
                pub fn min_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "BweTraceInfo", "min_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`max_bitrate` field](BweTraceInfo#structfield.max_bitrate).
                #[inline]
                pub fn max_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "BweTraceInfo", "max_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`start_bitrate` field](BweTraceInfo#structfield.start_bitrate).
                #[inline]
                pub fn start_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "BweTraceInfo", "start_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`max_padding_bitrate` field](BweTraceInfo#structfield.max_padding_bitrate).
                #[inline]
                pub fn max_padding_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "BweTraceInfo", "max_padding_bitrate")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`available_bitrate` field](BweTraceInfo#structfield.available_bitrate).
                #[inline]
                pub fn available_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "BweTraceInfo", "available_bitrate")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BweTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BweTraceInfoRef");
                    f.field("bwe_type", &self.bwe_type());
                    f.field("desired_bitrate", &self.desired_bitrate());
                    f.field(
                        "effective_desired_bitrate",
                        &self.effective_desired_bitrate(),
                    );
                    f.field("min_bitrate", &self.min_bitrate());
                    f.field("max_bitrate", &self.max_bitrate());
                    f.field("start_bitrate", &self.start_bitrate());
                    f.field("max_padding_bitrate", &self.max_padding_bitrate());
                    f.field("available_bitrate", &self.available_bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BweTraceInfoRef<'a>> for BweTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BweTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        bwe_type: ::core::convert::TryInto::try_into(value.bwe_type()?)?,
                        desired_bitrate: ::core::convert::TryInto::try_into(
                            value.desired_bitrate()?,
                        )?,
                        effective_desired_bitrate: ::core::convert::TryInto::try_into(
                            value.effective_desired_bitrate()?,
                        )?,
                        min_bitrate: ::core::convert::TryInto::try_into(value.min_bitrate()?)?,
                        max_bitrate: ::core::convert::TryInto::try_into(value.max_bitrate()?)?,
                        start_bitrate: ::core::convert::TryInto::try_into(value.start_bitrate()?)?,
                        max_padding_bitrate: ::core::convert::TryInto::try_into(
                            value.max_padding_bitrate()?,
                        )?,
                        available_bitrate: ::core::convert::TryInto::try_into(
                            value.available_bitrate()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BweTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BweTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BweTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BweTraceInfo>> for BweTraceInfo {
                type Value = ::planus::Offset<BweTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BweTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BweTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BweTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `TraceNotification` in the namespace `FBS.Transport`
            ///
            /// Generated from these locations:
            /// * Table `TraceNotification` in the file `../worker/fbs/transport.fbs:236`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TraceNotification {
                /// The field `type` in the table `TraceNotification`
                pub type_: self::TraceEventType,
                /// The field `timestamp` in the table `TraceNotification`
                pub timestamp: u64,
                /// The field `direction` in the table `TraceNotification`
                pub direction: super::common::TraceDirection,
                /// The field `info` in the table `TraceNotification`
                pub info: ::core::option::Option<self::TraceInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for TraceNotification {
                fn default() -> Self {
                    Self {
                        type_: self::TraceEventType::Probation,
                        timestamp: 0,
                        direction: super::common::TraceDirection::DirectionIn,
                        info: ::core::default::Default::default(),
                    }
                }
            }

            impl TraceNotification {
                /// Creates a [TraceNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TraceNotificationBuilder<()> {
                    TraceNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<
                        self::TraceEventType,
                        self::TraceEventType,
                    >,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_direction: impl ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    field_info: impl ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ =
                        field_type_.prepare(builder, &self::TraceEventType::Probation);
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_direction = field_direction
                        .prepare(builder, &super::common::TraceDirection::DirectionIn);
                    let prepared_info = field_info.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(1);
                    }
                    if prepared_info.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::TraceInfo>>(4);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<self::TraceEventType>(0);
                    }
                    if prepared_direction.is_some() {
                        table_writer.write_entry::<super::common::TraceDirection>(2);
                    }
                    if prepared_info.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_info) = prepared_info {
                                object_writer.write::<_, _, 4>(&prepared_info.offset());
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_direction) =
                                prepared_direction
                            {
                                object_writer.write::<_, _, 1>(&prepared_direction);
                            }
                            if let ::core::option::Option::Some(prepared_info) = prepared_info {
                                object_writer.write::<_, _, 1>(&prepared_info.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TraceNotification> for TraceNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    TraceNotification::create(
                        builder,
                        self.type_,
                        self.timestamp,
                        self.direction,
                        &self.info,
                    )
                }
            }

            /// Builder for serializing an instance of the [TraceNotification] type.
            ///
            /// Can be created using the [TraceNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TraceNotificationBuilder<State>(State);

            impl TraceNotificationBuilder<()> {
                /// Setter for the [`type` field](TraceNotification#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T0>(self, value: T0) -> TraceNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                {
                    TraceNotificationBuilder((value,))
                }

                /// Sets the [`type` field](TraceNotification#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> TraceNotificationBuilder<(::planus::DefaultValue,)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0> TraceNotificationBuilder<(T0,)> {
                /// Setter for the [`timestamp` field](TraceNotification#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T1>(self, value: T1) -> TraceNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0,) = self.0;
                    TraceNotificationBuilder((v0, value))
                }

                /// Sets the [`timestamp` field](TraceNotification#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(
                    self,
                ) -> TraceNotificationBuilder<(T0, ::planus::DefaultValue)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0, T1> TraceNotificationBuilder<(T0, T1)> {
                /// Setter for the [`direction` field](TraceNotification#structfield.direction).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction<T2>(self, value: T2) -> TraceNotificationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                {
                    let (v0, v1) = self.0;
                    TraceNotificationBuilder((v0, v1, value))
                }

                /// Sets the [`direction` field](TraceNotification#structfield.direction) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction_as_default(
                    self,
                ) -> TraceNotificationBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.direction(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> TraceNotificationBuilder<(T0, T1, T2)> {
                /// Setter for the [`info` field](TraceNotification#structfield.info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn info<T3>(self, value: T3) -> TraceNotificationBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                {
                    let (v0, v1, v2) = self.0;
                    TraceNotificationBuilder((v0, v1, v2, value))
                }

                /// Sets the [`info` field](TraceNotification#structfield.info) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn info_as_null(self) -> TraceNotificationBuilder<(T0, T1, T2, ())> {
                    self.info(())
                }
            }

            impl<T0, T1, T2, T3> TraceNotificationBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TraceNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification>
                where
                    Self: ::planus::WriteAsOffset<TraceNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAs<::planus::Offset<TraceNotification>>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<TraceNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAsOptional<::planus::Offset<TraceNotification>>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<TraceNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAsOffset<TraceNotification>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    let (v0, v1, v2, v3) = &self.0;
                    TraceNotification::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [TraceNotification].
            #[derive(Copy, Clone)]
            pub struct TraceNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TraceNotificationRef<'a> {
                /// Getter for the [`type` field](TraceNotification#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<self::TraceEventType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TraceNotification", "type_")?
                            .unwrap_or(self::TraceEventType::Probation),
                    )
                }

                /// Getter for the [`timestamp` field](TraceNotification#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "TraceNotification", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`direction` field](TraceNotification#structfield.direction).
                #[inline]
                pub fn direction(&self) -> ::planus::Result<super::common::TraceDirection> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "TraceNotification", "direction")?
                            .unwrap_or(super::common::TraceDirection::DirectionIn),
                    )
                }

                /// Getter for the [`info` field](TraceNotification#structfield.info).
                #[inline]
                pub fn info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TraceInfoRef<'a>>>
                {
                    self.0.access_union(3, "TraceNotification", "info")
                }
            }

            impl<'a> ::core::fmt::Debug for TraceNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TraceNotificationRef");
                    f.field("type_", &self.type_());
                    f.field("timestamp", &self.timestamp());
                    f.field("direction", &self.direction());
                    if let ::core::option::Option::Some(field_info) = self.info().transpose() {
                        f.field("info", &field_info);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TraceNotificationRef<'a>> for TraceNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TraceNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        direction: ::core::convert::TryInto::try_into(value.direction()?)?,
                        info: if let ::core::option::Option::Some(info) = value.info()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(info)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TraceNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TraceNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TraceNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TraceNotification>> for TraceNotification {
                type Value = ::planus::Offset<TraceNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TraceNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TraceNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TraceNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.SctpAssociation`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/sctpAssociation.fbs`
        pub mod sctp_association {
            /// The enum `SctpState` in the namespace `FBS.SctpAssociation`
            ///
            /// Generated from these locations:
            /// * Enum `SctpState` in the file `../worker/fbs/sctpAssociation.fbs:3`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum SctpState {
                /// The variant `NEW` in the enum `SctpState`
                New = 0,

                /// The variant `CONNECTING` in the enum `SctpState`
                Connecting = 1,

                /// The variant `CONNECTED` in the enum `SctpState`
                Connected = 2,

                /// The variant `FAILED` in the enum `SctpState`
                Failed = 3,

                /// The variant `CLOSED` in the enum `SctpState`
                Closed = 4,
            }

            impl SctpState {
                /// Array containing all valid variants of SctpState
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::New,
                    Self::Connecting,
                    Self::Connected,
                    Self::Failed,
                    Self::Closed,
                ];
            }

            impl ::core::convert::TryFrom<u8> for SctpState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(SctpState::New),
                        1 => ::core::result::Result::Ok(SctpState::Connecting),
                        2 => ::core::result::Result::Ok(SctpState::Connected),
                        3 => ::core::result::Result::Ok(SctpState::Failed),
                        4 => ::core::result::Result::Ok(SctpState::Closed),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<SctpState> for u8 {
                #[inline]
                fn from(value: SctpState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for SctpState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<SctpState> for SctpState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<SctpState> for SctpState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> SctpState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<SctpState, SctpState> for SctpState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &SctpState,
                ) -> ::core::option::Option<SctpState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<SctpState> for SctpState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<SctpState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for SctpState {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for SctpState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "SctpState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<SctpState> for SctpState {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }
        }
        /// The namespace `FBS.SrtpParameters`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/srtpParameters.fbs`
        pub mod srtp_parameters {
            /// The enum `SrtpCryptoSuite` in the namespace `FBS.SrtpParameters`
            ///
            /// Generated from these locations:
            /// * Enum `SrtpCryptoSuite` in the file `../worker/fbs/srtpParameters.fbs:3`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum SrtpCryptoSuite {
                /// The variant `AEAD_AES_256_GCM` in the enum `SrtpCryptoSuite`
                AeadAes256Gcm = 0,

                /// The variant `AEAD_AES_128_GCM` in the enum `SrtpCryptoSuite`
                AeadAes128Gcm = 1,

                /// The variant `AES_CM_128_HMAC_SHA1_80` in the enum `SrtpCryptoSuite`
                AesCm128HmacSha180 = 2,

                /// The variant `AES_CM_128_HMAC_SHA1_32` in the enum `SrtpCryptoSuite`
                AesCm128HmacSha132 = 3,
            }

            impl SrtpCryptoSuite {
                /// Array containing all valid variants of SrtpCryptoSuite
                pub const ENUM_VALUES: [Self; 4] = [
                    Self::AeadAes256Gcm,
                    Self::AeadAes128Gcm,
                    Self::AesCm128HmacSha180,
                    Self::AesCm128HmacSha132,
                ];
            }

            impl ::core::convert::TryFrom<u8> for SrtpCryptoSuite {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(SrtpCryptoSuite::AeadAes256Gcm),
                        1 => ::core::result::Result::Ok(SrtpCryptoSuite::AeadAes128Gcm),
                        2 => ::core::result::Result::Ok(SrtpCryptoSuite::AesCm128HmacSha180),
                        3 => ::core::result::Result::Ok(SrtpCryptoSuite::AesCm128HmacSha132),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<SrtpCryptoSuite> for u8 {
                #[inline]
                fn from(value: SrtpCryptoSuite) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for SrtpCryptoSuite {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<SrtpCryptoSuite> for SrtpCryptoSuite {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<SrtpCryptoSuite> for SrtpCryptoSuite {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> SrtpCryptoSuite {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<SrtpCryptoSuite, SrtpCryptoSuite> for SrtpCryptoSuite {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &SrtpCryptoSuite,
                ) -> ::core::option::Option<SrtpCryptoSuite> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<SrtpCryptoSuite> for SrtpCryptoSuite {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<SrtpCryptoSuite> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for SrtpCryptoSuite {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for SrtpCryptoSuite {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "SrtpCryptoSuite",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<SrtpCryptoSuite> for SrtpCryptoSuite {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `SrtpParameters` in the namespace `FBS.SrtpParameters`
            ///
            /// Generated from these locations:
            /// * Table `SrtpParameters` in the file `../worker/fbs/srtpParameters.fbs:10`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SrtpParameters {
                /// The field `crypto_suite` in the table `SrtpParameters`
                pub crypto_suite: self::SrtpCryptoSuite,
                /// The field `key_base64` in the table `SrtpParameters`
                pub key_base64: ::planus::alloc::string::String,
            }

            impl SrtpParameters {
                /// Creates a [SrtpParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SrtpParametersBuilder<()> {
                    SrtpParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_crypto_suite: impl ::planus::WriteAsDefault<
                        self::SrtpCryptoSuite,
                        self::SrtpCryptoSuite,
                    >,
                    field_key_base64: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_crypto_suite =
                        field_crypto_suite.prepare(builder, &self::SrtpCryptoSuite::AeadAes256Gcm);
                    let prepared_key_base64 = field_key_base64.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_crypto_suite.is_some() {
                        table_writer.write_entry::<self::SrtpCryptoSuite>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_key_base64);
                            if let ::core::option::Option::Some(prepared_crypto_suite) =
                                prepared_crypto_suite
                            {
                                object_writer.write::<_, _, 1>(&prepared_crypto_suite);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SrtpParameters>> for SrtpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SrtpParameters>> for SrtpParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SrtpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SrtpParameters> for SrtpParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters> {
                    SrtpParameters::create(builder, self.crypto_suite, &self.key_base64)
                }
            }

            /// Builder for serializing an instance of the [SrtpParameters] type.
            ///
            /// Can be created using the [SrtpParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SrtpParametersBuilder<State>(State);

            impl SrtpParametersBuilder<()> {
                /// Setter for the [`crypto_suite` field](SrtpParameters#structfield.crypto_suite).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn crypto_suite<T0>(self, value: T0) -> SrtpParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::SrtpCryptoSuite, self::SrtpCryptoSuite>,
                {
                    SrtpParametersBuilder((value,))
                }

                /// Sets the [`crypto_suite` field](SrtpParameters#structfield.crypto_suite) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn crypto_suite_as_default(
                    self,
                ) -> SrtpParametersBuilder<(::planus::DefaultValue,)> {
                    self.crypto_suite(::planus::DefaultValue)
                }
            }

            impl<T0> SrtpParametersBuilder<(T0,)> {
                /// Setter for the [`key_base64` field](SrtpParameters#structfield.key_base64).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn key_base64<T1>(self, value: T1) -> SrtpParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    SrtpParametersBuilder((v0, value))
                }
            }

            impl<T0, T1> SrtpParametersBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SrtpParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters>
                where
                    Self: ::planus::WriteAsOffset<SrtpParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::SrtpCryptoSuite, self::SrtpCryptoSuite>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<SrtpParameters>>
                for SrtpParametersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<SrtpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::SrtpCryptoSuite, self::SrtpCryptoSuite>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<SrtpParameters>>
                for SrtpParametersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<SrtpParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SrtpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::SrtpCryptoSuite, self::SrtpCryptoSuite>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<SrtpParameters> for SrtpParametersBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters> {
                    let (v0, v1) = &self.0;
                    SrtpParameters::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [SrtpParameters].
            #[derive(Copy, Clone)]
            pub struct SrtpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SrtpParametersRef<'a> {
                /// Getter for the [`crypto_suite` field](SrtpParameters#structfield.crypto_suite).
                #[inline]
                pub fn crypto_suite(&self) -> ::planus::Result<self::SrtpCryptoSuite> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SrtpParameters", "crypto_suite")?
                            .unwrap_or(self::SrtpCryptoSuite::AeadAes256Gcm),
                    )
                }

                /// Getter for the [`key_base64` field](SrtpParameters#structfield.key_base64).
                #[inline]
                pub fn key_base64(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "SrtpParameters", "key_base64")
                }
            }

            impl<'a> ::core::fmt::Debug for SrtpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SrtpParametersRef");
                    f.field("crypto_suite", &self.crypto_suite());
                    f.field("key_base64", &self.key_base64());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SrtpParametersRef<'a>> for SrtpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SrtpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        crypto_suite: ::core::convert::TryInto::try_into(value.crypto_suite()?)?,
                        key_base64: ::core::convert::TryInto::try_into(value.key_base64()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SrtpParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SrtpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SrtpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SrtpParameters>> for SrtpParameters {
                type Value = ::planus::Offset<SrtpParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SrtpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SrtpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SrtpParametersRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Log`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/log.fbs`
        pub mod log {
            /// The table `Log` in the namespace `FBS.Log`
            ///
            /// Generated from these locations:
            /// * Table `Log` in the file `../worker/fbs/log.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Log {
                /// The field `data` in the table `Log`
                pub data: ::planus::alloc::string::String,
            }

            impl Log {
                /// Creates a [LogBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> LogBuilder<()> {
                    LogBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Log>> for Log {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Log>> for Log {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Log>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Log> for Log {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log> {
                    Log::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [Log] type.
            ///
            /// Can be created using the [Log::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct LogBuilder<State>(State);

            impl LogBuilder<()> {
                /// Setter for the [`data` field](Log#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> LogBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    LogBuilder((value,))
                }
            }

            impl<T0> LogBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Log].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log>
                where
                    Self: ::planus::WriteAsOffset<Log>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<Log>> for LogBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Log>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<Log>> for LogBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Log>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Log>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<Log>
                for LogBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log> {
                    let (v0,) = &self.0;
                    Log::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Log].
            #[derive(Copy, Clone)]
            pub struct LogRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> LogRef<'a> {
                /// Getter for the [`data` field](Log#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Log", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for LogRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("LogRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<LogRef<'a>> for Log {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: LogRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for LogRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for LogRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[LogRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Log>> for Log {
                type Value = ::planus::Offset<Log>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Log>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for LogRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[LogRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Message`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/message.fbs`
        pub mod message {
            /// The enum `Type` in the namespace `FBS.Message`
            ///
            /// Generated from these locations:
            /// * Enum `Type` in the file `../worker/fbs/message.fbs:8`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Type {
                /// The variant `REQUEST` in the enum `Type`
                Request = 0,

                /// The variant `RESPONSE` in the enum `Type`
                Response = 1,

                /// The variant `NOTIFICATION` in the enum `Type`
                Notification = 2,

                /// The variant `LOG` in the enum `Type`
                Log = 3,
            }

            impl Type {
                /// Array containing all valid variants of Type
                pub const ENUM_VALUES: [Self; 4] =
                    [Self::Request, Self::Response, Self::Notification, Self::Log];
            }

            impl ::core::convert::TryFrom<u8> for Type {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Type::Request),
                        1 => ::core::result::Result::Ok(Type::Response),
                        2 => ::core::result::Result::Ok(Type::Notification),
                        3 => ::core::result::Result::Ok(Type::Log),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Type> for u8 {
                #[inline]
                fn from(value: Type) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Type {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Type> for Type {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Type {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Type, Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Type,
                ) -> ::core::option::Option<Type> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Type> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Type {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Type {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Type",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Type> for Type {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The union `Body` in the namespace `FBS.Message`
            ///
            /// Generated from these locations:
            /// * Union `Body` in the file `../worker/fbs/message.fbs:15`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Body {
                /// The variant `Request` in the union `Body`
                Request(::planus::alloc::boxed::Box<super::request::Request>),

                /// The variant `Response` in the union `Body`
                Response(::planus::alloc::boxed::Box<super::response::Response>),

                /// The variant `Notification` in the union `Body`
                Notification(::planus::alloc::boxed::Box<super::notification::Notification>),

                /// The variant `Log` in the union `Body`
                Log(::planus::alloc::boxed::Box<super::log::Log>),
            }

            impl Body {
                /// Creates a [BodyBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BodyBuilder<::planus::Uninitialized> {
                    BodyBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::request::Request>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::response::Response>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::notification::Notification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_log(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::log::Log>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::Request(value) => Self::create_request(builder, value),
                        Self::Response(value) => Self::create_response(builder, value),
                        Self::Notification(value) => Self::create_notification(builder, value),
                        Self::Log(value) => Self::create_log(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [Body] type.
            ///
            /// Can be created using the [Body::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BodyBuilder<T>(T);

            impl BodyBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`Request` variant](Body#variant.Request).
                #[inline]
                pub fn request<T>(self, value: T) -> BodyBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<super::request::Request>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Response` variant](Body#variant.Response).
                #[inline]
                pub fn response<T>(self, value: T) -> BodyBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<super::response::Response>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Notification` variant](Body#variant.Notification).
                #[inline]
                pub fn notification<T>(self, value: T) -> BodyBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<super::notification::Notification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Log` variant](Body#variant.Log).
                #[inline]
                pub fn log<T>(self, value: T) -> BodyBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<super::log::Log>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> BodyBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [Body].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body>
                where
                    Self: ::planus::WriteAsUnion<Body>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::request::Request>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::request::Request>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::response::Response>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::response::Response>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::notification::Notification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::notification::Notification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::log::Log>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::log::Log>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [Body].
            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                Request(super::request::RequestRef<'a>),
                Response(super::response::ResponseRef<'a>),
                Notification(super::notification::NotificationRef<'a>),
                Log(super::log::LogRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::Request(value) => Self::Request(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        BodyRef::Response(value) => {
                            Self::Response(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::Notification(value) => {
                            Self::Notification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::Log(value) => Self::Log(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::Request(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Response(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::Notification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::Log(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Message` in the namespace `FBS.Message`
            ///
            /// Generated from these locations:
            /// * Table `Message` in the file `../worker/fbs/message.fbs:22`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Message {
                /// The field `type` in the table `Message`
                pub type_: self::Type,
                /// The field `data` in the table `Message`
                pub data: self::Body,
            }

            impl Message {
                /// Creates a [MessageBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> MessageBuilder<()> {
                    MessageBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<self::Type, self::Type>,
                    field_data: impl ::planus::WriteAsUnion<self::Body>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder, &self::Type::Request);
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::Body>>(2);
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<self::Type>(0);
                    }
                    table_writer.write_entry::<u8>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data.offset());
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            object_writer.write::<_, _, 1>(&prepared_data.tag());
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Message>> for Message {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Message>> for Message {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Message>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Message> for Message {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message> {
                    Message::create(builder, self.type_, &self.data)
                }
            }

            /// Builder for serializing an instance of the [Message] type.
            ///
            /// Can be created using the [Message::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct MessageBuilder<State>(State);

            impl MessageBuilder<()> {
                /// Setter for the [`type` field](Message#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T0>(self, value: T0) -> MessageBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::Type, self::Type>,
                {
                    MessageBuilder((value,))
                }

                /// Sets the [`type` field](Message#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(self) -> MessageBuilder<(::planus::DefaultValue,)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0> MessageBuilder<(T0,)> {
                /// Setter for the [`data` field](Message#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T1>(self, value: T1) -> MessageBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsUnion<self::Body>,
                {
                    let (v0,) = self.0;
                    MessageBuilder((v0, value))
                }
            }

            impl<T0, T1> MessageBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Message].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message>
                where
                    Self: ::planus::WriteAsOffset<Message>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Type, self::Type>,
                    T1: ::planus::WriteAsUnion<self::Body>,
                > ::planus::WriteAs<::planus::Offset<Message>> for MessageBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Message>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Type, self::Type>,
                    T1: ::planus::WriteAsUnion<self::Body>,
                > ::planus::WriteAsOptional<::planus::Offset<Message>>
                for MessageBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Message>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Message>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Type, self::Type>,
                    T1: ::planus::WriteAsUnion<self::Body>,
                > ::planus::WriteAsOffset<Message> for MessageBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message> {
                    let (v0, v1) = &self.0;
                    Message::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [Message].
            #[derive(Copy, Clone)]
            pub struct MessageRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MessageRef<'a> {
                /// Getter for the [`type` field](Message#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<self::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "Message", "type_")?
                            .unwrap_or(self::Type::Request),
                    )
                }

                /// Getter for the [`data` field](Message#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<self::BodyRef<'a>> {
                    self.0.access_union_required(1, "Message", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for MessageRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MessageRef");
                    f.field("type_", &self.type_());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MessageRef<'a>> for Message {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MessageRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MessageRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MessageRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MessageRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Message>> for Message {
                type Value = ::planus::Offset<Message>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Message>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MessageRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[MessageRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Notification`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/notification.fbs`
        pub mod notification {
            /// The enum `Event` in the namespace `FBS.Notification`
            ///
            /// Generated from these locations:
            /// * Enum `Event` in the file `../worker/fbs/notification.fbs:13`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Event {
                /// The variant `TRANSPORT_SEND_RTCP` in the enum `Event`
                TransportSendRtcp = 0,

                /// The variant `PRODUCER_SEND` in the enum `Event`
                ProducerSend = 1,

                /// The variant `DATAPRODUCER_SEND` in the enum `Event`
                DataproducerSend = 2,

                /// The variant `WORKER_RUNNING` in the enum `Event`
                WorkerRunning = 3,

                /// The variant `TRANSPORT_SCTP_STATE_CHANGE` in the enum `Event`
                TransportSctpStateChange = 4,

                /// The variant `TRANSPORT_TRACE` in the enum `Event`
                TransportTrace = 5,

                /// The variant `WEBRTCTRANSPORT_ICE_SELECTED_TUPLE_CHANGE` in the enum `Event`
                WebrtctransportIceSelectedTupleChange = 6,

                /// The variant `WEBRTCTRANSPORT_ICE_STATE_CHANGE` in the enum `Event`
                WebrtctransportIceStateChange = 7,

                /// The variant `WEBRTCTRANSPORT_DTLS_STATE_CHANGE` in the enum `Event`
                WebrtctransportDtlsStateChange = 8,

                /// The variant `PLAINTRANSPORT_TUPLE` in the enum `Event`
                PlaintransportTuple = 9,

                /// The variant `PLAINTRANSPORT_RTCP_TUPLE` in the enum `Event`
                PlaintransportRtcpTuple = 10,

                /// The variant `DIRECTTRANSPORT_RTCP` in the enum `Event`
                DirecttransportRtcp = 11,

                /// The variant `PRODUCER_SCORE` in the enum `Event`
                ProducerScore = 12,

                /// The variant `PRODUCER_TRACE` in the enum `Event`
                ProducerTrace = 13,

                /// The variant `PRODUCER_VIDEO_ORIENTATION_CHANGE` in the enum `Event`
                ProducerVideoOrientationChange = 14,

                /// The variant `CONSUMER_PRODUCER_PAUSE` in the enum `Event`
                ConsumerProducerPause = 15,

                /// The variant `CONSUMER_PRODUCER_RESUME` in the enum `Event`
                ConsumerProducerResume = 16,

                /// The variant `CONSUMER_PRODUCER_CLOSE` in the enum `Event`
                ConsumerProducerClose = 17,

                /// The variant `CONSUMER_LAYERS_CHANGE` in the enum `Event`
                ConsumerLayersChange = 18,

                /// The variant `CONSUMER_RTP` in the enum `Event`
                ConsumerRtp = 19,

                /// The variant `CONSUMER_SCORE` in the enum `Event`
                ConsumerScore = 20,

                /// The variant `CONSUMER_TRACE` in the enum `Event`
                ConsumerTrace = 21,

                /// The variant `DATACONSUMER_BUFFERED_AMOUNT_LOW` in the enum `Event`
                DataconsumerBufferedAmountLow = 22,

                /// The variant `DATACONSUMER_SCTP_SENDBUFFER_FULL` in the enum `Event`
                DataconsumerSctpSendbufferFull = 23,

                /// The variant `DATACONSUMER_DATAPRODUCER_PAUSE` in the enum `Event`
                DataconsumerDataproducerPause = 24,

                /// The variant `DATACONSUMER_DATAPRODUCER_RESUME` in the enum `Event`
                DataconsumerDataproducerResume = 25,

                /// The variant `DATACONSUMER_DATAPRODUCER_CLOSE` in the enum `Event`
                DataconsumerDataproducerClose = 26,

                /// The variant `DATACONSUMER_MESSAGE` in the enum `Event`
                DataconsumerMessage = 27,

                /// The variant `ACTIVESPEAKEROBSERVER_DOMINANT_SPEAKER` in the enum `Event`
                ActivespeakerobserverDominantSpeaker = 28,

                /// The variant `AUDIOLEVELOBSERVER_SILENCE` in the enum `Event`
                AudiolevelobserverSilence = 29,

                /// The variant `AUDIOLEVELOBSERVER_VOLUMES` in the enum `Event`
                AudiolevelobserverVolumes = 30,
            }

            impl Event {
                /// Array containing all valid variants of Event
                pub const ENUM_VALUES: [Self; 31] = [
                    Self::TransportSendRtcp,
                    Self::ProducerSend,
                    Self::DataproducerSend,
                    Self::WorkerRunning,
                    Self::TransportSctpStateChange,
                    Self::TransportTrace,
                    Self::WebrtctransportIceSelectedTupleChange,
                    Self::WebrtctransportIceStateChange,
                    Self::WebrtctransportDtlsStateChange,
                    Self::PlaintransportTuple,
                    Self::PlaintransportRtcpTuple,
                    Self::DirecttransportRtcp,
                    Self::ProducerScore,
                    Self::ProducerTrace,
                    Self::ProducerVideoOrientationChange,
                    Self::ConsumerProducerPause,
                    Self::ConsumerProducerResume,
                    Self::ConsumerProducerClose,
                    Self::ConsumerLayersChange,
                    Self::ConsumerRtp,
                    Self::ConsumerScore,
                    Self::ConsumerTrace,
                    Self::DataconsumerBufferedAmountLow,
                    Self::DataconsumerSctpSendbufferFull,
                    Self::DataconsumerDataproducerPause,
                    Self::DataconsumerDataproducerResume,
                    Self::DataconsumerDataproducerClose,
                    Self::DataconsumerMessage,
                    Self::ActivespeakerobserverDominantSpeaker,
                    Self::AudiolevelobserverSilence,
                    Self::AudiolevelobserverVolumes,
                ];
            }

            impl ::core::convert::TryFrom<u8> for Event {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Event::TransportSendRtcp),
                        1 => ::core::result::Result::Ok(Event::ProducerSend),
                        2 => ::core::result::Result::Ok(Event::DataproducerSend),
                        3 => ::core::result::Result::Ok(Event::WorkerRunning),
                        4 => ::core::result::Result::Ok(Event::TransportSctpStateChange),
                        5 => ::core::result::Result::Ok(Event::TransportTrace),
                        6 => {
                            ::core::result::Result::Ok(Event::WebrtctransportIceSelectedTupleChange)
                        }
                        7 => ::core::result::Result::Ok(Event::WebrtctransportIceStateChange),
                        8 => ::core::result::Result::Ok(Event::WebrtctransportDtlsStateChange),
                        9 => ::core::result::Result::Ok(Event::PlaintransportTuple),
                        10 => ::core::result::Result::Ok(Event::PlaintransportRtcpTuple),
                        11 => ::core::result::Result::Ok(Event::DirecttransportRtcp),
                        12 => ::core::result::Result::Ok(Event::ProducerScore),
                        13 => ::core::result::Result::Ok(Event::ProducerTrace),
                        14 => ::core::result::Result::Ok(Event::ProducerVideoOrientationChange),
                        15 => ::core::result::Result::Ok(Event::ConsumerProducerPause),
                        16 => ::core::result::Result::Ok(Event::ConsumerProducerResume),
                        17 => ::core::result::Result::Ok(Event::ConsumerProducerClose),
                        18 => ::core::result::Result::Ok(Event::ConsumerLayersChange),
                        19 => ::core::result::Result::Ok(Event::ConsumerRtp),
                        20 => ::core::result::Result::Ok(Event::ConsumerScore),
                        21 => ::core::result::Result::Ok(Event::ConsumerTrace),
                        22 => ::core::result::Result::Ok(Event::DataconsumerBufferedAmountLow),
                        23 => ::core::result::Result::Ok(Event::DataconsumerSctpSendbufferFull),
                        24 => ::core::result::Result::Ok(Event::DataconsumerDataproducerPause),
                        25 => ::core::result::Result::Ok(Event::DataconsumerDataproducerResume),
                        26 => ::core::result::Result::Ok(Event::DataconsumerDataproducerClose),
                        27 => ::core::result::Result::Ok(Event::DataconsumerMessage),
                        28 => {
                            ::core::result::Result::Ok(Event::ActivespeakerobserverDominantSpeaker)
                        }
                        29 => ::core::result::Result::Ok(Event::AudiolevelobserverSilence),
                        30 => ::core::result::Result::Ok(Event::AudiolevelobserverVolumes),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Event> for u8 {
                #[inline]
                fn from(value: Event) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Event {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Event> for Event {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Event> for Event {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Event {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Event, Event> for Event {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Event,
                ) -> ::core::option::Option<Event> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Event> for Event {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Event> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Event {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Event {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Event",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Event> for Event {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The union `Body` in the namespace `FBS.Notification`
            ///
            /// Generated from these locations:
            /// * Union `Body` in the file `../worker/fbs/notification.fbs:50`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Body {
                /// The variant `Transport_SendRtcpNotification` in the union `Body`
                TransportSendRtcpNotification(
                    ::planus::alloc::boxed::Box<super::transport::SendRtcpNotification>,
                ),

                /// The variant `Transport_SctpStateChangeNotification` in the union `Body`
                TransportSctpStateChangeNotification(
                    ::planus::alloc::boxed::Box<super::transport::SctpStateChangeNotification>,
                ),

                /// The variant `Producer_SendNotification` in the union `Body`
                ProducerSendNotification(
                    ::planus::alloc::boxed::Box<super::producer::SendNotification>,
                ),

                /// The variant `DataProducer_SendNotification` in the union `Body`
                DataProducerSendNotification(
                    ::planus::alloc::boxed::Box<super::data_producer::SendNotification>,
                ),

                /// The variant `Transport_TraceNotification` in the union `Body`
                TransportTraceNotification(
                    ::planus::alloc::boxed::Box<super::transport::TraceNotification>,
                ),

                /// The variant `WebRtcTransport_IceSelectedTupleChangeNotification` in the union `Body`
                WebRtcTransportIceSelectedTupleChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::web_rtc_transport::IceSelectedTupleChangeNotification,
                    >,
                ),

                /// The variant `WebRtcTransport_IceStateChangeNotification` in the union `Body`
                WebRtcTransportIceStateChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::web_rtc_transport::IceStateChangeNotification,
                    >,
                ),

                /// The variant `WebRtcTransport_DtlsStateChangeNotification` in the union `Body`
                WebRtcTransportDtlsStateChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::web_rtc_transport::DtlsStateChangeNotification,
                    >,
                ),

                /// The variant `PlainTransport_TupleNotification` in the union `Body`
                PlainTransportTupleNotification(
                    ::planus::alloc::boxed::Box<super::plain_transport::TupleNotification>,
                ),

                /// The variant `PlainTransport_RtcpTupleNotification` in the union `Body`
                PlainTransportRtcpTupleNotification(
                    ::planus::alloc::boxed::Box<super::plain_transport::RtcpTupleNotification>,
                ),

                /// The variant `DirectTransport_RtcpNotification` in the union `Body`
                DirectTransportRtcpNotification(
                    ::planus::alloc::boxed::Box<super::direct_transport::RtcpNotification>,
                ),

                /// The variant `Producer_ScoreNotification` in the union `Body`
                ProducerScoreNotification(
                    ::planus::alloc::boxed::Box<super::producer::ScoreNotification>,
                ),

                /// The variant `Producer_TraceNotification` in the union `Body`
                ProducerTraceNotification(
                    ::planus::alloc::boxed::Box<super::producer::TraceNotification>,
                ),

                /// The variant `Producer_VideoOrientationChangeNotification` in the union `Body`
                ProducerVideoOrientationChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::producer::VideoOrientationChangeNotification,
                    >,
                ),

                /// The variant `Consumer_LayersChangeNotification` in the union `Body`
                ConsumerLayersChangeNotification(
                    ::planus::alloc::boxed::Box<super::consumer::LayersChangeNotification>,
                ),

                /// The variant `Consumer_RtpNotification` in the union `Body`
                ConsumerRtpNotification(
                    ::planus::alloc::boxed::Box<super::consumer::RtpNotification>,
                ),

                /// The variant `Consumer_ScoreNotification` in the union `Body`
                ConsumerScoreNotification(
                    ::planus::alloc::boxed::Box<super::consumer::ScoreNotification>,
                ),

                /// The variant `Consumer_TraceNotification` in the union `Body`
                ConsumerTraceNotification(
                    ::planus::alloc::boxed::Box<super::consumer::TraceNotification>,
                ),

                /// The variant `DataConsumer_MessageNotification` in the union `Body`
                DataConsumerMessageNotification(
                    ::planus::alloc::boxed::Box<super::data_consumer::MessageNotification>,
                ),

                /// The variant `DataConsumer_BufferedAmountLowNotification` in the union `Body`
                DataConsumerBufferedAmountLowNotification(
                    ::planus::alloc::boxed::Box<
                        super::data_consumer::BufferedAmountLowNotification,
                    >,
                ),

                /// The variant `ActiveSpeakerObserver_DominantSpeakerNotification` in the union `Body`
                ActiveSpeakerObserverDominantSpeakerNotification(
                    ::planus::alloc::boxed::Box<
                        super::active_speaker_observer::DominantSpeakerNotification,
                    >,
                ),

                /// The variant `AudioLevelObserver_VolumesNotification` in the union `Body`
                AudioLevelObserverVolumesNotification(
                    ::planus::alloc::boxed::Box<super::audio_level_observer::VolumesNotification>,
                ),
            }

            impl Body {
                /// Creates a [BodyBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BodyBuilder<::planus::Uninitialized> {
                    BodyBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_transport_send_rtcp_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SendRtcpNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_sctp_state_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SctpStateChangeNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_send_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::producer::SendNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_producer_send_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_producer::SendNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_trace_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::TraceNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_ice_selected_tuple_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::web_rtc_transport::IceSelectedTupleChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_ice_state_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::web_rtc_transport::IceStateChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_dtls_state_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::web_rtc_transport::DtlsStateChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_plain_transport_tuple_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::TupleNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_plain_transport_rtcp_tuple_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::RtcpTupleNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_direct_transport_rtcp_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::direct_transport::RtcpNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_score_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::producer::ScoreNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_trace_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::producer::TraceNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_video_orientation_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::producer::VideoOrientationChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_layers_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::LayersChangeNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_rtp_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::RtpNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_score_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::ScoreNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_trace_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::TraceNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_message_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::MessageNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_buffered_amount_low_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::data_consumer::BufferedAmountLowNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_active_speaker_observer_dominant_speaker_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::active_speaker_observer::DominantSpeakerNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(21, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_audio_level_observer_volumes_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::audio_level_observer::VolumesNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(22, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::TransportSendRtcpNotification(value) => {
                            Self::create_transport_send_rtcp_notification(builder, value)
                        }
                        Self::TransportSctpStateChangeNotification(value) => {
                            Self::create_transport_sctp_state_change_notification(builder, value)
                        }
                        Self::ProducerSendNotification(value) => {
                            Self::create_producer_send_notification(builder, value)
                        }
                        Self::DataProducerSendNotification(value) => {
                            Self::create_data_producer_send_notification(builder, value)
                        }
                        Self::TransportTraceNotification(value) => {
                            Self::create_transport_trace_notification(builder, value)
                        }
                        Self::WebRtcTransportIceSelectedTupleChangeNotification(value) => {
                            Self::create_web_rtc_transport_ice_selected_tuple_change_notification(
                                builder, value,
                            )
                        }
                        Self::WebRtcTransportIceStateChangeNotification(value) => {
                            Self::create_web_rtc_transport_ice_state_change_notification(
                                builder, value,
                            )
                        }
                        Self::WebRtcTransportDtlsStateChangeNotification(value) => {
                            Self::create_web_rtc_transport_dtls_state_change_notification(
                                builder, value,
                            )
                        }
                        Self::PlainTransportTupleNotification(value) => {
                            Self::create_plain_transport_tuple_notification(builder, value)
                        }
                        Self::PlainTransportRtcpTupleNotification(value) => {
                            Self::create_plain_transport_rtcp_tuple_notification(builder, value)
                        }
                        Self::DirectTransportRtcpNotification(value) => {
                            Self::create_direct_transport_rtcp_notification(builder, value)
                        }
                        Self::ProducerScoreNotification(value) => {
                            Self::create_producer_score_notification(builder, value)
                        }
                        Self::ProducerTraceNotification(value) => {
                            Self::create_producer_trace_notification(builder, value)
                        }
                        Self::ProducerVideoOrientationChangeNotification(value) => {
                            Self::create_producer_video_orientation_change_notification(
                                builder, value,
                            )
                        }
                        Self::ConsumerLayersChangeNotification(value) => {
                            Self::create_consumer_layers_change_notification(builder, value)
                        }
                        Self::ConsumerRtpNotification(value) => {
                            Self::create_consumer_rtp_notification(builder, value)
                        }
                        Self::ConsumerScoreNotification(value) => {
                            Self::create_consumer_score_notification(builder, value)
                        }
                        Self::ConsumerTraceNotification(value) => {
                            Self::create_consumer_trace_notification(builder, value)
                        }
                        Self::DataConsumerMessageNotification(value) => {
                            Self::create_data_consumer_message_notification(builder, value)
                        }
                        Self::DataConsumerBufferedAmountLowNotification(value) => {
                            Self::create_data_consumer_buffered_amount_low_notification(
                                builder, value,
                            )
                        }
                        Self::ActiveSpeakerObserverDominantSpeakerNotification(value) => {
                            Self::create_active_speaker_observer_dominant_speaker_notification(
                                builder, value,
                            )
                        }
                        Self::AudioLevelObserverVolumesNotification(value) => {
                            Self::create_audio_level_observer_volumes_notification(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [Body] type.
            ///
            /// Can be created using the [Body::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BodyBuilder<T>(T);

            impl BodyBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`Transport_SendRtcpNotification` variant](Body#variant.TransportSendRtcpNotification).
                #[inline]
                pub fn transport_send_rtcp_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::SendRtcpNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_SctpStateChangeNotification` variant](Body#variant.TransportSctpStateChangeNotification).
                #[inline]
                pub fn transport_sctp_state_change_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::SctpStateChangeNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_SendNotification` variant](Body#variant.ProducerSendNotification).
                #[inline]
                pub fn producer_send_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::SendNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataProducer_SendNotification` variant](Body#variant.DataProducerSendNotification).
                #[inline]
                pub fn data_producer_send_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_producer::SendNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_TraceNotification` variant](Body#variant.TransportTraceNotification).
                #[inline]
                pub fn transport_trace_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<5, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::TraceNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_IceSelectedTupleChangeNotification` variant](Body#variant.WebRtcTransportIceSelectedTupleChangeNotification).
                #[inline]
                pub fn web_rtc_transport_ice_selected_tuple_change_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<6, T>>
                where
                    T: ::planus::WriteAsOffset<
                        super::web_rtc_transport::IceSelectedTupleChangeNotification,
                    >,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_IceStateChangeNotification` variant](Body#variant.WebRtcTransportIceStateChangeNotification).
                #[inline]
                pub fn web_rtc_transport_ice_state_change_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<7, T>>
                where
                    T: ::planus::WriteAsOffset<
                        super::web_rtc_transport::IceStateChangeNotification,
                    >,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_DtlsStateChangeNotification` variant](Body#variant.WebRtcTransportDtlsStateChangeNotification).
                #[inline]
                pub fn web_rtc_transport_dtls_state_change_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<8, T>>
                where
                    T: ::planus::WriteAsOffset<
                        super::web_rtc_transport::DtlsStateChangeNotification,
                    >,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PlainTransport_TupleNotification` variant](Body#variant.PlainTransportTupleNotification).
                #[inline]
                pub fn plain_transport_tuple_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<9, T>>
                where
                    T: ::planus::WriteAsOffset<super::plain_transport::TupleNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PlainTransport_RtcpTupleNotification` variant](Body#variant.PlainTransportRtcpTupleNotification).
                #[inline]
                pub fn plain_transport_rtcp_tuple_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<10, T>>
                where
                    T: ::planus::WriteAsOffset<super::plain_transport::RtcpTupleNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DirectTransport_RtcpNotification` variant](Body#variant.DirectTransportRtcpNotification).
                #[inline]
                pub fn direct_transport_rtcp_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<11, T>>
                where
                    T: ::planus::WriteAsOffset<super::direct_transport::RtcpNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_ScoreNotification` variant](Body#variant.ProducerScoreNotification).
                #[inline]
                pub fn producer_score_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<12, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::ScoreNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_TraceNotification` variant](Body#variant.ProducerTraceNotification).
                #[inline]
                pub fn producer_trace_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<13, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::TraceNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_VideoOrientationChangeNotification` variant](Body#variant.ProducerVideoOrientationChangeNotification).
                #[inline]
                pub fn producer_video_orientation_change_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<14, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::VideoOrientationChangeNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_LayersChangeNotification` variant](Body#variant.ConsumerLayersChangeNotification).
                #[inline]
                pub fn consumer_layers_change_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<15, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::LayersChangeNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_RtpNotification` variant](Body#variant.ConsumerRtpNotification).
                #[inline]
                pub fn consumer_rtp_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<16, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::RtpNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_ScoreNotification` variant](Body#variant.ConsumerScoreNotification).
                #[inline]
                pub fn consumer_score_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<17, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::ScoreNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_TraceNotification` variant](Body#variant.ConsumerTraceNotification).
                #[inline]
                pub fn consumer_trace_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<18, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::TraceNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_MessageNotification` variant](Body#variant.DataConsumerMessageNotification).
                #[inline]
                pub fn data_consumer_message_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<19, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::MessageNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_BufferedAmountLowNotification` variant](Body#variant.DataConsumerBufferedAmountLowNotification).
                #[inline]
                pub fn data_consumer_buffered_amount_low_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<20, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::BufferedAmountLowNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`ActiveSpeakerObserver_DominantSpeakerNotification` variant](Body#variant.ActiveSpeakerObserverDominantSpeakerNotification).
                #[inline]
                pub fn active_speaker_observer_dominant_speaker_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<21, T>>
                where
                    T: ::planus::WriteAsOffset<
                        super::active_speaker_observer::DominantSpeakerNotification,
                    >,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`AudioLevelObserver_VolumesNotification` variant](Body#variant.AudioLevelObserverVolumesNotification).
                #[inline]
                pub fn audio_level_observer_volumes_notification<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<22, T>>
                where
                    T: ::planus::WriteAsOffset<super::audio_level_observer::VolumesNotification>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> BodyBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [Body].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body>
                where
                    Self: ::planus::WriteAsUnion<Body>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SendRtcpNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SendRtcpNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SctpStateChangeNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SctpStateChangeNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::SendNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::SendNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::data_producer::SendNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::data_producer::SendNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::TraceNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::TraceNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<
                    super::web_rtc_transport::IceSelectedTupleChangeNotification,
                >,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<
                    super::web_rtc_transport::IceSelectedTupleChangeNotification,
                >,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::IceStateChangeNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::IceStateChangeNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::DtlsStateChangeNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::DtlsStateChangeNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::TupleNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::TupleNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::RtcpTupleNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::RtcpTupleNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<super::direct_transport::RtcpNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<super::direct_transport::RtcpNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::ScoreNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::ScoreNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::TraceNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::TraceNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::VideoOrientationChangeNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::VideoOrientationChangeNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::LayersChangeNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::LayersChangeNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::RtpNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::RtpNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::ScoreNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::ScoreNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::TraceNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::TraceNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::MessageNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::MessageNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::BufferedAmountLowNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(20, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::BufferedAmountLowNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<21, T>>
            where
                T: ::planus::WriteAsOffset<
                    super::active_speaker_observer::DominantSpeakerNotification,
                >,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(21, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<21, T>>
            where
                T: ::planus::WriteAsOffset<
                    super::active_speaker_observer::DominantSpeakerNotification,
                >,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<22, T>>
            where
                T: ::planus::WriteAsOffset<super::audio_level_observer::VolumesNotification>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(22, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<22, T>>
            where
                T: ::planus::WriteAsOffset<super::audio_level_observer::VolumesNotification>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [Body].
            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                TransportSendRtcpNotification(super::transport::SendRtcpNotificationRef<'a>),
                TransportSctpStateChangeNotification(
                    super::transport::SctpStateChangeNotificationRef<'a>,
                ),
                ProducerSendNotification(super::producer::SendNotificationRef<'a>),
                DataProducerSendNotification(super::data_producer::SendNotificationRef<'a>),
                TransportTraceNotification(super::transport::TraceNotificationRef<'a>),
                WebRtcTransportIceSelectedTupleChangeNotification(
                    super::web_rtc_transport::IceSelectedTupleChangeNotificationRef<'a>,
                ),
                WebRtcTransportIceStateChangeNotification(
                    super::web_rtc_transport::IceStateChangeNotificationRef<'a>,
                ),
                WebRtcTransportDtlsStateChangeNotification(
                    super::web_rtc_transport::DtlsStateChangeNotificationRef<'a>,
                ),
                PlainTransportTupleNotification(super::plain_transport::TupleNotificationRef<'a>),
                PlainTransportRtcpTupleNotification(
                    super::plain_transport::RtcpTupleNotificationRef<'a>,
                ),
                DirectTransportRtcpNotification(super::direct_transport::RtcpNotificationRef<'a>),
                ProducerScoreNotification(super::producer::ScoreNotificationRef<'a>),
                ProducerTraceNotification(super::producer::TraceNotificationRef<'a>),
                ProducerVideoOrientationChangeNotification(
                    super::producer::VideoOrientationChangeNotificationRef<'a>,
                ),
                ConsumerLayersChangeNotification(super::consumer::LayersChangeNotificationRef<'a>),
                ConsumerRtpNotification(super::consumer::RtpNotificationRef<'a>),
                ConsumerScoreNotification(super::consumer::ScoreNotificationRef<'a>),
                ConsumerTraceNotification(super::consumer::TraceNotificationRef<'a>),
                DataConsumerMessageNotification(super::data_consumer::MessageNotificationRef<'a>),
                DataConsumerBufferedAmountLowNotification(
                    super::data_consumer::BufferedAmountLowNotificationRef<'a>,
                ),
                ActiveSpeakerObserverDominantSpeakerNotification(
                    super::active_speaker_observer::DominantSpeakerNotificationRef<'a>,
                ),
                AudioLevelObserverVolumesNotification(
                    super::audio_level_observer::VolumesNotificationRef<'a>,
                ),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::TransportSendRtcpNotification(value) => {
                            Self::TransportSendRtcpNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportSctpStateChangeNotification(value) => {
                            Self::TransportSctpStateChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::ProducerSendNotification(value) => {
                            Self::ProducerSendNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataProducerSendNotification(value) => {
                            Self::DataProducerSendNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportTraceNotification(value) => {
                            Self::TransportTraceNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WebRtcTransportIceSelectedTupleChangeNotification(value) => {
                            Self::WebRtcTransportIceSelectedTupleChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::WebRtcTransportIceStateChangeNotification(value) => {
                            Self::WebRtcTransportIceStateChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::WebRtcTransportDtlsStateChangeNotification(value) => {
                            Self::WebRtcTransportDtlsStateChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::PlainTransportTupleNotification(value) => {
                            Self::PlainTransportTupleNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PlainTransportRtcpTupleNotification(value) => {
                            Self::PlainTransportRtcpTupleNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::DirectTransportRtcpNotification(value) => {
                            Self::DirectTransportRtcpNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProducerScoreNotification(value) => {
                            Self::ProducerScoreNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProducerTraceNotification(value) => {
                            Self::ProducerTraceNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProducerVideoOrientationChangeNotification(value) => {
                            Self::ProducerVideoOrientationChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::ConsumerLayersChangeNotification(value) => {
                            Self::ConsumerLayersChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::ConsumerRtpNotification(value) => {
                            Self::ConsumerRtpNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerScoreNotification(value) => {
                            Self::ConsumerScoreNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerTraceNotification(value) => {
                            Self::ConsumerTraceNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerMessageNotification(value) => {
                            Self::DataConsumerMessageNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerBufferedAmountLowNotification(value) => {
                            Self::DataConsumerBufferedAmountLowNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::ActiveSpeakerObserverDominantSpeakerNotification(value) => {
                            Self::ActiveSpeakerObserverDominantSpeakerNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::AudioLevelObserverVolumesNotification(value) => {
                            Self::AudioLevelObserverVolumesNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::TransportSendRtcpNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => {
                            ::core::result::Result::Ok(Self::TransportSctpStateChangeNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        3 => ::core::result::Result::Ok(Self::ProducerSendNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::DataProducerSendNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::TransportTraceNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(
                            Self::WebRtcTransportIceSelectedTupleChangeNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        7 => ::core::result::Result::Ok(
                            Self::WebRtcTransportIceStateChangeNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        8 => ::core::result::Result::Ok(
                            Self::WebRtcTransportDtlsStateChangeNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        9 => ::core::result::Result::Ok(Self::PlainTransportTupleNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        10 => {
                            ::core::result::Result::Ok(Self::PlainTransportRtcpTupleNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        11 => ::core::result::Result::Ok(Self::DirectTransportRtcpNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        12 => ::core::result::Result::Ok(Self::ProducerScoreNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        13 => ::core::result::Result::Ok(Self::ProducerTraceNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        14 => ::core::result::Result::Ok(
                            Self::ProducerVideoOrientationChangeNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        15 => ::core::result::Result::Ok(Self::ConsumerLayersChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        16 => ::core::result::Result::Ok(Self::ConsumerRtpNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        17 => ::core::result::Result::Ok(Self::ConsumerScoreNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        18 => ::core::result::Result::Ok(Self::ConsumerTraceNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        19 => ::core::result::Result::Ok(Self::DataConsumerMessageNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        20 => ::core::result::Result::Ok(
                            Self::DataConsumerBufferedAmountLowNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        21 => ::core::result::Result::Ok(
                            Self::ActiveSpeakerObserverDominantSpeakerNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        22 => {
                            ::core::result::Result::Ok(Self::AudioLevelObserverVolumesNotification(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Notification` in the namespace `FBS.Notification`
            ///
            /// Generated from these locations:
            /// * Table `Notification` in the file `../worker/fbs/notification.fbs:78`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Notification {
                /// The field `handler_id` in the table `Notification`
                pub handler_id: ::planus::alloc::string::String,
                /// The field `event` in the table `Notification`
                pub event: self::Event,
                /// The field `body` in the table `Notification`
                pub body: ::core::option::Option<self::Body>,
            }

            impl Notification {
                /// Creates a [NotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> NotificationBuilder<()> {
                    NotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_handler_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_event: impl ::planus::WriteAsDefault<self::Event, self::Event>,
                    field_body: impl ::planus::WriteAsOptionalUnion<self::Body>,
                ) -> ::planus::Offset<Self> {
                    let prepared_handler_id = field_handler_id.prepare(builder);
                    let prepared_event =
                        field_event.prepare(builder, &self::Event::TransportSendRtcp);
                    let prepared_body = field_body.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_body.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Body>>(3);
                    }
                    if prepared_event.is_some() {
                        table_writer.write_entry::<self::Event>(1);
                    }
                    if prepared_body.is_some() {
                        table_writer.write_entry::<u8>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_handler_id);
                            if let ::core::option::Option::Some(prepared_body) = prepared_body {
                                object_writer.write::<_, _, 4>(&prepared_body.offset());
                            }
                            if let ::core::option::Option::Some(prepared_event) = prepared_event {
                                object_writer.write::<_, _, 1>(&prepared_event);
                            }
                            if let ::core::option::Option::Some(prepared_body) = prepared_body {
                                object_writer.write::<_, _, 1>(&prepared_body.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Notification>> for Notification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Notification>> for Notification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Notification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Notification> for Notification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification> {
                    Notification::create(builder, &self.handler_id, self.event, &self.body)
                }
            }

            /// Builder for serializing an instance of the [Notification] type.
            ///
            /// Can be created using the [Notification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct NotificationBuilder<State>(State);

            impl NotificationBuilder<()> {
                /// Setter for the [`handler_id` field](Notification#structfield.handler_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn handler_id<T0>(self, value: T0) -> NotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    NotificationBuilder((value,))
                }
            }

            impl<T0> NotificationBuilder<(T0,)> {
                /// Setter for the [`event` field](Notification#structfield.event).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn event<T1>(self, value: T1) -> NotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::Event, self::Event>,
                {
                    let (v0,) = self.0;
                    NotificationBuilder((v0, value))
                }

                /// Sets the [`event` field](Notification#structfield.event) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn event_as_default(self) -> NotificationBuilder<(T0, ::planus::DefaultValue)> {
                    self.event(::planus::DefaultValue)
                }
            }

            impl<T0, T1> NotificationBuilder<(T0, T1)> {
                /// Setter for the [`body` field](Notification#structfield.body).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn body<T2>(self, value: T2) -> NotificationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                {
                    let (v0, v1) = self.0;
                    NotificationBuilder((v0, v1, value))
                }

                /// Sets the [`body` field](Notification#structfield.body) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn body_as_null(self) -> NotificationBuilder<(T0, T1, ())> {
                    self.body(())
                }
            }

            impl<T0, T1, T2> NotificationBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Notification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification>
                where
                    Self: ::planus::WriteAsOffset<Notification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<self::Event, self::Event>,
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                > ::planus::WriteAs<::planus::Offset<Notification>>
                for NotificationBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Notification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<self::Event, self::Event>,
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                > ::planus::WriteAsOptional<::planus::Offset<Notification>>
                for NotificationBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Notification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Notification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<self::Event, self::Event>,
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                > ::planus::WriteAsOffset<Notification> for NotificationBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification> {
                    let (v0, v1, v2) = &self.0;
                    Notification::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [Notification].
            #[derive(Copy, Clone)]
            pub struct NotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> NotificationRef<'a> {
                /// Getter for the [`handler_id` field](Notification#structfield.handler_id).
                #[inline]
                pub fn handler_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Notification", "handler_id")
                }

                /// Getter for the [`event` field](Notification#structfield.event).
                #[inline]
                pub fn event(&self) -> ::planus::Result<self::Event> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "Notification", "event")?
                            .unwrap_or(self::Event::TransportSendRtcp),
                    )
                }

                /// Getter for the [`body` field](Notification#structfield.body).
                #[inline]
                pub fn body(&self) -> ::planus::Result<::core::option::Option<self::BodyRef<'a>>> {
                    self.0.access_union(2, "Notification", "body")
                }
            }

            impl<'a> ::core::fmt::Debug for NotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("NotificationRef");
                    f.field("handler_id", &self.handler_id());
                    f.field("event", &self.event());
                    if let ::core::option::Option::Some(field_body) = self.body().transpose() {
                        f.field("body", &field_body);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<NotificationRef<'a>> for Notification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: NotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        handler_id: ::core::convert::TryInto::try_into(value.handler_id()?)?,
                        event: ::core::convert::TryInto::try_into(value.event()?)?,
                        body: if let ::core::option::Option::Some(body) = value.body()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(body)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for NotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for NotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[NotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Notification>> for Notification {
                type Value = ::planus::Offset<Notification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Notification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for NotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[NotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Request`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/request.fbs`
        pub mod request {
            /// The enum `Method` in the namespace `FBS.Request`
            ///
            /// Generated from these locations:
            /// * Enum `Method` in the file `../worker/fbs/request.fbs:11`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Method {
                /// The variant `WORKER_CLOSE` in the enum `Method`
                WorkerClose = 0,

                /// The variant `WORKER_DUMP` in the enum `Method`
                WorkerDump = 1,

                /// The variant `WORKER_GET_RESOURCE_USAGE` in the enum `Method`
                WorkerGetResourceUsage = 2,

                /// The variant `WORKER_UPDATE_SETTINGS` in the enum `Method`
                WorkerUpdateSettings = 3,

                /// The variant `WORKER_CREATE_WEBRTCSERVER` in the enum `Method`
                WorkerCreateWebrtcserver = 4,

                /// The variant `WORKER_CREATE_ROUTER` in the enum `Method`
                WorkerCreateRouter = 5,

                /// The variant `WORKER_WEBRTCSERVER_CLOSE` in the enum `Method`
                WorkerWebrtcserverClose = 6,

                /// The variant `WORKER_CLOSE_ROUTER` in the enum `Method`
                WorkerCloseRouter = 7,

                /// The variant `WEBRTCSERVER_DUMP` in the enum `Method`
                WebrtcserverDump = 8,

                /// The variant `ROUTER_DUMP` in the enum `Method`
                RouterDump = 9,

                /// The variant `ROUTER_CREATE_WEBRTCTRANSPORT` in the enum `Method`
                RouterCreateWebrtctransport = 10,

                /// The variant `ROUTER_CREATE_WEBRTCTRANSPORT_WITH_SERVER` in the enum `Method`
                RouterCreateWebrtctransportWithServer = 11,

                /// The variant `ROUTER_CREATE_PLAINTRANSPORT` in the enum `Method`
                RouterCreatePlaintransport = 12,

                /// The variant `ROUTER_CREATE_PIPETRANSPORT` in the enum `Method`
                RouterCreatePipetransport = 13,

                /// The variant `ROUTER_CREATE_DIRECTTRANSPORT` in the enum `Method`
                RouterCreateDirecttransport = 14,

                /// The variant `ROUTER_CLOSE_TRANSPORT` in the enum `Method`
                RouterCloseTransport = 15,

                /// The variant `ROUTER_CREATE_ACTIVESPEAKEROBSERVER` in the enum `Method`
                RouterCreateActivespeakerobserver = 16,

                /// The variant `ROUTER_CREATE_AUDIOLEVELOBSERVER` in the enum `Method`
                RouterCreateAudiolevelobserver = 17,

                /// The variant `ROUTER_CLOSE_RTPOBSERVER` in the enum `Method`
                RouterCloseRtpobserver = 18,

                /// The variant `TRANSPORT_DUMP` in the enum `Method`
                TransportDump = 19,

                /// The variant `TRANSPORT_GET_STATS` in the enum `Method`
                TransportGetStats = 20,

                /// The variant `TRANSPORT_CONNECT` in the enum `Method`
                TransportConnect = 21,

                /// The variant `TRANSPORT_SET_MAX_INCOMING_BITRATE` in the enum `Method`
                TransportSetMaxIncomingBitrate = 22,

                /// The variant `TRANSPORT_SET_MAX_OUTGOING_BITRATE` in the enum `Method`
                TransportSetMaxOutgoingBitrate = 23,

                /// The variant `TRANSPORT_SET_MIN_OUTGOING_BITRATE` in the enum `Method`
                TransportSetMinOutgoingBitrate = 24,

                /// The variant `TRANSPORT_RESTART_ICE` in the enum `Method`
                TransportRestartIce = 25,

                /// The variant `TRANSPORT_PRODUCE` in the enum `Method`
                TransportProduce = 26,

                /// The variant `TRANSPORT_PRODUCE_DATA` in the enum `Method`
                TransportProduceData = 27,

                /// The variant `TRANSPORT_CONSUME` in the enum `Method`
                TransportConsume = 28,

                /// The variant `TRANSPORT_CONSUME_DATA` in the enum `Method`
                TransportConsumeData = 29,

                /// The variant `TRANSPORT_ENABLE_TRACE_EVENT` in the enum `Method`
                TransportEnableTraceEvent = 30,

                /// The variant `TRANSPORT_CLOSE_PRODUCER` in the enum `Method`
                TransportCloseProducer = 31,

                /// The variant `TRANSPORT_CLOSE_CONSUMER` in the enum `Method`
                TransportCloseConsumer = 32,

                /// The variant `TRANSPORT_CLOSE_DATAPRODUCER` in the enum `Method`
                TransportCloseDataproducer = 33,

                /// The variant `TRANSPORT_CLOSE_DATACONSUMER` in the enum `Method`
                TransportCloseDataconsumer = 34,

                /// The variant `PLAINTRANSPORT_CONNECT` in the enum `Method`
                PlaintransportConnect = 35,

                /// The variant `PIPETRANSPORT_CONNECT` in the enum `Method`
                PipetransportConnect = 36,

                /// The variant `WEBRTCTRANSPORT_CONNECT` in the enum `Method`
                WebrtctransportConnect = 37,

                /// The variant `PRODUCER_DUMP` in the enum `Method`
                ProducerDump = 38,

                /// The variant `PRODUCER_GET_STATS` in the enum `Method`
                ProducerGetStats = 39,

                /// The variant `PRODUCER_PAUSE` in the enum `Method`
                ProducerPause = 40,

                /// The variant `PRODUCER_RESUME` in the enum `Method`
                ProducerResume = 41,

                /// The variant `PRODUCER_ENABLE_TRACE_EVENT` in the enum `Method`
                ProducerEnableTraceEvent = 42,

                /// The variant `CONSUMER_DUMP` in the enum `Method`
                ConsumerDump = 43,

                /// The variant `CONSUMER_GET_STATS` in the enum `Method`
                ConsumerGetStats = 44,

                /// The variant `CONSUMER_PAUSE` in the enum `Method`
                ConsumerPause = 45,

                /// The variant `CONSUMER_RESUME` in the enum `Method`
                ConsumerResume = 46,

                /// The variant `CONSUMER_SET_PREFERRED_LAYERS` in the enum `Method`
                ConsumerSetPreferredLayers = 47,

                /// The variant `CONSUMER_SET_PRIORITY` in the enum `Method`
                ConsumerSetPriority = 48,

                /// The variant `CONSUMER_REQUEST_KEY_FRAME` in the enum `Method`
                ConsumerRequestKeyFrame = 49,

                /// The variant `CONSUMER_ENABLE_TRACE_EVENT` in the enum `Method`
                ConsumerEnableTraceEvent = 50,

                /// The variant `DATAPRODUCER_DUMP` in the enum `Method`
                DataproducerDump = 51,

                /// The variant `DATAPRODUCER_GET_STATS` in the enum `Method`
                DataproducerGetStats = 52,

                /// The variant `DATAPRODUCER_PAUSE` in the enum `Method`
                DataproducerPause = 53,

                /// The variant `DATAPRODUCER_RESUME` in the enum `Method`
                DataproducerResume = 54,

                /// The variant `DATACONSUMER_DUMP` in the enum `Method`
                DataconsumerDump = 55,

                /// The variant `DATACONSUMER_GET_STATS` in the enum `Method`
                DataconsumerGetStats = 56,

                /// The variant `DATACONSUMER_PAUSE` in the enum `Method`
                DataconsumerPause = 57,

                /// The variant `DATACONSUMER_RESUME` in the enum `Method`
                DataconsumerResume = 58,

                /// The variant `DATACONSUMER_GET_BUFFERED_AMOUNT` in the enum `Method`
                DataconsumerGetBufferedAmount = 59,

                /// The variant `DATACONSUMER_SET_BUFFERED_AMOUNT_LOW_THRESHOLD` in the enum `Method`
                DataconsumerSetBufferedAmountLowThreshold = 60,

                /// The variant `DATACONSUMER_SEND` in the enum `Method`
                DataconsumerSend = 61,

                /// The variant `DATACONSUMER_SET_SUBCHANNELS` in the enum `Method`
                DataconsumerSetSubchannels = 62,

                /// The variant `RTPOBSERVER_PAUSE` in the enum `Method`
                RtpobserverPause = 63,

                /// The variant `RTPOBSERVER_RESUME` in the enum `Method`
                RtpobserverResume = 64,

                /// The variant `RTPOBSERVER_ADD_PRODUCER` in the enum `Method`
                RtpobserverAddProducer = 65,

                /// The variant `RTPOBSERVER_REMOVE_PRODUCER` in the enum `Method`
                RtpobserverRemoveProducer = 66,
            }

            impl Method {
                /// Array containing all valid variants of Method
                pub const ENUM_VALUES: [Self; 67] = [
                    Self::WorkerClose,
                    Self::WorkerDump,
                    Self::WorkerGetResourceUsage,
                    Self::WorkerUpdateSettings,
                    Self::WorkerCreateWebrtcserver,
                    Self::WorkerCreateRouter,
                    Self::WorkerWebrtcserverClose,
                    Self::WorkerCloseRouter,
                    Self::WebrtcserverDump,
                    Self::RouterDump,
                    Self::RouterCreateWebrtctransport,
                    Self::RouterCreateWebrtctransportWithServer,
                    Self::RouterCreatePlaintransport,
                    Self::RouterCreatePipetransport,
                    Self::RouterCreateDirecttransport,
                    Self::RouterCloseTransport,
                    Self::RouterCreateActivespeakerobserver,
                    Self::RouterCreateAudiolevelobserver,
                    Self::RouterCloseRtpobserver,
                    Self::TransportDump,
                    Self::TransportGetStats,
                    Self::TransportConnect,
                    Self::TransportSetMaxIncomingBitrate,
                    Self::TransportSetMaxOutgoingBitrate,
                    Self::TransportSetMinOutgoingBitrate,
                    Self::TransportRestartIce,
                    Self::TransportProduce,
                    Self::TransportProduceData,
                    Self::TransportConsume,
                    Self::TransportConsumeData,
                    Self::TransportEnableTraceEvent,
                    Self::TransportCloseProducer,
                    Self::TransportCloseConsumer,
                    Self::TransportCloseDataproducer,
                    Self::TransportCloseDataconsumer,
                    Self::PlaintransportConnect,
                    Self::PipetransportConnect,
                    Self::WebrtctransportConnect,
                    Self::ProducerDump,
                    Self::ProducerGetStats,
                    Self::ProducerPause,
                    Self::ProducerResume,
                    Self::ProducerEnableTraceEvent,
                    Self::ConsumerDump,
                    Self::ConsumerGetStats,
                    Self::ConsumerPause,
                    Self::ConsumerResume,
                    Self::ConsumerSetPreferredLayers,
                    Self::ConsumerSetPriority,
                    Self::ConsumerRequestKeyFrame,
                    Self::ConsumerEnableTraceEvent,
                    Self::DataproducerDump,
                    Self::DataproducerGetStats,
                    Self::DataproducerPause,
                    Self::DataproducerResume,
                    Self::DataconsumerDump,
                    Self::DataconsumerGetStats,
                    Self::DataconsumerPause,
                    Self::DataconsumerResume,
                    Self::DataconsumerGetBufferedAmount,
                    Self::DataconsumerSetBufferedAmountLowThreshold,
                    Self::DataconsumerSend,
                    Self::DataconsumerSetSubchannels,
                    Self::RtpobserverPause,
                    Self::RtpobserverResume,
                    Self::RtpobserverAddProducer,
                    Self::RtpobserverRemoveProducer,
                ];
            }

            impl ::core::convert::TryFrom<u8> for Method {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Method::WorkerClose),
                        1 => ::core::result::Result::Ok(Method::WorkerDump),
                        2 => ::core::result::Result::Ok(Method::WorkerGetResourceUsage),
                        3 => ::core::result::Result::Ok(Method::WorkerUpdateSettings),
                        4 => ::core::result::Result::Ok(Method::WorkerCreateWebrtcserver),
                        5 => ::core::result::Result::Ok(Method::WorkerCreateRouter),
                        6 => ::core::result::Result::Ok(Method::WorkerWebrtcserverClose),
                        7 => ::core::result::Result::Ok(Method::WorkerCloseRouter),
                        8 => ::core::result::Result::Ok(Method::WebrtcserverDump),
                        9 => ::core::result::Result::Ok(Method::RouterDump),
                        10 => ::core::result::Result::Ok(Method::RouterCreateWebrtctransport),
                        11 => ::core::result::Result::Ok(
                            Method::RouterCreateWebrtctransportWithServer,
                        ),
                        12 => ::core::result::Result::Ok(Method::RouterCreatePlaintransport),
                        13 => ::core::result::Result::Ok(Method::RouterCreatePipetransport),
                        14 => ::core::result::Result::Ok(Method::RouterCreateDirecttransport),
                        15 => ::core::result::Result::Ok(Method::RouterCloseTransport),
                        16 => ::core::result::Result::Ok(Method::RouterCreateActivespeakerobserver),
                        17 => ::core::result::Result::Ok(Method::RouterCreateAudiolevelobserver),
                        18 => ::core::result::Result::Ok(Method::RouterCloseRtpobserver),
                        19 => ::core::result::Result::Ok(Method::TransportDump),
                        20 => ::core::result::Result::Ok(Method::TransportGetStats),
                        21 => ::core::result::Result::Ok(Method::TransportConnect),
                        22 => ::core::result::Result::Ok(Method::TransportSetMaxIncomingBitrate),
                        23 => ::core::result::Result::Ok(Method::TransportSetMaxOutgoingBitrate),
                        24 => ::core::result::Result::Ok(Method::TransportSetMinOutgoingBitrate),
                        25 => ::core::result::Result::Ok(Method::TransportRestartIce),
                        26 => ::core::result::Result::Ok(Method::TransportProduce),
                        27 => ::core::result::Result::Ok(Method::TransportProduceData),
                        28 => ::core::result::Result::Ok(Method::TransportConsume),
                        29 => ::core::result::Result::Ok(Method::TransportConsumeData),
                        30 => ::core::result::Result::Ok(Method::TransportEnableTraceEvent),
                        31 => ::core::result::Result::Ok(Method::TransportCloseProducer),
                        32 => ::core::result::Result::Ok(Method::TransportCloseConsumer),
                        33 => ::core::result::Result::Ok(Method::TransportCloseDataproducer),
                        34 => ::core::result::Result::Ok(Method::TransportCloseDataconsumer),
                        35 => ::core::result::Result::Ok(Method::PlaintransportConnect),
                        36 => ::core::result::Result::Ok(Method::PipetransportConnect),
                        37 => ::core::result::Result::Ok(Method::WebrtctransportConnect),
                        38 => ::core::result::Result::Ok(Method::ProducerDump),
                        39 => ::core::result::Result::Ok(Method::ProducerGetStats),
                        40 => ::core::result::Result::Ok(Method::ProducerPause),
                        41 => ::core::result::Result::Ok(Method::ProducerResume),
                        42 => ::core::result::Result::Ok(Method::ProducerEnableTraceEvent),
                        43 => ::core::result::Result::Ok(Method::ConsumerDump),
                        44 => ::core::result::Result::Ok(Method::ConsumerGetStats),
                        45 => ::core::result::Result::Ok(Method::ConsumerPause),
                        46 => ::core::result::Result::Ok(Method::ConsumerResume),
                        47 => ::core::result::Result::Ok(Method::ConsumerSetPreferredLayers),
                        48 => ::core::result::Result::Ok(Method::ConsumerSetPriority),
                        49 => ::core::result::Result::Ok(Method::ConsumerRequestKeyFrame),
                        50 => ::core::result::Result::Ok(Method::ConsumerEnableTraceEvent),
                        51 => ::core::result::Result::Ok(Method::DataproducerDump),
                        52 => ::core::result::Result::Ok(Method::DataproducerGetStats),
                        53 => ::core::result::Result::Ok(Method::DataproducerPause),
                        54 => ::core::result::Result::Ok(Method::DataproducerResume),
                        55 => ::core::result::Result::Ok(Method::DataconsumerDump),
                        56 => ::core::result::Result::Ok(Method::DataconsumerGetStats),
                        57 => ::core::result::Result::Ok(Method::DataconsumerPause),
                        58 => ::core::result::Result::Ok(Method::DataconsumerResume),
                        59 => ::core::result::Result::Ok(Method::DataconsumerGetBufferedAmount),
                        60 => ::core::result::Result::Ok(
                            Method::DataconsumerSetBufferedAmountLowThreshold,
                        ),
                        61 => ::core::result::Result::Ok(Method::DataconsumerSend),
                        62 => ::core::result::Result::Ok(Method::DataconsumerSetSubchannels),
                        63 => ::core::result::Result::Ok(Method::RtpobserverPause),
                        64 => ::core::result::Result::Ok(Method::RtpobserverResume),
                        65 => ::core::result::Result::Ok(Method::RtpobserverAddProducer),
                        66 => ::core::result::Result::Ok(Method::RtpobserverRemoveProducer),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Method> for u8 {
                #[inline]
                fn from(value: Method) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Method {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Method> for Method {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Method> for Method {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Method {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Method, Method> for Method {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Method,
                ) -> ::core::option::Option<Method> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Method> for Method {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Method> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Method {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Method {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Method",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Method> for Method {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The union `Body` in the namespace `FBS.Request`
            ///
            /// Generated from these locations:
            /// * Union `Body` in the file `../worker/fbs/request.fbs:81`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Body {
                /// The variant `Worker_UpdateSettingsRequest` in the union `Body`
                WorkerUpdateSettingsRequest(
                    ::planus::alloc::boxed::Box<super::worker::UpdateSettingsRequest>,
                ),

                /// The variant `Worker_CreateWebRtcServerRequest` in the union `Body`
                WorkerCreateWebRtcServerRequest(
                    ::planus::alloc::boxed::Box<super::worker::CreateWebRtcServerRequest>,
                ),

                /// The variant `Worker_CloseWebRtcServerRequest` in the union `Body`
                WorkerCloseWebRtcServerRequest(
                    ::planus::alloc::boxed::Box<super::worker::CloseWebRtcServerRequest>,
                ),

                /// The variant `Worker_CreateRouterRequest` in the union `Body`
                WorkerCreateRouterRequest(
                    ::planus::alloc::boxed::Box<super::worker::CreateRouterRequest>,
                ),

                /// The variant `Worker_CloseRouterRequest` in the union `Body`
                WorkerCloseRouterRequest(
                    ::planus::alloc::boxed::Box<super::worker::CloseRouterRequest>,
                ),

                /// The variant `Router_CreateWebRtcTransportRequest` in the union `Body`
                RouterCreateWebRtcTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateWebRtcTransportRequest>,
                ),

                /// The variant `Router_CreatePlainTransportRequest` in the union `Body`
                RouterCreatePlainTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreatePlainTransportRequest>,
                ),

                /// The variant `Router_CreatePipeTransportRequest` in the union `Body`
                RouterCreatePipeTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreatePipeTransportRequest>,
                ),

                /// The variant `Router_CreateDirectTransportRequest` in the union `Body`
                RouterCreateDirectTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateDirectTransportRequest>,
                ),

                /// The variant `Router_CreateActiveSpeakerObserverRequest` in the union `Body`
                RouterCreateActiveSpeakerObserverRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateActiveSpeakerObserverRequest>,
                ),

                /// The variant `Router_CreateAudioLevelObserverRequest` in the union `Body`
                RouterCreateAudioLevelObserverRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateAudioLevelObserverRequest>,
                ),

                /// The variant `Router_CloseTransportRequest` in the union `Body`
                RouterCloseTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CloseTransportRequest>,
                ),

                /// The variant `Router_CloseRtpObserverRequest` in the union `Body`
                RouterCloseRtpObserverRequest(
                    ::planus::alloc::boxed::Box<super::router::CloseRtpObserverRequest>,
                ),

                /// The variant `Transport_SetMaxIncomingBitrateRequest` in the union `Body`
                TransportSetMaxIncomingBitrateRequest(
                    ::planus::alloc::boxed::Box<super::transport::SetMaxIncomingBitrateRequest>,
                ),

                /// The variant `Transport_SetMaxOutgoingBitrateRequest` in the union `Body`
                TransportSetMaxOutgoingBitrateRequest(
                    ::planus::alloc::boxed::Box<super::transport::SetMaxOutgoingBitrateRequest>,
                ),

                /// The variant `Transport_SetMinOutgoingBitrateRequest` in the union `Body`
                TransportSetMinOutgoingBitrateRequest(
                    ::planus::alloc::boxed::Box<super::transport::SetMinOutgoingBitrateRequest>,
                ),

                /// The variant `Transport_ProduceRequest` in the union `Body`
                TransportProduceRequest(
                    ::planus::alloc::boxed::Box<super::transport::ProduceRequest>,
                ),

                /// The variant `Transport_ConsumeRequest` in the union `Body`
                TransportConsumeRequest(
                    ::planus::alloc::boxed::Box<super::transport::ConsumeRequest>,
                ),

                /// The variant `Transport_ProduceDataRequest` in the union `Body`
                TransportProduceDataRequest(
                    ::planus::alloc::boxed::Box<super::transport::ProduceDataRequest>,
                ),

                /// The variant `Transport_ConsumeDataRequest` in the union `Body`
                TransportConsumeDataRequest(
                    ::planus::alloc::boxed::Box<super::transport::ConsumeDataRequest>,
                ),

                /// The variant `Transport_EnableTraceEventRequest` in the union `Body`
                TransportEnableTraceEventRequest(
                    ::planus::alloc::boxed::Box<super::transport::EnableTraceEventRequest>,
                ),

                /// The variant `Transport_CloseProducerRequest` in the union `Body`
                TransportCloseProducerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseProducerRequest>,
                ),

                /// The variant `Transport_CloseConsumerRequest` in the union `Body`
                TransportCloseConsumerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseConsumerRequest>,
                ),

                /// The variant `Transport_CloseDataProducerRequest` in the union `Body`
                TransportCloseDataProducerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseDataProducerRequest>,
                ),

                /// The variant `Transport_CloseDataConsumerRequest` in the union `Body`
                TransportCloseDataConsumerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseDataConsumerRequest>,
                ),

                /// The variant `PlainTransport_ConnectRequest` in the union `Body`
                PlainTransportConnectRequest(
                    ::planus::alloc::boxed::Box<super::plain_transport::ConnectRequest>,
                ),

                /// The variant `PipeTransport_ConnectRequest` in the union `Body`
                PipeTransportConnectRequest(
                    ::planus::alloc::boxed::Box<super::pipe_transport::ConnectRequest>,
                ),

                /// The variant `WebRtcTransport_ConnectRequest` in the union `Body`
                WebRtcTransportConnectRequest(
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::ConnectRequest>,
                ),

                /// The variant `Producer_EnableTraceEventRequest` in the union `Body`
                ProducerEnableTraceEventRequest(
                    ::planus::alloc::boxed::Box<super::producer::EnableTraceEventRequest>,
                ),

                /// The variant `Consumer_SetPreferredLayersRequest` in the union `Body`
                ConsumerSetPreferredLayersRequest(
                    ::planus::alloc::boxed::Box<super::consumer::SetPreferredLayersRequest>,
                ),

                /// The variant `Consumer_SetPriorityRequest` in the union `Body`
                ConsumerSetPriorityRequest(
                    ::planus::alloc::boxed::Box<super::consumer::SetPriorityRequest>,
                ),

                /// The variant `Consumer_EnableTraceEventRequest` in the union `Body`
                ConsumerEnableTraceEventRequest(
                    ::planus::alloc::boxed::Box<super::consumer::EnableTraceEventRequest>,
                ),

                /// The variant `DataConsumer_SetBufferedAmountLowThresholdRequest` in the union `Body`
                DataConsumerSetBufferedAmountLowThresholdRequest(
                    ::planus::alloc::boxed::Box<
                        super::data_consumer::SetBufferedAmountLowThresholdRequest,
                    >,
                ),

                /// The variant `DataConsumer_SendRequest` in the union `Body`
                DataConsumerSendRequest(
                    ::planus::alloc::boxed::Box<super::data_consumer::SendRequest>,
                ),

                /// The variant `DataConsumer_SetSubchannelsRequest` in the union `Body`
                DataConsumerSetSubchannelsRequest(
                    ::planus::alloc::boxed::Box<super::data_consumer::SetSubchannelsRequest>,
                ),

                /// The variant `RtpObserver_AddProducerRequest` in the union `Body`
                RtpObserverAddProducerRequest(
                    ::planus::alloc::boxed::Box<super::rtp_observer::AddProducerRequest>,
                ),

                /// The variant `RtpObserver_RemoveProducerRequest` in the union `Body`
                RtpObserverRemoveProducerRequest(
                    ::planus::alloc::boxed::Box<super::rtp_observer::RemoveProducerRequest>,
                ),
            }

            impl Body {
                /// Creates a [BodyBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BodyBuilder<::planus::Uninitialized> {
                    BodyBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_worker_update_settings_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::UpdateSettingsRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_worker_create_web_rtc_server_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CreateWebRtcServerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_worker_close_web_rtc_server_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CloseWebRtcServerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_worker_create_router_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CreateRouterRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_worker_close_router_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CloseRouterRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_create_web_rtc_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreateWebRtcTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_create_plain_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreatePlainTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_create_pipe_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreatePipeTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_create_direct_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreateDirectTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_create_active_speaker_observer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::router::CreateActiveSpeakerObserverRequest,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_create_audio_level_observer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreateAudioLevelObserverRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_close_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CloseTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_close_rtp_observer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CloseRtpObserverRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_set_max_incoming_bitrate_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SetMaxIncomingBitrateRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_set_max_outgoing_bitrate_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SetMaxOutgoingBitrateRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_set_min_outgoing_bitrate_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SetMinOutgoingBitrateRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_produce_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ProduceRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_consume_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ConsumeRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_produce_data_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ProduceDataRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_consume_data_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ConsumeDataRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_enable_trace_event_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::EnableTraceEventRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(21, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_close_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(22, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_close_consumer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseConsumerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(23, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_close_data_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseDataProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(24, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_close_data_consumer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseDataConsumerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(25, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_plain_transport_connect_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::ConnectRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(26, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_pipe_transport_connect_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::pipe_transport::ConnectRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(27, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_connect_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_transport::ConnectRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(28, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_enable_trace_event_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::producer::EnableTraceEventRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(29, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_set_preferred_layers_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPreferredLayersRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(30, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_set_priority_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPriorityRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(31, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_enable_trace_event_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::EnableTraceEventRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(32, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_set_buffered_amount_low_threshold_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::data_consumer::SetBufferedAmountLowThresholdRequest,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(33, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_send_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::SendRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(34, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_set_subchannels_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(35, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_rtp_observer_add_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::rtp_observer::AddProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(36, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_rtp_observer_remove_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::rtp_observer::RemoveProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(37, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::WorkerUpdateSettingsRequest(value) => {
                            Self::create_worker_update_settings_request(builder, value)
                        }
                        Self::WorkerCreateWebRtcServerRequest(value) => {
                            Self::create_worker_create_web_rtc_server_request(builder, value)
                        }
                        Self::WorkerCloseWebRtcServerRequest(value) => {
                            Self::create_worker_close_web_rtc_server_request(builder, value)
                        }
                        Self::WorkerCreateRouterRequest(value) => {
                            Self::create_worker_create_router_request(builder, value)
                        }
                        Self::WorkerCloseRouterRequest(value) => {
                            Self::create_worker_close_router_request(builder, value)
                        }
                        Self::RouterCreateWebRtcTransportRequest(value) => {
                            Self::create_router_create_web_rtc_transport_request(builder, value)
                        }
                        Self::RouterCreatePlainTransportRequest(value) => {
                            Self::create_router_create_plain_transport_request(builder, value)
                        }
                        Self::RouterCreatePipeTransportRequest(value) => {
                            Self::create_router_create_pipe_transport_request(builder, value)
                        }
                        Self::RouterCreateDirectTransportRequest(value) => {
                            Self::create_router_create_direct_transport_request(builder, value)
                        }
                        Self::RouterCreateActiveSpeakerObserverRequest(value) => {
                            Self::create_router_create_active_speaker_observer_request(
                                builder, value,
                            )
                        }
                        Self::RouterCreateAudioLevelObserverRequest(value) => {
                            Self::create_router_create_audio_level_observer_request(builder, value)
                        }
                        Self::RouterCloseTransportRequest(value) => {
                            Self::create_router_close_transport_request(builder, value)
                        }
                        Self::RouterCloseRtpObserverRequest(value) => {
                            Self::create_router_close_rtp_observer_request(builder, value)
                        }
                        Self::TransportSetMaxIncomingBitrateRequest(value) => {
                            Self::create_transport_set_max_incoming_bitrate_request(builder, value)
                        }
                        Self::TransportSetMaxOutgoingBitrateRequest(value) => {
                            Self::create_transport_set_max_outgoing_bitrate_request(builder, value)
                        }
                        Self::TransportSetMinOutgoingBitrateRequest(value) => {
                            Self::create_transport_set_min_outgoing_bitrate_request(builder, value)
                        }
                        Self::TransportProduceRequest(value) => {
                            Self::create_transport_produce_request(builder, value)
                        }
                        Self::TransportConsumeRequest(value) => {
                            Self::create_transport_consume_request(builder, value)
                        }
                        Self::TransportProduceDataRequest(value) => {
                            Self::create_transport_produce_data_request(builder, value)
                        }
                        Self::TransportConsumeDataRequest(value) => {
                            Self::create_transport_consume_data_request(builder, value)
                        }
                        Self::TransportEnableTraceEventRequest(value) => {
                            Self::create_transport_enable_trace_event_request(builder, value)
                        }
                        Self::TransportCloseProducerRequest(value) => {
                            Self::create_transport_close_producer_request(builder, value)
                        }
                        Self::TransportCloseConsumerRequest(value) => {
                            Self::create_transport_close_consumer_request(builder, value)
                        }
                        Self::TransportCloseDataProducerRequest(value) => {
                            Self::create_transport_close_data_producer_request(builder, value)
                        }
                        Self::TransportCloseDataConsumerRequest(value) => {
                            Self::create_transport_close_data_consumer_request(builder, value)
                        }
                        Self::PlainTransportConnectRequest(value) => {
                            Self::create_plain_transport_connect_request(builder, value)
                        }
                        Self::PipeTransportConnectRequest(value) => {
                            Self::create_pipe_transport_connect_request(builder, value)
                        }
                        Self::WebRtcTransportConnectRequest(value) => {
                            Self::create_web_rtc_transport_connect_request(builder, value)
                        }
                        Self::ProducerEnableTraceEventRequest(value) => {
                            Self::create_producer_enable_trace_event_request(builder, value)
                        }
                        Self::ConsumerSetPreferredLayersRequest(value) => {
                            Self::create_consumer_set_preferred_layers_request(builder, value)
                        }
                        Self::ConsumerSetPriorityRequest(value) => {
                            Self::create_consumer_set_priority_request(builder, value)
                        }
                        Self::ConsumerEnableTraceEventRequest(value) => {
                            Self::create_consumer_enable_trace_event_request(builder, value)
                        }
                        Self::DataConsumerSetBufferedAmountLowThresholdRequest(value) => {
                            Self::create_data_consumer_set_buffered_amount_low_threshold_request(
                                builder, value,
                            )
                        }
                        Self::DataConsumerSendRequest(value) => {
                            Self::create_data_consumer_send_request(builder, value)
                        }
                        Self::DataConsumerSetSubchannelsRequest(value) => {
                            Self::create_data_consumer_set_subchannels_request(builder, value)
                        }
                        Self::RtpObserverAddProducerRequest(value) => {
                            Self::create_rtp_observer_add_producer_request(builder, value)
                        }
                        Self::RtpObserverRemoveProducerRequest(value) => {
                            Self::create_rtp_observer_remove_producer_request(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [Body] type.
            ///
            /// Can be created using the [Body::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BodyBuilder<T>(T);

            impl BodyBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`Worker_UpdateSettingsRequest` variant](Body#variant.WorkerUpdateSettingsRequest).
                #[inline]
                pub fn worker_update_settings_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::UpdateSettingsRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Worker_CreateWebRtcServerRequest` variant](Body#variant.WorkerCreateWebRtcServerRequest).
                #[inline]
                pub fn worker_create_web_rtc_server_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::CreateWebRtcServerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Worker_CloseWebRtcServerRequest` variant](Body#variant.WorkerCloseWebRtcServerRequest).
                #[inline]
                pub fn worker_close_web_rtc_server_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::CloseWebRtcServerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Worker_CreateRouterRequest` variant](Body#variant.WorkerCreateRouterRequest).
                #[inline]
                pub fn worker_create_router_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::CreateRouterRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Worker_CloseRouterRequest` variant](Body#variant.WorkerCloseRouterRequest).
                #[inline]
                pub fn worker_close_router_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<5, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::CloseRouterRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CreateWebRtcTransportRequest` variant](Body#variant.RouterCreateWebRtcTransportRequest).
                #[inline]
                pub fn router_create_web_rtc_transport_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<6, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CreateWebRtcTransportRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CreatePlainTransportRequest` variant](Body#variant.RouterCreatePlainTransportRequest).
                #[inline]
                pub fn router_create_plain_transport_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<7, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CreatePlainTransportRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CreatePipeTransportRequest` variant](Body#variant.RouterCreatePipeTransportRequest).
                #[inline]
                pub fn router_create_pipe_transport_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<8, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CreatePipeTransportRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CreateDirectTransportRequest` variant](Body#variant.RouterCreateDirectTransportRequest).
                #[inline]
                pub fn router_create_direct_transport_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<9, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CreateDirectTransportRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CreateActiveSpeakerObserverRequest` variant](Body#variant.RouterCreateActiveSpeakerObserverRequest).
                #[inline]
                pub fn router_create_active_speaker_observer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<10, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CreateActiveSpeakerObserverRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CreateAudioLevelObserverRequest` variant](Body#variant.RouterCreateAudioLevelObserverRequest).
                #[inline]
                pub fn router_create_audio_level_observer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<11, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CreateAudioLevelObserverRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CloseTransportRequest` variant](Body#variant.RouterCloseTransportRequest).
                #[inline]
                pub fn router_close_transport_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<12, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CloseTransportRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_CloseRtpObserverRequest` variant](Body#variant.RouterCloseRtpObserverRequest).
                #[inline]
                pub fn router_close_rtp_observer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<13, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::CloseRtpObserverRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_SetMaxIncomingBitrateRequest` variant](Body#variant.TransportSetMaxIncomingBitrateRequest).
                #[inline]
                pub fn transport_set_max_incoming_bitrate_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<14, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::SetMaxIncomingBitrateRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_SetMaxOutgoingBitrateRequest` variant](Body#variant.TransportSetMaxOutgoingBitrateRequest).
                #[inline]
                pub fn transport_set_max_outgoing_bitrate_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<15, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::SetMaxOutgoingBitrateRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_SetMinOutgoingBitrateRequest` variant](Body#variant.TransportSetMinOutgoingBitrateRequest).
                #[inline]
                pub fn transport_set_min_outgoing_bitrate_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<16, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::SetMinOutgoingBitrateRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_ProduceRequest` variant](Body#variant.TransportProduceRequest).
                #[inline]
                pub fn transport_produce_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<17, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::ProduceRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_ConsumeRequest` variant](Body#variant.TransportConsumeRequest).
                #[inline]
                pub fn transport_consume_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<18, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::ConsumeRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_ProduceDataRequest` variant](Body#variant.TransportProduceDataRequest).
                #[inline]
                pub fn transport_produce_data_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<19, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::ProduceDataRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_ConsumeDataRequest` variant](Body#variant.TransportConsumeDataRequest).
                #[inline]
                pub fn transport_consume_data_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<20, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::ConsumeDataRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_EnableTraceEventRequest` variant](Body#variant.TransportEnableTraceEventRequest).
                #[inline]
                pub fn transport_enable_trace_event_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<21, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::EnableTraceEventRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_CloseProducerRequest` variant](Body#variant.TransportCloseProducerRequest).
                #[inline]
                pub fn transport_close_producer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<22, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::CloseProducerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_CloseConsumerRequest` variant](Body#variant.TransportCloseConsumerRequest).
                #[inline]
                pub fn transport_close_consumer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<23, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::CloseConsumerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_CloseDataProducerRequest` variant](Body#variant.TransportCloseDataProducerRequest).
                #[inline]
                pub fn transport_close_data_producer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<24, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::CloseDataProducerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_CloseDataConsumerRequest` variant](Body#variant.TransportCloseDataConsumerRequest).
                #[inline]
                pub fn transport_close_data_consumer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<25, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::CloseDataConsumerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PlainTransport_ConnectRequest` variant](Body#variant.PlainTransportConnectRequest).
                #[inline]
                pub fn plain_transport_connect_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<26, T>>
                where
                    T: ::planus::WriteAsOffset<super::plain_transport::ConnectRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PipeTransport_ConnectRequest` variant](Body#variant.PipeTransportConnectRequest).
                #[inline]
                pub fn pipe_transport_connect_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<27, T>>
                where
                    T: ::planus::WriteAsOffset<super::pipe_transport::ConnectRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_ConnectRequest` variant](Body#variant.WebRtcTransportConnectRequest).
                #[inline]
                pub fn web_rtc_transport_connect_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<28, T>>
                where
                    T: ::planus::WriteAsOffset<super::web_rtc_transport::ConnectRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_EnableTraceEventRequest` variant](Body#variant.ProducerEnableTraceEventRequest).
                #[inline]
                pub fn producer_enable_trace_event_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<29, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::EnableTraceEventRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_SetPreferredLayersRequest` variant](Body#variant.ConsumerSetPreferredLayersRequest).
                #[inline]
                pub fn consumer_set_preferred_layers_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<30, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::SetPreferredLayersRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_SetPriorityRequest` variant](Body#variant.ConsumerSetPriorityRequest).
                #[inline]
                pub fn consumer_set_priority_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<31, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::SetPriorityRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_EnableTraceEventRequest` variant](Body#variant.ConsumerEnableTraceEventRequest).
                #[inline]
                pub fn consumer_enable_trace_event_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<32, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::EnableTraceEventRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_SetBufferedAmountLowThresholdRequest` variant](Body#variant.DataConsumerSetBufferedAmountLowThresholdRequest).
                #[inline]
                pub fn data_consumer_set_buffered_amount_low_threshold_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<33, T>>
                where
                    T: ::planus::WriteAsOffset<
                        super::data_consumer::SetBufferedAmountLowThresholdRequest,
                    >,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_SendRequest` variant](Body#variant.DataConsumerSendRequest).
                #[inline]
                pub fn data_consumer_send_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<34, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::SendRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_SetSubchannelsRequest` variant](Body#variant.DataConsumerSetSubchannelsRequest).
                #[inline]
                pub fn data_consumer_set_subchannels_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<35, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`RtpObserver_AddProducerRequest` variant](Body#variant.RtpObserverAddProducerRequest).
                #[inline]
                pub fn rtp_observer_add_producer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<36, T>>
                where
                    T: ::planus::WriteAsOffset<super::rtp_observer::AddProducerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`RtpObserver_RemoveProducerRequest` variant](Body#variant.RtpObserverRemoveProducerRequest).
                #[inline]
                pub fn rtp_observer_remove_producer_request<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<37, T>>
                where
                    T: ::planus::WriteAsOffset<super::rtp_observer::RemoveProducerRequest>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> BodyBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [Body].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body>
                where
                    Self: ::planus::WriteAsUnion<Body>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::UpdateSettingsRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::UpdateSettingsRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CreateWebRtcServerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CreateWebRtcServerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CloseWebRtcServerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CloseWebRtcServerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CreateRouterRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CreateRouterRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CloseRouterRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::CloseRouterRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateWebRtcTransportRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateWebRtcTransportRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreatePlainTransportRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreatePlainTransportRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreatePipeTransportRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreatePipeTransportRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateDirectTransportRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateDirectTransportRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateActiveSpeakerObserverRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateActiveSpeakerObserverRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateAudioLevelObserverRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CreateAudioLevelObserverRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CloseTransportRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CloseTransportRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CloseRtpObserverRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<super::router::CloseRtpObserverRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SetMaxIncomingBitrateRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SetMaxIncomingBitrateRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SetMaxOutgoingBitrateRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SetMaxOutgoingBitrateRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SetMinOutgoingBitrateRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::SetMinOutgoingBitrateRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ProduceRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ProduceRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ConsumeRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ConsumeRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ProduceDataRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ProduceDataRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ConsumeDataRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(20, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ConsumeDataRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<21, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::EnableTraceEventRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(21, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<21, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::EnableTraceEventRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<22, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseProducerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(22, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<22, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseProducerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<23, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseConsumerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(23, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<23, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseConsumerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<24, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseDataProducerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(24, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<24, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseDataProducerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<25, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseDataConsumerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(25, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<25, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::CloseDataConsumerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<26, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::ConnectRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(26, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<26, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::ConnectRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<27, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::ConnectRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(27, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<27, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::ConnectRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<28, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::ConnectRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(28, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<28, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::ConnectRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<29, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::EnableTraceEventRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(29, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<29, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::EnableTraceEventRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<30, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPreferredLayersRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(30, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<30, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPreferredLayersRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<31, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPriorityRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(31, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<31, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPriorityRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<32, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::EnableTraceEventRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(32, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<32, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::EnableTraceEventRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<33, T>>
            where
                T: ::planus::WriteAsOffset<
                    super::data_consumer::SetBufferedAmountLowThresholdRequest,
                >,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(33, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<33, T>>
            where
                T: ::planus::WriteAsOffset<
                    super::data_consumer::SetBufferedAmountLowThresholdRequest,
                >,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<34, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::SendRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(34, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<34, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::SendRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<35, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(35, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<35, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<36, T>>
            where
                T: ::planus::WriteAsOffset<super::rtp_observer::AddProducerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(36, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<36, T>>
            where
                T: ::planus::WriteAsOffset<super::rtp_observer::AddProducerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<37, T>>
            where
                T: ::planus::WriteAsOffset<super::rtp_observer::RemoveProducerRequest>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(37, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<37, T>>
            where
                T: ::planus::WriteAsOffset<super::rtp_observer::RemoveProducerRequest>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [Body].
            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                WorkerUpdateSettingsRequest(super::worker::UpdateSettingsRequestRef<'a>),
                WorkerCreateWebRtcServerRequest(super::worker::CreateWebRtcServerRequestRef<'a>),
                WorkerCloseWebRtcServerRequest(super::worker::CloseWebRtcServerRequestRef<'a>),
                WorkerCreateRouterRequest(super::worker::CreateRouterRequestRef<'a>),
                WorkerCloseRouterRequest(super::worker::CloseRouterRequestRef<'a>),
                RouterCreateWebRtcTransportRequest(
                    super::router::CreateWebRtcTransportRequestRef<'a>,
                ),
                RouterCreatePlainTransportRequest(
                    super::router::CreatePlainTransportRequestRef<'a>,
                ),
                RouterCreatePipeTransportRequest(super::router::CreatePipeTransportRequestRef<'a>),
                RouterCreateDirectTransportRequest(
                    super::router::CreateDirectTransportRequestRef<'a>,
                ),
                RouterCreateActiveSpeakerObserverRequest(
                    super::router::CreateActiveSpeakerObserverRequestRef<'a>,
                ),
                RouterCreateAudioLevelObserverRequest(
                    super::router::CreateAudioLevelObserverRequestRef<'a>,
                ),
                RouterCloseTransportRequest(super::router::CloseTransportRequestRef<'a>),
                RouterCloseRtpObserverRequest(super::router::CloseRtpObserverRequestRef<'a>),
                TransportSetMaxIncomingBitrateRequest(
                    super::transport::SetMaxIncomingBitrateRequestRef<'a>,
                ),
                TransportSetMaxOutgoingBitrateRequest(
                    super::transport::SetMaxOutgoingBitrateRequestRef<'a>,
                ),
                TransportSetMinOutgoingBitrateRequest(
                    super::transport::SetMinOutgoingBitrateRequestRef<'a>,
                ),
                TransportProduceRequest(super::transport::ProduceRequestRef<'a>),
                TransportConsumeRequest(super::transport::ConsumeRequestRef<'a>),
                TransportProduceDataRequest(super::transport::ProduceDataRequestRef<'a>),
                TransportConsumeDataRequest(super::transport::ConsumeDataRequestRef<'a>),
                TransportEnableTraceEventRequest(super::transport::EnableTraceEventRequestRef<'a>),
                TransportCloseProducerRequest(super::transport::CloseProducerRequestRef<'a>),
                TransportCloseConsumerRequest(super::transport::CloseConsumerRequestRef<'a>),
                TransportCloseDataProducerRequest(
                    super::transport::CloseDataProducerRequestRef<'a>,
                ),
                TransportCloseDataConsumerRequest(
                    super::transport::CloseDataConsumerRequestRef<'a>,
                ),
                PlainTransportConnectRequest(super::plain_transport::ConnectRequestRef<'a>),
                PipeTransportConnectRequest(super::pipe_transport::ConnectRequestRef<'a>),
                WebRtcTransportConnectRequest(super::web_rtc_transport::ConnectRequestRef<'a>),
                ProducerEnableTraceEventRequest(super::producer::EnableTraceEventRequestRef<'a>),
                ConsumerSetPreferredLayersRequest(
                    super::consumer::SetPreferredLayersRequestRef<'a>,
                ),
                ConsumerSetPriorityRequest(super::consumer::SetPriorityRequestRef<'a>),
                ConsumerEnableTraceEventRequest(super::consumer::EnableTraceEventRequestRef<'a>),
                DataConsumerSetBufferedAmountLowThresholdRequest(
                    super::data_consumer::SetBufferedAmountLowThresholdRequestRef<'a>,
                ),
                DataConsumerSendRequest(super::data_consumer::SendRequestRef<'a>),
                DataConsumerSetSubchannelsRequest(
                    super::data_consumer::SetSubchannelsRequestRef<'a>,
                ),
                RtpObserverAddProducerRequest(super::rtp_observer::AddProducerRequestRef<'a>),
                RtpObserverRemoveProducerRequest(super::rtp_observer::RemoveProducerRequestRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::WorkerUpdateSettingsRequest(value) => {
                            Self::WorkerUpdateSettingsRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WorkerCreateWebRtcServerRequest(value) => {
                            Self::WorkerCreateWebRtcServerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WorkerCloseWebRtcServerRequest(value) => {
                            Self::WorkerCloseWebRtcServerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WorkerCreateRouterRequest(value) => {
                            Self::WorkerCreateRouterRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WorkerCloseRouterRequest(value) => {
                            Self::WorkerCloseRouterRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RouterCreateWebRtcTransportRequest(value) => {
                            Self::RouterCreateWebRtcTransportRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RouterCreatePlainTransportRequest(value) => {
                            Self::RouterCreatePlainTransportRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RouterCreatePipeTransportRequest(value) => {
                            Self::RouterCreatePipeTransportRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RouterCreateDirectTransportRequest(value) => {
                            Self::RouterCreateDirectTransportRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RouterCreateActiveSpeakerObserverRequest(value) => {
                            Self::RouterCreateActiveSpeakerObserverRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RouterCreateAudioLevelObserverRequest(value) => {
                            Self::RouterCreateAudioLevelObserverRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RouterCloseTransportRequest(value) => {
                            Self::RouterCloseTransportRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RouterCloseRtpObserverRequest(value) => {
                            Self::RouterCloseRtpObserverRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportSetMaxIncomingBitrateRequest(value) => {
                            Self::TransportSetMaxIncomingBitrateRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::TransportSetMaxOutgoingBitrateRequest(value) => {
                            Self::TransportSetMaxOutgoingBitrateRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::TransportSetMinOutgoingBitrateRequest(value) => {
                            Self::TransportSetMinOutgoingBitrateRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::TransportProduceRequest(value) => {
                            Self::TransportProduceRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportConsumeRequest(value) => {
                            Self::TransportConsumeRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportProduceDataRequest(value) => {
                            Self::TransportProduceDataRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportConsumeDataRequest(value) => {
                            Self::TransportConsumeDataRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportEnableTraceEventRequest(value) => {
                            Self::TransportEnableTraceEventRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::TransportCloseProducerRequest(value) => {
                            Self::TransportCloseProducerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportCloseConsumerRequest(value) => {
                            Self::TransportCloseConsumerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportCloseDataProducerRequest(value) => {
                            Self::TransportCloseDataProducerRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::TransportCloseDataConsumerRequest(value) => {
                            Self::TransportCloseDataConsumerRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::PlainTransportConnectRequest(value) => {
                            Self::PlainTransportConnectRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PipeTransportConnectRequest(value) => {
                            Self::PipeTransportConnectRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WebRtcTransportConnectRequest(value) => {
                            Self::WebRtcTransportConnectRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProducerEnableTraceEventRequest(value) => {
                            Self::ProducerEnableTraceEventRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerSetPreferredLayersRequest(value) => {
                            Self::ConsumerSetPreferredLayersRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::ConsumerSetPriorityRequest(value) => {
                            Self::ConsumerSetPriorityRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerEnableTraceEventRequest(value) => {
                            Self::ConsumerEnableTraceEventRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerSetBufferedAmountLowThresholdRequest(value) => {
                            Self::DataConsumerSetBufferedAmountLowThresholdRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::DataConsumerSendRequest(value) => {
                            Self::DataConsumerSendRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerSetSubchannelsRequest(value) => {
                            Self::DataConsumerSetSubchannelsRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::RtpObserverAddProducerRequest(value) => {
                            Self::RtpObserverAddProducerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RtpObserverRemoveProducerRequest(value) => {
                            Self::RtpObserverRemoveProducerRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::WorkerUpdateSettingsRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::WorkerCreateWebRtcServerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::WorkerCloseWebRtcServerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::WorkerCreateRouterRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::WorkerCloseRouterRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(Self::RouterCreateWebRtcTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        7 => ::core::result::Result::Ok(Self::RouterCreatePlainTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        8 => ::core::result::Result::Ok(Self::RouterCreatePipeTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        9 => ::core::result::Result::Ok(Self::RouterCreateDirectTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        10 => ::core::result::Result::Ok(
                            Self::RouterCreateActiveSpeakerObserverRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        11 => {
                            ::core::result::Result::Ok(Self::RouterCreateAudioLevelObserverRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        12 => ::core::result::Result::Ok(Self::RouterCloseTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        13 => ::core::result::Result::Ok(Self::RouterCloseRtpObserverRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        14 => {
                            ::core::result::Result::Ok(Self::TransportSetMaxIncomingBitrateRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        15 => {
                            ::core::result::Result::Ok(Self::TransportSetMaxOutgoingBitrateRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        16 => {
                            ::core::result::Result::Ok(Self::TransportSetMinOutgoingBitrateRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        17 => ::core::result::Result::Ok(Self::TransportProduceRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        18 => ::core::result::Result::Ok(Self::TransportConsumeRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        19 => ::core::result::Result::Ok(Self::TransportProduceDataRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        20 => ::core::result::Result::Ok(Self::TransportConsumeDataRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        21 => ::core::result::Result::Ok(Self::TransportEnableTraceEventRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        22 => ::core::result::Result::Ok(Self::TransportCloseProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        23 => ::core::result::Result::Ok(Self::TransportCloseConsumerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        24 => ::core::result::Result::Ok(Self::TransportCloseDataProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        25 => ::core::result::Result::Ok(Self::TransportCloseDataConsumerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        26 => ::core::result::Result::Ok(Self::PlainTransportConnectRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        27 => ::core::result::Result::Ok(Self::PipeTransportConnectRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        28 => ::core::result::Result::Ok(Self::WebRtcTransportConnectRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        29 => ::core::result::Result::Ok(Self::ProducerEnableTraceEventRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        30 => ::core::result::Result::Ok(Self::ConsumerSetPreferredLayersRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        31 => ::core::result::Result::Ok(Self::ConsumerSetPriorityRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        32 => ::core::result::Result::Ok(Self::ConsumerEnableTraceEventRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        33 => ::core::result::Result::Ok(
                            Self::DataConsumerSetBufferedAmountLowThresholdRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ),
                        ),
                        34 => ::core::result::Result::Ok(Self::DataConsumerSendRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        35 => ::core::result::Result::Ok(Self::DataConsumerSetSubchannelsRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        36 => ::core::result::Result::Ok(Self::RtpObserverAddProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        37 => ::core::result::Result::Ok(Self::RtpObserverRemoveProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Request` in the namespace `FBS.Request`
            ///
            /// Generated from these locations:
            /// * Table `Request` in the file `../worker/fbs/request.fbs:121`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Request {
                /// The field `id` in the table `Request`
                pub id: u32,
                /// The field `method` in the table `Request`
                pub method: self::Method,
                /// The field `handler_id` in the table `Request`
                pub handler_id: ::planus::alloc::string::String,
                /// The field `body` in the table `Request`
                pub body: ::core::option::Option<self::Body>,
            }

            impl Request {
                /// Creates a [RequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RequestBuilder<()> {
                    RequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_method: impl ::planus::WriteAsDefault<self::Method, self::Method>,
                    field_handler_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_body: impl ::planus::WriteAsOptionalUnion<self::Body>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder, &0);
                    let prepared_method = field_method.prepare(builder, &self::Method::WorkerClose);
                    let prepared_handler_id = field_handler_id.prepare(builder);
                    let prepared_body = field_body.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_id.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_body.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Body>>(4);
                    }
                    if prepared_method.is_some() {
                        table_writer.write_entry::<self::Method>(1);
                    }
                    if prepared_body.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_id) = prepared_id {
                                object_writer.write::<_, _, 4>(&prepared_id);
                            }
                            object_writer.write::<_, _, 4>(&prepared_handler_id);
                            if let ::core::option::Option::Some(prepared_body) = prepared_body {
                                object_writer.write::<_, _, 4>(&prepared_body.offset());
                            }
                            if let ::core::option::Option::Some(prepared_method) = prepared_method {
                                object_writer.write::<_, _, 1>(&prepared_method);
                            }
                            if let ::core::option::Option::Some(prepared_body) = prepared_body {
                                object_writer.write::<_, _, 1>(&prepared_body.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Request>> for Request {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Request>> for Request {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Request>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Request> for Request {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request> {
                    Request::create(builder, self.id, self.method, &self.handler_id, &self.body)
                }
            }

            /// Builder for serializing an instance of the [Request] type.
            ///
            /// Can be created using the [Request::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RequestBuilder<State>(State);

            impl RequestBuilder<()> {
                /// Setter for the [`id` field](Request#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> RequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    RequestBuilder((value,))
                }

                /// Sets the [`id` field](Request#structfield.id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id_as_default(self) -> RequestBuilder<(::planus::DefaultValue,)> {
                    self.id(::planus::DefaultValue)
                }
            }

            impl<T0> RequestBuilder<(T0,)> {
                /// Setter for the [`method` field](Request#structfield.method).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn method<T1>(self, value: T1) -> RequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::Method, self::Method>,
                {
                    let (v0,) = self.0;
                    RequestBuilder((v0, value))
                }

                /// Sets the [`method` field](Request#structfield.method) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn method_as_default(self) -> RequestBuilder<(T0, ::planus::DefaultValue)> {
                    self.method(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RequestBuilder<(T0, T1)> {
                /// Setter for the [`handler_id` field](Request#structfield.handler_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn handler_id<T2>(self, value: T2) -> RequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    RequestBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> RequestBuilder<(T0, T1, T2)> {
                /// Setter for the [`body` field](Request#structfield.body).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn body<T3>(self, value: T3) -> RequestBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptionalUnion<self::Body>,
                {
                    let (v0, v1, v2) = self.0;
                    RequestBuilder((v0, v1, v2, value))
                }

                /// Sets the [`body` field](Request#structfield.body) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn body_as_null(self) -> RequestBuilder<(T0, T1, T2, ())> {
                    self.body(())
                }
            }

            impl<T0, T1, T2, T3> RequestBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Request].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request>
                where
                    Self: ::planus::WriteAsOffset<Request>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<self::Method, self::Method>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsOptionalUnion<self::Body>,
                > ::planus::WriteAs<::planus::Offset<Request>>
                for RequestBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Request>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<self::Method, self::Method>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsOptionalUnion<self::Body>,
                > ::planus::WriteAsOptional<::planus::Offset<Request>>
                for RequestBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Request>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Request>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<self::Method, self::Method>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsOptionalUnion<self::Body>,
                > ::planus::WriteAsOffset<Request> for RequestBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request> {
                    let (v0, v1, v2, v3) = &self.0;
                    Request::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [Request].
            #[derive(Copy, Clone)]
            pub struct RequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RequestRef<'a> {
                /// Getter for the [`id` field](Request#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Request", "id")?.unwrap_or(0))
                }

                /// Getter for the [`method` field](Request#structfield.method).
                #[inline]
                pub fn method(&self) -> ::planus::Result<self::Method> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "Request", "method")?
                            .unwrap_or(self::Method::WorkerClose),
                    )
                }

                /// Getter for the [`handler_id` field](Request#structfield.handler_id).
                #[inline]
                pub fn handler_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "Request", "handler_id")
                }

                /// Getter for the [`body` field](Request#structfield.body).
                #[inline]
                pub fn body(&self) -> ::planus::Result<::core::option::Option<self::BodyRef<'a>>> {
                    self.0.access_union(3, "Request", "body")
                }
            }

            impl<'a> ::core::fmt::Debug for RequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RequestRef");
                    f.field("id", &self.id());
                    f.field("method", &self.method());
                    f.field("handler_id", &self.handler_id());
                    if let ::core::option::Option::Some(field_body) = self.body().transpose() {
                        f.field("body", &field_body);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RequestRef<'a>> for Request {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        method: ::core::convert::TryInto::try_into(value.method()?)?,
                        handler_id: ::core::convert::TryInto::try_into(value.handler_id()?)?,
                        body: if let ::core::option::Option::Some(body) = value.body()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(body)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Request>> for Request {
                type Value = ::planus::Offset<Request>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Request>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RequestRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Response`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/response.fbs`
        pub mod response {
            /// The union `Body` in the namespace `FBS.Response`
            ///
            /// Generated from these locations:
            /// * Union `Body` in the file `../worker/fbs/response.fbs:12`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Body {
                /// The variant `Worker_DumpResponse` in the union `Body`
                WorkerDumpResponse(::planus::alloc::boxed::Box<super::worker::DumpResponse>),

                /// The variant `Worker_ResourceUsageResponse` in the union `Body`
                WorkerResourceUsageResponse(
                    ::planus::alloc::boxed::Box<super::worker::ResourceUsageResponse>,
                ),

                /// The variant `WebRtcServer_DumpResponse` in the union `Body`
                WebRtcServerDumpResponse(
                    ::planus::alloc::boxed::Box<super::web_rtc_server::DumpResponse>,
                ),

                /// The variant `Router_DumpResponse` in the union `Body`
                RouterDumpResponse(::planus::alloc::boxed::Box<super::router::DumpResponse>),

                /// The variant `Transport_ProduceResponse` in the union `Body`
                TransportProduceResponse(
                    ::planus::alloc::boxed::Box<super::transport::ProduceResponse>,
                ),

                /// The variant `Transport_ConsumeResponse` in the union `Body`
                TransportConsumeResponse(
                    ::planus::alloc::boxed::Box<super::transport::ConsumeResponse>,
                ),

                /// The variant `Transport_RestartIceResponse` in the union `Body`
                TransportRestartIceResponse(
                    ::planus::alloc::boxed::Box<super::transport::RestartIceResponse>,
                ),

                /// The variant `PlainTransport_ConnectResponse` in the union `Body`
                PlainTransportConnectResponse(
                    ::planus::alloc::boxed::Box<super::plain_transport::ConnectResponse>,
                ),

                /// The variant `PlainTransport_DumpResponse` in the union `Body`
                PlainTransportDumpResponse(
                    ::planus::alloc::boxed::Box<super::plain_transport::DumpResponse>,
                ),

                /// The variant `PlainTransport_GetStatsResponse` in the union `Body`
                PlainTransportGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::plain_transport::GetStatsResponse>,
                ),

                /// The variant `PipeTransport_ConnectResponse` in the union `Body`
                PipeTransportConnectResponse(
                    ::planus::alloc::boxed::Box<super::pipe_transport::ConnectResponse>,
                ),

                /// The variant `PipeTransport_DumpResponse` in the union `Body`
                PipeTransportDumpResponse(
                    ::planus::alloc::boxed::Box<super::pipe_transport::DumpResponse>,
                ),

                /// The variant `PipeTransport_GetStatsResponse` in the union `Body`
                PipeTransportGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::pipe_transport::GetStatsResponse>,
                ),

                /// The variant `DirectTransport_DumpResponse` in the union `Body`
                DirectTransportDumpResponse(
                    ::planus::alloc::boxed::Box<super::direct_transport::DumpResponse>,
                ),

                /// The variant `DirectTransport_GetStatsResponse` in the union `Body`
                DirectTransportGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::direct_transport::GetStatsResponse>,
                ),

                /// The variant `WebRtcTransport_ConnectResponse` in the union `Body`
                WebRtcTransportConnectResponse(
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::ConnectResponse>,
                ),

                /// The variant `WebRtcTransport_DumpResponse` in the union `Body`
                WebRtcTransportDumpResponse(
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::DumpResponse>,
                ),

                /// The variant `WebRtcTransport_GetStatsResponse` in the union `Body`
                WebRtcTransportGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::GetStatsResponse>,
                ),

                /// The variant `Producer_DumpResponse` in the union `Body`
                ProducerDumpResponse(::planus::alloc::boxed::Box<super::producer::DumpResponse>),

                /// The variant `Producer_GetStatsResponse` in the union `Body`
                ProducerGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::producer::GetStatsResponse>,
                ),

                /// The variant `Consumer_DumpResponse` in the union `Body`
                ConsumerDumpResponse(::planus::alloc::boxed::Box<super::consumer::DumpResponse>),

                /// The variant `Consumer_GetStatsResponse` in the union `Body`
                ConsumerGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::consumer::GetStatsResponse>,
                ),

                /// The variant `Consumer_SetPreferredLayersResponse` in the union `Body`
                ConsumerSetPreferredLayersResponse(
                    ::planus::alloc::boxed::Box<super::consumer::SetPreferredLayersResponse>,
                ),

                /// The variant `Consumer_SetPriorityResponse` in the union `Body`
                ConsumerSetPriorityResponse(
                    ::planus::alloc::boxed::Box<super::consumer::SetPriorityResponse>,
                ),

                /// The variant `DataProducer_DumpResponse` in the union `Body`
                DataProducerDumpResponse(
                    ::planus::alloc::boxed::Box<super::data_producer::DumpResponse>,
                ),

                /// The variant `DataProducer_GetStatsResponse` in the union `Body`
                DataProducerGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::data_producer::GetStatsResponse>,
                ),

                /// The variant `DataConsumer_GetBufferedAmountResponse` in the union `Body`
                DataConsumerGetBufferedAmountResponse(
                    ::planus::alloc::boxed::Box<super::data_consumer::GetBufferedAmountResponse>,
                ),

                /// The variant `DataConsumer_DumpResponse` in the union `Body`
                DataConsumerDumpResponse(
                    ::planus::alloc::boxed::Box<super::data_consumer::DumpResponse>,
                ),

                /// The variant `DataConsumer_GetStatsResponse` in the union `Body`
                DataConsumerGetStatsResponse(
                    ::planus::alloc::boxed::Box<super::data_consumer::GetStatsResponse>,
                ),

                /// The variant `DataConsumer_SetSubchannelsResponse` in the union `Body`
                DataConsumerSetSubchannelsResponse(
                    ::planus::alloc::boxed::Box<super::data_consumer::SetSubchannelsResponse>,
                ),
            }

            impl Body {
                /// Creates a [BodyBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BodyBuilder<::planus::Uninitialized> {
                    BodyBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_worker_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_worker_resource_usage_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::ResourceUsageResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_server_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_server::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_router_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_produce_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ProduceResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_consume_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ConsumeResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_transport_restart_ice_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::RestartIceResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_plain_transport_connect_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::ConnectResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_plain_transport_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_plain_transport_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_pipe_transport_connect_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::pipe_transport::ConnectResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_pipe_transport_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::pipe_transport::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_pipe_transport_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::pipe_transport::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_direct_transport_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::direct_transport::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_direct_transport_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::direct_transport::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_connect_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_transport::ConnectResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_transport::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_web_rtc_transport_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_transport::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::producer::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_producer_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::producer::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(21, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(22, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_set_preferred_layers_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPreferredLayersResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(23, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_consumer_set_priority_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPriorityResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(24, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_producer_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_producer::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(25, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_producer_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_producer::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(26, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_get_buffered_amount_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::GetBufferedAmountResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(27, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(28, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(29, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_data_consumer_set_subchannels_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(30, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::WorkerDumpResponse(value) => {
                            Self::create_worker_dump_response(builder, value)
                        }
                        Self::WorkerResourceUsageResponse(value) => {
                            Self::create_worker_resource_usage_response(builder, value)
                        }
                        Self::WebRtcServerDumpResponse(value) => {
                            Self::create_web_rtc_server_dump_response(builder, value)
                        }
                        Self::RouterDumpResponse(value) => {
                            Self::create_router_dump_response(builder, value)
                        }
                        Self::TransportProduceResponse(value) => {
                            Self::create_transport_produce_response(builder, value)
                        }
                        Self::TransportConsumeResponse(value) => {
                            Self::create_transport_consume_response(builder, value)
                        }
                        Self::TransportRestartIceResponse(value) => {
                            Self::create_transport_restart_ice_response(builder, value)
                        }
                        Self::PlainTransportConnectResponse(value) => {
                            Self::create_plain_transport_connect_response(builder, value)
                        }
                        Self::PlainTransportDumpResponse(value) => {
                            Self::create_plain_transport_dump_response(builder, value)
                        }
                        Self::PlainTransportGetStatsResponse(value) => {
                            Self::create_plain_transport_get_stats_response(builder, value)
                        }
                        Self::PipeTransportConnectResponse(value) => {
                            Self::create_pipe_transport_connect_response(builder, value)
                        }
                        Self::PipeTransportDumpResponse(value) => {
                            Self::create_pipe_transport_dump_response(builder, value)
                        }
                        Self::PipeTransportGetStatsResponse(value) => {
                            Self::create_pipe_transport_get_stats_response(builder, value)
                        }
                        Self::DirectTransportDumpResponse(value) => {
                            Self::create_direct_transport_dump_response(builder, value)
                        }
                        Self::DirectTransportGetStatsResponse(value) => {
                            Self::create_direct_transport_get_stats_response(builder, value)
                        }
                        Self::WebRtcTransportConnectResponse(value) => {
                            Self::create_web_rtc_transport_connect_response(builder, value)
                        }
                        Self::WebRtcTransportDumpResponse(value) => {
                            Self::create_web_rtc_transport_dump_response(builder, value)
                        }
                        Self::WebRtcTransportGetStatsResponse(value) => {
                            Self::create_web_rtc_transport_get_stats_response(builder, value)
                        }
                        Self::ProducerDumpResponse(value) => {
                            Self::create_producer_dump_response(builder, value)
                        }
                        Self::ProducerGetStatsResponse(value) => {
                            Self::create_producer_get_stats_response(builder, value)
                        }
                        Self::ConsumerDumpResponse(value) => {
                            Self::create_consumer_dump_response(builder, value)
                        }
                        Self::ConsumerGetStatsResponse(value) => {
                            Self::create_consumer_get_stats_response(builder, value)
                        }
                        Self::ConsumerSetPreferredLayersResponse(value) => {
                            Self::create_consumer_set_preferred_layers_response(builder, value)
                        }
                        Self::ConsumerSetPriorityResponse(value) => {
                            Self::create_consumer_set_priority_response(builder, value)
                        }
                        Self::DataProducerDumpResponse(value) => {
                            Self::create_data_producer_dump_response(builder, value)
                        }
                        Self::DataProducerGetStatsResponse(value) => {
                            Self::create_data_producer_get_stats_response(builder, value)
                        }
                        Self::DataConsumerGetBufferedAmountResponse(value) => {
                            Self::create_data_consumer_get_buffered_amount_response(builder, value)
                        }
                        Self::DataConsumerDumpResponse(value) => {
                            Self::create_data_consumer_dump_response(builder, value)
                        }
                        Self::DataConsumerGetStatsResponse(value) => {
                            Self::create_data_consumer_get_stats_response(builder, value)
                        }
                        Self::DataConsumerSetSubchannelsResponse(value) => {
                            Self::create_data_consumer_set_subchannels_response(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [Body] type.
            ///
            /// Can be created using the [Body::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BodyBuilder<T>(T);

            impl BodyBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`Worker_DumpResponse` variant](Body#variant.WorkerDumpResponse).
                #[inline]
                pub fn worker_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Worker_ResourceUsageResponse` variant](Body#variant.WorkerResourceUsageResponse).
                #[inline]
                pub fn worker_resource_usage_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<super::worker::ResourceUsageResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcServer_DumpResponse` variant](Body#variant.WebRtcServerDumpResponse).
                #[inline]
                pub fn web_rtc_server_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<super::web_rtc_server::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Router_DumpResponse` variant](Body#variant.RouterDumpResponse).
                #[inline]
                pub fn router_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<super::router::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_ProduceResponse` variant](Body#variant.TransportProduceResponse).
                #[inline]
                pub fn transport_produce_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<5, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::ProduceResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_ConsumeResponse` variant](Body#variant.TransportConsumeResponse).
                #[inline]
                pub fn transport_consume_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<6, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::ConsumeResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Transport_RestartIceResponse` variant](Body#variant.TransportRestartIceResponse).
                #[inline]
                pub fn transport_restart_ice_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<7, T>>
                where
                    T: ::planus::WriteAsOffset<super::transport::RestartIceResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PlainTransport_ConnectResponse` variant](Body#variant.PlainTransportConnectResponse).
                #[inline]
                pub fn plain_transport_connect_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<8, T>>
                where
                    T: ::planus::WriteAsOffset<super::plain_transport::ConnectResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PlainTransport_DumpResponse` variant](Body#variant.PlainTransportDumpResponse).
                #[inline]
                pub fn plain_transport_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<9, T>>
                where
                    T: ::planus::WriteAsOffset<super::plain_transport::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PlainTransport_GetStatsResponse` variant](Body#variant.PlainTransportGetStatsResponse).
                #[inline]
                pub fn plain_transport_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<10, T>>
                where
                    T: ::planus::WriteAsOffset<super::plain_transport::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PipeTransport_ConnectResponse` variant](Body#variant.PipeTransportConnectResponse).
                #[inline]
                pub fn pipe_transport_connect_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<11, T>>
                where
                    T: ::planus::WriteAsOffset<super::pipe_transport::ConnectResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PipeTransport_DumpResponse` variant](Body#variant.PipeTransportDumpResponse).
                #[inline]
                pub fn pipe_transport_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<12, T>>
                where
                    T: ::planus::WriteAsOffset<super::pipe_transport::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PipeTransport_GetStatsResponse` variant](Body#variant.PipeTransportGetStatsResponse).
                #[inline]
                pub fn pipe_transport_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<13, T>>
                where
                    T: ::planus::WriteAsOffset<super::pipe_transport::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DirectTransport_DumpResponse` variant](Body#variant.DirectTransportDumpResponse).
                #[inline]
                pub fn direct_transport_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<14, T>>
                where
                    T: ::planus::WriteAsOffset<super::direct_transport::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DirectTransport_GetStatsResponse` variant](Body#variant.DirectTransportGetStatsResponse).
                #[inline]
                pub fn direct_transport_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<15, T>>
                where
                    T: ::planus::WriteAsOffset<super::direct_transport::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_ConnectResponse` variant](Body#variant.WebRtcTransportConnectResponse).
                #[inline]
                pub fn web_rtc_transport_connect_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<16, T>>
                where
                    T: ::planus::WriteAsOffset<super::web_rtc_transport::ConnectResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_DumpResponse` variant](Body#variant.WebRtcTransportDumpResponse).
                #[inline]
                pub fn web_rtc_transport_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<17, T>>
                where
                    T: ::planus::WriteAsOffset<super::web_rtc_transport::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`WebRtcTransport_GetStatsResponse` variant](Body#variant.WebRtcTransportGetStatsResponse).
                #[inline]
                pub fn web_rtc_transport_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<18, T>>
                where
                    T: ::planus::WriteAsOffset<super::web_rtc_transport::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_DumpResponse` variant](Body#variant.ProducerDumpResponse).
                #[inline]
                pub fn producer_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<19, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Producer_GetStatsResponse` variant](Body#variant.ProducerGetStatsResponse).
                #[inline]
                pub fn producer_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<20, T>>
                where
                    T: ::planus::WriteAsOffset<super::producer::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_DumpResponse` variant](Body#variant.ConsumerDumpResponse).
                #[inline]
                pub fn consumer_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<21, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_GetStatsResponse` variant](Body#variant.ConsumerGetStatsResponse).
                #[inline]
                pub fn consumer_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<22, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_SetPreferredLayersResponse` variant](Body#variant.ConsumerSetPreferredLayersResponse).
                #[inline]
                pub fn consumer_set_preferred_layers_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<23, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::SetPreferredLayersResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Consumer_SetPriorityResponse` variant](Body#variant.ConsumerSetPriorityResponse).
                #[inline]
                pub fn consumer_set_priority_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<24, T>>
                where
                    T: ::planus::WriteAsOffset<super::consumer::SetPriorityResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataProducer_DumpResponse` variant](Body#variant.DataProducerDumpResponse).
                #[inline]
                pub fn data_producer_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<25, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_producer::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataProducer_GetStatsResponse` variant](Body#variant.DataProducerGetStatsResponse).
                #[inline]
                pub fn data_producer_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<26, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_producer::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_GetBufferedAmountResponse` variant](Body#variant.DataConsumerGetBufferedAmountResponse).
                #[inline]
                pub fn data_consumer_get_buffered_amount_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<27, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::GetBufferedAmountResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_DumpResponse` variant](Body#variant.DataConsumerDumpResponse).
                #[inline]
                pub fn data_consumer_dump_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<28, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::DumpResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_GetStatsResponse` variant](Body#variant.DataConsumerGetStatsResponse).
                #[inline]
                pub fn data_consumer_get_stats_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<29, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::GetStatsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`DataConsumer_SetSubchannelsResponse` variant](Body#variant.DataConsumerSetSubchannelsResponse).
                #[inline]
                pub fn data_consumer_set_subchannels_response<T>(
                    self,
                    value: T,
                ) -> BodyBuilder<::planus::Initialized<30, T>>
                where
                    T: ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsResponse>,
                {
                    BodyBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> BodyBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [Body].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body>
                where
                    Self: ::planus::WriteAsUnion<Body>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::ResourceUsageResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<super::worker::ResourceUsageResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_server::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_server::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::router::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<super::router::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ProduceResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ProduceResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ConsumeResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::ConsumeResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::RestartIceResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(7, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<7, T>>
            where
                T: ::planus::WriteAsOffset<super::transport::RestartIceResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::ConnectResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(8, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<8, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::ConnectResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(9, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<9, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(10, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<10, T>>
            where
                T: ::planus::WriteAsOffset<super::plain_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::ConnectResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(11, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<11, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::ConnectResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(12, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<12, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(13, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<13, T>>
            where
                T: ::planus::WriteAsOffset<super::pipe_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<super::direct_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(14, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<14, T>>
            where
                T: ::planus::WriteAsOffset<super::direct_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<super::direct_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(15, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<15, T>>
            where
                T: ::planus::WriteAsOffset<super::direct_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::ConnectResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(16, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<16, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::ConnectResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(17, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<17, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(18, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<18, T>>
            where
                T: ::planus::WriteAsOffset<super::web_rtc_transport::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(19, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<19, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(20, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<20, T>>
            where
                T: ::planus::WriteAsOffset<super::producer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<21, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(21, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<21, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<22, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(22, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<22, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<23, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPreferredLayersResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(23, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<23, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPreferredLayersResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<24, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPriorityResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(24, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<24, T>>
            where
                T: ::planus::WriteAsOffset<super::consumer::SetPriorityResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<25, T>>
            where
                T: ::planus::WriteAsOffset<super::data_producer::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(25, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<25, T>>
            where
                T: ::planus::WriteAsOffset<super::data_producer::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<26, T>>
            where
                T: ::planus::WriteAsOffset<super::data_producer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(26, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<26, T>>
            where
                T: ::planus::WriteAsOffset<super::data_producer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<27, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::GetBufferedAmountResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(27, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<27, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::GetBufferedAmountResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<28, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::DumpResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(28, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<28, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::DumpResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<29, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(29, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<29, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::GetStatsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Body> for BodyBuilder<::planus::Initialized<30, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsResponse>,
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Body> {
                    ::planus::UnionOffset::new(30, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Body> for BodyBuilder<::planus::Initialized<30, T>>
            where
                T: ::planus::WriteAsOffset<super::data_consumer::SetSubchannelsResponse>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Body>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [Body].
            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                WorkerDumpResponse(super::worker::DumpResponseRef<'a>),
                WorkerResourceUsageResponse(super::worker::ResourceUsageResponseRef<'a>),
                WebRtcServerDumpResponse(super::web_rtc_server::DumpResponseRef<'a>),
                RouterDumpResponse(super::router::DumpResponseRef<'a>),
                TransportProduceResponse(super::transport::ProduceResponseRef<'a>),
                TransportConsumeResponse(super::transport::ConsumeResponseRef<'a>),
                TransportRestartIceResponse(super::transport::RestartIceResponseRef<'a>),
                PlainTransportConnectResponse(super::plain_transport::ConnectResponseRef<'a>),
                PlainTransportDumpResponse(super::plain_transport::DumpResponseRef<'a>),
                PlainTransportGetStatsResponse(super::plain_transport::GetStatsResponseRef<'a>),
                PipeTransportConnectResponse(super::pipe_transport::ConnectResponseRef<'a>),
                PipeTransportDumpResponse(super::pipe_transport::DumpResponseRef<'a>),
                PipeTransportGetStatsResponse(super::pipe_transport::GetStatsResponseRef<'a>),
                DirectTransportDumpResponse(super::direct_transport::DumpResponseRef<'a>),
                DirectTransportGetStatsResponse(super::direct_transport::GetStatsResponseRef<'a>),
                WebRtcTransportConnectResponse(super::web_rtc_transport::ConnectResponseRef<'a>),
                WebRtcTransportDumpResponse(super::web_rtc_transport::DumpResponseRef<'a>),
                WebRtcTransportGetStatsResponse(super::web_rtc_transport::GetStatsResponseRef<'a>),
                ProducerDumpResponse(super::producer::DumpResponseRef<'a>),
                ProducerGetStatsResponse(super::producer::GetStatsResponseRef<'a>),
                ConsumerDumpResponse(super::consumer::DumpResponseRef<'a>),
                ConsumerGetStatsResponse(super::consumer::GetStatsResponseRef<'a>),
                ConsumerSetPreferredLayersResponse(
                    super::consumer::SetPreferredLayersResponseRef<'a>,
                ),
                ConsumerSetPriorityResponse(super::consumer::SetPriorityResponseRef<'a>),
                DataProducerDumpResponse(super::data_producer::DumpResponseRef<'a>),
                DataProducerGetStatsResponse(super::data_producer::GetStatsResponseRef<'a>),
                DataConsumerGetBufferedAmountResponse(
                    super::data_consumer::GetBufferedAmountResponseRef<'a>,
                ),
                DataConsumerDumpResponse(super::data_consumer::DumpResponseRef<'a>),
                DataConsumerGetStatsResponse(super::data_consumer::GetStatsResponseRef<'a>),
                DataConsumerSetSubchannelsResponse(
                    super::data_consumer::SetSubchannelsResponseRef<'a>,
                ),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::WorkerDumpResponse(value) => {
                            Self::WorkerDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WorkerResourceUsageResponse(value) => {
                            Self::WorkerResourceUsageResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WebRtcServerDumpResponse(value) => {
                            Self::WebRtcServerDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RouterDumpResponse(value) => {
                            Self::RouterDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportProduceResponse(value) => {
                            Self::TransportProduceResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportConsumeResponse(value) => {
                            Self::TransportConsumeResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TransportRestartIceResponse(value) => {
                            Self::TransportRestartIceResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PlainTransportConnectResponse(value) => {
                            Self::PlainTransportConnectResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PlainTransportDumpResponse(value) => {
                            Self::PlainTransportDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PlainTransportGetStatsResponse(value) => {
                            Self::PlainTransportGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PipeTransportConnectResponse(value) => {
                            Self::PipeTransportConnectResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PipeTransportDumpResponse(value) => {
                            Self::PipeTransportDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::PipeTransportGetStatsResponse(value) => {
                            Self::PipeTransportGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DirectTransportDumpResponse(value) => {
                            Self::DirectTransportDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DirectTransportGetStatsResponse(value) => {
                            Self::DirectTransportGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WebRtcTransportConnectResponse(value) => {
                            Self::WebRtcTransportConnectResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WebRtcTransportDumpResponse(value) => {
                            Self::WebRtcTransportDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::WebRtcTransportGetStatsResponse(value) => {
                            Self::WebRtcTransportGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProducerDumpResponse(value) => {
                            Self::ProducerDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProducerGetStatsResponse(value) => {
                            Self::ProducerGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerDumpResponse(value) => {
                            Self::ConsumerDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerGetStatsResponse(value) => {
                            Self::ConsumerGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumerSetPreferredLayersResponse(value) => {
                            Self::ConsumerSetPreferredLayersResponse(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::ConsumerSetPriorityResponse(value) => {
                            Self::ConsumerSetPriorityResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataProducerDumpResponse(value) => {
                            Self::DataProducerDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataProducerGetStatsResponse(value) => {
                            Self::DataProducerGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerGetBufferedAmountResponse(value) => {
                            Self::DataConsumerGetBufferedAmountResponse(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::DataConsumerDumpResponse(value) => {
                            Self::DataConsumerDumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerGetStatsResponse(value) => {
                            Self::DataConsumerGetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DataConsumerSetSubchannelsResponse(value) => {
                            Self::DataConsumerSetSubchannelsResponse(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::WorkerDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::WorkerResourceUsageResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::WebRtcServerDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::RouterDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::TransportProduceResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(Self::TransportConsumeResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        7 => ::core::result::Result::Ok(Self::TransportRestartIceResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        8 => ::core::result::Result::Ok(Self::PlainTransportConnectResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        9 => ::core::result::Result::Ok(Self::PlainTransportDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        10 => ::core::result::Result::Ok(Self::PlainTransportGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        11 => ::core::result::Result::Ok(Self::PipeTransportConnectResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        12 => ::core::result::Result::Ok(Self::PipeTransportDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        13 => ::core::result::Result::Ok(Self::PipeTransportGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        14 => ::core::result::Result::Ok(Self::DirectTransportDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        15 => ::core::result::Result::Ok(Self::DirectTransportGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        16 => ::core::result::Result::Ok(Self::WebRtcTransportConnectResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        17 => ::core::result::Result::Ok(Self::WebRtcTransportDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        18 => ::core::result::Result::Ok(Self::WebRtcTransportGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        19 => ::core::result::Result::Ok(Self::ProducerDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        20 => ::core::result::Result::Ok(Self::ProducerGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        21 => ::core::result::Result::Ok(Self::ConsumerDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        22 => ::core::result::Result::Ok(Self::ConsumerGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        23 => ::core::result::Result::Ok(Self::ConsumerSetPreferredLayersResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        24 => ::core::result::Result::Ok(Self::ConsumerSetPriorityResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        25 => ::core::result::Result::Ok(Self::DataProducerDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        26 => ::core::result::Result::Ok(Self::DataProducerGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        27 => {
                            ::core::result::Result::Ok(Self::DataConsumerGetBufferedAmountResponse(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        28 => ::core::result::Result::Ok(Self::DataConsumerDumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        29 => ::core::result::Result::Ok(Self::DataConsumerGetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        30 => ::core::result::Result::Ok(Self::DataConsumerSetSubchannelsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Response` in the namespace `FBS.Response`
            ///
            /// Generated from these locations:
            /// * Table `Response` in the file `../worker/fbs/response.fbs:45`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Response {
                /// The field `id` in the table `Response`
                pub id: u32,
                /// The field `accepted` in the table `Response`
                pub accepted: bool,
                /// The field `body` in the table `Response`
                pub body: ::core::option::Option<self::Body>,
                /// The field `error` in the table `Response`
                pub error: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `reason` in the table `Response`
                pub reason: ::core::option::Option<::planus::alloc::string::String>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Response {
                fn default() -> Self {
                    Self {
                        id: 0,
                        accepted: false,
                        body: ::core::default::Default::default(),
                        error: ::core::default::Default::default(),
                        reason: ::core::default::Default::default(),
                    }
                }
            }

            impl Response {
                /// Creates a [ResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ResponseBuilder<()> {
                    ResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_accepted: impl ::planus::WriteAsDefault<bool, bool>,
                    field_body: impl ::planus::WriteAsOptionalUnion<self::Body>,
                    field_error: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_reason: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder, &0);
                    let prepared_accepted = field_accepted.prepare(builder, &false);
                    let prepared_body = field_body.prepare(builder);
                    let prepared_error = field_error.prepare(builder);
                    let prepared_reason = field_reason.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    if prepared_id.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_body.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Body>>(3);
                    }
                    if prepared_error.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(4);
                    }
                    if prepared_reason.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(5);
                    }
                    if prepared_accepted.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }
                    if prepared_body.is_some() {
                        table_writer.write_entry::<u8>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_id) = prepared_id {
                                object_writer.write::<_, _, 4>(&prepared_id);
                            }
                            if let ::core::option::Option::Some(prepared_body) = prepared_body {
                                object_writer.write::<_, _, 4>(&prepared_body.offset());
                            }
                            if let ::core::option::Option::Some(prepared_error) = prepared_error {
                                object_writer.write::<_, _, 4>(&prepared_error);
                            }
                            if let ::core::option::Option::Some(prepared_reason) = prepared_reason {
                                object_writer.write::<_, _, 4>(&prepared_reason);
                            }
                            if let ::core::option::Option::Some(prepared_accepted) =
                                prepared_accepted
                            {
                                object_writer.write::<_, _, 1>(&prepared_accepted);
                            }
                            if let ::core::option::Option::Some(prepared_body) = prepared_body {
                                object_writer.write::<_, _, 1>(&prepared_body.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Response>> for Response {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Response>> for Response {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Response>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Response> for Response {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response> {
                    Response::create(
                        builder,
                        self.id,
                        self.accepted,
                        &self.body,
                        &self.error,
                        &self.reason,
                    )
                }
            }

            /// Builder for serializing an instance of the [Response] type.
            ///
            /// Can be created using the [Response::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ResponseBuilder<State>(State);

            impl ResponseBuilder<()> {
                /// Setter for the [`id` field](Response#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> ResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    ResponseBuilder((value,))
                }

                /// Sets the [`id` field](Response#structfield.id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id_as_default(self) -> ResponseBuilder<(::planus::DefaultValue,)> {
                    self.id(::planus::DefaultValue)
                }
            }

            impl<T0> ResponseBuilder<(T0,)> {
                /// Setter for the [`accepted` field](Response#structfield.accepted).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn accepted<T1>(self, value: T1) -> ResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    ResponseBuilder((v0, value))
                }

                /// Sets the [`accepted` field](Response#structfield.accepted) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn accepted_as_default(self) -> ResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.accepted(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ResponseBuilder<(T0, T1)> {
                /// Setter for the [`body` field](Response#structfield.body).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn body<T2>(self, value: T2) -> ResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                {
                    let (v0, v1) = self.0;
                    ResponseBuilder((v0, v1, value))
                }

                /// Sets the [`body` field](Response#structfield.body) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn body_as_null(self) -> ResponseBuilder<(T0, T1, ())> {
                    self.body(())
                }
            }

            impl<T0, T1, T2> ResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`error` field](Response#structfield.error).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn error<T3>(self, value: T3) -> ResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2) = self.0;
                    ResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`error` field](Response#structfield.error) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn error_as_null(self) -> ResponseBuilder<(T0, T1, T2, ())> {
                    self.error(())
                }
            }

            impl<T0, T1, T2, T3> ResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`reason` field](Response#structfield.reason).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn reason<T4>(self, value: T4) -> ResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`reason` field](Response#structfield.reason) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn reason_as_null(self) -> ResponseBuilder<(T0, T1, T2, T3, ())> {
                    self.reason(())
                }
            }

            impl<T0, T1, T2, T3, T4> ResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Response].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response>
                where
                    Self: ::planus::WriteAsOffset<Response>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAs<::planus::Offset<Response>>
                for ResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<Response>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAsOptional<::planus::Offset<Response>>
                for ResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<Response>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Response>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsOptionalUnion<self::Body>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAsOffset<Response> for ResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    Response::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [Response].
            #[derive(Copy, Clone)]
            pub struct ResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ResponseRef<'a> {
                /// Getter for the [`id` field](Response#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Response", "id")?.unwrap_or(0))
                }

                /// Getter for the [`accepted` field](Response#structfield.accepted).
                #[inline]
                pub fn accepted(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Response", "accepted")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`body` field](Response#structfield.body).
                #[inline]
                pub fn body(&self) -> ::planus::Result<::core::option::Option<self::BodyRef<'a>>> {
                    self.0.access_union(2, "Response", "body")
                }

                /// Getter for the [`error` field](Response#structfield.error).
                #[inline]
                pub fn error(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "Response", "error")
                }

                /// Getter for the [`reason` field](Response#structfield.reason).
                #[inline]
                pub fn reason(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "Response", "reason")
                }
            }

            impl<'a> ::core::fmt::Debug for ResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ResponseRef");
                    f.field("id", &self.id());
                    f.field("accepted", &self.accepted());
                    if let ::core::option::Option::Some(field_body) = self.body().transpose() {
                        f.field("body", &field_body);
                    }
                    if let ::core::option::Option::Some(field_error) = self.error().transpose() {
                        f.field("error", &field_error);
                    }
                    if let ::core::option::Option::Some(field_reason) = self.reason().transpose() {
                        f.field("reason", &field_reason);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ResponseRef<'a>> for Response {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        accepted: ::core::convert::TryInto::try_into(value.accepted()?)?,
                        body: if let ::core::option::Option::Some(body) = value.body()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(body)?)
                        } else {
                            ::core::option::Option::None
                        },
                        error: if let ::core::option::Option::Some(error) = value.error()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(error)?)
                        } else {
                            ::core::option::Option::None
                        },
                        reason: if let ::core::option::Option::Some(reason) = value.reason()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                reason,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Response>> for Response {
                type Value = ::planus::Offset<Response>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Response>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ResponseRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Worker`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/worker.fbs`
        pub mod worker {
            /// The table `ChannelMessageHandlers` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `ChannelMessageHandlers` in the file `../worker/fbs/worker.fbs:5`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ChannelMessageHandlers {
                /// The field `channel_request_handlers` in the table `ChannelMessageHandlers`
                pub channel_request_handlers:
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `channel_notification_handlers` in the table `ChannelMessageHandlers`
                pub channel_notification_handlers:
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            }

            impl ChannelMessageHandlers {
                /// Creates a [ChannelMessageHandlersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ChannelMessageHandlersBuilder<()> {
                    ChannelMessageHandlersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_channel_request_handlers: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_channel_notification_handlers: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_channel_request_handlers =
                        field_channel_request_handlers.prepare(builder);
                    let prepared_channel_notification_handlers =
                        field_channel_notification_handlers.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(0);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_channel_request_handlers);
                            object_writer.write::<_, _, 4>(&prepared_channel_notification_handlers);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ChannelMessageHandlers>> for ChannelMessageHandlers {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ChannelMessageHandlers>>
                for ChannelMessageHandlers
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ChannelMessageHandlers>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ChannelMessageHandlers> for ChannelMessageHandlers {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers> {
                    ChannelMessageHandlers::create(
                        builder,
                        &self.channel_request_handlers,
                        &self.channel_notification_handlers,
                    )
                }
            }

            /// Builder for serializing an instance of the [ChannelMessageHandlers] type.
            ///
            /// Can be created using the [ChannelMessageHandlers::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ChannelMessageHandlersBuilder<State>(State);

            impl ChannelMessageHandlersBuilder<()> {
                /// Setter for the [`channel_request_handlers` field](ChannelMessageHandlers#structfield.channel_request_handlers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn channel_request_handlers<T0>(
                    self,
                    value: T0,
                ) -> ChannelMessageHandlersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    ChannelMessageHandlersBuilder((value,))
                }
            }

            impl<T0> ChannelMessageHandlersBuilder<(T0,)> {
                /// Setter for the [`channel_notification_handlers` field](ChannelMessageHandlers#structfield.channel_notification_handlers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn channel_notification_handlers<T1>(
                    self,
                    value: T1,
                ) -> ChannelMessageHandlersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0,) = self.0;
                    ChannelMessageHandlersBuilder((v0, value))
                }
            }

            impl<T0, T1> ChannelMessageHandlersBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ChannelMessageHandlers].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers>
                where
                    Self: ::planus::WriteAsOffset<ChannelMessageHandlers>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAs<::planus::Offset<ChannelMessageHandlers>>
                for ChannelMessageHandlersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ChannelMessageHandlers>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<ChannelMessageHandlers>>
                for ChannelMessageHandlersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ChannelMessageHandlers>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ChannelMessageHandlers>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAsOffset<ChannelMessageHandlers>
                for ChannelMessageHandlersBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers> {
                    let (v0, v1) = &self.0;
                    ChannelMessageHandlers::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [ChannelMessageHandlers].
            #[derive(Copy, Clone)]
            pub struct ChannelMessageHandlersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ChannelMessageHandlersRef<'a> {
                /// Getter for the [`channel_request_handlers` field](ChannelMessageHandlers#structfield.channel_request_handlers).
                #[inline]
                pub fn channel_request_handlers(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(0, "ChannelMessageHandlers", "channel_request_handlers")
                }

                /// Getter for the [`channel_notification_handlers` field](ChannelMessageHandlers#structfield.channel_notification_handlers).
                #[inline]
                pub fn channel_notification_handlers(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(
                        1,
                        "ChannelMessageHandlers",
                        "channel_notification_handlers",
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ChannelMessageHandlersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ChannelMessageHandlersRef");
                    f.field("channel_request_handlers", &self.channel_request_handlers());
                    f.field(
                        "channel_notification_handlers",
                        &self.channel_notification_handlers(),
                    );
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ChannelMessageHandlersRef<'a>> for ChannelMessageHandlers {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ChannelMessageHandlersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        channel_request_handlers: value
                            .channel_request_handlers()?
                            .to_vec_result()?,
                        channel_notification_handlers: value
                            .channel_notification_handlers()?
                            .to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ChannelMessageHandlersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ChannelMessageHandlersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ChannelMessageHandlersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ChannelMessageHandlers>> for ChannelMessageHandlers {
                type Value = ::planus::Offset<ChannelMessageHandlers>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ChannelMessageHandlers>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ChannelMessageHandlersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ChannelMessageHandlersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/worker.fbs:10`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `pid` in the table `DumpResponse`
                pub pid: u32,
                /// The field `web_rtc_server_ids` in the table `DumpResponse`
                pub web_rtc_server_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `router_ids` in the table `DumpResponse`
                pub router_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `channel_message_handlers` in the table `DumpResponse`
                pub channel_message_handlers:
                    ::planus::alloc::boxed::Box<self::ChannelMessageHandlers>,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_pid: impl ::planus::WriteAsDefault<u32, u32>,
                    field_web_rtc_server_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_router_ids: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    field_channel_message_handlers: impl ::planus::WriteAs<
                        ::planus::Offset<self::ChannelMessageHandlers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_pid = field_pid.prepare(builder, &0);
                    let prepared_web_rtc_server_ids = field_web_rtc_server_ids.prepare(builder);
                    let prepared_router_ids = field_router_ids.prepare(builder);
                    let prepared_channel_message_handlers =
                        field_channel_message_handlers.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_pid.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(1);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(2);
                    table_writer.write_entry::<::planus::Offset<self::ChannelMessageHandlers>>(3);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_pid) = prepared_pid {
                                object_writer.write::<_, _, 4>(&prepared_pid);
                            }
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_server_ids);
                            object_writer.write::<_, _, 4>(&prepared_router_ids);
                            object_writer.write::<_, _, 4>(&prepared_channel_message_handlers);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        self.pid,
                        &self.web_rtc_server_ids,
                        &self.router_ids,
                        &self.channel_message_handlers,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`pid` field](DumpResponse#structfield.pid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn pid<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    DumpResponseBuilder((value,))
                }

                /// Sets the [`pid` field](DumpResponse#structfield.pid) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn pid_as_default(self) -> DumpResponseBuilder<(::planus::DefaultValue,)> {
                    self.pid(::planus::DefaultValue)
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`web_rtc_server_ids` field](DumpResponse#structfield.web_rtc_server_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_server_ids<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`router_ids` field](DumpResponse#structfield.router_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn router_ids<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`channel_message_handlers` field](DumpResponse#structfield.channel_message_handlers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn channel_message_handlers<T3>(
                    self,
                    value: T3,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<self::ChannelMessageHandlers>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<self::ChannelMessageHandlers>>,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<self::ChannelMessageHandlers>>,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<self::ChannelMessageHandlers>>,
                > ::planus::WriteAsOffset<DumpResponse> for DumpResponseBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`pid` field](DumpResponse#structfield.pid).
                #[inline]
                pub fn pid(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "DumpResponse", "pid")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`web_rtc_server_ids` field](DumpResponse#structfield.web_rtc_server_ids).
                #[inline]
                pub fn web_rtc_server_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(1, "DumpResponse", "web_rtc_server_ids")
                }

                /// Getter for the [`router_ids` field](DumpResponse#structfield.router_ids).
                #[inline]
                pub fn router_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(2, "DumpResponse", "router_ids")
                }

                /// Getter for the [`channel_message_handlers` field](DumpResponse#structfield.channel_message_handlers).
                #[inline]
                pub fn channel_message_handlers(
                    &self,
                ) -> ::planus::Result<self::ChannelMessageHandlersRef<'a>> {
                    self.0
                        .access_required(3, "DumpResponse", "channel_message_handlers")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("pid", &self.pid());
                    f.field("web_rtc_server_ids", &self.web_rtc_server_ids());
                    f.field("router_ids", &self.router_ids());
                    f.field("channel_message_handlers", &self.channel_message_handlers());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        pid: ::core::convert::TryInto::try_into(value.pid()?)?,
                        web_rtc_server_ids: value.web_rtc_server_ids()?.to_vec_result()?,
                        router_ids: value.router_ids()?.to_vec_result()?,
                        channel_message_handlers: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.channel_message_handlers()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ResourceUsageResponse` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `ResourceUsageResponse` in the file `../worker/fbs/worker.fbs:17`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ResourceUsageResponse {
                /// The field `ru_utime` in the table `ResourceUsageResponse`
                pub ru_utime: u64,
                /// The field `ru_stime` in the table `ResourceUsageResponse`
                pub ru_stime: u64,
                /// The field `ru_maxrss` in the table `ResourceUsageResponse`
                pub ru_maxrss: u64,
                /// The field `ru_ixrss` in the table `ResourceUsageResponse`
                pub ru_ixrss: u64,
                /// The field `ru_idrss` in the table `ResourceUsageResponse`
                pub ru_idrss: u64,
                /// The field `ru_isrss` in the table `ResourceUsageResponse`
                pub ru_isrss: u64,
                /// The field `ru_minflt` in the table `ResourceUsageResponse`
                pub ru_minflt: u64,
                /// The field `ru_majflt` in the table `ResourceUsageResponse`
                pub ru_majflt: u64,
                /// The field `ru_nswap` in the table `ResourceUsageResponse`
                pub ru_nswap: u64,
                /// The field `ru_inblock` in the table `ResourceUsageResponse`
                pub ru_inblock: u64,
                /// The field `ru_oublock` in the table `ResourceUsageResponse`
                pub ru_oublock: u64,
                /// The field `ru_msgsnd` in the table `ResourceUsageResponse`
                pub ru_msgsnd: u64,
                /// The field `ru_msgrcv` in the table `ResourceUsageResponse`
                pub ru_msgrcv: u64,
                /// The field `ru_nsignals` in the table `ResourceUsageResponse`
                pub ru_nsignals: u64,
                /// The field `ru_nvcsw` in the table `ResourceUsageResponse`
                pub ru_nvcsw: u64,
                /// The field `ru_nivcsw` in the table `ResourceUsageResponse`
                pub ru_nivcsw: u64,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ResourceUsageResponse {
                fn default() -> Self {
                    Self {
                        ru_utime: 0,
                        ru_stime: 0,
                        ru_maxrss: 0,
                        ru_ixrss: 0,
                        ru_idrss: 0,
                        ru_isrss: 0,
                        ru_minflt: 0,
                        ru_majflt: 0,
                        ru_nswap: 0,
                        ru_inblock: 0,
                        ru_oublock: 0,
                        ru_msgsnd: 0,
                        ru_msgrcv: 0,
                        ru_nsignals: 0,
                        ru_nvcsw: 0,
                        ru_nivcsw: 0,
                    }
                }
            }

            impl ResourceUsageResponse {
                /// Creates a [ResourceUsageResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ResourceUsageResponseBuilder<()> {
                    ResourceUsageResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ru_utime: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_stime: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_maxrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_ixrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_idrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_isrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_minflt: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_majflt: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nswap: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_inblock: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_oublock: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_msgsnd: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_msgrcv: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nsignals: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nvcsw: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nivcsw: impl ::planus::WriteAsDefault<u64, u64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ru_utime = field_ru_utime.prepare(builder, &0);
                    let prepared_ru_stime = field_ru_stime.prepare(builder, &0);
                    let prepared_ru_maxrss = field_ru_maxrss.prepare(builder, &0);
                    let prepared_ru_ixrss = field_ru_ixrss.prepare(builder, &0);
                    let prepared_ru_idrss = field_ru_idrss.prepare(builder, &0);
                    let prepared_ru_isrss = field_ru_isrss.prepare(builder, &0);
                    let prepared_ru_minflt = field_ru_minflt.prepare(builder, &0);
                    let prepared_ru_majflt = field_ru_majflt.prepare(builder, &0);
                    let prepared_ru_nswap = field_ru_nswap.prepare(builder, &0);
                    let prepared_ru_inblock = field_ru_inblock.prepare(builder, &0);
                    let prepared_ru_oublock = field_ru_oublock.prepare(builder, &0);
                    let prepared_ru_msgsnd = field_ru_msgsnd.prepare(builder, &0);
                    let prepared_ru_msgrcv = field_ru_msgrcv.prepare(builder, &0);
                    let prepared_ru_nsignals = field_ru_nsignals.prepare(builder, &0);
                    let prepared_ru_nvcsw = field_ru_nvcsw.prepare(builder, &0);
                    let prepared_ru_nivcsw = field_ru_nivcsw.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<36> =
                        ::core::default::Default::default();
                    if prepared_ru_utime.is_some() {
                        table_writer.write_entry::<u64>(0);
                    }
                    if prepared_ru_stime.is_some() {
                        table_writer.write_entry::<u64>(1);
                    }
                    if prepared_ru_maxrss.is_some() {
                        table_writer.write_entry::<u64>(2);
                    }
                    if prepared_ru_ixrss.is_some() {
                        table_writer.write_entry::<u64>(3);
                    }
                    if prepared_ru_idrss.is_some() {
                        table_writer.write_entry::<u64>(4);
                    }
                    if prepared_ru_isrss.is_some() {
                        table_writer.write_entry::<u64>(5);
                    }
                    if prepared_ru_minflt.is_some() {
                        table_writer.write_entry::<u64>(6);
                    }
                    if prepared_ru_majflt.is_some() {
                        table_writer.write_entry::<u64>(7);
                    }
                    if prepared_ru_nswap.is_some() {
                        table_writer.write_entry::<u64>(8);
                    }
                    if prepared_ru_inblock.is_some() {
                        table_writer.write_entry::<u64>(9);
                    }
                    if prepared_ru_oublock.is_some() {
                        table_writer.write_entry::<u64>(10);
                    }
                    if prepared_ru_msgsnd.is_some() {
                        table_writer.write_entry::<u64>(11);
                    }
                    if prepared_ru_msgrcv.is_some() {
                        table_writer.write_entry::<u64>(12);
                    }
                    if prepared_ru_nsignals.is_some() {
                        table_writer.write_entry::<u64>(13);
                    }
                    if prepared_ru_nvcsw.is_some() {
                        table_writer.write_entry::<u64>(14);
                    }
                    if prepared_ru_nivcsw.is_some() {
                        table_writer.write_entry::<u64>(15);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ru_utime) =
                                prepared_ru_utime
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_utime);
                            }
                            if let ::core::option::Option::Some(prepared_ru_stime) =
                                prepared_ru_stime
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_stime);
                            }
                            if let ::core::option::Option::Some(prepared_ru_maxrss) =
                                prepared_ru_maxrss
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_maxrss);
                            }
                            if let ::core::option::Option::Some(prepared_ru_ixrss) =
                                prepared_ru_ixrss
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_ixrss);
                            }
                            if let ::core::option::Option::Some(prepared_ru_idrss) =
                                prepared_ru_idrss
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_idrss);
                            }
                            if let ::core::option::Option::Some(prepared_ru_isrss) =
                                prepared_ru_isrss
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_isrss);
                            }
                            if let ::core::option::Option::Some(prepared_ru_minflt) =
                                prepared_ru_minflt
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_minflt);
                            }
                            if let ::core::option::Option::Some(prepared_ru_majflt) =
                                prepared_ru_majflt
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_majflt);
                            }
                            if let ::core::option::Option::Some(prepared_ru_nswap) =
                                prepared_ru_nswap
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_nswap);
                            }
                            if let ::core::option::Option::Some(prepared_ru_inblock) =
                                prepared_ru_inblock
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_inblock);
                            }
                            if let ::core::option::Option::Some(prepared_ru_oublock) =
                                prepared_ru_oublock
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_oublock);
                            }
                            if let ::core::option::Option::Some(prepared_ru_msgsnd) =
                                prepared_ru_msgsnd
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_msgsnd);
                            }
                            if let ::core::option::Option::Some(prepared_ru_msgrcv) =
                                prepared_ru_msgrcv
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_msgrcv);
                            }
                            if let ::core::option::Option::Some(prepared_ru_nsignals) =
                                prepared_ru_nsignals
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_nsignals);
                            }
                            if let ::core::option::Option::Some(prepared_ru_nvcsw) =
                                prepared_ru_nvcsw
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_nvcsw);
                            }
                            if let ::core::option::Option::Some(prepared_ru_nivcsw) =
                                prepared_ru_nivcsw
                            {
                                object_writer.write::<_, _, 8>(&prepared_ru_nivcsw);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ResourceUsageResponse>> for ResourceUsageResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ResourceUsageResponse>> for ResourceUsageResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ResourceUsageResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ResourceUsageResponse> for ResourceUsageResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse> {
                    ResourceUsageResponse::create(
                        builder,
                        self.ru_utime,
                        self.ru_stime,
                        self.ru_maxrss,
                        self.ru_ixrss,
                        self.ru_idrss,
                        self.ru_isrss,
                        self.ru_minflt,
                        self.ru_majflt,
                        self.ru_nswap,
                        self.ru_inblock,
                        self.ru_oublock,
                        self.ru_msgsnd,
                        self.ru_msgrcv,
                        self.ru_nsignals,
                        self.ru_nvcsw,
                        self.ru_nivcsw,
                    )
                }
            }

            /// Builder for serializing an instance of the [ResourceUsageResponse] type.
            ///
            /// Can be created using the [ResourceUsageResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ResourceUsageResponseBuilder<State>(State);

            impl ResourceUsageResponseBuilder<()> {
                /// Setter for the [`ru_utime` field](ResourceUsageResponse#structfield.ru_utime).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_utime<T0>(self, value: T0) -> ResourceUsageResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u64, u64>,
                {
                    ResourceUsageResponseBuilder((value,))
                }

                /// Sets the [`ru_utime` field](ResourceUsageResponse#structfield.ru_utime) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_utime_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(::planus::DefaultValue,)> {
                    self.ru_utime(::planus::DefaultValue)
                }
            }

            impl<T0> ResourceUsageResponseBuilder<(T0,)> {
                /// Setter for the [`ru_stime` field](ResourceUsageResponse#structfield.ru_stime).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_stime<T1>(self, value: T1) -> ResourceUsageResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0,) = self.0;
                    ResourceUsageResponseBuilder((v0, value))
                }

                /// Sets the [`ru_stime` field](ResourceUsageResponse#structfield.ru_stime) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_stime_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.ru_stime(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ResourceUsageResponseBuilder<(T0, T1)> {
                /// Setter for the [`ru_maxrss` field](ResourceUsageResponse#structfield.ru_maxrss).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_maxrss<T2>(self, value: T2) -> ResourceUsageResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, value))
                }

                /// Sets the [`ru_maxrss` field](ResourceUsageResponse#structfield.ru_maxrss) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_maxrss_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(T0, T1, ::planus::DefaultValue)>
                {
                    self.ru_maxrss(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> ResourceUsageResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`ru_ixrss` field](ResourceUsageResponse#structfield.ru_ixrss).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_ixrss<T3>(
                    self,
                    value: T3,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`ru_ixrss` field](ResourceUsageResponse#structfield.ru_ixrss) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_ixrss_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, ::planus::DefaultValue)>
                {
                    self.ru_ixrss(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> ResourceUsageResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`ru_idrss` field](ResourceUsageResponse#structfield.ru_idrss).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_idrss<T4>(
                    self,
                    value: T4,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`ru_idrss` field](ResourceUsageResponse#structfield.ru_idrss) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_idrss_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.ru_idrss(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`ru_isrss` field](ResourceUsageResponse#structfield.ru_isrss).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_isrss<T5>(
                    self,
                    value: T5,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`ru_isrss` field](ResourceUsageResponse#structfield.ru_isrss) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_isrss_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.ru_isrss(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`ru_minflt` field](ResourceUsageResponse#structfield.ru_minflt).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_minflt<T6>(
                    self,
                    value: T6,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`ru_minflt` field](ResourceUsageResponse#structfield.ru_minflt) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_minflt_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.ru_minflt(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`ru_majflt` field](ResourceUsageResponse#structfield.ru_majflt).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_majflt<T7>(
                    self,
                    value: T7,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`ru_majflt` field](ResourceUsageResponse#structfield.ru_majflt) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_majflt_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    ::planus::DefaultValue,
                )> {
                    self.ru_majflt(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7>
                ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                /// Setter for the [`ru_nswap` field](ResourceUsageResponse#structfield.ru_nswap).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nswap<T8>(
                    self,
                    value: T8,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`ru_nswap` field](ResourceUsageResponse#structfield.ru_nswap) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nswap_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    ::planus::DefaultValue,
                )> {
                    self.ru_nswap(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Setter for the [`ru_inblock` field](ResourceUsageResponse#structfield.ru_inblock).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_inblock<T9>(
                    self,
                    value: T9,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`ru_inblock` field](ResourceUsageResponse#structfield.ru_inblock) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_inblock_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    ::planus::DefaultValue,
                )> {
                    self.ru_inblock(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`ru_oublock` field](ResourceUsageResponse#structfield.ru_oublock).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_oublock<T10>(
                    self,
                    value: T10,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    ResourceUsageResponseBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`ru_oublock` field](ResourceUsageResponse#structfield.ru_oublock) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_oublock_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.ru_oublock(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`ru_msgsnd` field](ResourceUsageResponse#structfield.ru_msgsnd).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_msgsnd<T11>(
                    self,
                    value: T11,
                ) -> ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    ResourceUsageResponseBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value,
                    ))
                }

                /// Sets the [`ru_msgsnd` field](ResourceUsageResponse#structfield.ru_msgsnd) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_msgsnd_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.ru_msgsnd(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                ResourceUsageResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`ru_msgrcv` field](ResourceUsageResponse#structfield.ru_msgrcv).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_msgrcv<T12>(
                    self,
                    value: T12,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                )>
                where
                    T12: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    ResourceUsageResponseBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value,
                    ))
                }

                /// Sets the [`ru_msgrcv` field](ResourceUsageResponse#structfield.ru_msgrcv) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_msgrcv_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.ru_msgrcv(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                )>
            {
                /// Setter for the [`ru_nsignals` field](ResourceUsageResponse#structfield.ru_nsignals).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nsignals<T13>(
                    self,
                    value: T13,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                )>
                where
                    T13: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    ResourceUsageResponseBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value,
                    ))
                }

                /// Sets the [`ru_nsignals` field](ResourceUsageResponse#structfield.ru_nsignals) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nsignals_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.ru_nsignals(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                )>
            {
                /// Setter for the [`ru_nvcsw` field](ResourceUsageResponse#structfield.ru_nvcsw).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nvcsw<T14>(
                    self,
                    value: T14,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    ResourceUsageResponseBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`ru_nvcsw` field](ResourceUsageResponse#structfield.ru_nvcsw) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nvcsw_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    ::planus::DefaultValue,
                )> {
                    self.ru_nvcsw(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`ru_nivcsw` field](ResourceUsageResponse#structfield.ru_nivcsw).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nivcsw<T15>(
                    self,
                    value: T15,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    ResourceUsageResponseBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }

                /// Sets the [`ru_nivcsw` field](ResourceUsageResponse#structfield.ru_nivcsw) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ru_nivcsw_as_default(
                    self,
                ) -> ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    ::planus::DefaultValue,
                )> {
                    self.ru_nivcsw(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ResourceUsageResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse>
                where
                    Self: ::planus::WriteAsOffset<ResourceUsageResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u64, u64>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u64, u64>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u64, u64>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u64, u64>,
                    T13: ::planus::WriteAsDefault<u64, u64>,
                    T14: ::planus::WriteAsDefault<u64, u64>,
                    T15: ::planus::WriteAsDefault<u64, u64>,
                > ::planus::WriteAs<::planus::Offset<ResourceUsageResponse>>
                for ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                type Prepared = ::planus::Offset<ResourceUsageResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u64, u64>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u64, u64>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u64, u64>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u64, u64>,
                    T13: ::planus::WriteAsDefault<u64, u64>,
                    T14: ::planus::WriteAsDefault<u64, u64>,
                    T15: ::planus::WriteAsDefault<u64, u64>,
                > ::planus::WriteAsOptional<::planus::Offset<ResourceUsageResponse>>
                for ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                type Prepared = ::planus::Offset<ResourceUsageResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ResourceUsageResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<u64, u64>,
                    T3: ::planus::WriteAsDefault<u64, u64>,
                    T4: ::planus::WriteAsDefault<u64, u64>,
                    T5: ::planus::WriteAsDefault<u64, u64>,
                    T6: ::planus::WriteAsDefault<u64, u64>,
                    T7: ::planus::WriteAsDefault<u64, u64>,
                    T8: ::planus::WriteAsDefault<u64, u64>,
                    T9: ::planus::WriteAsDefault<u64, u64>,
                    T10: ::planus::WriteAsDefault<u64, u64>,
                    T11: ::planus::WriteAsDefault<u64, u64>,
                    T12: ::planus::WriteAsDefault<u64, u64>,
                    T13: ::planus::WriteAsDefault<u64, u64>,
                    T14: ::planus::WriteAsDefault<u64, u64>,
                    T15: ::planus::WriteAsDefault<u64, u64>,
                > ::planus::WriteAsOffset<ResourceUsageResponse>
                for ResourceUsageResponseBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        &self.0;
                    ResourceUsageResponse::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15,
                    )
                }
            }

            /// Reference to a deserialized [ResourceUsageResponse].
            #[derive(Copy, Clone)]
            pub struct ResourceUsageResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ResourceUsageResponseRef<'a> {
                /// Getter for the [`ru_utime` field](ResourceUsageResponse#structfield.ru_utime).
                #[inline]
                pub fn ru_utime(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ResourceUsageResponse", "ru_utime")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_stime` field](ResourceUsageResponse#structfield.ru_stime).
                #[inline]
                pub fn ru_stime(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ResourceUsageResponse", "ru_stime")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_maxrss` field](ResourceUsageResponse#structfield.ru_maxrss).
                #[inline]
                pub fn ru_maxrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "ResourceUsageResponse", "ru_maxrss")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_ixrss` field](ResourceUsageResponse#structfield.ru_ixrss).
                #[inline]
                pub fn ru_ixrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "ResourceUsageResponse", "ru_ixrss")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_idrss` field](ResourceUsageResponse#structfield.ru_idrss).
                #[inline]
                pub fn ru_idrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ResourceUsageResponse", "ru_idrss")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_isrss` field](ResourceUsageResponse#structfield.ru_isrss).
                #[inline]
                pub fn ru_isrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "ResourceUsageResponse", "ru_isrss")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_minflt` field](ResourceUsageResponse#structfield.ru_minflt).
                #[inline]
                pub fn ru_minflt(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "ResourceUsageResponse", "ru_minflt")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_majflt` field](ResourceUsageResponse#structfield.ru_majflt).
                #[inline]
                pub fn ru_majflt(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "ResourceUsageResponse", "ru_majflt")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_nswap` field](ResourceUsageResponse#structfield.ru_nswap).
                #[inline]
                pub fn ru_nswap(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "ResourceUsageResponse", "ru_nswap")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_inblock` field](ResourceUsageResponse#structfield.ru_inblock).
                #[inline]
                pub fn ru_inblock(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "ResourceUsageResponse", "ru_inblock")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_oublock` field](ResourceUsageResponse#structfield.ru_oublock).
                #[inline]
                pub fn ru_oublock(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "ResourceUsageResponse", "ru_oublock")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_msgsnd` field](ResourceUsageResponse#structfield.ru_msgsnd).
                #[inline]
                pub fn ru_msgsnd(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "ResourceUsageResponse", "ru_msgsnd")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_msgrcv` field](ResourceUsageResponse#structfield.ru_msgrcv).
                #[inline]
                pub fn ru_msgrcv(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "ResourceUsageResponse", "ru_msgrcv")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_nsignals` field](ResourceUsageResponse#structfield.ru_nsignals).
                #[inline]
                pub fn ru_nsignals(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(13, "ResourceUsageResponse", "ru_nsignals")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_nvcsw` field](ResourceUsageResponse#structfield.ru_nvcsw).
                #[inline]
                pub fn ru_nvcsw(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(14, "ResourceUsageResponse", "ru_nvcsw")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`ru_nivcsw` field](ResourceUsageResponse#structfield.ru_nivcsw).
                #[inline]
                pub fn ru_nivcsw(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(15, "ResourceUsageResponse", "ru_nivcsw")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ResourceUsageResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ResourceUsageResponseRef");
                    f.field("ru_utime", &self.ru_utime());
                    f.field("ru_stime", &self.ru_stime());
                    f.field("ru_maxrss", &self.ru_maxrss());
                    f.field("ru_ixrss", &self.ru_ixrss());
                    f.field("ru_idrss", &self.ru_idrss());
                    f.field("ru_isrss", &self.ru_isrss());
                    f.field("ru_minflt", &self.ru_minflt());
                    f.field("ru_majflt", &self.ru_majflt());
                    f.field("ru_nswap", &self.ru_nswap());
                    f.field("ru_inblock", &self.ru_inblock());
                    f.field("ru_oublock", &self.ru_oublock());
                    f.field("ru_msgsnd", &self.ru_msgsnd());
                    f.field("ru_msgrcv", &self.ru_msgrcv());
                    f.field("ru_nsignals", &self.ru_nsignals());
                    f.field("ru_nvcsw", &self.ru_nvcsw());
                    f.field("ru_nivcsw", &self.ru_nivcsw());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ResourceUsageResponseRef<'a>> for ResourceUsageResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ResourceUsageResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ru_utime: ::core::convert::TryInto::try_into(value.ru_utime()?)?,
                        ru_stime: ::core::convert::TryInto::try_into(value.ru_stime()?)?,
                        ru_maxrss: ::core::convert::TryInto::try_into(value.ru_maxrss()?)?,
                        ru_ixrss: ::core::convert::TryInto::try_into(value.ru_ixrss()?)?,
                        ru_idrss: ::core::convert::TryInto::try_into(value.ru_idrss()?)?,
                        ru_isrss: ::core::convert::TryInto::try_into(value.ru_isrss()?)?,
                        ru_minflt: ::core::convert::TryInto::try_into(value.ru_minflt()?)?,
                        ru_majflt: ::core::convert::TryInto::try_into(value.ru_majflt()?)?,
                        ru_nswap: ::core::convert::TryInto::try_into(value.ru_nswap()?)?,
                        ru_inblock: ::core::convert::TryInto::try_into(value.ru_inblock()?)?,
                        ru_oublock: ::core::convert::TryInto::try_into(value.ru_oublock()?)?,
                        ru_msgsnd: ::core::convert::TryInto::try_into(value.ru_msgsnd()?)?,
                        ru_msgrcv: ::core::convert::TryInto::try_into(value.ru_msgrcv()?)?,
                        ru_nsignals: ::core::convert::TryInto::try_into(value.ru_nsignals()?)?,
                        ru_nvcsw: ::core::convert::TryInto::try_into(value.ru_nvcsw()?)?,
                        ru_nivcsw: ::core::convert::TryInto::try_into(value.ru_nivcsw()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ResourceUsageResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ResourceUsageResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ResourceUsageResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ResourceUsageResponse>> for ResourceUsageResponse {
                type Value = ::planus::Offset<ResourceUsageResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ResourceUsageResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ResourceUsageResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ResourceUsageResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `UpdateSettingsRequest` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `UpdateSettingsRequest` in the file `../worker/fbs/worker.fbs:36`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct UpdateSettingsRequest {
                /// The field `log_level` in the table `UpdateSettingsRequest`
                pub log_level: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `log_tags` in the table `UpdateSettingsRequest`
                pub log_tags: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for UpdateSettingsRequest {
                fn default() -> Self {
                    Self {
                        log_level: ::core::default::Default::default(),
                        log_tags: ::core::default::Default::default(),
                    }
                }
            }

            impl UpdateSettingsRequest {
                /// Creates a [UpdateSettingsRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> UpdateSettingsRequestBuilder<()> {
                    UpdateSettingsRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_log_level: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_log_tags: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_log_level = field_log_level.prepare(builder);
                    let prepared_log_tags = field_log_tags.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_log_level.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(0);
                    }
                    if prepared_log_tags.is_some() {
                        table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_log_level) =
                                prepared_log_level
                            {
                                object_writer.write::<_, _, 4>(&prepared_log_level);
                            }
                            if let ::core::option::Option::Some(prepared_log_tags) =
                                prepared_log_tags
                            {
                                object_writer.write::<_, _, 4>(&prepared_log_tags);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<UpdateSettingsRequest>> for UpdateSettingsRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<UpdateSettingsRequest>> for UpdateSettingsRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<UpdateSettingsRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<UpdateSettingsRequest> for UpdateSettingsRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest> {
                    UpdateSettingsRequest::create(builder, &self.log_level, &self.log_tags)
                }
            }

            /// Builder for serializing an instance of the [UpdateSettingsRequest] type.
            ///
            /// Can be created using the [UpdateSettingsRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct UpdateSettingsRequestBuilder<State>(State);

            impl UpdateSettingsRequestBuilder<()> {
                /// Setter for the [`log_level` field](UpdateSettingsRequest#structfield.log_level).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn log_level<T0>(self, value: T0) -> UpdateSettingsRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    UpdateSettingsRequestBuilder((value,))
                }

                /// Sets the [`log_level` field](UpdateSettingsRequest#structfield.log_level) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn log_level_as_null(self) -> UpdateSettingsRequestBuilder<((),)> {
                    self.log_level(())
                }
            }

            impl<T0> UpdateSettingsRequestBuilder<(T0,)> {
                /// Setter for the [`log_tags` field](UpdateSettingsRequest#structfield.log_tags).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn log_tags<T1>(self, value: T1) -> UpdateSettingsRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0,) = self.0;
                    UpdateSettingsRequestBuilder((v0, value))
                }

                /// Sets the [`log_tags` field](UpdateSettingsRequest#structfield.log_tags) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn log_tags_as_null(self) -> UpdateSettingsRequestBuilder<(T0, ())> {
                    self.log_tags(())
                }
            }

            impl<T0, T1> UpdateSettingsRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [UpdateSettingsRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest>
                where
                    Self: ::planus::WriteAsOffset<UpdateSettingsRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAs<::planus::Offset<UpdateSettingsRequest>>
                for UpdateSettingsRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<UpdateSettingsRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<UpdateSettingsRequest>>
                for UpdateSettingsRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<UpdateSettingsRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<UpdateSettingsRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<[::planus::Offset<str>]>>,
                > ::planus::WriteAsOffset<UpdateSettingsRequest>
                for UpdateSettingsRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest> {
                    let (v0, v1) = &self.0;
                    UpdateSettingsRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [UpdateSettingsRequest].
            #[derive(Copy, Clone)]
            pub struct UpdateSettingsRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> UpdateSettingsRequestRef<'a> {
                /// Getter for the [`log_level` field](UpdateSettingsRequest#structfield.log_level).
                #[inline]
                pub fn log_level(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "UpdateSettingsRequest", "log_level")
                }

                /// Getter for the [`log_tags` field](UpdateSettingsRequest#structfield.log_tags).
                #[inline]
                pub fn log_tags(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(1, "UpdateSettingsRequest", "log_tags")
                }
            }

            impl<'a> ::core::fmt::Debug for UpdateSettingsRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("UpdateSettingsRequestRef");
                    if let ::core::option::Option::Some(field_log_level) =
                        self.log_level().transpose()
                    {
                        f.field("log_level", &field_log_level);
                    }
                    if let ::core::option::Option::Some(field_log_tags) =
                        self.log_tags().transpose()
                    {
                        f.field("log_tags", &field_log_tags);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<UpdateSettingsRequestRef<'a>> for UpdateSettingsRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: UpdateSettingsRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        log_level: if let ::core::option::Option::Some(log_level) =
                            value.log_level()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                log_level,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        log_tags: if let ::core::option::Option::Some(log_tags) =
                            value.log_tags()?
                        {
                            ::core::option::Option::Some(log_tags.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for UpdateSettingsRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for UpdateSettingsRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[UpdateSettingsRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<UpdateSettingsRequest>> for UpdateSettingsRequest {
                type Value = ::planus::Offset<UpdateSettingsRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<UpdateSettingsRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for UpdateSettingsRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[UpdateSettingsRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreateWebRtcServerRequest` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `CreateWebRtcServerRequest` in the file `../worker/fbs/worker.fbs:41`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateWebRtcServerRequest {
                /// The field `web_rtc_server_id` in the table `CreateWebRtcServerRequest`
                pub web_rtc_server_id: ::planus::alloc::string::String,
                /// The field `listen_infos` in the table `CreateWebRtcServerRequest`
                pub listen_infos:
                    ::core::option::Option<::planus::alloc::vec::Vec<super::transport::ListenInfo>>,
            }

            impl CreateWebRtcServerRequest {
                /// Creates a [CreateWebRtcServerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreateWebRtcServerRequestBuilder<()> {
                    CreateWebRtcServerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_web_rtc_server_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_listen_infos: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_web_rtc_server_id = field_web_rtc_server_id.prepare(builder);
                    let prepared_listen_infos = field_listen_infos.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_listen_infos.is_some() {
                        table_writer.write_entry::<::planus::Offset<
                            [::planus::Offset<super::transport::ListenInfo>],
                        >>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_server_id);
                            if let ::core::option::Option::Some(prepared_listen_infos) =
                                prepared_listen_infos
                            {
                                object_writer.write::<_, _, 4>(&prepared_listen_infos);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateWebRtcServerRequest>> for CreateWebRtcServerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateWebRtcServerRequest>>
                for CreateWebRtcServerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateWebRtcServerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateWebRtcServerRequest> for CreateWebRtcServerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest> {
                    CreateWebRtcServerRequest::create(
                        builder,
                        &self.web_rtc_server_id,
                        &self.listen_infos,
                    )
                }
            }

            /// Builder for serializing an instance of the [CreateWebRtcServerRequest] type.
            ///
            /// Can be created using the [CreateWebRtcServerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreateWebRtcServerRequestBuilder<State>(State);

            impl CreateWebRtcServerRequestBuilder<()> {
                /// Setter for the [`web_rtc_server_id` field](CreateWebRtcServerRequest#structfield.web_rtc_server_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_server_id<T0>(
                    self,
                    value: T0,
                ) -> CreateWebRtcServerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreateWebRtcServerRequestBuilder((value,))
                }
            }

            impl<T0> CreateWebRtcServerRequestBuilder<(T0,)> {
                /// Setter for the [`listen_infos` field](CreateWebRtcServerRequest#structfield.listen_infos).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn listen_infos<T1>(
                    self,
                    value: T1,
                ) -> CreateWebRtcServerRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                {
                    let (v0,) = self.0;
                    CreateWebRtcServerRequestBuilder((v0, value))
                }

                /// Sets the [`listen_infos` field](CreateWebRtcServerRequest#structfield.listen_infos) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn listen_infos_as_null(self) -> CreateWebRtcServerRequestBuilder<(T0, ())> {
                    self.listen_infos(())
                }
            }

            impl<T0, T1> CreateWebRtcServerRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreateWebRtcServerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest>
                where
                    Self: ::planus::WriteAsOffset<CreateWebRtcServerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<CreateWebRtcServerRequest>>
                for CreateWebRtcServerRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateWebRtcServerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<CreateWebRtcServerRequest>>
                for CreateWebRtcServerRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateWebRtcServerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateWebRtcServerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                > ::planus::WriteAsOffset<CreateWebRtcServerRequest>
                for CreateWebRtcServerRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest> {
                    let (v0, v1) = &self.0;
                    CreateWebRtcServerRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreateWebRtcServerRequest].
            #[derive(Copy, Clone)]
            pub struct CreateWebRtcServerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateWebRtcServerRequestRef<'a> {
                /// Getter for the [`web_rtc_server_id` field](CreateWebRtcServerRequest#structfield.web_rtc_server_id).
                #[inline]
                pub fn web_rtc_server_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateWebRtcServerRequest", "web_rtc_server_id")
                }

                /// Getter for the [`listen_infos` field](CreateWebRtcServerRequest#structfield.listen_infos).
                #[inline]
                pub fn listen_infos(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<super::transport::ListenInfoRef<'a>>>,
                    >,
                > {
                    self.0
                        .access(1, "CreateWebRtcServerRequest", "listen_infos")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateWebRtcServerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateWebRtcServerRequestRef");
                    f.field("web_rtc_server_id", &self.web_rtc_server_id());
                    if let ::core::option::Option::Some(field_listen_infos) =
                        self.listen_infos().transpose()
                    {
                        f.field("listen_infos", &field_listen_infos);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateWebRtcServerRequestRef<'a>> for CreateWebRtcServerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateWebRtcServerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        web_rtc_server_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_server_id()?,
                        )?,
                        listen_infos: if let ::core::option::Option::Some(listen_infos) =
                            value.listen_infos()?
                        {
                            ::core::option::Option::Some(listen_infos.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateWebRtcServerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateWebRtcServerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcServerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateWebRtcServerRequest>>
                for CreateWebRtcServerRequest
            {
                type Value = ::planus::Offset<CreateWebRtcServerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateWebRtcServerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateWebRtcServerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcServerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseWebRtcServerRequest` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `CloseWebRtcServerRequest` in the file `../worker/fbs/worker.fbs:46`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseWebRtcServerRequest {
                /// The field `web_rtc_server_id` in the table `CloseWebRtcServerRequest`
                pub web_rtc_server_id: ::planus::alloc::string::String,
            }

            impl CloseWebRtcServerRequest {
                /// Creates a [CloseWebRtcServerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseWebRtcServerRequestBuilder<()> {
                    CloseWebRtcServerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_web_rtc_server_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_web_rtc_server_id = field_web_rtc_server_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_server_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseWebRtcServerRequest>> for CloseWebRtcServerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseWebRtcServerRequest>>
                for CloseWebRtcServerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseWebRtcServerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseWebRtcServerRequest> for CloseWebRtcServerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest> {
                    CloseWebRtcServerRequest::create(builder, &self.web_rtc_server_id)
                }
            }

            /// Builder for serializing an instance of the [CloseWebRtcServerRequest] type.
            ///
            /// Can be created using the [CloseWebRtcServerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseWebRtcServerRequestBuilder<State>(State);

            impl CloseWebRtcServerRequestBuilder<()> {
                /// Setter for the [`web_rtc_server_id` field](CloseWebRtcServerRequest#structfield.web_rtc_server_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_server_id<T0>(
                    self,
                    value: T0,
                ) -> CloseWebRtcServerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseWebRtcServerRequestBuilder((value,))
                }
            }

            impl<T0> CloseWebRtcServerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseWebRtcServerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseWebRtcServerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseWebRtcServerRequest>>
                for CloseWebRtcServerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseWebRtcServerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseWebRtcServerRequest>>
                for CloseWebRtcServerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseWebRtcServerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseWebRtcServerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseWebRtcServerRequest>
                for CloseWebRtcServerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest> {
                    let (v0,) = &self.0;
                    CloseWebRtcServerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseWebRtcServerRequest].
            #[derive(Copy, Clone)]
            pub struct CloseWebRtcServerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseWebRtcServerRequestRef<'a> {
                /// Getter for the [`web_rtc_server_id` field](CloseWebRtcServerRequest#structfield.web_rtc_server_id).
                #[inline]
                pub fn web_rtc_server_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseWebRtcServerRequest", "web_rtc_server_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseWebRtcServerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseWebRtcServerRequestRef");
                    f.field("web_rtc_server_id", &self.web_rtc_server_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseWebRtcServerRequestRef<'a>> for CloseWebRtcServerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseWebRtcServerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        web_rtc_server_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_server_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseWebRtcServerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseWebRtcServerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseWebRtcServerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseWebRtcServerRequest>>
                for CloseWebRtcServerRequest
            {
                type Value = ::planus::Offset<CloseWebRtcServerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseWebRtcServerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseWebRtcServerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseWebRtcServerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreateRouterRequest` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `CreateRouterRequest` in the file `../worker/fbs/worker.fbs:50`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateRouterRequest {
                /// The field `router_id` in the table `CreateRouterRequest`
                pub router_id: ::planus::alloc::string::String,
            }

            impl CreateRouterRequest {
                /// Creates a [CreateRouterRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreateRouterRequestBuilder<()> {
                    CreateRouterRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_router_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_router_id = field_router_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_router_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateRouterRequest>> for CreateRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateRouterRequest>> for CreateRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateRouterRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateRouterRequest> for CreateRouterRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest> {
                    CreateRouterRequest::create(builder, &self.router_id)
                }
            }

            /// Builder for serializing an instance of the [CreateRouterRequest] type.
            ///
            /// Can be created using the [CreateRouterRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreateRouterRequestBuilder<State>(State);

            impl CreateRouterRequestBuilder<()> {
                /// Setter for the [`router_id` field](CreateRouterRequest#structfield.router_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn router_id<T0>(self, value: T0) -> CreateRouterRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreateRouterRequestBuilder((value,))
                }
            }

            impl<T0> CreateRouterRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreateRouterRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest>
                where
                    Self: ::planus::WriteAsOffset<CreateRouterRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CreateRouterRequest>>
                for CreateRouterRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CreateRouterRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CreateRouterRequest>>
                for CreateRouterRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CreateRouterRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateRouterRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CreateRouterRequest> for CreateRouterRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest> {
                    let (v0,) = &self.0;
                    CreateRouterRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CreateRouterRequest].
            #[derive(Copy, Clone)]
            pub struct CreateRouterRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateRouterRequestRef<'a> {
                /// Getter for the [`router_id` field](CreateRouterRequest#structfield.router_id).
                #[inline]
                pub fn router_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateRouterRequest", "router_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateRouterRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateRouterRequestRef");
                    f.field("router_id", &self.router_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateRouterRequestRef<'a>> for CreateRouterRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateRouterRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        router_id: ::core::convert::TryInto::try_into(value.router_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateRouterRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateRouterRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateRouterRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateRouterRequest>> for CreateRouterRequest {
                type Value = ::planus::Offset<CreateRouterRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateRouterRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateRouterRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateRouterRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseRouterRequest` in the namespace `FBS.Worker`
            ///
            /// Generated from these locations:
            /// * Table `CloseRouterRequest` in the file `../worker/fbs/worker.fbs:54`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseRouterRequest {
                /// The field `router_id` in the table `CloseRouterRequest`
                pub router_id: ::planus::alloc::string::String,
            }

            impl CloseRouterRequest {
                /// Creates a [CloseRouterRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseRouterRequestBuilder<()> {
                    CloseRouterRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_router_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_router_id = field_router_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_router_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseRouterRequest>> for CloseRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseRouterRequest>> for CloseRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseRouterRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseRouterRequest> for CloseRouterRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest> {
                    CloseRouterRequest::create(builder, &self.router_id)
                }
            }

            /// Builder for serializing an instance of the [CloseRouterRequest] type.
            ///
            /// Can be created using the [CloseRouterRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseRouterRequestBuilder<State>(State);

            impl CloseRouterRequestBuilder<()> {
                /// Setter for the [`router_id` field](CloseRouterRequest#structfield.router_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn router_id<T0>(self, value: T0) -> CloseRouterRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseRouterRequestBuilder((value,))
                }
            }

            impl<T0> CloseRouterRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseRouterRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseRouterRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseRouterRequest>>
                for CloseRouterRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseRouterRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseRouterRequest>>
                for CloseRouterRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseRouterRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseRouterRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseRouterRequest> for CloseRouterRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest> {
                    let (v0,) = &self.0;
                    CloseRouterRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseRouterRequest].
            #[derive(Copy, Clone)]
            pub struct CloseRouterRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseRouterRequestRef<'a> {
                /// Getter for the [`router_id` field](CloseRouterRequest#structfield.router_id).
                #[inline]
                pub fn router_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "CloseRouterRequest", "router_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseRouterRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseRouterRequestRef");
                    f.field("router_id", &self.router_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseRouterRequestRef<'a>> for CloseRouterRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseRouterRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        router_id: ::core::convert::TryInto::try_into(value.router_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseRouterRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseRouterRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseRouterRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseRouterRequest>> for CloseRouterRequest {
                type Value = ::planus::Offset<CloseRouterRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseRouterRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseRouterRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[CloseRouterRequestRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Router`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/router.fbs`
        pub mod router {
            /// The table `DumpResponse` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/router.fbs:12`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `id` in the table `DumpResponse`
                pub id: ::planus::alloc::string::String,
                /// The field `transport_ids` in the table `DumpResponse`
                pub transport_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `rtp_observer_ids` in the table `DumpResponse`
                pub rtp_observer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `map_producer_id_consumer_ids` in the table `DumpResponse`
                pub map_producer_id_consumer_ids:
                    ::planus::alloc::vec::Vec<super::common::StringStringArray>,
                /// The field `map_consumer_id_producer_id` in the table `DumpResponse`
                pub map_consumer_id_producer_id:
                    ::planus::alloc::vec::Vec<super::common::StringString>,
                /// The field `map_producer_id_observer_ids` in the table `DumpResponse`
                pub map_producer_id_observer_ids:
                    ::planus::alloc::vec::Vec<super::common::StringStringArray>,
                /// The field `map_data_producer_id_data_consumer_ids` in the table `DumpResponse`
                pub map_data_producer_id_data_consumer_ids:
                    ::planus::alloc::vec::Vec<super::common::StringStringArray>,
                /// The field `map_data_consumer_id_data_producer_id` in the table `DumpResponse`
                pub map_data_consumer_id_data_producer_id:
                    ::planus::alloc::vec::Vec<super::common::StringString>,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_transport_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_rtp_observer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_map_producer_id_consumer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    field_map_consumer_id_producer_id: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    field_map_producer_id_observer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    field_map_data_producer_id_data_consumer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    field_map_data_consumer_id_data_producer_id: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_transport_ids = field_transport_ids.prepare(builder);
                    let prepared_rtp_observer_ids = field_rtp_observer_ids.prepare(builder);
                    let prepared_map_producer_id_consumer_ids =
                        field_map_producer_id_consumer_ids.prepare(builder);
                    let prepared_map_consumer_id_producer_id =
                        field_map_consumer_id_producer_id.prepare(builder);
                    let prepared_map_producer_id_observer_ids =
                        field_map_producer_id_observer_ids.prepare(builder);
                    let prepared_map_data_producer_id_data_consumer_ids =
                        field_map_data_producer_id_data_consumer_ids.prepare(builder);
                    let prepared_map_data_consumer_id_data_producer_id =
                        field_map_data_consumer_id_data_producer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(1);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(2);
                    table_writer.write_entry::<::planus::Offset<
                        [::planus::Offset<super::common::StringStringArray>],
                    >>(3);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::StringString>]>>(4);
                    table_writer.write_entry::<::planus::Offset<
                        [::planus::Offset<super::common::StringStringArray>],
                    >>(5);
                    table_writer.write_entry::<::planus::Offset<
                        [::planus::Offset<super::common::StringStringArray>],
                    >>(6);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::common::StringString>]>>(7);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            object_writer.write::<_, _, 4>(&prepared_transport_ids);
                            object_writer.write::<_, _, 4>(&prepared_rtp_observer_ids);
                            object_writer.write::<_, _, 4>(&prepared_map_producer_id_consumer_ids);
                            object_writer.write::<_, _, 4>(&prepared_map_consumer_id_producer_id);
                            object_writer.write::<_, _, 4>(&prepared_map_producer_id_observer_ids);
                            object_writer
                                .write::<_, _, 4>(&prepared_map_data_producer_id_data_consumer_ids);
                            object_writer
                                .write::<_, _, 4>(&prepared_map_data_consumer_id_data_producer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.transport_ids,
                        &self.rtp_observer_ids,
                        &self.map_producer_id_consumer_ids,
                        &self.map_consumer_id_producer_id,
                        &self.map_producer_id_observer_ids,
                        &self.map_data_producer_id_data_consumer_ids,
                        &self.map_data_consumer_id_data_producer_id,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`transport_ids` field](DumpResponse#structfield.transport_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_ids<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`rtp_observer_ids` field](DumpResponse#structfield.rtp_observer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_observer_ids<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`map_producer_id_consumer_ids` field](DumpResponse#structfield.map_producer_id_consumer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_producer_id_consumer_ids<T3>(
                    self,
                    value: T3,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`map_consumer_id_producer_id` field](DumpResponse#structfield.map_consumer_id_producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_consumer_id_producer_id<T4>(
                    self,
                    value: T4,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`map_producer_id_observer_ids` field](DumpResponse#structfield.map_producer_id_observer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_producer_id_observer_ids<T5>(
                    self,
                    value: T5,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`map_data_producer_id_data_consumer_ids` field](DumpResponse#structfield.map_data_producer_id_data_consumer_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_data_producer_id_data_consumer_ids<T6>(
                    self,
                    value: T6,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`map_data_consumer_id_data_producer_id` field](DumpResponse#structfield.map_data_consumer_id_data_producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn map_data_consumer_id_data_producer_id<T7>(
                    self,
                    value: T7,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T6: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T7: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T6: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T7: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T3: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T6: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    T7: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                /// Getter for the [`transport_ids` field](DumpResponse#structfield.transport_ids).
                #[inline]
                pub fn transport_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(1, "DumpResponse", "transport_ids")
                }

                /// Getter for the [`rtp_observer_ids` field](DumpResponse#structfield.rtp_observer_ids).
                #[inline]
                pub fn rtp_observer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(2, "DumpResponse", "rtp_observer_ids")
                }

                /// Getter for the [`map_producer_id_consumer_ids` field](DumpResponse#structfield.map_producer_id_consumer_ids).
                #[inline]
                pub fn map_producer_id_consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringArrayRef<'a>>>,
                > {
                    self.0
                        .access_required(3, "DumpResponse", "map_producer_id_consumer_ids")
                }

                /// Getter for the [`map_consumer_id_producer_id` field](DumpResponse#structfield.map_consumer_id_producer_id).
                #[inline]
                pub fn map_consumer_id_producer_id(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                > {
                    self.0
                        .access_required(4, "DumpResponse", "map_consumer_id_producer_id")
                }

                /// Getter for the [`map_producer_id_observer_ids` field](DumpResponse#structfield.map_producer_id_observer_ids).
                #[inline]
                pub fn map_producer_id_observer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringArrayRef<'a>>>,
                > {
                    self.0
                        .access_required(5, "DumpResponse", "map_producer_id_observer_ids")
                }

                /// Getter for the [`map_data_producer_id_data_consumer_ids` field](DumpResponse#structfield.map_data_producer_id_data_consumer_ids).
                #[inline]
                pub fn map_data_producer_id_data_consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringArrayRef<'a>>>,
                > {
                    self.0.access_required(
                        6,
                        "DumpResponse",
                        "map_data_producer_id_data_consumer_ids",
                    )
                }

                /// Getter for the [`map_data_consumer_id_data_producer_id` field](DumpResponse#structfield.map_data_consumer_id_data_producer_id).
                #[inline]
                pub fn map_data_consumer_id_data_producer_id(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                > {
                    self.0.access_required(
                        7,
                        "DumpResponse",
                        "map_data_consumer_id_data_producer_id",
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("transport_ids", &self.transport_ids());
                    f.field("rtp_observer_ids", &self.rtp_observer_ids());
                    f.field(
                        "map_producer_id_consumer_ids",
                        &self.map_producer_id_consumer_ids(),
                    );
                    f.field(
                        "map_consumer_id_producer_id",
                        &self.map_consumer_id_producer_id(),
                    );
                    f.field(
                        "map_producer_id_observer_ids",
                        &self.map_producer_id_observer_ids(),
                    );
                    f.field(
                        "map_data_producer_id_data_consumer_ids",
                        &self.map_data_producer_id_data_consumer_ids(),
                    );
                    f.field(
                        "map_data_consumer_id_data_producer_id",
                        &self.map_data_consumer_id_data_producer_id(),
                    );
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        transport_ids: value.transport_ids()?.to_vec_result()?,
                        rtp_observer_ids: value.rtp_observer_ids()?.to_vec_result()?,
                        map_producer_id_consumer_ids: value
                            .map_producer_id_consumer_ids()?
                            .to_vec_result()?,
                        map_consumer_id_producer_id: value
                            .map_consumer_id_producer_id()?
                            .to_vec_result()?,
                        map_producer_id_observer_ids: value
                            .map_producer_id_observer_ids()?
                            .to_vec_result()?,
                        map_data_producer_id_data_consumer_ids: value
                            .map_data_producer_id_data_consumer_ids()?
                            .to_vec_result()?,
                        map_data_consumer_id_data_producer_id: value
                            .map_data_consumer_id_data_producer_id()?
                            .to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `CreatePipeTransportRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CreatePipeTransportRequest` in the file `../worker/fbs/router.fbs:23`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreatePipeTransportRequest {
                /// The field `transport_id` in the table `CreatePipeTransportRequest`
                pub transport_id: ::planus::alloc::string::String,
                /// The field `options` in the table `CreatePipeTransportRequest`
                pub options:
                    ::planus::alloc::boxed::Box<super::pipe_transport::PipeTransportOptions>,
            }

            impl CreatePipeTransportRequest {
                /// Creates a [CreatePipeTransportRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreatePipeTransportRequestBuilder<()> {
                    CreatePipeTransportRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::pipe_transport::PipeTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);
                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<super::pipe_transport::PipeTransportOptions>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_transport_id);
                            object_writer.write::<_, _, 4>(&prepared_options);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreatePipeTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreatePipeTransportRequest> for CreatePipeTransportRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest> {
                    CreatePipeTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            /// Builder for serializing an instance of the [CreatePipeTransportRequest] type.
            ///
            /// Can be created using the [CreatePipeTransportRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreatePipeTransportRequestBuilder<State>(State);

            impl CreatePipeTransportRequestBuilder<()> {
                /// Setter for the [`transport_id` field](CreatePipeTransportRequest#structfield.transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_id<T0>(self, value: T0) -> CreatePipeTransportRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreatePipeTransportRequestBuilder((value,))
                }
            }

            impl<T0> CreatePipeTransportRequestBuilder<(T0,)> {
                /// Setter for the [`options` field](CreatePipeTransportRequest#structfield.options).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn options<T1>(self, value: T1) -> CreatePipeTransportRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::pipe_transport::PipeTransportOptions>,
                    >,
                {
                    let (v0,) = self.0;
                    CreatePipeTransportRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> CreatePipeTransportRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreatePipeTransportRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest>
                where
                    Self: ::planus::WriteAsOffset<CreatePipeTransportRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::pipe_transport::PipeTransportOptions>,
                    >,
                > ::planus::WriteAs<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreatePipeTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::pipe_transport::PipeTransportOptions>,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreatePipeTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreatePipeTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::pipe_transport::PipeTransportOptions>,
                    >,
                > ::planus::WriteAsOffset<CreatePipeTransportRequest>
                for CreatePipeTransportRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest> {
                    let (v0, v1) = &self.0;
                    CreatePipeTransportRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreatePipeTransportRequest].
            #[derive(Copy, Clone)]
            pub struct CreatePipeTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreatePipeTransportRequestRef<'a> {
                /// Getter for the [`transport_id` field](CreatePipeTransportRequest#structfield.transport_id).
                #[inline]
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreatePipeTransportRequest", "transport_id")
                }

                /// Getter for the [`options` field](CreatePipeTransportRequest#structfield.options).
                #[inline]
                pub fn options(
                    &self,
                ) -> ::planus::Result<super::pipe_transport::PipeTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreatePipeTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreatePipeTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreatePipeTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreatePipeTransportRequestRef<'a>>
                for CreatePipeTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreatePipeTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreatePipeTransportRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreatePipeTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePipeTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequest
            {
                type Value = ::planus::Offset<CreatePipeTransportRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreatePipeTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreatePipeTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePipeTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreatePlainTransportRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CreatePlainTransportRequest` in the file `../worker/fbs/router.fbs:28`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreatePlainTransportRequest {
                /// The field `transport_id` in the table `CreatePlainTransportRequest`
                pub transport_id: ::planus::alloc::string::String,
                /// The field `options` in the table `CreatePlainTransportRequest`
                pub options:
                    ::planus::alloc::boxed::Box<super::plain_transport::PlainTransportOptions>,
            }

            impl CreatePlainTransportRequest {
                /// Creates a [CreatePlainTransportRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreatePlainTransportRequestBuilder<()> {
                    CreatePlainTransportRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::plain_transport::PlainTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);
                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<super::plain_transport::PlainTransportOptions>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_transport_id);
                            object_writer.write::<_, _, 4>(&prepared_options);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreatePlainTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreatePlainTransportRequest> for CreatePlainTransportRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest> {
                    CreatePlainTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            /// Builder for serializing an instance of the [CreatePlainTransportRequest] type.
            ///
            /// Can be created using the [CreatePlainTransportRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreatePlainTransportRequestBuilder<State>(State);

            impl CreatePlainTransportRequestBuilder<()> {
                /// Setter for the [`transport_id` field](CreatePlainTransportRequest#structfield.transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_id<T0>(
                    self,
                    value: T0,
                ) -> CreatePlainTransportRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreatePlainTransportRequestBuilder((value,))
                }
            }

            impl<T0> CreatePlainTransportRequestBuilder<(T0,)> {
                /// Setter for the [`options` field](CreatePlainTransportRequest#structfield.options).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn options<T1>(self, value: T1) -> CreatePlainTransportRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::plain_transport::PlainTransportOptions>,
                    >,
                {
                    let (v0,) = self.0;
                    CreatePlainTransportRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> CreatePlainTransportRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreatePlainTransportRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest>
                where
                    Self: ::planus::WriteAsOffset<CreatePlainTransportRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::plain_transport::PlainTransportOptions>,
                    >,
                > ::planus::WriteAs<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreatePlainTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::plain_transport::PlainTransportOptions>,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreatePlainTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreatePlainTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::plain_transport::PlainTransportOptions>,
                    >,
                > ::planus::WriteAsOffset<CreatePlainTransportRequest>
                for CreatePlainTransportRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest> {
                    let (v0, v1) = &self.0;
                    CreatePlainTransportRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreatePlainTransportRequest].
            #[derive(Copy, Clone)]
            pub struct CreatePlainTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreatePlainTransportRequestRef<'a> {
                /// Getter for the [`transport_id` field](CreatePlainTransportRequest#structfield.transport_id).
                #[inline]
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreatePlainTransportRequest", "transport_id")
                }

                /// Getter for the [`options` field](CreatePlainTransportRequest#structfield.options).
                #[inline]
                pub fn options(
                    &self,
                ) -> ::planus::Result<super::plain_transport::PlainTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreatePlainTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreatePlainTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreatePlainTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreatePlainTransportRequestRef<'a>>
                for CreatePlainTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreatePlainTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreatePlainTransportRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreatePlainTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePlainTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequest
            {
                type Value = ::planus::Offset<CreatePlainTransportRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreatePlainTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreatePlainTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePlainTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreateWebRtcTransportRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CreateWebRtcTransportRequest` in the file `../worker/fbs/router.fbs:33`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateWebRtcTransportRequest {
                /// The field `transport_id` in the table `CreateWebRtcTransportRequest`
                pub transport_id: ::planus::alloc::string::String,
                /// The field `options` in the table `CreateWebRtcTransportRequest`
                pub options:
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::WebRtcTransportOptions>,
            }

            impl CreateWebRtcTransportRequest {
                /// Creates a [CreateWebRtcTransportRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreateWebRtcTransportRequestBuilder<()> {
                    CreateWebRtcTransportRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);
                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_transport_id);
                            object_writer.write::<_, _, 4>(&prepared_options);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateWebRtcTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateWebRtcTransportRequest> for CreateWebRtcTransportRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest> {
                    CreateWebRtcTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            /// Builder for serializing an instance of the [CreateWebRtcTransportRequest] type.
            ///
            /// Can be created using the [CreateWebRtcTransportRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreateWebRtcTransportRequestBuilder<State>(State);

            impl CreateWebRtcTransportRequestBuilder<()> {
                /// Setter for the [`transport_id` field](CreateWebRtcTransportRequest#structfield.transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_id<T0>(
                    self,
                    value: T0,
                ) -> CreateWebRtcTransportRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreateWebRtcTransportRequestBuilder((value,))
                }
            }

            impl<T0> CreateWebRtcTransportRequestBuilder<(T0,)> {
                /// Setter for the [`options` field](CreateWebRtcTransportRequest#structfield.options).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn options<T1>(self, value: T1) -> CreateWebRtcTransportRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>,
                    >,
                {
                    let (v0,) = self.0;
                    CreateWebRtcTransportRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> CreateWebRtcTransportRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreateWebRtcTransportRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest>
                where
                    Self: ::planus::WriteAsOffset<CreateWebRtcTransportRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>,
                    >,
                > ::planus::WriteAs<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateWebRtcTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateWebRtcTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateWebRtcTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>,
                    >,
                > ::planus::WriteAsOffset<CreateWebRtcTransportRequest>
                for CreateWebRtcTransportRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest> {
                    let (v0, v1) = &self.0;
                    CreateWebRtcTransportRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreateWebRtcTransportRequest].
            #[derive(Copy, Clone)]
            pub struct CreateWebRtcTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateWebRtcTransportRequestRef<'a> {
                /// Getter for the [`transport_id` field](CreateWebRtcTransportRequest#structfield.transport_id).
                #[inline]
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateWebRtcTransportRequest", "transport_id")
                }

                /// Getter for the [`options` field](CreateWebRtcTransportRequest#structfield.options).
                #[inline]
                pub fn options(
                    &self,
                ) -> ::planus::Result<super::web_rtc_transport::WebRtcTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreateWebRtcTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateWebRtcTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateWebRtcTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateWebRtcTransportRequestRef<'a>>
                for CreateWebRtcTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateWebRtcTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateWebRtcTransportRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateWebRtcTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequest
            {
                type Value = ::planus::Offset<CreateWebRtcTransportRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateWebRtcTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateWebRtcTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreateDirectTransportRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CreateDirectTransportRequest` in the file `../worker/fbs/router.fbs:38`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateDirectTransportRequest {
                /// The field `transport_id` in the table `CreateDirectTransportRequest`
                pub transport_id: ::planus::alloc::string::String,
                /// The field `options` in the table `CreateDirectTransportRequest`
                pub options:
                    ::planus::alloc::boxed::Box<super::direct_transport::DirectTransportOptions>,
            }

            impl CreateDirectTransportRequest {
                /// Creates a [CreateDirectTransportRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreateDirectTransportRequestBuilder<()> {
                    CreateDirectTransportRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::direct_transport::DirectTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);
                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<super::direct_transport::DirectTransportOptions>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_transport_id);
                            object_writer.write::<_, _, 4>(&prepared_options);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateDirectTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateDirectTransportRequest> for CreateDirectTransportRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest> {
                    CreateDirectTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            /// Builder for serializing an instance of the [CreateDirectTransportRequest] type.
            ///
            /// Can be created using the [CreateDirectTransportRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreateDirectTransportRequestBuilder<State>(State);

            impl CreateDirectTransportRequestBuilder<()> {
                /// Setter for the [`transport_id` field](CreateDirectTransportRequest#structfield.transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_id<T0>(
                    self,
                    value: T0,
                ) -> CreateDirectTransportRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreateDirectTransportRequestBuilder((value,))
                }
            }

            impl<T0> CreateDirectTransportRequestBuilder<(T0,)> {
                /// Setter for the [`options` field](CreateDirectTransportRequest#structfield.options).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn options<T1>(self, value: T1) -> CreateDirectTransportRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::direct_transport::DirectTransportOptions>,
                    >,
                {
                    let (v0,) = self.0;
                    CreateDirectTransportRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> CreateDirectTransportRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreateDirectTransportRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest>
                where
                    Self: ::planus::WriteAsOffset<CreateDirectTransportRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::direct_transport::DirectTransportOptions>,
                    >,
                > ::planus::WriteAs<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateDirectTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::direct_transport::DirectTransportOptions>,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateDirectTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateDirectTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::direct_transport::DirectTransportOptions>,
                    >,
                > ::planus::WriteAsOffset<CreateDirectTransportRequest>
                for CreateDirectTransportRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest> {
                    let (v0, v1) = &self.0;
                    CreateDirectTransportRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreateDirectTransportRequest].
            #[derive(Copy, Clone)]
            pub struct CreateDirectTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateDirectTransportRequestRef<'a> {
                /// Getter for the [`transport_id` field](CreateDirectTransportRequest#structfield.transport_id).
                #[inline]
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateDirectTransportRequest", "transport_id")
                }

                /// Getter for the [`options` field](CreateDirectTransportRequest#structfield.options).
                #[inline]
                pub fn options(
                    &self,
                ) -> ::planus::Result<super::direct_transport::DirectTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreateDirectTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateDirectTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateDirectTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateDirectTransportRequestRef<'a>>
                for CreateDirectTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateDirectTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateDirectTransportRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateDirectTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateDirectTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequest
            {
                type Value = ::planus::Offset<CreateDirectTransportRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateDirectTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateDirectTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateDirectTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreateAudioLevelObserverRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CreateAudioLevelObserverRequest` in the file `../worker/fbs/router.fbs:43`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateAudioLevelObserverRequest {
                /// The field `rtp_observer_id` in the table `CreateAudioLevelObserverRequest`
                pub rtp_observer_id: ::planus::alloc::string::String,
                /// The field `options` in the table `CreateAudioLevelObserverRequest`
                pub options: ::planus::alloc::boxed::Box<
                    super::audio_level_observer::AudioLevelObserverOptions,
                >,
            }

            impl CreateAudioLevelObserverRequest {
                /// Creates a [CreateAudioLevelObserverRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreateAudioLevelObserverRequestBuilder<()> {
                    CreateAudioLevelObserverRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_observer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::audio_level_observer::AudioLevelObserverOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_observer_id = field_rtp_observer_id.prepare(builder);
                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<
                        super::audio_level_observer::AudioLevelObserverOptions,
                    >>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_observer_id);
                            object_writer.write::<_, _, 4>(&prepared_options);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateAudioLevelObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateAudioLevelObserverRequest> for CreateAudioLevelObserverRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest> {
                    CreateAudioLevelObserverRequest::create(
                        builder,
                        &self.rtp_observer_id,
                        &self.options,
                    )
                }
            }

            /// Builder for serializing an instance of the [CreateAudioLevelObserverRequest] type.
            ///
            /// Can be created using the [CreateAudioLevelObserverRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreateAudioLevelObserverRequestBuilder<State>(State);

            impl CreateAudioLevelObserverRequestBuilder<()> {
                /// Setter for the [`rtp_observer_id` field](CreateAudioLevelObserverRequest#structfield.rtp_observer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_observer_id<T0>(
                    self,
                    value: T0,
                ) -> CreateAudioLevelObserverRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreateAudioLevelObserverRequestBuilder((value,))
                }
            }

            impl<T0> CreateAudioLevelObserverRequestBuilder<(T0,)> {
                /// Setter for the [`options` field](CreateAudioLevelObserverRequest#structfield.options).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn options<T1>(
                    self,
                    value: T1,
                ) -> CreateAudioLevelObserverRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::audio_level_observer::AudioLevelObserverOptions>,
                    >,
                {
                    let (v0,) = self.0;
                    CreateAudioLevelObserverRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> CreateAudioLevelObserverRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreateAudioLevelObserverRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest>
                where
                    Self: ::planus::WriteAsOffset<CreateAudioLevelObserverRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::audio_level_observer::AudioLevelObserverOptions>,
                    >,
                > ::planus::WriteAs<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateAudioLevelObserverRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::audio_level_observer::AudioLevelObserverOptions>,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateAudioLevelObserverRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateAudioLevelObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<super::audio_level_observer::AudioLevelObserverOptions>,
                    >,
                > ::planus::WriteAsOffset<CreateAudioLevelObserverRequest>
                for CreateAudioLevelObserverRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest> {
                    let (v0, v1) = &self.0;
                    CreateAudioLevelObserverRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreateAudioLevelObserverRequest].
            #[derive(Copy, Clone)]
            pub struct CreateAudioLevelObserverRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateAudioLevelObserverRequestRef<'a> {
                /// Getter for the [`rtp_observer_id` field](CreateAudioLevelObserverRequest#structfield.rtp_observer_id).
                #[inline]
                pub fn rtp_observer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateAudioLevelObserverRequest", "rtp_observer_id")
                }

                /// Getter for the [`options` field](CreateAudioLevelObserverRequest#structfield.options).
                #[inline]
                pub fn options(
                    &self,
                ) -> ::planus::Result<super::audio_level_observer::AudioLevelObserverOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreateAudioLevelObserverRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateAudioLevelObserverRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateAudioLevelObserverRequestRef");
                    f.field("rtp_observer_id", &self.rtp_observer_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateAudioLevelObserverRequestRef<'a>>
                for CreateAudioLevelObserverRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: CreateAudioLevelObserverRequestRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_observer_id: ::core::convert::TryInto::try_into(
                            value.rtp_observer_id()?,
                        )?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateAudioLevelObserverRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateAudioLevelObserverRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateAudioLevelObserverRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequest
            {
                type Value = ::planus::Offset<CreateAudioLevelObserverRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateAudioLevelObserverRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateAudioLevelObserverRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateAudioLevelObserverRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CreateActiveSpeakerObserverRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CreateActiveSpeakerObserverRequest` in the file `../worker/fbs/router.fbs:48`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateActiveSpeakerObserverRequest {
                /// The field `rtp_observer_id` in the table `CreateActiveSpeakerObserverRequest`
                pub rtp_observer_id: ::planus::alloc::string::String,
                /// The field `options` in the table `CreateActiveSpeakerObserverRequest`
                pub options: ::planus::alloc::boxed::Box<
                    super::active_speaker_observer::ActiveSpeakerObserverOptions,
                >,
            }

            impl CreateActiveSpeakerObserverRequest {
                /// Creates a [CreateActiveSpeakerObserverRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CreateActiveSpeakerObserverRequestBuilder<()> {
                    CreateActiveSpeakerObserverRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_observer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<
                            super::active_speaker_observer::ActiveSpeakerObserverOptions,
                        >,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_observer_id = field_rtp_observer_id.prepare(builder);
                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<
                        super::active_speaker_observer::ActiveSpeakerObserverOptions,
                    >>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_observer_id);
                            object_writer.write::<_, _, 4>(&prepared_options);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateActiveSpeakerObserverRequest>
                for CreateActiveSpeakerObserverRequest
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest> {
                    CreateActiveSpeakerObserverRequest::create(
                        builder,
                        &self.rtp_observer_id,
                        &self.options,
                    )
                }
            }

            /// Builder for serializing an instance of the [CreateActiveSpeakerObserverRequest] type.
            ///
            /// Can be created using the [CreateActiveSpeakerObserverRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CreateActiveSpeakerObserverRequestBuilder<State>(State);

            impl CreateActiveSpeakerObserverRequestBuilder<()> {
                /// Setter for the [`rtp_observer_id` field](CreateActiveSpeakerObserverRequest#structfield.rtp_observer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_observer_id<T0>(
                    self,
                    value: T0,
                ) -> CreateActiveSpeakerObserverRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CreateActiveSpeakerObserverRequestBuilder((value,))
                }
            }

            impl<T0> CreateActiveSpeakerObserverRequestBuilder<(T0,)> {
                /// Setter for the [`options` field](CreateActiveSpeakerObserverRequest#structfield.options).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn options<T1>(
                    self,
                    value: T1,
                ) -> CreateActiveSpeakerObserverRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<
                            super::active_speaker_observer::ActiveSpeakerObserverOptions,
                        >,
                    >,
                {
                    let (v0,) = self.0;
                    CreateActiveSpeakerObserverRequestBuilder((v0, value))
                }
            }

            impl<T0, T1> CreateActiveSpeakerObserverRequestBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CreateActiveSpeakerObserverRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest>
                where
                    Self: ::planus::WriteAsOffset<CreateActiveSpeakerObserverRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<
                            super::active_speaker_observer::ActiveSpeakerObserverOptions,
                        >,
                    >,
                >
                ::planus::WriteAs<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateActiveSpeakerObserverRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<
                            super::active_speaker_observer::ActiveSpeakerObserverOptions,
                        >,
                    >,
                >
                ::planus::WriteAsOptional<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequestBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CreateActiveSpeakerObserverRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<
                        ::planus::Offset<
                            super::active_speaker_observer::ActiveSpeakerObserverOptions,
                        >,
                    >,
                > ::planus::WriteAsOffset<CreateActiveSpeakerObserverRequest>
                for CreateActiveSpeakerObserverRequestBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest> {
                    let (v0, v1) = &self.0;
                    CreateActiveSpeakerObserverRequest::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CreateActiveSpeakerObserverRequest].
            #[derive(Copy, Clone)]
            pub struct CreateActiveSpeakerObserverRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateActiveSpeakerObserverRequestRef<'a> {
                /// Getter for the [`rtp_observer_id` field](CreateActiveSpeakerObserverRequest#structfield.rtp_observer_id).
                #[inline]
                pub fn rtp_observer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(
                        0,
                        "CreateActiveSpeakerObserverRequest",
                        "rtp_observer_id",
                    )
                }

                /// Getter for the [`options` field](CreateActiveSpeakerObserverRequest#structfield.options).
                #[inline]
                pub fn options(
                    &self,
                ) -> ::planus::Result<
                    super::active_speaker_observer::ActiveSpeakerObserverOptionsRef<'a>,
                > {
                    self.0
                        .access_required(1, "CreateActiveSpeakerObserverRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateActiveSpeakerObserverRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateActiveSpeakerObserverRequestRef");
                    f.field("rtp_observer_id", &self.rtp_observer_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateActiveSpeakerObserverRequestRef<'a>>
                for CreateActiveSpeakerObserverRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: CreateActiveSpeakerObserverRequestRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_observer_id: ::core::convert::TryInto::try_into(
                            value.rtp_observer_id()?,
                        )?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateActiveSpeakerObserverRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateActiveSpeakerObserverRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateActiveSpeakerObserverRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequest
            {
                type Value = ::planus::Offset<CreateActiveSpeakerObserverRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateActiveSpeakerObserverRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateActiveSpeakerObserverRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateActiveSpeakerObserverRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseTransportRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CloseTransportRequest` in the file `../worker/fbs/router.fbs:53`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseTransportRequest {
                /// The field `transport_id` in the table `CloseTransportRequest`
                pub transport_id: ::planus::alloc::string::String,
            }

            impl CloseTransportRequest {
                /// Creates a [CloseTransportRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseTransportRequestBuilder<()> {
                    CloseTransportRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_transport_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseTransportRequest>> for CloseTransportRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseTransportRequest>> for CloseTransportRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseTransportRequest> for CloseTransportRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest> {
                    CloseTransportRequest::create(builder, &self.transport_id)
                }
            }

            /// Builder for serializing an instance of the [CloseTransportRequest] type.
            ///
            /// Can be created using the [CloseTransportRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseTransportRequestBuilder<State>(State);

            impl CloseTransportRequestBuilder<()> {
                /// Setter for the [`transport_id` field](CloseTransportRequest#structfield.transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn transport_id<T0>(self, value: T0) -> CloseTransportRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseTransportRequestBuilder((value,))
                }
            }

            impl<T0> CloseTransportRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseTransportRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseTransportRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseTransportRequest>>
                for CloseTransportRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseTransportRequest>>
                for CloseTransportRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseTransportRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseTransportRequest>
                for CloseTransportRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest> {
                    let (v0,) = &self.0;
                    CloseTransportRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseTransportRequest].
            #[derive(Copy, Clone)]
            pub struct CloseTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseTransportRequestRef<'a> {
                /// Getter for the [`transport_id` field](CloseTransportRequest#structfield.transport_id).
                #[inline]
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseTransportRequest", "transport_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseTransportRequestRef<'a>> for CloseTransportRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseTransportRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseTransportRequest>> for CloseTransportRequest {
                type Value = ::planus::Offset<CloseTransportRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `CloseRtpObserverRequest` in the namespace `FBS.Router`
            ///
            /// Generated from these locations:
            /// * Table `CloseRtpObserverRequest` in the file `../worker/fbs/router.fbs:57`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseRtpObserverRequest {
                /// The field `rtp_observer_id` in the table `CloseRtpObserverRequest`
                pub rtp_observer_id: ::planus::alloc::string::String,
            }

            impl CloseRtpObserverRequest {
                /// Creates a [CloseRtpObserverRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CloseRtpObserverRequestBuilder<()> {
                    CloseRtpObserverRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_observer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_observer_id = field_rtp_observer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_observer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseRtpObserverRequest>> for CloseRtpObserverRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseRtpObserverRequest>>
                for CloseRtpObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseRtpObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseRtpObserverRequest> for CloseRtpObserverRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest> {
                    CloseRtpObserverRequest::create(builder, &self.rtp_observer_id)
                }
            }

            /// Builder for serializing an instance of the [CloseRtpObserverRequest] type.
            ///
            /// Can be created using the [CloseRtpObserverRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CloseRtpObserverRequestBuilder<State>(State);

            impl CloseRtpObserverRequestBuilder<()> {
                /// Setter for the [`rtp_observer_id` field](CloseRtpObserverRequest#structfield.rtp_observer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_observer_id<T0>(self, value: T0) -> CloseRtpObserverRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    CloseRtpObserverRequestBuilder((value,))
                }
            }

            impl<T0> CloseRtpObserverRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CloseRtpObserverRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest>
                where
                    Self: ::planus::WriteAsOffset<CloseRtpObserverRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<CloseRtpObserverRequest>>
                for CloseRtpObserverRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseRtpObserverRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<CloseRtpObserverRequest>>
                for CloseRtpObserverRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<CloseRtpObserverRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseRtpObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<CloseRtpObserverRequest>
                for CloseRtpObserverRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest> {
                    let (v0,) = &self.0;
                    CloseRtpObserverRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [CloseRtpObserverRequest].
            #[derive(Copy, Clone)]
            pub struct CloseRtpObserverRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseRtpObserverRequestRef<'a> {
                /// Getter for the [`rtp_observer_id` field](CloseRtpObserverRequest#structfield.rtp_observer_id).
                #[inline]
                pub fn rtp_observer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseRtpObserverRequest", "rtp_observer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseRtpObserverRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseRtpObserverRequestRef");
                    f.field("rtp_observer_id", &self.rtp_observer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseRtpObserverRequestRef<'a>> for CloseRtpObserverRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseRtpObserverRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_observer_id: ::core::convert::TryInto::try_into(
                            value.rtp_observer_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseRtpObserverRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseRtpObserverRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseRtpObserverRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseRtpObserverRequest>> for CloseRtpObserverRequest {
                type Value = ::planus::Offset<CloseRtpObserverRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseRtpObserverRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseRtpObserverRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseRtpObserverRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.WebRtcServer`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/webRtcServer.fbs`
        pub mod web_rtc_server {
            /// The table `IpPort` in the namespace `FBS.WebRtcServer`
            ///
            /// Generated from these locations:
            /// * Table `IpPort` in the file `../worker/fbs/webRtcServer.fbs:5`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IpPort {
                /// The field `ip` in the table `IpPort`
                pub ip: ::planus::alloc::string::String,
                /// The field `port` in the table `IpPort`
                pub port: u16,
            }

            impl IpPort {
                /// Creates a [IpPortBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> IpPortBuilder<()> {
                    IpPortBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);
                    let prepared_port = field_port.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_port.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_ip);
                            if let ::core::option::Option::Some(prepared_port) = prepared_port {
                                object_writer.write::<_, _, 2>(&prepared_port);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IpPort>> for IpPort {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IpPort>> for IpPort {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IpPort>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IpPort> for IpPort {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort> {
                    IpPort::create(builder, &self.ip, self.port)
                }
            }

            /// Builder for serializing an instance of the [IpPort] type.
            ///
            /// Can be created using the [IpPort::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct IpPortBuilder<State>(State);

            impl IpPortBuilder<()> {
                /// Setter for the [`ip` field](IpPort#structfield.ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ip<T0>(self, value: T0) -> IpPortBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    IpPortBuilder((value,))
                }
            }

            impl<T0> IpPortBuilder<(T0,)> {
                /// Setter for the [`port` field](IpPort#structfield.port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port<T1>(self, value: T1) -> IpPortBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0,) = self.0;
                    IpPortBuilder((v0, value))
                }

                /// Sets the [`port` field](IpPort#structfield.port) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port_as_default(self) -> IpPortBuilder<(T0, ::planus::DefaultValue)> {
                    self.port(::planus::DefaultValue)
                }
            }

            impl<T0, T1> IpPortBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [IpPort].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort>
                where
                    Self: ::planus::WriteAsOffset<IpPort>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAs<::planus::Offset<IpPort>> for IpPortBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<IpPort>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOptional<::planus::Offset<IpPort>> for IpPortBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<IpPort>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IpPort>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOffset<IpPort> for IpPortBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort> {
                    let (v0, v1) = &self.0;
                    IpPort::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [IpPort].
            #[derive(Copy, Clone)]
            pub struct IpPortRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IpPortRef<'a> {
                /// Getter for the [`ip` field](IpPort#structfield.ip).
                #[inline]
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "IpPort", "ip")
                }

                /// Getter for the [`port` field](IpPort#structfield.port).
                #[inline]
                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(self.0.access(1, "IpPort", "port")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for IpPortRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IpPortRef");
                    f.field("ip", &self.ip());
                    f.field("port", &self.port());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IpPortRef<'a>> for IpPort {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IpPortRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IpPortRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IpPortRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IpPortRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IpPort>> for IpPort {
                type Value = ::planus::Offset<IpPort>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IpPort>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IpPortRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IpPortRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `IceUserNameFragment` in the namespace `FBS.WebRtcServer`
            ///
            /// Generated from these locations:
            /// * Table `IceUserNameFragment` in the file `../worker/fbs/webRtcServer.fbs:10`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceUserNameFragment {
                /// The field `local_ice_username_fragment` in the table `IceUserNameFragment`
                pub local_ice_username_fragment: ::planus::alloc::string::String,
                /// The field `web_rtc_transport_id` in the table `IceUserNameFragment`
                pub web_rtc_transport_id: ::planus::alloc::string::String,
            }

            impl IceUserNameFragment {
                /// Creates a [IceUserNameFragmentBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> IceUserNameFragmentBuilder<()> {
                    IceUserNameFragmentBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_local_ice_username_fragment: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_web_rtc_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_local_ice_username_fragment =
                        field_local_ice_username_fragment.prepare(builder);
                    let prepared_web_rtc_transport_id = field_web_rtc_transport_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_local_ice_username_fragment);
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_transport_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceUserNameFragment>> for IceUserNameFragment {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceUserNameFragment>> for IceUserNameFragment {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceUserNameFragment>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceUserNameFragment> for IceUserNameFragment {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment> {
                    IceUserNameFragment::create(
                        builder,
                        &self.local_ice_username_fragment,
                        &self.web_rtc_transport_id,
                    )
                }
            }

            /// Builder for serializing an instance of the [IceUserNameFragment] type.
            ///
            /// Can be created using the [IceUserNameFragment::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct IceUserNameFragmentBuilder<State>(State);

            impl IceUserNameFragmentBuilder<()> {
                /// Setter for the [`local_ice_username_fragment` field](IceUserNameFragment#structfield.local_ice_username_fragment).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_ice_username_fragment<T0>(
                    self,
                    value: T0,
                ) -> IceUserNameFragmentBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    IceUserNameFragmentBuilder((value,))
                }
            }

            impl<T0> IceUserNameFragmentBuilder<(T0,)> {
                /// Setter for the [`web_rtc_transport_id` field](IceUserNameFragment#structfield.web_rtc_transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_transport_id<T1>(
                    self,
                    value: T1,
                ) -> IceUserNameFragmentBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    IceUserNameFragmentBuilder((v0, value))
                }
            }

            impl<T0, T1> IceUserNameFragmentBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [IceUserNameFragment].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment>
                where
                    Self: ::planus::WriteAsOffset<IceUserNameFragment>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<IceUserNameFragment>>
                for IceUserNameFragmentBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<IceUserNameFragment>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<IceUserNameFragment>>
                for IceUserNameFragmentBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<IceUserNameFragment>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceUserNameFragment>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<IceUserNameFragment>
                for IceUserNameFragmentBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment> {
                    let (v0, v1) = &self.0;
                    IceUserNameFragment::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [IceUserNameFragment].
            #[derive(Copy, Clone)]
            pub struct IceUserNameFragmentRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceUserNameFragmentRef<'a> {
                /// Getter for the [`local_ice_username_fragment` field](IceUserNameFragment#structfield.local_ice_username_fragment).
                #[inline]
                pub fn local_ice_username_fragment(
                    &self,
                ) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "IceUserNameFragment", "local_ice_username_fragment")
                }

                /// Getter for the [`web_rtc_transport_id` field](IceUserNameFragment#structfield.web_rtc_transport_id).
                #[inline]
                pub fn web_rtc_transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "IceUserNameFragment", "web_rtc_transport_id")
                }
            }

            impl<'a> ::core::fmt::Debug for IceUserNameFragmentRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceUserNameFragmentRef");
                    f.field(
                        "local_ice_username_fragment",
                        &self.local_ice_username_fragment(),
                    );
                    f.field("web_rtc_transport_id", &self.web_rtc_transport_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceUserNameFragmentRef<'a>> for IceUserNameFragment {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceUserNameFragmentRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        local_ice_username_fragment: ::core::convert::TryInto::try_into(
                            value.local_ice_username_fragment()?,
                        )?,
                        web_rtc_transport_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_transport_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceUserNameFragmentRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceUserNameFragmentRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceUserNameFragmentRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceUserNameFragment>> for IceUserNameFragment {
                type Value = ::planus::Offset<IceUserNameFragment>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceUserNameFragment>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceUserNameFragmentRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceUserNameFragmentRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `TupleHash` in the namespace `FBS.WebRtcServer`
            ///
            /// Generated from these locations:
            /// * Table `TupleHash` in the file `../worker/fbs/webRtcServer.fbs:15`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TupleHash {
                /// The field `local_ice_username_fragment` in the table `TupleHash`
                pub local_ice_username_fragment: u64,
                /// The field `web_rtc_transport_id` in the table `TupleHash`
                pub web_rtc_transport_id: ::planus::alloc::string::String,
            }

            impl TupleHash {
                /// Creates a [TupleHashBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TupleHashBuilder<()> {
                    TupleHashBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_local_ice_username_fragment: impl ::planus::WriteAsDefault<u64, u64>,
                    field_web_rtc_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_local_ice_username_fragment =
                        field_local_ice_username_fragment.prepare(builder, &0);
                    let prepared_web_rtc_transport_id = field_web_rtc_transport_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_local_ice_username_fragment.is_some() {
                        table_writer.write_entry::<u64>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(
                                prepared_local_ice_username_fragment,
                            ) = prepared_local_ice_username_fragment
                            {
                                object_writer
                                    .write::<_, _, 8>(&prepared_local_ice_username_fragment);
                            }
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_transport_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TupleHash>> for TupleHash {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TupleHash>> for TupleHash {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TupleHash>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TupleHash> for TupleHash {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash> {
                    TupleHash::create(
                        builder,
                        self.local_ice_username_fragment,
                        &self.web_rtc_transport_id,
                    )
                }
            }

            /// Builder for serializing an instance of the [TupleHash] type.
            ///
            /// Can be created using the [TupleHash::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TupleHashBuilder<State>(State);

            impl TupleHashBuilder<()> {
                /// Setter for the [`local_ice_username_fragment` field](TupleHash#structfield.local_ice_username_fragment).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_ice_username_fragment<T0>(self, value: T0) -> TupleHashBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u64, u64>,
                {
                    TupleHashBuilder((value,))
                }

                /// Sets the [`local_ice_username_fragment` field](TupleHash#structfield.local_ice_username_fragment) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_ice_username_fragment_as_default(
                    self,
                ) -> TupleHashBuilder<(::planus::DefaultValue,)> {
                    self.local_ice_username_fragment(::planus::DefaultValue)
                }
            }

            impl<T0> TupleHashBuilder<(T0,)> {
                /// Setter for the [`web_rtc_transport_id` field](TupleHash#structfield.web_rtc_transport_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_transport_id<T1>(self, value: T1) -> TupleHashBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    TupleHashBuilder((v0, value))
                }
            }

            impl<T0, T1> TupleHashBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TupleHash].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash>
                where
                    Self: ::planus::WriteAsOffset<TupleHash>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<TupleHash>> for TupleHashBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<TupleHash>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<TupleHash>>
                for TupleHashBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<TupleHash>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TupleHash>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u64, u64>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<TupleHash> for TupleHashBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash> {
                    let (v0, v1) = &self.0;
                    TupleHash::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [TupleHash].
            #[derive(Copy, Clone)]
            pub struct TupleHashRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TupleHashRef<'a> {
                /// Getter for the [`local_ice_username_fragment` field](TupleHash#structfield.local_ice_username_fragment).
                #[inline]
                pub fn local_ice_username_fragment(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TupleHash", "local_ice_username_fragment")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`web_rtc_transport_id` field](TupleHash#structfield.web_rtc_transport_id).
                #[inline]
                pub fn web_rtc_transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "TupleHash", "web_rtc_transport_id")
                }
            }

            impl<'a> ::core::fmt::Debug for TupleHashRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TupleHashRef");
                    f.field(
                        "local_ice_username_fragment",
                        &self.local_ice_username_fragment(),
                    );
                    f.field("web_rtc_transport_id", &self.web_rtc_transport_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TupleHashRef<'a>> for TupleHash {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TupleHashRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        local_ice_username_fragment: ::core::convert::TryInto::try_into(
                            value.local_ice_username_fragment()?,
                        )?,
                        web_rtc_transport_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_transport_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TupleHashRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TupleHashRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TupleHashRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TupleHash>> for TupleHash {
                type Value = ::planus::Offset<TupleHash>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TupleHash>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TupleHashRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TupleHashRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.WebRtcServer`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/webRtcServer.fbs:20`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `id` in the table `DumpResponse`
                pub id: ::planus::alloc::string::String,
                /// The field `udp_sockets` in the table `DumpResponse`
                pub udp_sockets: ::planus::alloc::vec::Vec<self::IpPort>,
                /// The field `tcp_servers` in the table `DumpResponse`
                pub tcp_servers: ::planus::alloc::vec::Vec<self::IpPort>,
                /// The field `web_rtc_transport_ids` in the table `DumpResponse`
                pub web_rtc_transport_ids:
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                /// The field `local_ice_username_fragments` in the table `DumpResponse`
                pub local_ice_username_fragments:
                    ::planus::alloc::vec::Vec<self::IceUserNameFragment>,
                /// The field `tuple_hashes` in the table `DumpResponse`
                pub tuple_hashes: ::planus::alloc::vec::Vec<self::TupleHash>,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_udp_sockets: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IpPort>]>,
                    >,
                    field_tcp_servers: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IpPort>]>,
                    >,
                    field_web_rtc_transport_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_local_ice_username_fragments: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>,
                    >,
                    field_tuple_hashes: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::TupleHash>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_udp_sockets = field_udp_sockets.prepare(builder);
                    let prepared_tcp_servers = field_tcp_servers.prepare(builder);
                    let prepared_web_rtc_transport_ids =
                        field_web_rtc_transport_ids.prepare(builder);
                    let prepared_local_ice_username_fragments =
                        field_local_ice_username_fragments.prepare(builder);
                    let prepared_tuple_hashes = field_tuple_hashes.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::IpPort>]>>(1);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::IpPort>]>>(2);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(3);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>>(4);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::TupleHash>]>>(5);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            object_writer.write::<_, _, 4>(&prepared_udp_sockets);
                            object_writer.write::<_, _, 4>(&prepared_tcp_servers);
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_transport_ids);
                            object_writer.write::<_, _, 4>(&prepared_local_ice_username_fragments);
                            object_writer.write::<_, _, 4>(&prepared_tuple_hashes);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.udp_sockets,
                        &self.tcp_servers,
                        &self.web_rtc_transport_ids,
                        &self.local_ice_username_fragments,
                        &self.tuple_hashes,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`udp_sockets` field](DumpResponse#structfield.udp_sockets).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn udp_sockets<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`tcp_servers` field](DumpResponse#structfield.tcp_servers).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tcp_servers<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`web_rtc_transport_ids` field](DumpResponse#structfield.web_rtc_transport_ids).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_transport_ids<T3>(
                    self,
                    value: T3,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`local_ice_username_fragments` field](DumpResponse#structfield.local_ice_username_fragments).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local_ice_username_fragments<T4>(
                    self,
                    value: T4,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`tuple_hashes` field](DumpResponse#structfield.tuple_hashes).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple_hashes<T5>(
                    self,
                    value: T5,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::TupleHash>]>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>,
                    >,
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::TupleHash>]>>,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>,
                    >,
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::TupleHash>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IpPort>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>,
                    >,
                    T5: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::TupleHash>]>>,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                /// Getter for the [`udp_sockets` field](DumpResponse#structfield.udp_sockets).
                #[inline]
                pub fn udp_sockets(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::IpPortRef<'a>>>>
                {
                    self.0.access_required(1, "DumpResponse", "udp_sockets")
                }

                /// Getter for the [`tcp_servers` field](DumpResponse#structfield.tcp_servers).
                #[inline]
                pub fn tcp_servers(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::IpPortRef<'a>>>>
                {
                    self.0.access_required(2, "DumpResponse", "tcp_servers")
                }

                /// Getter for the [`web_rtc_transport_ids` field](DumpResponse#structfield.web_rtc_transport_ids).
                #[inline]
                pub fn web_rtc_transport_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(3, "DumpResponse", "web_rtc_transport_ids")
                }

                /// Getter for the [`local_ice_username_fragments` field](DumpResponse#structfield.local_ice_username_fragments).
                #[inline]
                pub fn local_ice_username_fragments(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::IceUserNameFragmentRef<'a>>>,
                > {
                    self.0
                        .access_required(4, "DumpResponse", "local_ice_username_fragments")
                }

                /// Getter for the [`tuple_hashes` field](DumpResponse#structfield.tuple_hashes).
                #[inline]
                pub fn tuple_hashes(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::TupleHashRef<'a>>>>
                {
                    self.0.access_required(5, "DumpResponse", "tuple_hashes")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("udp_sockets", &self.udp_sockets());
                    f.field("tcp_servers", &self.tcp_servers());
                    f.field("web_rtc_transport_ids", &self.web_rtc_transport_ids());
                    f.field(
                        "local_ice_username_fragments",
                        &self.local_ice_username_fragments(),
                    );
                    f.field("tuple_hashes", &self.tuple_hashes());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        udp_sockets: value.udp_sockets()?.to_vec_result()?,
                        tcp_servers: value.tcp_servers()?.to_vec_result()?,
                        web_rtc_transport_ids: value.web_rtc_transport_ids()?.to_vec_result()?,
                        local_ice_username_fragments: value
                            .local_ice_username_fragments()?
                            .to_vec_result()?,
                        tuple_hashes: value.tuple_hashes()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.Producer`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/producer.fbs`
        pub mod producer {
            /// The enum `TraceEventType` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Enum `TraceEventType` in the file `../worker/fbs/producer.fbs:8`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceEventType {
                /// The variant `KEYFRAME` in the enum `TraceEventType`
                Keyframe = 0,

                /// The variant `FIR` in the enum `TraceEventType`
                Fir = 1,

                /// The variant `NACK` in the enum `TraceEventType`
                Nack = 2,

                /// The variant `PLI` in the enum `TraceEventType`
                Pli = 3,

                /// The variant `RTP` in the enum `TraceEventType`
                Rtp = 4,
            }

            impl TraceEventType {
                /// Array containing all valid variants of TraceEventType
                pub const ENUM_VALUES: [Self; 5] =
                    [Self::Keyframe, Self::Fir, Self::Nack, Self::Pli, Self::Rtp];
            }

            impl ::core::convert::TryFrom<u8> for TraceEventType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceEventType::Keyframe),
                        1 => ::core::result::Result::Ok(TraceEventType::Fir),
                        2 => ::core::result::Result::Ok(TraceEventType::Nack),
                        3 => ::core::result::Result::Ok(TraceEventType::Pli),
                        4 => ::core::result::Result::Ok(TraceEventType::Rtp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceEventType> for u8 {
                #[inline]
                fn from(value: TraceEventType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceEventType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceEventType> for TraceEventType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceEventType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceEventType, TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceEventType,
                ) -> ::core::option::Option<TraceEventType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceEventType> for TraceEventType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceEventType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceEventType {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceEventType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceEventType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceEventType> for TraceEventType {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `EnableTraceEventRequest` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `EnableTraceEventRequest` in the file `../worker/fbs/producer.fbs:16`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EnableTraceEventRequest {
                /// The field `events` in the table `EnableTraceEventRequest`
                pub events: ::planus::alloc::vec::Vec<self::TraceEventType>,
            }

            impl EnableTraceEventRequest {
                /// Creates a [EnableTraceEventRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> EnableTraceEventRequestBuilder<()> {
                    EnableTraceEventRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_events: impl ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_events = field_events.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[self::TraceEventType]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_events);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequest
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EnableTraceEventRequest> for EnableTraceEventRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    EnableTraceEventRequest::create(builder, &self.events)
                }
            }

            /// Builder for serializing an instance of the [EnableTraceEventRequest] type.
            ///
            /// Can be created using the [EnableTraceEventRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct EnableTraceEventRequestBuilder<State>(State);

            impl EnableTraceEventRequestBuilder<()> {
                /// Setter for the [`events` field](EnableTraceEventRequest#structfield.events).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn events<T0>(self, value: T0) -> EnableTraceEventRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                {
                    EnableTraceEventRequestBuilder((value,))
                }
            }

            impl<T0> EnableTraceEventRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [EnableTraceEventRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest>
                where
                    Self: ::planus::WriteAsOffset<EnableTraceEventRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<EnableTraceEventRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<EnableTraceEventRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>>
                ::planus::WriteAsOffset<EnableTraceEventRequest>
                for EnableTraceEventRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    let (v0,) = &self.0;
                    EnableTraceEventRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [EnableTraceEventRequest].
            #[derive(Copy, Clone)]
            pub struct EnableTraceEventRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EnableTraceEventRequestRef<'a> {
                /// Getter for the [`events` field](EnableTraceEventRequest#structfield.events).
                #[inline]
                pub fn events(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::core::result::Result<
                            self::TraceEventType,
                            ::planus::errors::UnknownEnumTag,
                        >,
                    >,
                > {
                    self.0
                        .access_required(0, "EnableTraceEventRequest", "events")
                }
            }

            impl<'a> ::core::fmt::Debug for EnableTraceEventRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EnableTraceEventRequestRef");
                    f.field("events", &self.events());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EnableTraceEventRequestRef<'a>> for EnableTraceEventRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EnableTraceEventRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        events: value.events()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EnableTraceEventRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EnableTraceEventRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Value = ::planus::Offset<EnableTraceEventRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EnableTraceEventRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EnableTraceEventRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/producer.fbs:20`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `id` in the table `DumpResponse`
                pub id: ::planus::alloc::string::String,
                /// The field `kind` in the table `DumpResponse`
                pub kind: super::rtp_parameters::MediaKind,
                /// The field `type` in the table `DumpResponse`
                pub type_: super::rtp_parameters::Type,
                /// The field `rtp_parameters` in the table `DumpResponse`
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                /// The field `rtp_mapping` in the table `DumpResponse`
                pub rtp_mapping: ::planus::alloc::boxed::Box<super::rtp_parameters::RtpMapping>,
                /// The field `rtp_streams` in the table `DumpResponse`
                pub rtp_streams: ::planus::alloc::vec::Vec<super::rtp_stream::Dump>,
                /// The field `trace_event_types` in the table `DumpResponse`
                pub trace_event_types: ::planus::alloc::vec::Vec<self::TraceEventType>,
                /// The field `paused` in the table `DumpResponse`
                pub paused: bool,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_rtp_mapping: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpMapping>,
                    >,
                    field_rtp_streams: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    field_trace_event_types: impl ::planus::WriteAs<
                        ::planus::Offset<[self::TraceEventType]>,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);
                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::Audio);
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::Simple);
                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);
                    let prepared_rtp_mapping = field_rtp_mapping.prepare(builder);
                    let prepared_rtp_streams = field_rtp_streams.prepare(builder);
                    let prepared_trace_event_types = field_trace_event_types.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer
                        .write_entry::<::planus::Offset<super::rtp_parameters::RtpParameters>>(3);
                    table_writer
                        .write_entry::<::planus::Offset<super::rtp_parameters::RtpMapping>>(4);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>>(5);
                    table_writer.write_entry::<::planus::Offset<[self::TraceEventType]>>(6);
                    if prepared_kind.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::MediaKind>(1);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<super::rtp_parameters::Type>(2);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<bool>(7);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_id);
                            object_writer.write::<_, _, 4>(&prepared_rtp_parameters);
                            object_writer.write::<_, _, 4>(&prepared_rtp_mapping);
                            object_writer.write::<_, _, 4>(&prepared_rtp_streams);
                            object_writer.write::<_, _, 4>(&prepared_trace_event_types);
                            if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                                object_writer.write::<_, _, 1>(&prepared_kind);
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        self.kind,
                        self.type_,
                        &self.rtp_parameters,
                        &self.rtp_mapping,
                        &self.rtp_streams,
                        &self.trace_event_types,
                        self.paused,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`kind` field](DumpResponse#structfield.kind).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }

                /// Sets the [`kind` field](DumpResponse#structfield.kind) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn kind_as_default(self) -> DumpResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.kind(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`type` field](DumpResponse#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }

                /// Sets the [`type` field](DumpResponse#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`rtp_parameters` field](DumpResponse#structfield.rtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_parameters<T3>(self, value: T3) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`rtp_mapping` field](DumpResponse#structfield.rtp_mapping).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_mapping<T4>(self, value: T4) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`rtp_streams` field](DumpResponse#structfield.rtp_streams).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_streams<T5>(
                    self,
                    value: T5,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`trace_event_types` field](DumpResponse#structfield.trace_event_types).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trace_event_types<T6>(
                    self,
                    value: T6,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`paused` field](DumpResponse#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T7>(
                    self,
                    value: T7,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`paused` field](DumpResponse#structfield.paused) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.paused(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    T2: ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    T3: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpParameters>>,
                    T4: ::planus::WriteAs<::planus::Offset<super::rtp_parameters::RtpMapping>>,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    T6: ::planus::WriteAs<::planus::Offset<[self::TraceEventType]>>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`id` field](DumpResponse#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                /// Getter for the [`kind` field](DumpResponse#structfield.kind).
                #[inline]
                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DumpResponse", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::Audio),
                    )
                }

                /// Getter for the [`type` field](DumpResponse#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "DumpResponse", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::Simple),
                    )
                }

                /// Getter for the [`rtp_parameters` field](DumpResponse#structfield.rtp_parameters).
                #[inline]
                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0.access_required(3, "DumpResponse", "rtp_parameters")
                }

                /// Getter for the [`rtp_mapping` field](DumpResponse#structfield.rtp_mapping).
                #[inline]
                pub fn rtp_mapping(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpMappingRef<'a>> {
                    self.0.access_required(4, "DumpResponse", "rtp_mapping")
                }

                /// Getter for the [`rtp_streams` field](DumpResponse#structfield.rtp_streams).
                #[inline]
                pub fn rtp_streams(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::rtp_stream::DumpRef<'a>>>,
                > {
                    self.0.access_required(5, "DumpResponse", "rtp_streams")
                }

                /// Getter for the [`trace_event_types` field](DumpResponse#structfield.trace_event_types).
                #[inline]
                pub fn trace_event_types(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::core::result::Result<
                            self::TraceEventType,
                            ::planus::errors::UnknownEnumTag,
                        >,
                    >,
                > {
                    self.0
                        .access_required(6, "DumpResponse", "trace_event_types")
                }

                /// Getter for the [`paused` field](DumpResponse#structfield.paused).
                #[inline]
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(7, "DumpResponse", "paused")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("kind", &self.kind());
                    f.field("type_", &self.type_());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("rtp_mapping", &self.rtp_mapping());
                    f.field("rtp_streams", &self.rtp_streams());
                    f.field("trace_event_types", &self.trace_event_types());
                    f.field("paused", &self.paused());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        rtp_mapping: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_mapping()?)?,
                        ),
                        rtp_streams: value.rtp_streams()?.to_vec_result()?,
                        trace_event_types: value.trace_event_types()?.to_vec_result()?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/producer.fbs:31`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `stats` in the table `GetStatsResponse`
                pub stats: ::planus::alloc::vec::Vec<super::rtp_stream::Stats>,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stats: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_stats = field_stats.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_stats);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.stats)
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`stats` field](GetStatsResponse#structfield.stats).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn stats<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                {
                    GetStatsResponseBuilder((value,))
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                > ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0,) = &self.0;
                    GetStatsResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`stats` field](GetStatsResponse#structfield.stats).
                #[inline]
                pub fn stats(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::rtp_stream::StatsRef<'a>>>,
                > {
                    self.0.access_required(0, "GetStatsResponse", "stats")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("stats", &self.stats());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stats: value.stats()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SendNotification` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `SendNotification` in the file `../worker/fbs/producer.fbs:35`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendNotification {
                /// The field `data` in the table `SendNotification`
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl SendNotification {
                /// Creates a [SendNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SendNotificationBuilder<()> {
                    SendNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[u8]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_data);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendNotification> for SendNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    SendNotification::create(builder, &self.data)
                }
            }

            /// Builder for serializing an instance of the [SendNotification] type.
            ///
            /// Can be created using the [SendNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SendNotificationBuilder<State>(State);

            impl SendNotificationBuilder<()> {
                /// Setter for the [`data` field](SendNotification#structfield.data).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn data<T0>(self, value: T0) -> SendNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    SendNotificationBuilder((value,))
                }
            }

            impl<T0> SendNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SendNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification>
                where
                    Self: ::planus::WriteAsOffset<SendNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAs<::planus::Offset<SendNotification>>
                for SendNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SendNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOptional<::planus::Offset<SendNotification>>
                for SendNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SendNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[u8]>>>
                ::planus::WriteAsOffset<SendNotification> for SendNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    let (v0,) = &self.0;
                    SendNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SendNotification].
            #[derive(Copy, Clone)]
            pub struct SendNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendNotificationRef<'a> {
                /// Getter for the [`data` field](SendNotification#structfield.data).
                #[inline]
                pub fn data(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(0, "SendNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendNotificationRef<'a>> for SendNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendNotification>> for SendNotification {
                type Value = ::planus::Offset<SendNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Score` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `Score` in the file `../worker/fbs/producer.fbs:41`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Score {
                /// The field `encoding_idx` in the table `Score`
                pub encoding_idx: u32,
                /// The field `ssrc` in the table `Score`
                pub ssrc: u32,
                /// The field `rid` in the table `Score`
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `score` in the table `Score`
                pub score: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Score {
                fn default() -> Self {
                    Self {
                        encoding_idx: 0,
                        ssrc: 0,
                        rid: ::core::default::Default::default(),
                        score: 0,
                    }
                }
            }

            impl Score {
                /// Creates a [ScoreBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ScoreBuilder<()> {
                    ScoreBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_encoding_idx: impl ::planus::WriteAsDefault<u32, u32>,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_encoding_idx = field_encoding_idx.prepare(builder, &0);
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);
                    let prepared_rid = field_rid.prepare(builder);
                    let prepared_score = field_score.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_encoding_idx.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_rid.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(2);
                    }
                    if prepared_score.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_encoding_idx) =
                                prepared_encoding_idx
                            {
                                object_writer.write::<_, _, 4>(&prepared_encoding_idx);
                            }
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                            if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                                object_writer.write::<_, _, 4>(&prepared_rid);
                            }
                            if let ::core::option::Option::Some(prepared_score) = prepared_score {
                                object_writer.write::<_, _, 1>(&prepared_score);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Score>> for Score {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Score>> for Score {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Score>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Score> for Score {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score> {
                    Score::create(builder, self.encoding_idx, self.ssrc, &self.rid, self.score)
                }
            }

            /// Builder for serializing an instance of the [Score] type.
            ///
            /// Can be created using the [Score::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ScoreBuilder<State>(State);

            impl ScoreBuilder<()> {
                /// Setter for the [`encoding_idx` field](Score#structfield.encoding_idx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encoding_idx<T0>(self, value: T0) -> ScoreBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    ScoreBuilder((value,))
                }

                /// Sets the [`encoding_idx` field](Score#structfield.encoding_idx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn encoding_idx_as_default(self) -> ScoreBuilder<(::planus::DefaultValue,)> {
                    self.encoding_idx(::planus::DefaultValue)
                }
            }

            impl<T0> ScoreBuilder<(T0,)> {
                /// Setter for the [`ssrc` field](Score#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T1>(self, value: T1) -> ScoreBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    ScoreBuilder((v0, value))
                }

                /// Sets the [`ssrc` field](Score#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> ScoreBuilder<(T0, ::planus::DefaultValue)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ScoreBuilder<(T0, T1)> {
                /// Setter for the [`rid` field](Score#structfield.rid).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid<T2>(self, value: T2) -> ScoreBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1) = self.0;
                    ScoreBuilder((v0, v1, value))
                }

                /// Sets the [`rid` field](Score#structfield.rid) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rid_as_null(self) -> ScoreBuilder<(T0, T1, ())> {
                    self.rid(())
                }
            }

            impl<T0, T1, T2> ScoreBuilder<(T0, T1, T2)> {
                /// Setter for the [`score` field](Score#structfield.score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score<T3>(self, value: T3) -> ScoreBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u8, u8>,
                {
                    let (v0, v1, v2) = self.0;
                    ScoreBuilder((v0, v1, v2, value))
                }

                /// Sets the [`score` field](Score#structfield.score) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score_as_default(
                    self,
                ) -> ScoreBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.score(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> ScoreBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Score].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score>
                where
                    Self: ::planus::WriteAsOffset<Score>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAs<::planus::Offset<Score>> for ScoreBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Score>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOptional<::planus::Offset<Score>>
                for ScoreBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Score>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Score>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T3: ::planus::WriteAsDefault<u8, u8>,
                > ::planus::WriteAsOffset<Score> for ScoreBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score> {
                    let (v0, v1, v2, v3) = &self.0;
                    Score::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [Score].
            #[derive(Copy, Clone)]
            pub struct ScoreRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScoreRef<'a> {
                /// Getter for the [`encoding_idx` field](Score#structfield.encoding_idx).
                #[inline]
                pub fn encoding_idx(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Score", "encoding_idx")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`ssrc` field](Score#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(1, "Score", "ssrc")?.unwrap_or(0))
                }

                /// Getter for the [`rid` field](Score#structfield.rid).
                #[inline]
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "Score", "rid")
                }

                /// Getter for the [`score` field](Score#structfield.score).
                #[inline]
                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(self.0.access(3, "Score", "score")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreRef");
                    f.field("encoding_idx", &self.encoding_idx());
                    f.field("ssrc", &self.ssrc());
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    f.field("score", &self.score());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScoreRef<'a>> for Score {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScoreRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        encoding_idx: ::core::convert::TryInto::try_into(value.encoding_idx()?)?,
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScoreRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScoreRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Score>> for Score {
                type Value = ::planus::Offset<Score>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Score>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScoreRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ScoreRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ScoreNotification` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `ScoreNotification` in the file `../worker/fbs/producer.fbs:48`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ScoreNotification {
                /// The field `scores` in the table `ScoreNotification`
                pub scores: ::planus::alloc::vec::Vec<self::Score>,
            }

            impl ScoreNotification {
                /// Creates a [ScoreNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ScoreNotificationBuilder<()> {
                    ScoreNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_scores: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::Score>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_scores = field_scores.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::Score>]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_scores);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScoreNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ScoreNotification> for ScoreNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ScoreNotification::create(builder, &self.scores)
                }
            }

            /// Builder for serializing an instance of the [ScoreNotification] type.
            ///
            /// Can be created using the [ScoreNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ScoreNotificationBuilder<State>(State);

            impl ScoreNotificationBuilder<()> {
                /// Setter for the [`scores` field](ScoreNotification#structfield.scores).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scores<T0>(self, value: T0) -> ScoreNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Score>]>>,
                {
                    ScoreNotificationBuilder((value,))
                }
            }

            impl<T0> ScoreNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ScoreNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification>
                where
                    Self: ::planus::WriteAsOffset<ScoreNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Score>]>>>
                ::planus::WriteAs<::planus::Offset<ScoreNotification>>
                for ScoreNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ScoreNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Score>]>>>
                ::planus::WriteAsOptional<::planus::Offset<ScoreNotification>>
                for ScoreNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ScoreNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScoreNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Score>]>>>
                ::planus::WriteAsOffset<ScoreNotification> for ScoreNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    let (v0,) = &self.0;
                    ScoreNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ScoreNotification].
            #[derive(Copy, Clone)]
            pub struct ScoreNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScoreNotificationRef<'a> {
                /// Getter for the [`scores` field](ScoreNotification#structfield.scores).
                #[inline]
                pub fn scores(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::ScoreRef<'a>>>>
                {
                    self.0.access_required(0, "ScoreNotification", "scores")
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreNotificationRef");
                    f.field("scores", &self.scores());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScoreNotificationRef<'a>> for ScoreNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScoreNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        scores: value.scores()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScoreNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScoreNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Value = ::planus::Offset<ScoreNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ScoreNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScoreNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ScoreNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `VideoOrientationChangeNotification` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `VideoOrientationChangeNotification` in the file `../worker/fbs/producer.fbs:52`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct VideoOrientationChangeNotification {
                /// The field `camera` in the table `VideoOrientationChangeNotification`
                pub camera: bool,
                /// The field `flip` in the table `VideoOrientationChangeNotification`
                pub flip: bool,
                /// The field `rotation` in the table `VideoOrientationChangeNotification`
                pub rotation: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for VideoOrientationChangeNotification {
                fn default() -> Self {
                    Self {
                        camera: false,
                        flip: false,
                        rotation: 0,
                    }
                }
            }

            impl VideoOrientationChangeNotification {
                /// Creates a [VideoOrientationChangeNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> VideoOrientationChangeNotificationBuilder<()> {
                    VideoOrientationChangeNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_camera: impl ::planus::WriteAsDefault<bool, bool>,
                    field_flip: impl ::planus::WriteAsDefault<bool, bool>,
                    field_rotation: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_camera = field_camera.prepare(builder, &false);
                    let prepared_flip = field_flip.prepare(builder, &false);
                    let prepared_rotation = field_rotation.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    if prepared_rotation.is_some() {
                        table_writer.write_entry::<u16>(2);
                    }
                    if prepared_camera.is_some() {
                        table_writer.write_entry::<bool>(0);
                    }
                    if prepared_flip.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_rotation) =
                                prepared_rotation
                            {
                                object_writer.write::<_, _, 2>(&prepared_rotation);
                            }
                            if let ::core::option::Option::Some(prepared_camera) = prepared_camera {
                                object_writer.write::<_, _, 1>(&prepared_camera);
                            }
                            if let ::core::option::Option::Some(prepared_flip) = prepared_flip {
                                object_writer.write::<_, _, 1>(&prepared_flip);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<VideoOrientationChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<VideoOrientationChangeNotification>
                for VideoOrientationChangeNotification
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification> {
                    VideoOrientationChangeNotification::create(
                        builder,
                        self.camera,
                        self.flip,
                        self.rotation,
                    )
                }
            }

            /// Builder for serializing an instance of the [VideoOrientationChangeNotification] type.
            ///
            /// Can be created using the [VideoOrientationChangeNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct VideoOrientationChangeNotificationBuilder<State>(State);

            impl VideoOrientationChangeNotificationBuilder<()> {
                /// Setter for the [`camera` field](VideoOrientationChangeNotification#structfield.camera).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn camera<T0>(
                    self,
                    value: T0,
                ) -> VideoOrientationChangeNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<bool, bool>,
                {
                    VideoOrientationChangeNotificationBuilder((value,))
                }

                /// Sets the [`camera` field](VideoOrientationChangeNotification#structfield.camera) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn camera_as_default(
                    self,
                ) -> VideoOrientationChangeNotificationBuilder<(::planus::DefaultValue,)>
                {
                    self.camera(::planus::DefaultValue)
                }
            }

            impl<T0> VideoOrientationChangeNotificationBuilder<(T0,)> {
                /// Setter for the [`flip` field](VideoOrientationChangeNotification#structfield.flip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn flip<T1>(
                    self,
                    value: T1,
                ) -> VideoOrientationChangeNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    VideoOrientationChangeNotificationBuilder((v0, value))
                }

                /// Sets the [`flip` field](VideoOrientationChangeNotification#structfield.flip) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn flip_as_default(
                    self,
                ) -> VideoOrientationChangeNotificationBuilder<(T0, ::planus::DefaultValue)>
                {
                    self.flip(::planus::DefaultValue)
                }
            }

            impl<T0, T1> VideoOrientationChangeNotificationBuilder<(T0, T1)> {
                /// Setter for the [`rotation` field](VideoOrientationChangeNotification#structfield.rotation).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rotation<T2>(
                    self,
                    value: T2,
                ) -> VideoOrientationChangeNotificationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0, v1) = self.0;
                    VideoOrientationChangeNotificationBuilder((v0, v1, value))
                }

                /// Sets the [`rotation` field](VideoOrientationChangeNotification#structfield.rotation) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rotation_as_default(
                    self,
                ) -> VideoOrientationChangeNotificationBuilder<(T0, T1, ::planus::DefaultValue)>
                {
                    self.rotation(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> VideoOrientationChangeNotificationBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [VideoOrientationChangeNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification>
                where
                    Self: ::planus::WriteAsOffset<VideoOrientationChangeNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                >
                ::planus::WriteAs<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotificationBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<VideoOrientationChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                >
                ::planus::WriteAsOptional<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotificationBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<VideoOrientationChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<VideoOrientationChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<bool, bool>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<u16, u16>,
                > ::planus::WriteAsOffset<VideoOrientationChangeNotification>
                for VideoOrientationChangeNotificationBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification> {
                    let (v0, v1, v2) = &self.0;
                    VideoOrientationChangeNotification::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [VideoOrientationChangeNotification].
            #[derive(Copy, Clone)]
            pub struct VideoOrientationChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> VideoOrientationChangeNotificationRef<'a> {
                /// Getter for the [`camera` field](VideoOrientationChangeNotification#structfield.camera).
                #[inline]
                pub fn camera(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "VideoOrientationChangeNotification", "camera")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`flip` field](VideoOrientationChangeNotification#structfield.flip).
                #[inline]
                pub fn flip(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "VideoOrientationChangeNotification", "flip")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`rotation` field](VideoOrientationChangeNotification#structfield.rotation).
                #[inline]
                pub fn rotation(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "VideoOrientationChangeNotification", "rotation")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for VideoOrientationChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("VideoOrientationChangeNotificationRef");
                    f.field("camera", &self.camera());
                    f.field("flip", &self.flip());
                    f.field("rotation", &self.rotation());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<VideoOrientationChangeNotificationRef<'a>>
                for VideoOrientationChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: VideoOrientationChangeNotificationRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        camera: ::core::convert::TryInto::try_into(value.camera()?)?,
                        flip: ::core::convert::TryInto::try_into(value.flip()?)?,
                        rotation: ::core::convert::TryInto::try_into(value.rotation()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for VideoOrientationChangeNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for VideoOrientationChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VideoOrientationChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotification
            {
                type Value = ::planus::Offset<VideoOrientationChangeNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<VideoOrientationChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for VideoOrientationChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VideoOrientationChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The union `TraceInfo` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Union `TraceInfo` in the file `../worker/fbs/producer.fbs:58`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum TraceInfo {
                /// The variant of type `KeyFrameTraceInfo` in the union `TraceInfo`
                KeyFrameTraceInfo(::planus::alloc::boxed::Box<self::KeyFrameTraceInfo>),

                /// The variant of type `FirTraceInfo` in the union `TraceInfo`
                FirTraceInfo(::planus::alloc::boxed::Box<self::FirTraceInfo>),

                /// The variant of type `PliTraceInfo` in the union `TraceInfo`
                PliTraceInfo(::planus::alloc::boxed::Box<self::PliTraceInfo>),

                /// The variant of type `RtpTraceInfo` in the union `TraceInfo`
                RtpTraceInfo(::planus::alloc::boxed::Box<self::RtpTraceInfo>),
            }

            impl TraceInfo {
                /// Creates a [TraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TraceInfoBuilder<::planus::Uninitialized> {
                    TraceInfoBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_key_frame_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_fir_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::FirTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_pli_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PliTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_rtp_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RtpTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<TraceInfo> for TraceInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::KeyFrameTraceInfo(value) => {
                            Self::create_key_frame_trace_info(builder, value)
                        }
                        Self::FirTraceInfo(value) => Self::create_fir_trace_info(builder, value),
                        Self::PliTraceInfo(value) => Self::create_pli_trace_info(builder, value),
                        Self::RtpTraceInfo(value) => Self::create_rtp_trace_info(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [TraceInfo] type.
            ///
            /// Can be created using the [TraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TraceInfoBuilder<T>(T);

            impl TraceInfoBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`KeyFrameTraceInfo` variant](TraceInfo#variant.KeyFrameTraceInfo).
                #[inline]
                pub fn key_frame_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`FirTraceInfo` variant](TraceInfo#variant.FirTraceInfo).
                #[inline]
                pub fn fir_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::FirTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PliTraceInfo` variant](TraceInfo#variant.PliTraceInfo).
                #[inline]
                pub fn pli_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::PliTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`RtpTraceInfo` variant](TraceInfo#variant.RtpTraceInfo).
                #[inline]
                pub fn rtp_trace_info<T>(
                    self,
                    value: T,
                ) -> TraceInfoBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<self::RtpTraceInfo>,
                {
                    TraceInfoBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> TraceInfoBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [TraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo>
                where
                    Self: ::planus::WriteAsUnion<TraceInfo>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::FirTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::FirTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::PliTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::PliTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::RtpTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<TraceInfo> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfoBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::RtpTraceInfo>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<TraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [TraceInfo].
            #[derive(Copy, Clone, Debug)]
            pub enum TraceInfoRef<'a> {
                KeyFrameTraceInfo(self::KeyFrameTraceInfoRef<'a>),
                FirTraceInfo(self::FirTraceInfoRef<'a>),
                PliTraceInfo(self::PliTraceInfoRef<'a>),
                RtpTraceInfo(self::RtpTraceInfoRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<TraceInfoRef<'a>> for TraceInfo {
                type Error = ::planus::Error;

                fn try_from(value: TraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        TraceInfoRef::KeyFrameTraceInfo(value) => {
                            Self::KeyFrameTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::FirTraceInfo(value) => {
                            Self::FirTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::PliTraceInfo(value) => {
                            Self::PliTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::RtpTraceInfo(value) => {
                            Self::RtpTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for TraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::KeyFrameTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::FirTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::PliTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::RtpTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `KeyFrameTraceInfo` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `KeyFrameTraceInfo` in the file `../worker/fbs/producer.fbs:65`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct KeyFrameTraceInfo {
                /// The field `rtp_packet` in the table `KeyFrameTraceInfo`
                pub rtp_packet: ::planus::alloc::boxed::Box<super::rtp_packet::Dump>,
                /// The field `is_rtx` in the table `KeyFrameTraceInfo`
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for KeyFrameTraceInfo {
                fn default() -> Self {
                    Self {
                        rtp_packet: ::core::default::Default::default(),
                        is_rtx: false,
                    }
                }
            }

            impl KeyFrameTraceInfo {
                /// Creates a [KeyFrameTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> KeyFrameTraceInfoBuilder<()> {
                    KeyFrameTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_packet: impl ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_packet = field_rtp_packet.prepare(builder);
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::rtp_packet::Dump>>(0);
                    if prepared_is_rtx.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_packet);
                            if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                                object_writer.write::<_, _, 1>(&prepared_is_rtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<KeyFrameTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<KeyFrameTraceInfo> for KeyFrameTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    KeyFrameTraceInfo::create(builder, &self.rtp_packet, self.is_rtx)
                }
            }

            /// Builder for serializing an instance of the [KeyFrameTraceInfo] type.
            ///
            /// Can be created using the [KeyFrameTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct KeyFrameTraceInfoBuilder<State>(State);

            impl KeyFrameTraceInfoBuilder<()> {
                /// Setter for the [`rtp_packet` field](KeyFrameTraceInfo#structfield.rtp_packet).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet<T0>(self, value: T0) -> KeyFrameTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                {
                    KeyFrameTraceInfoBuilder((value,))
                }
            }

            impl<T0> KeyFrameTraceInfoBuilder<(T0,)> {
                /// Setter for the [`is_rtx` field](KeyFrameTraceInfo#structfield.is_rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx<T1>(self, value: T1) -> KeyFrameTraceInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    KeyFrameTraceInfoBuilder((v0, value))
                }

                /// Sets the [`is_rtx` field](KeyFrameTraceInfo#structfield.is_rtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx_as_default(
                    self,
                ) -> KeyFrameTraceInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.is_rtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1> KeyFrameTraceInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [KeyFrameTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<KeyFrameTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<KeyFrameTraceInfo>>
                for KeyFrameTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<KeyFrameTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<KeyFrameTraceInfo>>
                for KeyFrameTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<KeyFrameTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<KeyFrameTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<KeyFrameTraceInfo>
                for KeyFrameTraceInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    let (v0, v1) = &self.0;
                    KeyFrameTraceInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [KeyFrameTraceInfo].
            #[derive(Copy, Clone)]
            pub struct KeyFrameTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> KeyFrameTraceInfoRef<'a> {
                /// Getter for the [`rtp_packet` field](KeyFrameTraceInfo#structfield.rtp_packet).
                #[inline]
                pub fn rtp_packet(&self) -> ::planus::Result<super::rtp_packet::DumpRef<'a>> {
                    self.0.access_required(0, "KeyFrameTraceInfo", "rtp_packet")
                }

                /// Getter for the [`is_rtx` field](KeyFrameTraceInfo#structfield.is_rtx).
                #[inline]
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "KeyFrameTraceInfo", "is_rtx")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for KeyFrameTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("KeyFrameTraceInfoRef");
                    f.field("rtp_packet", &self.rtp_packet());
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<KeyFrameTraceInfoRef<'a>> for KeyFrameTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: KeyFrameTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_packet: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_packet()?)?,
                        ),
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for KeyFrameTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for KeyFrameTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[KeyFrameTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Value = ::planus::Offset<KeyFrameTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<KeyFrameTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for KeyFrameTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[KeyFrameTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `FirTraceInfo` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `FirTraceInfo` in the file `../worker/fbs/producer.fbs:70`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct FirTraceInfo {
                /// The field `ssrc` in the table `FirTraceInfo`
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for FirTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl FirTraceInfo {
                /// Creates a [FirTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> FirTraceInfoBuilder<()> {
                    FirTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FirTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<FirTraceInfo> for FirTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    FirTraceInfo::create(builder, self.ssrc)
                }
            }

            /// Builder for serializing an instance of the [FirTraceInfo] type.
            ///
            /// Can be created using the [FirTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct FirTraceInfoBuilder<State>(State);

            impl FirTraceInfoBuilder<()> {
                /// Setter for the [`ssrc` field](FirTraceInfo#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> FirTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    FirTraceInfoBuilder((value,))
                }

                /// Sets the [`ssrc` field](FirTraceInfo#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> FirTraceInfoBuilder<(::planus::DefaultValue,)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0> FirTraceInfoBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [FirTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<FirTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<FirTraceInfo>> for FirTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<FirTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<FirTraceInfo>>
                for FirTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<FirTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FirTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>> ::planus::WriteAsOffset<FirTraceInfo>
                for FirTraceInfoBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    let (v0,) = &self.0;
                    FirTraceInfo::create(builder, v0)
                }
            }

            /// Reference to a deserialized [FirTraceInfo].
            #[derive(Copy, Clone)]
            pub struct FirTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FirTraceInfoRef<'a> {
                /// Getter for the [`ssrc` field](FirTraceInfo#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "FirTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for FirTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FirTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FirTraceInfoRef<'a>> for FirTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FirTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FirTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FirTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FirTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Value = ::planus::Offset<FirTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<FirTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FirTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FirTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `PliTraceInfo` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `PliTraceInfo` in the file `../worker/fbs/producer.fbs:74`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PliTraceInfo {
                /// The field `ssrc` in the table `PliTraceInfo`
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PliTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl PliTraceInfo {
                /// Creates a [PliTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PliTraceInfoBuilder<()> {
                    PliTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_ssrc.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                                object_writer.write::<_, _, 4>(&prepared_ssrc);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PliTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PliTraceInfo> for PliTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    PliTraceInfo::create(builder, self.ssrc)
                }
            }

            /// Builder for serializing an instance of the [PliTraceInfo] type.
            ///
            /// Can be created using the [PliTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PliTraceInfoBuilder<State>(State);

            impl PliTraceInfoBuilder<()> {
                /// Setter for the [`ssrc` field](PliTraceInfo#structfield.ssrc).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc<T0>(self, value: T0) -> PliTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    PliTraceInfoBuilder((value,))
                }

                /// Sets the [`ssrc` field](PliTraceInfo#structfield.ssrc) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ssrc_as_default(self) -> PliTraceInfoBuilder<(::planus::DefaultValue,)> {
                    self.ssrc(::planus::DefaultValue)
                }
            }

            impl<T0> PliTraceInfoBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PliTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<PliTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAs<::planus::Offset<PliTraceInfo>> for PliTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<PliTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>>
                ::planus::WriteAsOptional<::planus::Offset<PliTraceInfo>>
                for PliTraceInfoBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<PliTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PliTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>> ::planus::WriteAsOffset<PliTraceInfo>
                for PliTraceInfoBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    let (v0,) = &self.0;
                    PliTraceInfo::create(builder, v0)
                }
            }

            /// Reference to a deserialized [PliTraceInfo].
            #[derive(Copy, Clone)]
            pub struct PliTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PliTraceInfoRef<'a> {
                /// Getter for the [`ssrc` field](PliTraceInfo#structfield.ssrc).
                #[inline]
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "PliTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PliTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PliTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PliTraceInfoRef<'a>> for PliTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PliTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PliTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PliTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PliTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Value = ::planus::Offset<PliTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PliTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PliTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PliTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtpTraceInfo` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `RtpTraceInfo` in the file `../worker/fbs/producer.fbs:78`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpTraceInfo {
                /// The field `rtp_packet` in the table `RtpTraceInfo`
                pub rtp_packet: ::planus::alloc::boxed::Box<super::rtp_packet::Dump>,
                /// The field `is_rtx` in the table `RtpTraceInfo`
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpTraceInfo {
                fn default() -> Self {
                    Self {
                        rtp_packet: ::core::default::Default::default(),
                        is_rtx: false,
                    }
                }
            }

            impl RtpTraceInfo {
                /// Creates a [RtpTraceInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtpTraceInfoBuilder<()> {
                    RtpTraceInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_packet: impl ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_packet = field_rtp_packet.prepare(builder);
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::rtp_packet::Dump>>(0);
                    if prepared_is_rtx.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_rtp_packet);
                            if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                                object_writer.write::<_, _, 1>(&prepared_is_rtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpTraceInfo> for RtpTraceInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    RtpTraceInfo::create(builder, &self.rtp_packet, self.is_rtx)
                }
            }

            /// Builder for serializing an instance of the [RtpTraceInfo] type.
            ///
            /// Can be created using the [RtpTraceInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtpTraceInfoBuilder<State>(State);

            impl RtpTraceInfoBuilder<()> {
                /// Setter for the [`rtp_packet` field](RtpTraceInfo#structfield.rtp_packet).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtp_packet<T0>(self, value: T0) -> RtpTraceInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                {
                    RtpTraceInfoBuilder((value,))
                }
            }

            impl<T0> RtpTraceInfoBuilder<(T0,)> {
                /// Setter for the [`is_rtx` field](RtpTraceInfo#structfield.is_rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx<T1>(self, value: T1) -> RtpTraceInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    RtpTraceInfoBuilder((v0, value))
                }

                /// Sets the [`is_rtx` field](RtpTraceInfo#structfield.is_rtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_rtx_as_default(
                    self,
                ) -> RtpTraceInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.is_rtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RtpTraceInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtpTraceInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo>
                where
                    Self: ::planus::WriteAsOffset<RtpTraceInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<RtpTraceInfo>>
                for RtpTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtpTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<RtpTraceInfo>>
                for RtpTraceInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RtpTraceInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::rtp_packet::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<RtpTraceInfo> for RtpTraceInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    let (v0, v1) = &self.0;
                    RtpTraceInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RtpTraceInfo].
            #[derive(Copy, Clone)]
            pub struct RtpTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpTraceInfoRef<'a> {
                /// Getter for the [`rtp_packet` field](RtpTraceInfo#structfield.rtp_packet).
                #[inline]
                pub fn rtp_packet(&self) -> ::planus::Result<super::rtp_packet::DumpRef<'a>> {
                    self.0.access_required(0, "RtpTraceInfo", "rtp_packet")
                }

                /// Getter for the [`is_rtx` field](RtpTraceInfo#structfield.is_rtx).
                #[inline]
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "RtpTraceInfo", "is_rtx")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RtpTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpTraceInfoRef");
                    f.field("rtp_packet", &self.rtp_packet());
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpTraceInfoRef<'a>> for RtpTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_packet: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_packet()?)?,
                        ),
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpTraceInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Value = ::planus::Offset<RtpTraceInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `TraceNotification` in the namespace `FBS.Producer`
            ///
            /// Generated from these locations:
            /// * Table `TraceNotification` in the file `../worker/fbs/producer.fbs:83`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TraceNotification {
                /// The field `type` in the table `TraceNotification`
                pub type_: self::TraceEventType,
                /// The field `timestamp` in the table `TraceNotification`
                pub timestamp: u64,
                /// The field `direction` in the table `TraceNotification`
                pub direction: super::common::TraceDirection,
                /// The field `info` in the table `TraceNotification`
                pub info: ::core::option::Option<self::TraceInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for TraceNotification {
                fn default() -> Self {
                    Self {
                        type_: self::TraceEventType::Keyframe,
                        timestamp: 0,
                        direction: super::common::TraceDirection::DirectionIn,
                        info: ::core::default::Default::default(),
                    }
                }
            }

            impl TraceNotification {
                /// Creates a [TraceNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TraceNotificationBuilder<()> {
                    TraceNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<
                        self::TraceEventType,
                        self::TraceEventType,
                    >,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_direction: impl ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    field_info: impl ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ =
                        field_type_.prepare(builder, &self::TraceEventType::Keyframe);
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);
                    let prepared_direction = field_direction
                        .prepare(builder, &super::common::TraceDirection::DirectionIn);
                    let prepared_info = field_info.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_timestamp.is_some() {
                        table_writer.write_entry::<u64>(1);
                    }
                    if prepared_info.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::TraceInfo>>(4);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<self::TraceEventType>(0);
                    }
                    if prepared_direction.is_some() {
                        table_writer.write_entry::<super::common::TraceDirection>(2);
                    }
                    if prepared_info.is_some() {
                        table_writer.write_entry::<u8>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_timestamp) =
                                prepared_timestamp
                            {
                                object_writer.write::<_, _, 8>(&prepared_timestamp);
                            }
                            if let ::core::option::Option::Some(prepared_info) = prepared_info {
                                object_writer.write::<_, _, 4>(&prepared_info.offset());
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_direction) =
                                prepared_direction
                            {
                                object_writer.write::<_, _, 1>(&prepared_direction);
                            }
                            if let ::core::option::Option::Some(prepared_info) = prepared_info {
                                object_writer.write::<_, _, 1>(&prepared_info.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TraceNotification> for TraceNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    TraceNotification::create(
                        builder,
                        self.type_,
                        self.timestamp,
                        self.direction,
                        &self.info,
                    )
                }
            }

            /// Builder for serializing an instance of the [TraceNotification] type.
            ///
            /// Can be created using the [TraceNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TraceNotificationBuilder<State>(State);

            impl TraceNotificationBuilder<()> {
                /// Setter for the [`type` field](TraceNotification#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T0>(self, value: T0) -> TraceNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                {
                    TraceNotificationBuilder((value,))
                }

                /// Sets the [`type` field](TraceNotification#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> TraceNotificationBuilder<(::planus::DefaultValue,)> {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0> TraceNotificationBuilder<(T0,)> {
                /// Setter for the [`timestamp` field](TraceNotification#structfield.timestamp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp<T1>(self, value: T1) -> TraceNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u64, u64>,
                {
                    let (v0,) = self.0;
                    TraceNotificationBuilder((v0, value))
                }

                /// Sets the [`timestamp` field](TraceNotification#structfield.timestamp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn timestamp_as_default(
                    self,
                ) -> TraceNotificationBuilder<(T0, ::planus::DefaultValue)> {
                    self.timestamp(::planus::DefaultValue)
                }
            }

            impl<T0, T1> TraceNotificationBuilder<(T0, T1)> {
                /// Setter for the [`direction` field](TraceNotification#structfield.direction).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction<T2>(self, value: T2) -> TraceNotificationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                {
                    let (v0, v1) = self.0;
                    TraceNotificationBuilder((v0, v1, value))
                }

                /// Sets the [`direction` field](TraceNotification#structfield.direction) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction_as_default(
                    self,
                ) -> TraceNotificationBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.direction(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> TraceNotificationBuilder<(T0, T1, T2)> {
                /// Setter for the [`info` field](TraceNotification#structfield.info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn info<T3>(self, value: T3) -> TraceNotificationBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                {
                    let (v0, v1, v2) = self.0;
                    TraceNotificationBuilder((v0, v1, v2, value))
                }

                /// Sets the [`info` field](TraceNotification#structfield.info) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn info_as_null(self) -> TraceNotificationBuilder<(T0, T1, T2, ())> {
                    self.info(())
                }
            }

            impl<T0, T1, T2, T3> TraceNotificationBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TraceNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification>
                where
                    Self: ::planus::WriteAsOffset<TraceNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAs<::planus::Offset<TraceNotification>>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<TraceNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAsOptional<::planus::Offset<TraceNotification>>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<TraceNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::TraceEventType, self::TraceEventType>,
                    T1: ::planus::WriteAsDefault<u64, u64>,
                    T2: ::planus::WriteAsDefault<
                        super::common::TraceDirection,
                        super::common::TraceDirection,
                    >,
                    T3: ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                > ::planus::WriteAsOffset<TraceNotification>
                for TraceNotificationBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    let (v0, v1, v2, v3) = &self.0;
                    TraceNotification::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [TraceNotification].
            #[derive(Copy, Clone)]
            pub struct TraceNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TraceNotificationRef<'a> {
                /// Getter for the [`type` field](TraceNotification#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<self::TraceEventType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TraceNotification", "type_")?
                            .unwrap_or(self::TraceEventType::Keyframe),
                    )
                }

                /// Getter for the [`timestamp` field](TraceNotification#structfield.timestamp).
                #[inline]
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "TraceNotification", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`direction` field](TraceNotification#structfield.direction).
                #[inline]
                pub fn direction(&self) -> ::planus::Result<super::common::TraceDirection> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "TraceNotification", "direction")?
                            .unwrap_or(super::common::TraceDirection::DirectionIn),
                    )
                }

                /// Getter for the [`info` field](TraceNotification#structfield.info).
                #[inline]
                pub fn info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TraceInfoRef<'a>>>
                {
                    self.0.access_union(3, "TraceNotification", "info")
                }
            }

            impl<'a> ::core::fmt::Debug for TraceNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TraceNotificationRef");
                    f.field("type_", &self.type_());
                    f.field("timestamp", &self.timestamp());
                    f.field("direction", &self.direction());
                    if let ::core::option::Option::Some(field_info) = self.info().transpose() {
                        f.field("info", &field_info);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TraceNotificationRef<'a>> for TraceNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TraceNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        direction: ::core::convert::TryInto::try_into(value.direction()?)?,
                        info: if let ::core::option::Option::Some(info) = value.info()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(info)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TraceNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TraceNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TraceNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TraceNotification>> for TraceNotification {
                type Value = ::planus::Offset<TraceNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TraceNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TraceNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TraceNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.PipeTransport`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/pipeTransport.fbs`
        pub mod pipe_transport {
            /// The table `PipeTransportOptions` in the namespace `FBS.PipeTransport`
            ///
            /// Generated from these locations:
            /// * Table `PipeTransportOptions` in the file `../worker/fbs/pipeTransport.fbs:6`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PipeTransportOptions {
                /// The field `base` in the table `PipeTransportOptions`
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
                /// The field `listen_info` in the table `PipeTransportOptions`
                pub listen_info: ::planus::alloc::boxed::Box<super::transport::ListenInfo>,
                /// The field `enable_rtx` in the table `PipeTransportOptions`
                pub enable_rtx: bool,
                /// The field `enable_srtp` in the table `PipeTransportOptions`
                pub enable_srtp: bool,
            }

            impl PipeTransportOptions {
                /// Creates a [PipeTransportOptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PipeTransportOptionsBuilder<()> {
                    PipeTransportOptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    field_listen_info: impl ::planus::WriteAs<
                        ::planus::Offset<super::transport::ListenInfo>,
                    >,
                    field_enable_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_srtp: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_listen_info = field_listen_info.prepare(builder);
                    let prepared_enable_rtx = field_enable_rtx.prepare(builder, &false);
                    let prepared_enable_srtp = field_enable_srtp.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Options>>(0);
                    table_writer.write_entry::<::planus::Offset<super::transport::ListenInfo>>(1);
                    if prepared_enable_rtx.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }
                    if prepared_enable_srtp.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_listen_info);
                            if let ::core::option::Option::Some(prepared_enable_rtx) =
                                prepared_enable_rtx
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_rtx);
                            }
                            if let ::core::option::Option::Some(prepared_enable_srtp) =
                                prepared_enable_srtp
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_srtp);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PipeTransportOptions>> for PipeTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PipeTransportOptions>> for PipeTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PipeTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PipeTransportOptions> for PipeTransportOptions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions> {
                    PipeTransportOptions::create(
                        builder,
                        &self.base,
                        &self.listen_info,
                        self.enable_rtx,
                        self.enable_srtp,
                    )
                }
            }

            /// Builder for serializing an instance of the [PipeTransportOptions] type.
            ///
            /// Can be created using the [PipeTransportOptions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PipeTransportOptionsBuilder<State>(State);

            impl PipeTransportOptionsBuilder<()> {
                /// Setter for the [`base` field](PipeTransportOptions#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> PipeTransportOptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                {
                    PipeTransportOptionsBuilder((value,))
                }
            }

            impl<T0> PipeTransportOptionsBuilder<(T0,)> {
                /// Setter for the [`listen_info` field](PipeTransportOptions#structfield.listen_info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn listen_info<T1>(self, value: T1) -> PipeTransportOptionsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                {
                    let (v0,) = self.0;
                    PipeTransportOptionsBuilder((v0, value))
                }
            }

            impl<T0, T1> PipeTransportOptionsBuilder<(T0, T1)> {
                /// Setter for the [`enable_rtx` field](PipeTransportOptions#structfield.enable_rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_rtx<T2>(self, value: T2) -> PipeTransportOptionsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    PipeTransportOptionsBuilder((v0, v1, value))
                }

                /// Sets the [`enable_rtx` field](PipeTransportOptions#structfield.enable_rtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_rtx_as_default(
                    self,
                ) -> PipeTransportOptionsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.enable_rtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> PipeTransportOptionsBuilder<(T0, T1, T2)> {
                /// Setter for the [`enable_srtp` field](PipeTransportOptions#structfield.enable_srtp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_srtp<T3>(
                    self,
                    value: T3,
                ) -> PipeTransportOptionsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    PipeTransportOptionsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`enable_srtp` field](PipeTransportOptions#structfield.enable_srtp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_srtp_as_default(
                    self,
                ) -> PipeTransportOptionsBuilder<(T0, T1, T2, ::planus::DefaultValue)>
                {
                    self.enable_srtp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> PipeTransportOptionsBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PipeTransportOptions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions>
                where
                    Self: ::planus::WriteAsOffset<PipeTransportOptions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<PipeTransportOptions>>
                for PipeTransportOptionsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<PipeTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<PipeTransportOptions>>
                for PipeTransportOptionsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<PipeTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PipeTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<PipeTransportOptions>
                for PipeTransportOptionsBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions> {
                    let (v0, v1, v2, v3) = &self.0;
                    PipeTransportOptions::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [PipeTransportOptions].
            #[derive(Copy, Clone)]
            pub struct PipeTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PipeTransportOptionsRef<'a> {
                /// Getter for the [`base` field](PipeTransportOptions#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "PipeTransportOptions", "base")
                }

                /// Getter for the [`listen_info` field](PipeTransportOptions#structfield.listen_info).
                #[inline]
                pub fn listen_info(&self) -> ::planus::Result<super::transport::ListenInfoRef<'a>> {
                    self.0
                        .access_required(1, "PipeTransportOptions", "listen_info")
                }

                /// Getter for the [`enable_rtx` field](PipeTransportOptions#structfield.enable_rtx).
                #[inline]
                pub fn enable_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "PipeTransportOptions", "enable_rtx")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`enable_srtp` field](PipeTransportOptions#structfield.enable_srtp).
                #[inline]
                pub fn enable_srtp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "PipeTransportOptions", "enable_srtp")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PipeTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PipeTransportOptionsRef");
                    f.field("base", &self.base());
                    f.field("listen_info", &self.listen_info());
                    f.field("enable_rtx", &self.enable_rtx());
                    f.field("enable_srtp", &self.enable_srtp());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PipeTransportOptionsRef<'a>> for PipeTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PipeTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        listen_info: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.listen_info()?)?,
                        ),
                        enable_rtx: ::core::convert::TryInto::try_into(value.enable_rtx()?)?,
                        enable_srtp: ::core::convert::TryInto::try_into(value.enable_srtp()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PipeTransportOptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PipeTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PipeTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PipeTransportOptions>> for PipeTransportOptions {
                type Value = ::planus::Offset<PipeTransportOptions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PipeTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PipeTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PipeTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `ConnectRequest` in the namespace `FBS.PipeTransport`
            ///
            /// Generated from these locations:
            /// * Table `ConnectRequest` in the file `../worker/fbs/pipeTransport.fbs:13`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectRequest {
                /// The field `ip` in the table `ConnectRequest`
                pub ip: ::planus::alloc::string::String,
                /// The field `port` in the table `ConnectRequest`
                pub port: ::core::option::Option<u16>,
                /// The field `srtp_parameters` in the table `ConnectRequest`
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::srtp_parameters::SrtpParameters>,
                >,
            }

            impl ConnectRequest {
                /// Creates a [ConnectRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectRequestBuilder<()> {
                    ConnectRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_port: impl ::planus::WriteAsOptional<u16>,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);
                    let prepared_port = field_port.prepare(builder);
                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_srtp_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::srtp_parameters::SrtpParameters>>(2);
                    }
                    if prepared_port.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_ip);
                            if let ::core::option::Option::Some(prepared_srtp_parameters) =
                                prepared_srtp_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_srtp_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_port) = prepared_port {
                                object_writer.write::<_, _, 2>(&prepared_port);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectRequest> for ConnectRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ConnectRequest::create(builder, &self.ip, self.port, &self.srtp_parameters)
                }
            }

            /// Builder for serializing an instance of the [ConnectRequest] type.
            ///
            /// Can be created using the [ConnectRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectRequestBuilder<State>(State);

            impl ConnectRequestBuilder<()> {
                /// Setter for the [`ip` field](ConnectRequest#structfield.ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ip<T0>(self, value: T0) -> ConnectRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ConnectRequestBuilder((value,))
                }
            }

            impl<T0> ConnectRequestBuilder<(T0,)> {
                /// Setter for the [`port` field](ConnectRequest#structfield.port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port<T1>(self, value: T1) -> ConnectRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<u16>,
                {
                    let (v0,) = self.0;
                    ConnectRequestBuilder((v0, value))
                }

                /// Sets the [`port` field](ConnectRequest#structfield.port) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port_as_null(self) -> ConnectRequestBuilder<(T0, ())> {
                    self.port(())
                }
            }

            impl<T0, T1> ConnectRequestBuilder<(T0, T1)> {
                /// Setter for the [`srtp_parameters` field](ConnectRequest#structfield.srtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters<T2>(self, value: T2) -> ConnectRequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                {
                    let (v0, v1) = self.0;
                    ConnectRequestBuilder((v0, v1, value))
                }

                /// Sets the [`srtp_parameters` field](ConnectRequest#structfield.srtp_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters_as_null(self) -> ConnectRequestBuilder<(T0, T1, ())> {
                    self.srtp_parameters(())
                }
            }

            impl<T0, T1, T2> ConnectRequestBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest>
                where
                    Self: ::planus::WriteAsOffset<ConnectRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<u16>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAs<::planus::Offset<ConnectRequest>>
                for ConnectRequestBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<ConnectRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<u16>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>>
                for ConnectRequestBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<ConnectRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsOptional<u16>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOffset<ConnectRequest> for ConnectRequestBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    let (v0, v1, v2) = &self.0;
                    ConnectRequest::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [ConnectRequest].
            #[derive(Copy, Clone)]
            pub struct ConnectRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectRequestRef<'a> {
                /// Getter for the [`ip` field](ConnectRequest#structfield.ip).
                #[inline]
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ConnectRequest", "ip")
                }

                /// Getter for the [`port` field](ConnectRequest#structfield.port).
                #[inline]
                pub fn port(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(1, "ConnectRequest", "port")
                }

                /// Getter for the [`srtp_parameters` field](ConnectRequest#structfield.srtp_parameters).
                #[inline]
                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::srtp_parameters::SrtpParametersRef<'a>>,
                > {
                    self.0.access(2, "ConnectRequest", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectRequestRef");
                    f.field("ip", &self.ip());
                    if let ::core::option::Option::Some(field_port) = self.port().transpose() {
                        f.field("port", &field_port);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectRequestRef<'a>> for ConnectRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        port: if let ::core::option::Option::Some(port) = value.port()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(port)?)
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Value = ::planus::Offset<ConnectRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConnectResponse` in the namespace `FBS.PipeTransport`
            ///
            /// Generated from these locations:
            /// * Table `ConnectResponse` in the file `../worker/fbs/pipeTransport.fbs:19`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectResponse {
                /// The field `tuple` in the table `ConnectResponse`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl ConnectResponse {
                /// Creates a [ConnectResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectResponseBuilder<()> {
                    ConnectResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectResponse> for ConnectResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ConnectResponse::create(builder, &self.tuple)
                }
            }

            /// Builder for serializing an instance of the [ConnectResponse] type.
            ///
            /// Can be created using the [ConnectResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectResponseBuilder<State>(State);

            impl ConnectResponseBuilder<()> {
                /// Setter for the [`tuple` field](ConnectResponse#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T0>(self, value: T0) -> ConnectResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    ConnectResponseBuilder((value,))
                }
            }

            impl<T0> ConnectResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse>
                where
                    Self: ::planus::WriteAsOffset<ConnectResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAs<::planus::Offset<ConnectResponse>>
                for ConnectResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConnectResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>>
                for ConnectResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConnectResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOffset<ConnectResponse> for ConnectResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    let (v0,) = &self.0;
                    ConnectResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ConnectResponse].
            #[derive(Copy, Clone)]
            pub struct ConnectResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectResponseRef<'a> {
                /// Getter for the [`tuple` field](ConnectResponse#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "ConnectResponse", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectResponseRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectResponseRef<'a>> for ConnectResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Value = ::planus::Offset<ConnectResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.PipeTransport`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/pipeTransport.fbs:23`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `base` in the table `DumpResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
                /// The field `tuple` in the table `DumpResponse`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                /// The field `rtx` in the table `DumpResponse`
                pub rtx: bool,
                /// The field `srtp_parameters` in the table `DumpResponse`
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::srtp_parameters::SrtpParameters>,
                >,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_tuple = field_tuple.prepare(builder);
                    let prepared_rtx = field_rtx.prepare(builder, &false);
                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Dump>>(0);
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(1);
                    if prepared_srtp_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::srtp_parameters::SrtpParameters>>(3);
                    }
                    if prepared_rtx.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                            if let ::core::option::Option::Some(prepared_srtp_parameters) =
                                prepared_srtp_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_srtp_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_rtx) = prepared_rtx {
                                object_writer.write::<_, _, 1>(&prepared_rtx);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.base,
                        &self.tuple,
                        self.rtx,
                        &self.srtp_parameters,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`tuple` field](DumpResponse#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`rtx` field](DumpResponse#structfield.rtx).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }

                /// Sets the [`rtx` field](DumpResponse#structfield.rtx) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtx_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.rtx(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`srtp_parameters` field](DumpResponse#structfield.srtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters<T3>(self, value: T3) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`srtp_parameters` field](DumpResponse#structfield.srtp_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters_as_null(self) -> DumpResponseBuilder<(T0, T1, T2, ())> {
                    self.srtp_parameters(())
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOffset<DumpResponse> for DumpResponseBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }

                /// Getter for the [`tuple` field](DumpResponse#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(1, "DumpResponse", "tuple")
                }

                /// Getter for the [`rtx` field](DumpResponse#structfield.rtx).
                #[inline]
                pub fn rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "DumpResponse", "rtx")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`srtp_parameters` field](DumpResponse#structfield.srtp_parameters).
                #[inline]
                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::srtp_parameters::SrtpParametersRef<'a>>,
                > {
                    self.0.access(3, "DumpResponse", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.field("tuple", &self.tuple());
                    f.field("rtx", &self.rtx());
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtx: ::core::convert::TryInto::try_into(value.rtx()?)?,
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.PipeTransport`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/pipeTransport.fbs:30`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `base` in the table `GetStatsResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
                /// The field `tuple` in the table `GetStatsResponse`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Stats>>(0);
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.base, &self.tuple)
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                {
                    GetStatsResponseBuilder((value,))
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Setter for the [`tuple` field](GetStatsResponse#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T1>(self, value: T1) -> GetStatsResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0,) = self.0;
                    GetStatsResponseBuilder((v0, value))
                }
            }

            impl<T0, T1> GetStatsResponseBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                > ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponseBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0, v1) = &self.0;
                    GetStatsResponse::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }

                /// Getter for the [`tuple` field](GetStatsResponse#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(1, "GetStatsResponse", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }
        }
        /// The namespace `FBS.PlainTransport`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/plainTransport.fbs`
        pub mod plain_transport {
            /// The table `PlainTransportOptions` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `PlainTransportOptions` in the file `../worker/fbs/plainTransport.fbs:7`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PlainTransportOptions {
                /// The field `base` in the table `PlainTransportOptions`
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
                /// The field `listen_info` in the table `PlainTransportOptions`
                pub listen_info: ::planus::alloc::boxed::Box<super::transport::ListenInfo>,
                /// The field `rtcp_listen_info` in the table `PlainTransportOptions`
                pub rtcp_listen_info: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::transport::ListenInfo>,
                >,
                /// The field `rtcp_mux` in the table `PlainTransportOptions`
                pub rtcp_mux: bool,
                /// The field `comedia` in the table `PlainTransportOptions`
                pub comedia: bool,
                /// The field `enable_srtp` in the table `PlainTransportOptions`
                pub enable_srtp: bool,
                /// The field `srtp_crypto_suite` in the table `PlainTransportOptions`
                pub srtp_crypto_suite:
                    ::core::option::Option<super::srtp_parameters::SrtpCryptoSuite>,
            }

            impl PlainTransportOptions {
                /// Creates a [PlainTransportOptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PlainTransportOptionsBuilder<()> {
                    PlainTransportOptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    field_listen_info: impl ::planus::WriteAs<
                        ::planus::Offset<super::transport::ListenInfo>,
                    >,
                    field_rtcp_listen_info: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::ListenInfo>,
                    >,
                    field_rtcp_mux: impl ::planus::WriteAsDefault<bool, bool>,
                    field_comedia: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_srtp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_srtp_crypto_suite: impl ::planus::WriteAsOptional<
                        super::srtp_parameters::SrtpCryptoSuite,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_listen_info = field_listen_info.prepare(builder);
                    let prepared_rtcp_listen_info = field_rtcp_listen_info.prepare(builder);
                    let prepared_rtcp_mux = field_rtcp_mux.prepare(builder, &false);
                    let prepared_comedia = field_comedia.prepare(builder, &false);
                    let prepared_enable_srtp = field_enable_srtp.prepare(builder, &false);
                    let prepared_srtp_crypto_suite = field_srtp_crypto_suite.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<18> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Options>>(0);
                    table_writer.write_entry::<::planus::Offset<super::transport::ListenInfo>>(1);
                    if prepared_rtcp_listen_info.is_some() {
                        table_writer
                            .write_entry::<::planus::Offset<super::transport::ListenInfo>>(2);
                    }
                    if prepared_rtcp_mux.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }
                    if prepared_comedia.is_some() {
                        table_writer.write_entry::<bool>(4);
                    }
                    if prepared_enable_srtp.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }
                    if prepared_srtp_crypto_suite.is_some() {
                        table_writer.write_entry::<super::srtp_parameters::SrtpCryptoSuite>(6);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_listen_info);
                            if let ::core::option::Option::Some(prepared_rtcp_listen_info) =
                                prepared_rtcp_listen_info
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtcp_listen_info);
                            }
                            if let ::core::option::Option::Some(prepared_rtcp_mux) =
                                prepared_rtcp_mux
                            {
                                object_writer.write::<_, _, 1>(&prepared_rtcp_mux);
                            }
                            if let ::core::option::Option::Some(prepared_comedia) = prepared_comedia
                            {
                                object_writer.write::<_, _, 1>(&prepared_comedia);
                            }
                            if let ::core::option::Option::Some(prepared_enable_srtp) =
                                prepared_enable_srtp
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_srtp);
                            }
                            if let ::core::option::Option::Some(prepared_srtp_crypto_suite) =
                                prepared_srtp_crypto_suite
                            {
                                object_writer.write::<_, _, 1>(&prepared_srtp_crypto_suite);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PlainTransportOptions>> for PlainTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PlainTransportOptions>> for PlainTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlainTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PlainTransportOptions> for PlainTransportOptions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions> {
                    PlainTransportOptions::create(
                        builder,
                        &self.base,
                        &self.listen_info,
                        &self.rtcp_listen_info,
                        self.rtcp_mux,
                        self.comedia,
                        self.enable_srtp,
                        self.srtp_crypto_suite,
                    )
                }
            }

            /// Builder for serializing an instance of the [PlainTransportOptions] type.
            ///
            /// Can be created using the [PlainTransportOptions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PlainTransportOptionsBuilder<State>(State);

            impl PlainTransportOptionsBuilder<()> {
                /// Setter for the [`base` field](PlainTransportOptions#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> PlainTransportOptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                {
                    PlainTransportOptionsBuilder((value,))
                }
            }

            impl<T0> PlainTransportOptionsBuilder<(T0,)> {
                /// Setter for the [`listen_info` field](PlainTransportOptions#structfield.listen_info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn listen_info<T1>(self, value: T1) -> PlainTransportOptionsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                {
                    let (v0,) = self.0;
                    PlainTransportOptionsBuilder((v0, value))
                }
            }

            impl<T0, T1> PlainTransportOptionsBuilder<(T0, T1)> {
                /// Setter for the [`rtcp_listen_info` field](PlainTransportOptions#structfield.rtcp_listen_info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_listen_info<T2>(
                    self,
                    value: T2,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::transport::ListenInfo>>,
                {
                    let (v0, v1) = self.0;
                    PlainTransportOptionsBuilder((v0, v1, value))
                }

                /// Sets the [`rtcp_listen_info` field](PlainTransportOptions#structfield.rtcp_listen_info) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_listen_info_as_null(
                    self,
                ) -> PlainTransportOptionsBuilder<(T0, T1, ())> {
                    self.rtcp_listen_info(())
                }
            }

            impl<T0, T1, T2> PlainTransportOptionsBuilder<(T0, T1, T2)> {
                /// Setter for the [`rtcp_mux` field](PlainTransportOptions#structfield.rtcp_mux).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_mux<T3>(
                    self,
                    value: T3,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    PlainTransportOptionsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`rtcp_mux` field](PlainTransportOptions#structfield.rtcp_mux) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_mux_as_default(
                    self,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, ::planus::DefaultValue)>
                {
                    self.rtcp_mux(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> PlainTransportOptionsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`comedia` field](PlainTransportOptions#structfield.comedia).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn comedia<T4>(
                    self,
                    value: T4,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    PlainTransportOptionsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`comedia` field](PlainTransportOptions#structfield.comedia) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn comedia_as_default(
                    self,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.comedia(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`enable_srtp` field](PlainTransportOptions#structfield.enable_srtp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_srtp<T5>(
                    self,
                    value: T5,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    PlainTransportOptionsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`enable_srtp` field](PlainTransportOptions#structfield.enable_srtp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_srtp_as_default(
                    self,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.enable_srtp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`srtp_crypto_suite` field](PlainTransportOptions#structfield.srtp_crypto_suite).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_crypto_suite<T6>(
                    self,
                    value: T6,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsOptional<super::srtp_parameters::SrtpCryptoSuite>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    PlainTransportOptionsBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`srtp_crypto_suite` field](PlainTransportOptions#structfield.srtp_crypto_suite) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_crypto_suite_as_null(
                    self,
                ) -> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5, ())> {
                    self.srtp_crypto_suite(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PlainTransportOptions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions>
                where
                    Self: ::planus::WriteAsOffset<PlainTransportOptions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::transport::ListenInfo>>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                    T6: ::planus::WriteAsOptional<super::srtp_parameters::SrtpCryptoSuite>,
                > ::planus::WriteAs<::planus::Offset<PlainTransportOptions>>
                for PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<PlainTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::transport::ListenInfo>>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                    T6: ::planus::WriteAsOptional<super::srtp_parameters::SrtpCryptoSuite>,
                > ::planus::WriteAsOptional<::planus::Offset<PlainTransportOptions>>
                for PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<PlainTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlainTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAs<::planus::Offset<super::transport::ListenInfo>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<super::transport::ListenInfo>>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                    T6: ::planus::WriteAsOptional<super::srtp_parameters::SrtpCryptoSuite>,
                > ::planus::WriteAsOffset<PlainTransportOptions>
                for PlainTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions> {
                    let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                    PlainTransportOptions::create(builder, v0, v1, v2, v3, v4, v5, v6)
                }
            }

            /// Reference to a deserialized [PlainTransportOptions].
            #[derive(Copy, Clone)]
            pub struct PlainTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PlainTransportOptionsRef<'a> {
                /// Getter for the [`base` field](PlainTransportOptions#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "PlainTransportOptions", "base")
                }

                /// Getter for the [`listen_info` field](PlainTransportOptions#structfield.listen_info).
                #[inline]
                pub fn listen_info(&self) -> ::planus::Result<super::transport::ListenInfoRef<'a>> {
                    self.0
                        .access_required(1, "PlainTransportOptions", "listen_info")
                }

                /// Getter for the [`rtcp_listen_info` field](PlainTransportOptions#structfield.rtcp_listen_info).
                #[inline]
                pub fn rtcp_listen_info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::ListenInfoRef<'a>>>
                {
                    self.0
                        .access(2, "PlainTransportOptions", "rtcp_listen_info")
                }

                /// Getter for the [`rtcp_mux` field](PlainTransportOptions#structfield.rtcp_mux).
                #[inline]
                pub fn rtcp_mux(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "PlainTransportOptions", "rtcp_mux")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`comedia` field](PlainTransportOptions#structfield.comedia).
                #[inline]
                pub fn comedia(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "PlainTransportOptions", "comedia")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`enable_srtp` field](PlainTransportOptions#structfield.enable_srtp).
                #[inline]
                pub fn enable_srtp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "PlainTransportOptions", "enable_srtp")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`srtp_crypto_suite` field](PlainTransportOptions#structfield.srtp_crypto_suite).
                #[inline]
                pub fn srtp_crypto_suite(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::srtp_parameters::SrtpCryptoSuite>>
                {
                    self.0
                        .access(6, "PlainTransportOptions", "srtp_crypto_suite")
                }
            }

            impl<'a> ::core::fmt::Debug for PlainTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PlainTransportOptionsRef");
                    f.field("base", &self.base());
                    f.field("listen_info", &self.listen_info());
                    if let ::core::option::Option::Some(field_rtcp_listen_info) =
                        self.rtcp_listen_info().transpose()
                    {
                        f.field("rtcp_listen_info", &field_rtcp_listen_info);
                    }
                    f.field("rtcp_mux", &self.rtcp_mux());
                    f.field("comedia", &self.comedia());
                    f.field("enable_srtp", &self.enable_srtp());
                    if let ::core::option::Option::Some(field_srtp_crypto_suite) =
                        self.srtp_crypto_suite().transpose()
                    {
                        f.field("srtp_crypto_suite", &field_srtp_crypto_suite);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PlainTransportOptionsRef<'a>> for PlainTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PlainTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        listen_info: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.listen_info()?)?,
                        ),
                        rtcp_listen_info: if let ::core::option::Option::Some(rtcp_listen_info) =
                            value.rtcp_listen_info()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_listen_info)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp_mux: ::core::convert::TryInto::try_into(value.rtcp_mux()?)?,
                        comedia: ::core::convert::TryInto::try_into(value.comedia()?)?,
                        enable_srtp: ::core::convert::TryInto::try_into(value.enable_srtp()?)?,
                        srtp_crypto_suite: if let ::core::option::Option::Some(srtp_crypto_suite) =
                            value.srtp_crypto_suite()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                srtp_crypto_suite,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PlainTransportOptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PlainTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlainTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PlainTransportOptions>> for PlainTransportOptions {
                type Value = ::planus::Offset<PlainTransportOptions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PlainTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PlainTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlainTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `ConnectRequest` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `ConnectRequest` in the file `../worker/fbs/plainTransport.fbs:17`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectRequest {
                /// The field `ip` in the table `ConnectRequest`
                pub ip: ::core::option::Option<::planus::alloc::string::String>,
                /// The field `port` in the table `ConnectRequest`
                pub port: ::core::option::Option<u16>,
                /// The field `rtcp_port` in the table `ConnectRequest`
                pub rtcp_port: ::core::option::Option<u16>,
                /// The field `srtp_parameters` in the table `ConnectRequest`
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::srtp_parameters::SrtpParameters>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConnectRequest {
                fn default() -> Self {
                    Self {
                        ip: ::core::default::Default::default(),
                        port: ::core::default::Default::default(),
                        rtcp_port: ::core::default::Default::default(),
                        srtp_parameters: ::core::default::Default::default(),
                    }
                }
            }

            impl ConnectRequest {
                /// Creates a [ConnectRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectRequestBuilder<()> {
                    ConnectRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_port: impl ::planus::WriteAsOptional<u16>,
                    field_rtcp_port: impl ::planus::WriteAsOptional<u16>,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);
                    let prepared_port = field_port.prepare(builder);
                    let prepared_rtcp_port = field_rtcp_port.prepare(builder);
                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_ip.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(0);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::srtp_parameters::SrtpParameters>>(3);
                    }
                    if prepared_port.is_some() {
                        table_writer.write_entry::<u16>(1);
                    }
                    if prepared_rtcp_port.is_some() {
                        table_writer.write_entry::<u16>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ip) = prepared_ip {
                                object_writer.write::<_, _, 4>(&prepared_ip);
                            }
                            if let ::core::option::Option::Some(prepared_srtp_parameters) =
                                prepared_srtp_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_srtp_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_port) = prepared_port {
                                object_writer.write::<_, _, 2>(&prepared_port);
                            }
                            if let ::core::option::Option::Some(prepared_rtcp_port) =
                                prepared_rtcp_port
                            {
                                object_writer.write::<_, _, 2>(&prepared_rtcp_port);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectRequest> for ConnectRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ConnectRequest::create(
                        builder,
                        &self.ip,
                        self.port,
                        self.rtcp_port,
                        &self.srtp_parameters,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConnectRequest] type.
            ///
            /// Can be created using the [ConnectRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectRequestBuilder<State>(State);

            impl ConnectRequestBuilder<()> {
                /// Setter for the [`ip` field](ConnectRequest#structfield.ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ip<T0>(self, value: T0) -> ConnectRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    ConnectRequestBuilder((value,))
                }

                /// Sets the [`ip` field](ConnectRequest#structfield.ip) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ip_as_null(self) -> ConnectRequestBuilder<((),)> {
                    self.ip(())
                }
            }

            impl<T0> ConnectRequestBuilder<(T0,)> {
                /// Setter for the [`port` field](ConnectRequest#structfield.port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port<T1>(self, value: T1) -> ConnectRequestBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<u16>,
                {
                    let (v0,) = self.0;
                    ConnectRequestBuilder((v0, value))
                }

                /// Sets the [`port` field](ConnectRequest#structfield.port) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port_as_null(self) -> ConnectRequestBuilder<(T0, ())> {
                    self.port(())
                }
            }

            impl<T0, T1> ConnectRequestBuilder<(T0, T1)> {
                /// Setter for the [`rtcp_port` field](ConnectRequest#structfield.rtcp_port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_port<T2>(self, value: T2) -> ConnectRequestBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<u16>,
                {
                    let (v0, v1) = self.0;
                    ConnectRequestBuilder((v0, v1, value))
                }

                /// Sets the [`rtcp_port` field](ConnectRequest#structfield.rtcp_port) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_port_as_null(self) -> ConnectRequestBuilder<(T0, T1, ())> {
                    self.rtcp_port(())
                }
            }

            impl<T0, T1, T2> ConnectRequestBuilder<(T0, T1, T2)> {
                /// Setter for the [`srtp_parameters` field](ConnectRequest#structfield.srtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters<T3>(
                    self,
                    value: T3,
                ) -> ConnectRequestBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    ConnectRequestBuilder((v0, v1, v2, value))
                }

                /// Sets the [`srtp_parameters` field](ConnectRequest#structfield.srtp_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters_as_null(self) -> ConnectRequestBuilder<(T0, T1, T2, ())> {
                    self.srtp_parameters(())
                }
            }

            impl<T0, T1, T2, T3> ConnectRequestBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest>
                where
                    Self: ::planus::WriteAsOffset<ConnectRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<u16>,
                    T2: ::planus::WriteAsOptional<u16>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAs<::planus::Offset<ConnectRequest>>
                for ConnectRequestBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<ConnectRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<u16>,
                    T2: ::planus::WriteAsOptional<u16>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>>
                for ConnectRequestBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<ConnectRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T1: ::planus::WriteAsOptional<u16>,
                    T2: ::planus::WriteAsOptional<u16>,
                    T3: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOffset<ConnectRequest>
                for ConnectRequestBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    let (v0, v1, v2, v3) = &self.0;
                    ConnectRequest::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [ConnectRequest].
            #[derive(Copy, Clone)]
            pub struct ConnectRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectRequestRef<'a> {
                /// Getter for the [`ip` field](ConnectRequest#structfield.ip).
                #[inline]
                pub fn ip(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "ConnectRequest", "ip")
                }

                /// Getter for the [`port` field](ConnectRequest#structfield.port).
                #[inline]
                pub fn port(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(1, "ConnectRequest", "port")
                }

                /// Getter for the [`rtcp_port` field](ConnectRequest#structfield.rtcp_port).
                #[inline]
                pub fn rtcp_port(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(2, "ConnectRequest", "rtcp_port")
                }

                /// Getter for the [`srtp_parameters` field](ConnectRequest#structfield.srtp_parameters).
                #[inline]
                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::srtp_parameters::SrtpParametersRef<'a>>,
                > {
                    self.0.access(3, "ConnectRequest", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectRequestRef");
                    if let ::core::option::Option::Some(field_ip) = self.ip().transpose() {
                        f.field("ip", &field_ip);
                    }
                    if let ::core::option::Option::Some(field_port) = self.port().transpose() {
                        f.field("port", &field_port);
                    }
                    if let ::core::option::Option::Some(field_rtcp_port) =
                        self.rtcp_port().transpose()
                    {
                        f.field("rtcp_port", &field_rtcp_port);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectRequestRef<'a>> for ConnectRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: if let ::core::option::Option::Some(ip) = value.ip()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(ip)?)
                        } else {
                            ::core::option::Option::None
                        },
                        port: if let ::core::option::Option::Some(port) = value.port()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(port)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp_port: if let ::core::option::Option::Some(rtcp_port) =
                            value.rtcp_port()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtcp_port,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Value = ::planus::Offset<ConnectRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConnectResponse` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `ConnectResponse` in the file `../worker/fbs/plainTransport.fbs:24`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectResponse {
                /// The field `tuple` in the table `ConnectResponse`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                /// The field `rtcp_tuple` in the table `ConnectResponse`
                pub rtcp_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                /// The field `srtp_parameters` in the table `ConnectResponse`
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::srtp_parameters::SrtpParameters>,
                >,
            }

            impl ConnectResponse {
                /// Creates a [ConnectResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectResponseBuilder<()> {
                    ConnectResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtcp_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);
                    let prepared_rtcp_tuple = field_rtcp_tuple.prepare(builder);
                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(0);
                    if prepared_rtcp_tuple.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(1);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::srtp_parameters::SrtpParameters>>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                            if let ::core::option::Option::Some(prepared_rtcp_tuple) =
                                prepared_rtcp_tuple
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtcp_tuple);
                            }
                            if let ::core::option::Option::Some(prepared_srtp_parameters) =
                                prepared_srtp_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_srtp_parameters);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectResponse> for ConnectResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ConnectResponse::create(
                        builder,
                        &self.tuple,
                        &self.rtcp_tuple,
                        &self.srtp_parameters,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConnectResponse] type.
            ///
            /// Can be created using the [ConnectResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectResponseBuilder<State>(State);

            impl ConnectResponseBuilder<()> {
                /// Setter for the [`tuple` field](ConnectResponse#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T0>(self, value: T0) -> ConnectResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    ConnectResponseBuilder((value,))
                }
            }

            impl<T0> ConnectResponseBuilder<(T0,)> {
                /// Setter for the [`rtcp_tuple` field](ConnectResponse#structfield.rtcp_tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_tuple<T1>(self, value: T1) -> ConnectResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0,) = self.0;
                    ConnectResponseBuilder((v0, value))
                }

                /// Sets the [`rtcp_tuple` field](ConnectResponse#structfield.rtcp_tuple) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_tuple_as_null(self) -> ConnectResponseBuilder<(T0, ())> {
                    self.rtcp_tuple(())
                }
            }

            impl<T0, T1> ConnectResponseBuilder<(T0, T1)> {
                /// Setter for the [`srtp_parameters` field](ConnectResponse#structfield.srtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters<T2>(self, value: T2) -> ConnectResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                {
                    let (v0, v1) = self.0;
                    ConnectResponseBuilder((v0, v1, value))
                }

                /// Sets the [`srtp_parameters` field](ConnectResponse#structfield.srtp_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters_as_null(self) -> ConnectResponseBuilder<(T0, T1, ())> {
                    self.srtp_parameters(())
                }
            }

            impl<T0, T1, T2> ConnectResponseBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse>
                where
                    Self: ::planus::WriteAsOffset<ConnectResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAs<::planus::Offset<ConnectResponse>>
                for ConnectResponseBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<ConnectResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>>
                for ConnectResponseBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<ConnectResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T2: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOffset<ConnectResponse>
                for ConnectResponseBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    let (v0, v1, v2) = &self.0;
                    ConnectResponse::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [ConnectResponse].
            #[derive(Copy, Clone)]
            pub struct ConnectResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectResponseRef<'a> {
                /// Getter for the [`tuple` field](ConnectResponse#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "ConnectResponse", "tuple")
                }

                /// Getter for the [`rtcp_tuple` field](ConnectResponse#structfield.rtcp_tuple).
                #[inline]
                pub fn rtcp_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(1, "ConnectResponse", "rtcp_tuple")
                }

                /// Getter for the [`srtp_parameters` field](ConnectResponse#structfield.srtp_parameters).
                #[inline]
                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::srtp_parameters::SrtpParametersRef<'a>>,
                > {
                    self.0.access(2, "ConnectResponse", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectResponseRef");
                    f.field("tuple", &self.tuple());
                    if let ::core::option::Option::Some(field_rtcp_tuple) =
                        self.rtcp_tuple().transpose()
                    {
                        f.field("rtcp_tuple", &field_rtcp_tuple);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectResponseRef<'a>> for ConnectResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtcp_tuple: if let ::core::option::Option::Some(rtcp_tuple) =
                            value.rtcp_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Value = ::planus::Offset<ConnectResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/plainTransport.fbs:30`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `base` in the table `DumpResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
                /// The field `rtcp_mux` in the table `DumpResponse`
                pub rtcp_mux: bool,
                /// The field `comedia` in the table `DumpResponse`
                pub comedia: bool,
                /// The field `tuple` in the table `DumpResponse`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                /// The field `rtcp_tuple` in the table `DumpResponse`
                pub rtcp_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                /// The field `srtp_parameters` in the table `DumpResponse`
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::srtp_parameters::SrtpParameters>,
                >,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    field_rtcp_mux: impl ::planus::WriteAsDefault<bool, bool>,
                    field_comedia: impl ::planus::WriteAsDefault<bool, bool>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtcp_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_rtcp_mux = field_rtcp_mux.prepare(builder, &false);
                    let prepared_comedia = field_comedia.prepare(builder, &false);
                    let prepared_tuple = field_tuple.prepare(builder);
                    let prepared_rtcp_tuple = field_rtcp_tuple.prepare(builder);
                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Dump>>(0);
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(3);
                    if prepared_rtcp_tuple.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(4);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::srtp_parameters::SrtpParameters>>(5);
                    }
                    if prepared_rtcp_mux.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }
                    if prepared_comedia.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                            if let ::core::option::Option::Some(prepared_rtcp_tuple) =
                                prepared_rtcp_tuple
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtcp_tuple);
                            }
                            if let ::core::option::Option::Some(prepared_srtp_parameters) =
                                prepared_srtp_parameters
                            {
                                object_writer.write::<_, _, 4>(&prepared_srtp_parameters);
                            }
                            if let ::core::option::Option::Some(prepared_rtcp_mux) =
                                prepared_rtcp_mux
                            {
                                object_writer.write::<_, _, 1>(&prepared_rtcp_mux);
                            }
                            if let ::core::option::Option::Some(prepared_comedia) = prepared_comedia
                            {
                                object_writer.write::<_, _, 1>(&prepared_comedia);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.base,
                        self.rtcp_mux,
                        self.comedia,
                        &self.tuple,
                        &self.rtcp_tuple,
                        &self.srtp_parameters,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`rtcp_mux` field](DumpResponse#structfield.rtcp_mux).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_mux<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }

                /// Sets the [`rtcp_mux` field](DumpResponse#structfield.rtcp_mux) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_mux_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.rtcp_mux(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`comedia` field](DumpResponse#structfield.comedia).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn comedia<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }

                /// Sets the [`comedia` field](DumpResponse#structfield.comedia) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn comedia_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.comedia(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`tuple` field](DumpResponse#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T3>(self, value: T3) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`rtcp_tuple` field](DumpResponse#structfield.rtcp_tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_tuple<T4>(self, value: T4) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`rtcp_tuple` field](DumpResponse#structfield.rtcp_tuple) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_tuple_as_null(self) -> DumpResponseBuilder<(T0, T1, T2, T3, ())> {
                    self.rtcp_tuple(())
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`srtp_parameters` field](DumpResponse#structfield.srtp_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters<T5>(
                    self,
                    value: T5,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`srtp_parameters` field](DumpResponse#structfield.srtp_parameters) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn srtp_parameters_as_null(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.srtp_parameters(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T5: ::planus::WriteAsOptional<
                        ::planus::Offset<super::srtp_parameters::SrtpParameters>,
                    >,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }

                /// Getter for the [`rtcp_mux` field](DumpResponse#structfield.rtcp_mux).
                #[inline]
                pub fn rtcp_mux(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DumpResponse", "rtcp_mux")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`comedia` field](DumpResponse#structfield.comedia).
                #[inline]
                pub fn comedia(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "DumpResponse", "comedia")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`tuple` field](DumpResponse#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(3, "DumpResponse", "tuple")
                }

                /// Getter for the [`rtcp_tuple` field](DumpResponse#structfield.rtcp_tuple).
                #[inline]
                pub fn rtcp_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(4, "DumpResponse", "rtcp_tuple")
                }

                /// Getter for the [`srtp_parameters` field](DumpResponse#structfield.srtp_parameters).
                #[inline]
                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::srtp_parameters::SrtpParametersRef<'a>>,
                > {
                    self.0.access(5, "DumpResponse", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.field("rtcp_mux", &self.rtcp_mux());
                    f.field("comedia", &self.comedia());
                    f.field("tuple", &self.tuple());
                    if let ::core::option::Option::Some(field_rtcp_tuple) =
                        self.rtcp_tuple().transpose()
                    {
                        f.field("rtcp_tuple", &field_rtcp_tuple);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtcp_mux: ::core::convert::TryInto::try_into(value.rtcp_mux()?)?,
                        comedia: ::core::convert::TryInto::try_into(value.comedia()?)?,
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtcp_tuple: if let ::core::option::Option::Some(rtcp_tuple) =
                            value.rtcp_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/plainTransport.fbs:39`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `base` in the table `GetStatsResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
                /// The field `rtcp_mux` in the table `GetStatsResponse`
                pub rtcp_mux: bool,
                /// The field `comedia` in the table `GetStatsResponse`
                pub comedia: bool,
                /// The field `tuple` in the table `GetStatsResponse`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                /// The field `rtcp_tuple` in the table `GetStatsResponse`
                pub rtcp_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    field_rtcp_mux: impl ::planus::WriteAsDefault<bool, bool>,
                    field_comedia: impl ::planus::WriteAsDefault<bool, bool>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtcp_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_rtcp_mux = field_rtcp_mux.prepare(builder, &false);
                    let prepared_comedia = field_comedia.prepare(builder, &false);
                    let prepared_tuple = field_tuple.prepare(builder);
                    let prepared_rtcp_tuple = field_rtcp_tuple.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Stats>>(0);
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(3);
                    if prepared_rtcp_tuple.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(4);
                    }
                    if prepared_rtcp_mux.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }
                    if prepared_comedia.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                            if let ::core::option::Option::Some(prepared_rtcp_tuple) =
                                prepared_rtcp_tuple
                            {
                                object_writer.write::<_, _, 4>(&prepared_rtcp_tuple);
                            }
                            if let ::core::option::Option::Some(prepared_rtcp_mux) =
                                prepared_rtcp_mux
                            {
                                object_writer.write::<_, _, 1>(&prepared_rtcp_mux);
                            }
                            if let ::core::option::Option::Some(prepared_comedia) = prepared_comedia
                            {
                                object_writer.write::<_, _, 1>(&prepared_comedia);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        &self.base,
                        self.rtcp_mux,
                        self.comedia,
                        &self.tuple,
                        &self.rtcp_tuple,
                    )
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                {
                    GetStatsResponseBuilder((value,))
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Setter for the [`rtcp_mux` field](GetStatsResponse#structfield.rtcp_mux).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_mux<T1>(self, value: T1) -> GetStatsResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    GetStatsResponseBuilder((v0, value))
                }

                /// Sets the [`rtcp_mux` field](GetStatsResponse#structfield.rtcp_mux) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_mux_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.rtcp_mux(::planus::DefaultValue)
                }
            }

            impl<T0, T1> GetStatsResponseBuilder<(T0, T1)> {
                /// Setter for the [`comedia` field](GetStatsResponse#structfield.comedia).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn comedia<T2>(self, value: T2) -> GetStatsResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    GetStatsResponseBuilder((v0, v1, value))
                }

                /// Sets the [`comedia` field](GetStatsResponse#structfield.comedia) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn comedia_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.comedia(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> GetStatsResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`tuple` field](GetStatsResponse#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T3>(self, value: T3) -> GetStatsResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0, v1, v2) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> GetStatsResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`rtcp_tuple` field](GetStatsResponse#structfield.rtcp_tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_tuple<T4>(
                    self,
                    value: T4,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`rtcp_tuple` field](GetStatsResponse#structfield.rtcp_tuple) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rtcp_tuple_as_null(self) -> GetStatsResponseBuilder<(T0, T1, T2, T3, ())> {
                    self.rtcp_tuple(())
                }
            }

            impl<T0, T1, T2, T3, T4> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                > ::planus::WriteAsOffset<GetStatsResponse>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    GetStatsResponse::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }

                /// Getter for the [`rtcp_mux` field](GetStatsResponse#structfield.rtcp_mux).
                #[inline]
                pub fn rtcp_mux(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "GetStatsResponse", "rtcp_mux")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`comedia` field](GetStatsResponse#structfield.comedia).
                #[inline]
                pub fn comedia(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "GetStatsResponse", "comedia")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`tuple` field](GetStatsResponse#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(3, "GetStatsResponse", "tuple")
                }

                /// Getter for the [`rtcp_tuple` field](GetStatsResponse#structfield.rtcp_tuple).
                #[inline]
                pub fn rtcp_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(4, "GetStatsResponse", "rtcp_tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.field("rtcp_mux", &self.rtcp_mux());
                    f.field("comedia", &self.comedia());
                    f.field("tuple", &self.tuple());
                    if let ::core::option::Option::Some(field_rtcp_tuple) =
                        self.rtcp_tuple().transpose()
                    {
                        f.field("rtcp_tuple", &field_rtcp_tuple);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtcp_mux: ::core::convert::TryInto::try_into(value.rtcp_mux()?)?,
                        comedia: ::core::convert::TryInto::try_into(value.comedia()?)?,
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtcp_tuple: if let ::core::option::Option::Some(rtcp_tuple) =
                            value.rtcp_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `TupleNotification` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `TupleNotification` in the file `../worker/fbs/plainTransport.fbs:49`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TupleNotification {
                /// The field `tuple` in the table `TupleNotification`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl TupleNotification {
                /// Creates a [TupleNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TupleNotificationBuilder<()> {
                    TupleNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TupleNotification>> for TupleNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TupleNotification>> for TupleNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TupleNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TupleNotification> for TupleNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification> {
                    TupleNotification::create(builder, &self.tuple)
                }
            }

            /// Builder for serializing an instance of the [TupleNotification] type.
            ///
            /// Can be created using the [TupleNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TupleNotificationBuilder<State>(State);

            impl TupleNotificationBuilder<()> {
                /// Setter for the [`tuple` field](TupleNotification#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T0>(self, value: T0) -> TupleNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    TupleNotificationBuilder((value,))
                }
            }

            impl<T0> TupleNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [TupleNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification>
                where
                    Self: ::planus::WriteAsOffset<TupleNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAs<::planus::Offset<TupleNotification>>
                for TupleNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<TupleNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOptional<::planus::Offset<TupleNotification>>
                for TupleNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<TupleNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TupleNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOffset<TupleNotification> for TupleNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification> {
                    let (v0,) = &self.0;
                    TupleNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [TupleNotification].
            #[derive(Copy, Clone)]
            pub struct TupleNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TupleNotificationRef<'a> {
                /// Getter for the [`tuple` field](TupleNotification#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "TupleNotification", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for TupleNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TupleNotificationRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TupleNotificationRef<'a>> for TupleNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TupleNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TupleNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TupleNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TupleNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TupleNotification>> for TupleNotification {
                type Value = ::planus::Offset<TupleNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TupleNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TupleNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TupleNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RtcpTupleNotification` in the namespace `FBS.PlainTransport`
            ///
            /// Generated from these locations:
            /// * Table `RtcpTupleNotification` in the file `../worker/fbs/plainTransport.fbs:53`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpTupleNotification {
                /// The field `tuple` in the table `RtcpTupleNotification`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl RtcpTupleNotification {
                /// Creates a [RtcpTupleNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RtcpTupleNotificationBuilder<()> {
                    RtcpTupleNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpTupleNotification>> for RtcpTupleNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpTupleNotification>> for RtcpTupleNotification {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpTupleNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpTupleNotification> for RtcpTupleNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification> {
                    RtcpTupleNotification::create(builder, &self.tuple)
                }
            }

            /// Builder for serializing an instance of the [RtcpTupleNotification] type.
            ///
            /// Can be created using the [RtcpTupleNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RtcpTupleNotificationBuilder<State>(State);

            impl RtcpTupleNotificationBuilder<()> {
                /// Setter for the [`tuple` field](RtcpTupleNotification#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T0>(self, value: T0) -> RtcpTupleNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    RtcpTupleNotificationBuilder((value,))
                }
            }

            impl<T0> RtcpTupleNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RtcpTupleNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification>
                where
                    Self: ::planus::WriteAsOffset<RtcpTupleNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAs<::planus::Offset<RtcpTupleNotification>>
                for RtcpTupleNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtcpTupleNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOptional<::planus::Offset<RtcpTupleNotification>>
                for RtcpTupleNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RtcpTupleNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpTupleNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOffset<RtcpTupleNotification>
                for RtcpTupleNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification> {
                    let (v0,) = &self.0;
                    RtcpTupleNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RtcpTupleNotification].
            #[derive(Copy, Clone)]
            pub struct RtcpTupleNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpTupleNotificationRef<'a> {
                /// Getter for the [`tuple` field](RtcpTupleNotification#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "RtcpTupleNotification", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpTupleNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpTupleNotificationRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpTupleNotificationRef<'a>> for RtcpTupleNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpTupleNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpTupleNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpTupleNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpTupleNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpTupleNotification>> for RtcpTupleNotification {
                type Value = ::planus::Offset<RtcpTupleNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpTupleNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpTupleNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpTupleNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.WebRtcTransport`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/webRtcTransport.fbs`
        pub mod web_rtc_transport {
            /// The table `ListenIndividual` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `ListenIndividual` in the file `../worker/fbs/webRtcTransport.fbs:6`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenIndividual {
                /// The field `listen_infos` in the table `ListenIndividual`
                pub listen_infos: ::planus::alloc::vec::Vec<super::transport::ListenInfo>,
            }

            impl ListenIndividual {
                /// Creates a [ListenIndividualBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ListenIndividualBuilder<()> {
                    ListenIndividualBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_listen_infos: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_listen_infos = field_listen_infos.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_listen_infos);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenIndividual>> for ListenIndividual {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenIndividual>> for ListenIndividual {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenIndividual>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenIndividual> for ListenIndividual {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual> {
                    ListenIndividual::create(builder, &self.listen_infos)
                }
            }

            /// Builder for serializing an instance of the [ListenIndividual] type.
            ///
            /// Can be created using the [ListenIndividual::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ListenIndividualBuilder<State>(State);

            impl ListenIndividualBuilder<()> {
                /// Setter for the [`listen_infos` field](ListenIndividual#structfield.listen_infos).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn listen_infos<T0>(self, value: T0) -> ListenIndividualBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                {
                    ListenIndividualBuilder((value,))
                }
            }

            impl<T0> ListenIndividualBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ListenIndividual].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual>
                where
                    Self: ::planus::WriteAsOffset<ListenIndividual>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                > ::planus::WriteAs<::planus::Offset<ListenIndividual>>
                for ListenIndividualBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ListenIndividual>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                > ::planus::WriteAsOptional<::planus::Offset<ListenIndividual>>
                for ListenIndividualBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ListenIndividual>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenIndividual>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenInfo>]>,
                    >,
                > ::planus::WriteAsOffset<ListenIndividual> for ListenIndividualBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual> {
                    let (v0,) = &self.0;
                    ListenIndividual::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ListenIndividual].
            #[derive(Copy, Clone)]
            pub struct ListenIndividualRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenIndividualRef<'a> {
                /// Getter for the [`listen_infos` field](ListenIndividual#structfield.listen_infos).
                #[inline]
                pub fn listen_infos(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::transport::ListenInfoRef<'a>>>,
                > {
                    self.0
                        .access_required(0, "ListenIndividual", "listen_infos")
                }
            }

            impl<'a> ::core::fmt::Debug for ListenIndividualRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenIndividualRef");
                    f.field("listen_infos", &self.listen_infos());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenIndividualRef<'a>> for ListenIndividual {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenIndividualRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        listen_infos: value.listen_infos()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenIndividualRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenIndividualRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenIndividualRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenIndividual>> for ListenIndividual {
                type Value = ::planus::Offset<ListenIndividual>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenIndividual>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenIndividualRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenIndividualRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ListenServer` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `ListenServer` in the file `../worker/fbs/webRtcTransport.fbs:10`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenServer {
                /// The field `web_rtc_server_id` in the table `ListenServer`
                pub web_rtc_server_id: ::planus::alloc::string::String,
            }

            impl ListenServer {
                /// Creates a [ListenServerBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ListenServerBuilder<()> {
                    ListenServerBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_web_rtc_server_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_web_rtc_server_id = field_web_rtc_server_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_web_rtc_server_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenServer>> for ListenServer {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenServer>> for ListenServer {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenServer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenServer> for ListenServer {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer> {
                    ListenServer::create(builder, &self.web_rtc_server_id)
                }
            }

            /// Builder for serializing an instance of the [ListenServer] type.
            ///
            /// Can be created using the [ListenServer::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ListenServerBuilder<State>(State);

            impl ListenServerBuilder<()> {
                /// Setter for the [`web_rtc_server_id` field](ListenServer#structfield.web_rtc_server_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn web_rtc_server_id<T0>(self, value: T0) -> ListenServerBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ListenServerBuilder((value,))
                }
            }

            impl<T0> ListenServerBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ListenServer].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer>
                where
                    Self: ::planus::WriteAsOffset<ListenServer>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<ListenServer>> for ListenServerBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ListenServer>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<ListenServer>>
                for ListenServerBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ListenServer>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenServer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<ListenServer>
                for ListenServerBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer> {
                    let (v0,) = &self.0;
                    ListenServer::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ListenServer].
            #[derive(Copy, Clone)]
            pub struct ListenServerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenServerRef<'a> {
                /// Getter for the [`web_rtc_server_id` field](ListenServer#structfield.web_rtc_server_id).
                #[inline]
                pub fn web_rtc_server_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ListenServer", "web_rtc_server_id")
                }
            }

            impl<'a> ::core::fmt::Debug for ListenServerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenServerRef");
                    f.field("web_rtc_server_id", &self.web_rtc_server_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenServerRef<'a>> for ListenServer {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenServerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        web_rtc_server_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_server_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenServerRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenServerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenServerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenServer>> for ListenServer {
                type Value = ::planus::Offset<ListenServer>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenServer>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenServerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenServerRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `Listen` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Union `Listen` in the file `../worker/fbs/webRtcTransport.fbs:14`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Listen {
                /// The variant of type `ListenIndividual` in the union `Listen`
                ListenIndividual(::planus::alloc::boxed::Box<self::ListenIndividual>),

                /// The variant of type `ListenServer` in the union `Listen`
                ListenServer(::planus::alloc::boxed::Box<self::ListenServer>),
            }

            impl Listen {
                /// Creates a [ListenBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ListenBuilder<::planus::Uninitialized> {
                    ListenBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_listen_individual(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::ListenIndividual>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_listen_server(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::ListenServer>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Listen> for Listen {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::ListenIndividual(value) => {
                            Self::create_listen_individual(builder, value)
                        }
                        Self::ListenServer(value) => Self::create_listen_server(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Listen> for Listen {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [Listen] type.
            ///
            /// Can be created using the [Listen::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ListenBuilder<T>(T);

            impl ListenBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`ListenIndividual` variant](Listen#variant.ListenIndividual).
                #[inline]
                pub fn listen_individual<T>(
                    self,
                    value: T,
                ) -> ListenBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::ListenIndividual>,
                {
                    ListenBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`ListenServer` variant](Listen#variant.ListenServer).
                #[inline]
                pub fn listen_server<T>(
                    self,
                    value: T,
                ) -> ListenBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::ListenServer>,
                {
                    ListenBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> ListenBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [Listen].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<Listen>
                where
                    Self: ::planus::WriteAsUnion<Listen>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<Listen> for ListenBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ListenIndividual>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<Listen> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Listen> for ListenBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::ListenIndividual>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Listen>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<Listen> for ListenBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ListenServer>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<Listen> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<Listen> for ListenBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::ListenServer>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Listen>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [Listen].
            #[derive(Copy, Clone, Debug)]
            pub enum ListenRef<'a> {
                ListenIndividual(self::ListenIndividualRef<'a>),
                ListenServer(self::ListenServerRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<ListenRef<'a>> for Listen {
                type Error = ::planus::Error;

                fn try_from(value: ListenRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        ListenRef::ListenIndividual(value) => {
                            Self::ListenIndividual(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        ListenRef::ListenServer(value) => {
                            Self::ListenServer(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for ListenRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::ListenIndividual(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::ListenServer(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `WebRtcTransportOptions` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `WebRtcTransportOptions` in the file `../worker/fbs/webRtcTransport.fbs:19`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct WebRtcTransportOptions {
                /// The field `base` in the table `WebRtcTransportOptions`
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
                /// The field `listen` in the table `WebRtcTransportOptions`
                pub listen: self::Listen,
                /// The field `enable_udp` in the table `WebRtcTransportOptions`
                pub enable_udp: bool,
                /// The field `enable_tcp` in the table `WebRtcTransportOptions`
                pub enable_tcp: bool,
                /// The field `prefer_udp` in the table `WebRtcTransportOptions`
                pub prefer_udp: bool,
                /// The field `prefer_tcp` in the table `WebRtcTransportOptions`
                pub prefer_tcp: bool,
            }

            impl WebRtcTransportOptions {
                /// Creates a [WebRtcTransportOptionsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> WebRtcTransportOptionsBuilder<()> {
                    WebRtcTransportOptionsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    field_listen: impl ::planus::WriteAsUnion<self::Listen>,
                    field_enable_udp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_tcp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_prefer_udp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_prefer_tcp: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_listen = field_listen.prepare(builder);
                    let prepared_enable_udp = field_enable_udp.prepare(builder, &true);
                    let prepared_enable_tcp = field_enable_tcp.prepare(builder, &true);
                    let prepared_prefer_udp = field_prefer_udp.prepare(builder, &false);
                    let prepared_prefer_tcp = field_prefer_tcp.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<18> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Options>>(0);
                    table_writer.write_entry::<::planus::Offset<self::Listen>>(2);
                    table_writer.write_entry::<u8>(1);
                    if prepared_enable_udp.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }
                    if prepared_enable_tcp.is_some() {
                        table_writer.write_entry::<bool>(4);
                    }
                    if prepared_prefer_udp.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }
                    if prepared_prefer_tcp.is_some() {
                        table_writer.write_entry::<bool>(6);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_listen.offset());
                            object_writer.write::<_, _, 1>(&prepared_listen.tag());
                            if let ::core::option::Option::Some(prepared_enable_udp) =
                                prepared_enable_udp
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_udp);
                            }
                            if let ::core::option::Option::Some(prepared_enable_tcp) =
                                prepared_enable_tcp
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_tcp);
                            }
                            if let ::core::option::Option::Some(prepared_prefer_udp) =
                                prepared_prefer_udp
                            {
                                object_writer.write::<_, _, 1>(&prepared_prefer_udp);
                            }
                            if let ::core::option::Option::Some(prepared_prefer_tcp) =
                                prepared_prefer_tcp
                            {
                                object_writer.write::<_, _, 1>(&prepared_prefer_tcp);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<WebRtcTransportOptions>> for WebRtcTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<WebRtcTransportOptions>>
                for WebRtcTransportOptions
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<WebRtcTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<WebRtcTransportOptions> for WebRtcTransportOptions {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions> {
                    WebRtcTransportOptions::create(
                        builder,
                        &self.base,
                        &self.listen,
                        self.enable_udp,
                        self.enable_tcp,
                        self.prefer_udp,
                        self.prefer_tcp,
                    )
                }
            }

            /// Builder for serializing an instance of the [WebRtcTransportOptions] type.
            ///
            /// Can be created using the [WebRtcTransportOptions::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct WebRtcTransportOptionsBuilder<State>(State);

            impl WebRtcTransportOptionsBuilder<()> {
                /// Setter for the [`base` field](WebRtcTransportOptions#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> WebRtcTransportOptionsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                {
                    WebRtcTransportOptionsBuilder((value,))
                }
            }

            impl<T0> WebRtcTransportOptionsBuilder<(T0,)> {
                /// Setter for the [`listen` field](WebRtcTransportOptions#structfield.listen).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn listen<T1>(self, value: T1) -> WebRtcTransportOptionsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsUnion<self::Listen>,
                {
                    let (v0,) = self.0;
                    WebRtcTransportOptionsBuilder((v0, value))
                }
            }

            impl<T0, T1> WebRtcTransportOptionsBuilder<(T0, T1)> {
                /// Setter for the [`enable_udp` field](WebRtcTransportOptions#structfield.enable_udp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_udp<T2>(
                    self,
                    value: T2,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    WebRtcTransportOptionsBuilder((v0, v1, value))
                }

                /// Sets the [`enable_udp` field](WebRtcTransportOptions#structfield.enable_udp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_udp_as_default(
                    self,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, ::planus::DefaultValue)>
                {
                    self.enable_udp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> WebRtcTransportOptionsBuilder<(T0, T1, T2)> {
                /// Setter for the [`enable_tcp` field](WebRtcTransportOptions#structfield.enable_tcp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_tcp<T3>(
                    self,
                    value: T3,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    WebRtcTransportOptionsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`enable_tcp` field](WebRtcTransportOptions#structfield.enable_tcp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_tcp_as_default(
                    self,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2, ::planus::DefaultValue)>
                {
                    self.enable_tcp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`prefer_udp` field](WebRtcTransportOptions#structfield.prefer_udp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn prefer_udp<T4>(
                    self,
                    value: T4,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    WebRtcTransportOptionsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`prefer_udp` field](WebRtcTransportOptions#structfield.prefer_udp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn prefer_udp_as_default(
                    self,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.prefer_udp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`prefer_tcp` field](WebRtcTransportOptions#structfield.prefer_tcp).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn prefer_tcp<T5>(
                    self,
                    value: T5,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    WebRtcTransportOptionsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`prefer_tcp` field](WebRtcTransportOptions#structfield.prefer_tcp) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn prefer_tcp_as_default(
                    self,
                ) -> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.prefer_tcp(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [WebRtcTransportOptions].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions>
                where
                    Self: ::planus::WriteAsOffset<WebRtcTransportOptions>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAsUnion<self::Listen>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<WebRtcTransportOptions>>
                for WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<WebRtcTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAsUnion<self::Listen>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<WebRtcTransportOptions>>
                for WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<WebRtcTransportOptions>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<WebRtcTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    T1: ::planus::WriteAsUnion<self::Listen>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<bool, bool>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<WebRtcTransportOptions>
                for WebRtcTransportOptionsBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    WebRtcTransportOptions::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [WebRtcTransportOptions].
            #[derive(Copy, Clone)]
            pub struct WebRtcTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> WebRtcTransportOptionsRef<'a> {
                /// Getter for the [`base` field](WebRtcTransportOptions#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "WebRtcTransportOptions", "base")
                }

                /// Getter for the [`listen` field](WebRtcTransportOptions#structfield.listen).
                #[inline]
                pub fn listen(&self) -> ::planus::Result<self::ListenRef<'a>> {
                    self.0
                        .access_union_required(1, "WebRtcTransportOptions", "listen")
                }

                /// Getter for the [`enable_udp` field](WebRtcTransportOptions#structfield.enable_udp).
                #[inline]
                pub fn enable_udp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "WebRtcTransportOptions", "enable_udp")?
                            .unwrap_or(true),
                    )
                }

                /// Getter for the [`enable_tcp` field](WebRtcTransportOptions#structfield.enable_tcp).
                #[inline]
                pub fn enable_tcp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "WebRtcTransportOptions", "enable_tcp")?
                            .unwrap_or(true),
                    )
                }

                /// Getter for the [`prefer_udp` field](WebRtcTransportOptions#structfield.prefer_udp).
                #[inline]
                pub fn prefer_udp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "WebRtcTransportOptions", "prefer_udp")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`prefer_tcp` field](WebRtcTransportOptions#structfield.prefer_tcp).
                #[inline]
                pub fn prefer_tcp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "WebRtcTransportOptions", "prefer_tcp")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for WebRtcTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("WebRtcTransportOptionsRef");
                    f.field("base", &self.base());
                    f.field("listen", &self.listen());
                    f.field("enable_udp", &self.enable_udp());
                    f.field("enable_tcp", &self.enable_tcp());
                    f.field("prefer_udp", &self.prefer_udp());
                    f.field("prefer_tcp", &self.prefer_tcp());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<WebRtcTransportOptionsRef<'a>> for WebRtcTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: WebRtcTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        listen: ::core::convert::TryInto::try_into(value.listen()?)?,
                        enable_udp: ::core::convert::TryInto::try_into(value.enable_udp()?)?,
                        enable_tcp: ::core::convert::TryInto::try_into(value.enable_tcp()?)?,
                        prefer_udp: ::core::convert::TryInto::try_into(value.prefer_udp()?)?,
                        prefer_tcp: ::core::convert::TryInto::try_into(value.prefer_tcp()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for WebRtcTransportOptionsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for WebRtcTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[WebRtcTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<WebRtcTransportOptions>> for WebRtcTransportOptions {
                type Value = ::planus::Offset<WebRtcTransportOptions>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<WebRtcTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for WebRtcTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[WebRtcTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The enum `FingerprintAlgorithm` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `FingerprintAlgorithm` in the file `../worker/fbs/webRtcTransport.fbs:28`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum FingerprintAlgorithm {
                /// The variant `SHA1` in the enum `FingerprintAlgorithm`
                Sha1 = 0,

                /// The variant `SHA224` in the enum `FingerprintAlgorithm`
                Sha224 = 1,

                /// The variant `SHA256` in the enum `FingerprintAlgorithm`
                Sha256 = 2,

                /// The variant `SHA384` in the enum `FingerprintAlgorithm`
                Sha384 = 3,

                /// The variant `SHA512` in the enum `FingerprintAlgorithm`
                Sha512 = 4,
            }

            impl FingerprintAlgorithm {
                /// Array containing all valid variants of FingerprintAlgorithm
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::Sha1,
                    Self::Sha224,
                    Self::Sha256,
                    Self::Sha384,
                    Self::Sha512,
                ];
            }

            impl ::core::convert::TryFrom<u8> for FingerprintAlgorithm {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(FingerprintAlgorithm::Sha1),
                        1 => ::core::result::Result::Ok(FingerprintAlgorithm::Sha224),
                        2 => ::core::result::Result::Ok(FingerprintAlgorithm::Sha256),
                        3 => ::core::result::Result::Ok(FingerprintAlgorithm::Sha384),
                        4 => ::core::result::Result::Ok(FingerprintAlgorithm::Sha512),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<FingerprintAlgorithm> for u8 {
                #[inline]
                fn from(value: FingerprintAlgorithm) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for FingerprintAlgorithm {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<FingerprintAlgorithm> for FingerprintAlgorithm {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<FingerprintAlgorithm> for FingerprintAlgorithm {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> FingerprintAlgorithm {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<FingerprintAlgorithm, FingerprintAlgorithm> for FingerprintAlgorithm {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &FingerprintAlgorithm,
                ) -> ::core::option::Option<FingerprintAlgorithm> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<FingerprintAlgorithm> for FingerprintAlgorithm {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<FingerprintAlgorithm> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for FingerprintAlgorithm {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for FingerprintAlgorithm {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "FingerprintAlgorithm",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<FingerprintAlgorithm> for FingerprintAlgorithm {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `Fingerprint` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `Fingerprint` in the file `../worker/fbs/webRtcTransport.fbs:36`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Fingerprint {
                /// The field `algorithm` in the table `Fingerprint`
                pub algorithm: self::FingerprintAlgorithm,
                /// The field `value` in the table `Fingerprint`
                pub value: ::planus::alloc::string::String,
            }

            impl Fingerprint {
                /// Creates a [FingerprintBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> FingerprintBuilder<()> {
                    FingerprintBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_algorithm: impl ::planus::WriteAsDefault<
                        self::FingerprintAlgorithm,
                        self::FingerprintAlgorithm,
                    >,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_algorithm =
                        field_algorithm.prepare(builder, &self::FingerprintAlgorithm::Sha1);
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_algorithm.is_some() {
                        table_writer.write_entry::<self::FingerprintAlgorithm>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_value);
                            if let ::core::option::Option::Some(prepared_algorithm) =
                                prepared_algorithm
                            {
                                object_writer.write::<_, _, 1>(&prepared_algorithm);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Fingerprint>> for Fingerprint {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Fingerprint>> for Fingerprint {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Fingerprint>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Fingerprint> for Fingerprint {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint> {
                    Fingerprint::create(builder, self.algorithm, &self.value)
                }
            }

            /// Builder for serializing an instance of the [Fingerprint] type.
            ///
            /// Can be created using the [Fingerprint::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct FingerprintBuilder<State>(State);

            impl FingerprintBuilder<()> {
                /// Setter for the [`algorithm` field](Fingerprint#structfield.algorithm).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn algorithm<T0>(self, value: T0) -> FingerprintBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<
                        self::FingerprintAlgorithm,
                        self::FingerprintAlgorithm,
                    >,
                {
                    FingerprintBuilder((value,))
                }

                /// Sets the [`algorithm` field](Fingerprint#structfield.algorithm) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn algorithm_as_default(self) -> FingerprintBuilder<(::planus::DefaultValue,)> {
                    self.algorithm(::planus::DefaultValue)
                }
            }

            impl<T0> FingerprintBuilder<(T0,)> {
                /// Setter for the [`value` field](Fingerprint#structfield.value).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn value<T1>(self, value: T1) -> FingerprintBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    FingerprintBuilder((v0, value))
                }
            }

            impl<T0, T1> FingerprintBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Fingerprint].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint>
                where
                    Self: ::planus::WriteAsOffset<Fingerprint>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        self::FingerprintAlgorithm,
                        self::FingerprintAlgorithm,
                    >,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<Fingerprint>>
                for FingerprintBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Fingerprint>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        self::FingerprintAlgorithm,
                        self::FingerprintAlgorithm,
                    >,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<Fingerprint>>
                for FingerprintBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<Fingerprint>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Fingerprint>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<
                        self::FingerprintAlgorithm,
                        self::FingerprintAlgorithm,
                    >,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<Fingerprint> for FingerprintBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint> {
                    let (v0, v1) = &self.0;
                    Fingerprint::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [Fingerprint].
            #[derive(Copy, Clone)]
            pub struct FingerprintRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FingerprintRef<'a> {
                /// Getter for the [`algorithm` field](Fingerprint#structfield.algorithm).
                #[inline]
                pub fn algorithm(&self) -> ::planus::Result<self::FingerprintAlgorithm> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "Fingerprint", "algorithm")?
                            .unwrap_or(self::FingerprintAlgorithm::Sha1),
                    )
                }

                /// Getter for the [`value` field](Fingerprint#structfield.value).
                #[inline]
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "Fingerprint", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for FingerprintRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FingerprintRef");
                    f.field("algorithm", &self.algorithm());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FingerprintRef<'a>> for Fingerprint {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FingerprintRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        algorithm: ::core::convert::TryInto::try_into(value.algorithm()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FingerprintRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FingerprintRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FingerprintRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Fingerprint>> for Fingerprint {
                type Value = ::planus::Offset<Fingerprint>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Fingerprint>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FingerprintRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FingerprintRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `DtlsRole` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `DtlsRole` in the file `../worker/fbs/webRtcTransport.fbs:41`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum DtlsRole {
                /// The variant `AUTO` in the enum `DtlsRole`
                Auto = 0,

                /// The variant `CLIENT` in the enum `DtlsRole`
                Client = 1,

                /// The variant `SERVER` in the enum `DtlsRole`
                Server = 2,
            }

            impl DtlsRole {
                /// Array containing all valid variants of DtlsRole
                pub const ENUM_VALUES: [Self; 3] = [Self::Auto, Self::Client, Self::Server];
            }

            impl ::core::convert::TryFrom<u8> for DtlsRole {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(DtlsRole::Auto),
                        1 => ::core::result::Result::Ok(DtlsRole::Client),
                        2 => ::core::result::Result::Ok(DtlsRole::Server),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<DtlsRole> for u8 {
                #[inline]
                fn from(value: DtlsRole) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for DtlsRole {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<DtlsRole> for DtlsRole {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<DtlsRole> for DtlsRole {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> DtlsRole {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<DtlsRole, DtlsRole> for DtlsRole {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &DtlsRole,
                ) -> ::core::option::Option<DtlsRole> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<DtlsRole> for DtlsRole {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<DtlsRole> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for DtlsRole {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for DtlsRole {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "DtlsRole",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<DtlsRole> for DtlsRole {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `DtlsState` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `DtlsState` in the file `../worker/fbs/webRtcTransport.fbs:47`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum DtlsState {
                /// The variant `NEW` in the enum `DtlsState`
                New = 0,

                /// The variant `CONNECTING` in the enum `DtlsState`
                Connecting = 1,

                /// The variant `CONNECTED` in the enum `DtlsState`
                Connected = 2,

                /// The variant `FAILED` in the enum `DtlsState`
                Failed = 3,

                /// The variant `CLOSED` in the enum `DtlsState`
                Closed = 4,
            }

            impl DtlsState {
                /// Array containing all valid variants of DtlsState
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::New,
                    Self::Connecting,
                    Self::Connected,
                    Self::Failed,
                    Self::Closed,
                ];
            }

            impl ::core::convert::TryFrom<u8> for DtlsState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(DtlsState::New),
                        1 => ::core::result::Result::Ok(DtlsState::Connecting),
                        2 => ::core::result::Result::Ok(DtlsState::Connected),
                        3 => ::core::result::Result::Ok(DtlsState::Failed),
                        4 => ::core::result::Result::Ok(DtlsState::Closed),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<DtlsState> for u8 {
                #[inline]
                fn from(value: DtlsState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for DtlsState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<DtlsState> for DtlsState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<DtlsState> for DtlsState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> DtlsState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<DtlsState, DtlsState> for DtlsState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &DtlsState,
                ) -> ::core::option::Option<DtlsState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<DtlsState> for DtlsState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<DtlsState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for DtlsState {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for DtlsState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "DtlsState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<DtlsState> for DtlsState {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `DtlsParameters` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `DtlsParameters` in the file `../worker/fbs/webRtcTransport.fbs:55`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DtlsParameters {
                /// The field `fingerprints` in the table `DtlsParameters`
                pub fingerprints: ::planus::alloc::vec::Vec<self::Fingerprint>,
                /// The field `role` in the table `DtlsParameters`
                pub role: self::DtlsRole,
            }

            impl DtlsParameters {
                /// Creates a [DtlsParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DtlsParametersBuilder<()> {
                    DtlsParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_fingerprints: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::Fingerprint>]>,
                    >,
                    field_role: impl ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                ) -> ::planus::Offset<Self> {
                    let prepared_fingerprints = field_fingerprints.prepare(builder);
                    let prepared_role = field_role.prepare(builder, &self::DtlsRole::Auto);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::Fingerprint>]>>(0);
                    if prepared_role.is_some() {
                        table_writer.write_entry::<self::DtlsRole>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_fingerprints);
                            if let ::core::option::Option::Some(prepared_role) = prepared_role {
                                object_writer.write::<_, _, 1>(&prepared_role);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DtlsParameters>> for DtlsParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DtlsParameters>> for DtlsParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DtlsParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DtlsParameters> for DtlsParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters> {
                    DtlsParameters::create(builder, &self.fingerprints, self.role)
                }
            }

            /// Builder for serializing an instance of the [DtlsParameters] type.
            ///
            /// Can be created using the [DtlsParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DtlsParametersBuilder<State>(State);

            impl DtlsParametersBuilder<()> {
                /// Setter for the [`fingerprints` field](DtlsParameters#structfield.fingerprints).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn fingerprints<T0>(self, value: T0) -> DtlsParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Fingerprint>]>>,
                {
                    DtlsParametersBuilder((value,))
                }
            }

            impl<T0> DtlsParametersBuilder<(T0,)> {
                /// Setter for the [`role` field](DtlsParameters#structfield.role).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn role<T1>(self, value: T1) -> DtlsParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                {
                    let (v0,) = self.0;
                    DtlsParametersBuilder((v0, value))
                }

                /// Sets the [`role` field](DtlsParameters#structfield.role) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn role_as_default(
                    self,
                ) -> DtlsParametersBuilder<(T0, ::planus::DefaultValue)> {
                    self.role(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DtlsParametersBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DtlsParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters>
                where
                    Self: ::planus::WriteAsOffset<DtlsParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Fingerprint>]>>,
                    T1: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                > ::planus::WriteAs<::planus::Offset<DtlsParameters>>
                for DtlsParametersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<DtlsParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Fingerprint>]>>,
                    T1: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                > ::planus::WriteAsOptional<::planus::Offset<DtlsParameters>>
                for DtlsParametersBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<DtlsParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DtlsParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::Fingerprint>]>>,
                    T1: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                > ::planus::WriteAsOffset<DtlsParameters> for DtlsParametersBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters> {
                    let (v0, v1) = &self.0;
                    DtlsParameters::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [DtlsParameters].
            #[derive(Copy, Clone)]
            pub struct DtlsParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DtlsParametersRef<'a> {
                /// Getter for the [`fingerprints` field](DtlsParameters#structfield.fingerprints).
                #[inline]
                pub fn fingerprints(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::FingerprintRef<'a>>>,
                > {
                    self.0.access_required(0, "DtlsParameters", "fingerprints")
                }

                /// Getter for the [`role` field](DtlsParameters#structfield.role).
                #[inline]
                pub fn role(&self) -> ::planus::Result<self::DtlsRole> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DtlsParameters", "role")?
                            .unwrap_or(self::DtlsRole::Auto),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DtlsParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DtlsParametersRef");
                    f.field("fingerprints", &self.fingerprints());
                    f.field("role", &self.role());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DtlsParametersRef<'a>> for DtlsParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DtlsParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        fingerprints: value.fingerprints()?.to_vec_result()?,
                        role: ::core::convert::TryInto::try_into(value.role()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DtlsParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DtlsParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DtlsParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DtlsParameters>> for DtlsParameters {
                type Value = ::planus::Offset<DtlsParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DtlsParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DtlsParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DtlsParametersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `IceParameters` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `IceParameters` in the file `../worker/fbs/webRtcTransport.fbs:60`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceParameters {
                /// The field `username_fragment` in the table `IceParameters`
                pub username_fragment: ::planus::alloc::string::String,
                /// The field `password` in the table `IceParameters`
                pub password: ::planus::alloc::string::String,
                /// The field `ice_lite` in the table `IceParameters`
                pub ice_lite: bool,
            }

            impl IceParameters {
                /// Creates a [IceParametersBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> IceParametersBuilder<()> {
                    IceParametersBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_username_fragment: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_password: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_lite: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_username_fragment = field_username_fragment.prepare(builder);
                    let prepared_password = field_password.prepare(builder);
                    let prepared_ice_lite = field_ice_lite.prepare(builder, &true);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    if prepared_ice_lite.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_username_fragment);
                            object_writer.write::<_, _, 4>(&prepared_password);
                            if let ::core::option::Option::Some(prepared_ice_lite) =
                                prepared_ice_lite
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_lite);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceParameters>> for IceParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceParameters>> for IceParameters {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceParameters> for IceParameters {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters> {
                    IceParameters::create(
                        builder,
                        &self.username_fragment,
                        &self.password,
                        self.ice_lite,
                    )
                }
            }

            /// Builder for serializing an instance of the [IceParameters] type.
            ///
            /// Can be created using the [IceParameters::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct IceParametersBuilder<State>(State);

            impl IceParametersBuilder<()> {
                /// Setter for the [`username_fragment` field](IceParameters#structfield.username_fragment).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn username_fragment<T0>(self, value: T0) -> IceParametersBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    IceParametersBuilder((value,))
                }
            }

            impl<T0> IceParametersBuilder<(T0,)> {
                /// Setter for the [`password` field](IceParameters#structfield.password).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn password<T1>(self, value: T1) -> IceParametersBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    IceParametersBuilder((v0, value))
                }
            }

            impl<T0, T1> IceParametersBuilder<(T0, T1)> {
                /// Setter for the [`ice_lite` field](IceParameters#structfield.ice_lite).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_lite<T2>(self, value: T2) -> IceParametersBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    IceParametersBuilder((v0, v1, value))
                }

                /// Sets the [`ice_lite` field](IceParameters#structfield.ice_lite) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_lite_as_default(
                    self,
                ) -> IceParametersBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.ice_lite(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> IceParametersBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [IceParameters].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters>
                where
                    Self: ::planus::WriteAsOffset<IceParameters>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<IceParameters>>
                for IceParametersBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<IceParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<IceParameters>>
                for IceParametersBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<IceParameters>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<IceParameters> for IceParametersBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters> {
                    let (v0, v1, v2) = &self.0;
                    IceParameters::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [IceParameters].
            #[derive(Copy, Clone)]
            pub struct IceParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceParametersRef<'a> {
                /// Getter for the [`username_fragment` field](IceParameters#structfield.username_fragment).
                #[inline]
                pub fn username_fragment(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "IceParameters", "username_fragment")
                }

                /// Getter for the [`password` field](IceParameters#structfield.password).
                #[inline]
                pub fn password(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "IceParameters", "password")
                }

                /// Getter for the [`ice_lite` field](IceParameters#structfield.ice_lite).
                #[inline]
                pub fn ice_lite(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "IceParameters", "ice_lite")?
                            .unwrap_or(true),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for IceParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceParametersRef");
                    f.field("username_fragment", &self.username_fragment());
                    f.field("password", &self.password());
                    f.field("ice_lite", &self.ice_lite());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceParametersRef<'a>> for IceParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        username_fragment: ::core::convert::TryInto::try_into(
                            value.username_fragment()?,
                        )?,
                        password: ::core::convert::TryInto::try_into(value.password()?)?,
                        ice_lite: ::core::convert::TryInto::try_into(value.ice_lite()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceParametersRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceParameters>> for IceParameters {
                type Value = ::planus::Offset<IceParameters>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IceParametersRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `IceCandidateType` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `IceCandidateType` in the file `../worker/fbs/webRtcTransport.fbs:66`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum IceCandidateType {
                /// The variant `HOST` in the enum `IceCandidateType`
                Host = 0,
            }

            impl IceCandidateType {
                /// Array containing all valid variants of IceCandidateType
                pub const ENUM_VALUES: [Self; 1] = [Self::Host];
            }

            impl ::core::convert::TryFrom<u8> for IceCandidateType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(IceCandidateType::Host),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<IceCandidateType> for u8 {
                #[inline]
                fn from(value: IceCandidateType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for IceCandidateType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<IceCandidateType> for IceCandidateType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<IceCandidateType> for IceCandidateType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> IceCandidateType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<IceCandidateType, IceCandidateType> for IceCandidateType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &IceCandidateType,
                ) -> ::core::option::Option<IceCandidateType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<IceCandidateType> for IceCandidateType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<IceCandidateType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for IceCandidateType {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for IceCandidateType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "IceCandidateType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<IceCandidateType> for IceCandidateType {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `IceCandidateTcpType` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `IceCandidateTcpType` in the file `../worker/fbs/webRtcTransport.fbs:70`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum IceCandidateTcpType {
                /// The variant `PASSIVE` in the enum `IceCandidateTcpType`
                Passive = 0,
            }

            impl IceCandidateTcpType {
                /// Array containing all valid variants of IceCandidateTcpType
                pub const ENUM_VALUES: [Self; 1] = [Self::Passive];
            }

            impl ::core::convert::TryFrom<u8> for IceCandidateTcpType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(IceCandidateTcpType::Passive),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<IceCandidateTcpType> for u8 {
                #[inline]
                fn from(value: IceCandidateTcpType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for IceCandidateTcpType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<IceCandidateTcpType> for IceCandidateTcpType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<IceCandidateTcpType> for IceCandidateTcpType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> IceCandidateTcpType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<IceCandidateTcpType, IceCandidateTcpType> for IceCandidateTcpType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &IceCandidateTcpType,
                ) -> ::core::option::Option<IceCandidateTcpType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<IceCandidateTcpType> for IceCandidateTcpType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<IceCandidateTcpType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for IceCandidateTcpType {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for IceCandidateTcpType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "IceCandidateTcpType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<IceCandidateTcpType> for IceCandidateTcpType {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `IceRole` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `IceRole` in the file `../worker/fbs/webRtcTransport.fbs:74`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum IceRole {
                /// The variant `CONTROLLED` in the enum `IceRole`
                Controlled = 0,

                /// The variant `CONTROLLING` in the enum `IceRole`
                Controlling = 1,
            }

            impl IceRole {
                /// Array containing all valid variants of IceRole
                pub const ENUM_VALUES: [Self; 2] = [Self::Controlled, Self::Controlling];
            }

            impl ::core::convert::TryFrom<u8> for IceRole {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(IceRole::Controlled),
                        1 => ::core::result::Result::Ok(IceRole::Controlling),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<IceRole> for u8 {
                #[inline]
                fn from(value: IceRole) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for IceRole {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<IceRole> for IceRole {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<IceRole> for IceRole {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> IceRole {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<IceRole, IceRole> for IceRole {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &IceRole,
                ) -> ::core::option::Option<IceRole> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<IceRole> for IceRole {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<IceRole> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for IceRole {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for IceRole {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "IceRole",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<IceRole> for IceRole {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `IceState` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Enum `IceState` in the file `../worker/fbs/webRtcTransport.fbs:79`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum IceState {
                /// The variant `NEW` in the enum `IceState`
                New = 0,

                /// The variant `CONNECTED` in the enum `IceState`
                Connected = 1,

                /// The variant `COMPLETED` in the enum `IceState`
                Completed = 2,

                /// The variant `DISCONNECTED` in the enum `IceState`
                Disconnected = 3,
            }

            impl IceState {
                /// Array containing all valid variants of IceState
                pub const ENUM_VALUES: [Self; 4] = [
                    Self::New,
                    Self::Connected,
                    Self::Completed,
                    Self::Disconnected,
                ];
            }

            impl ::core::convert::TryFrom<u8> for IceState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(IceState::New),
                        1 => ::core::result::Result::Ok(IceState::Connected),
                        2 => ::core::result::Result::Ok(IceState::Completed),
                        3 => ::core::result::Result::Ok(IceState::Disconnected),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<IceState> for u8 {
                #[inline]
                fn from(value: IceState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for IceState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<IceState> for IceState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<IceState> for IceState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> IceState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<IceState, IceState> for IceState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &IceState,
                ) -> ::core::option::Option<IceState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<IceState> for IceState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<IceState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for IceState {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for IceState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "IceState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<IceState> for IceState {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `IceCandidate` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `IceCandidate` in the file `../worker/fbs/webRtcTransport.fbs:86`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceCandidate {
                /// The field `foundation` in the table `IceCandidate`
                pub foundation: ::planus::alloc::string::String,
                /// The field `priority` in the table `IceCandidate`
                pub priority: u32,
                /// The field `ip` in the table `IceCandidate`
                pub ip: ::planus::alloc::string::String,
                /// The field `protocol` in the table `IceCandidate`
                pub protocol: super::transport::Protocol,
                /// The field `port` in the table `IceCandidate`
                pub port: u16,
                /// The field `type` in the table `IceCandidate`
                pub type_: self::IceCandidateType,
                /// The field `tcp_type` in the table `IceCandidate`
                pub tcp_type: ::core::option::Option<self::IceCandidateTcpType>,
            }

            impl IceCandidate {
                /// Creates a [IceCandidateBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> IceCandidateBuilder<()> {
                    IceCandidateBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_foundation: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_priority: impl ::planus::WriteAsDefault<u32, u32>,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAsDefault<
                        super::transport::Protocol,
                        super::transport::Protocol,
                    >,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_type_: impl ::planus::WriteAsDefault<
                        self::IceCandidateType,
                        self::IceCandidateType,
                    >,
                    field_tcp_type: impl ::planus::WriteAsOptional<self::IceCandidateTcpType>,
                ) -> ::planus::Offset<Self> {
                    let prepared_foundation = field_foundation.prepare(builder);
                    let prepared_priority = field_priority.prepare(builder, &0);
                    let prepared_ip = field_ip.prepare(builder);
                    let prepared_protocol =
                        field_protocol.prepare(builder, &super::transport::Protocol::Udp);
                    let prepared_port = field_port.prepare(builder, &0);
                    let prepared_type_ =
                        field_type_.prepare(builder, &self::IceCandidateType::Host);
                    let prepared_tcp_type = field_tcp_type.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<18> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_priority.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_port.is_some() {
                        table_writer.write_entry::<u16>(4);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.write_entry::<super::transport::Protocol>(3);
                    }
                    if prepared_type_.is_some() {
                        table_writer.write_entry::<self::IceCandidateType>(5);
                    }
                    if prepared_tcp_type.is_some() {
                        table_writer.write_entry::<self::IceCandidateTcpType>(6);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_foundation);
                            if let ::core::option::Option::Some(prepared_priority) =
                                prepared_priority
                            {
                                object_writer.write::<_, _, 4>(&prepared_priority);
                            }
                            object_writer.write::<_, _, 4>(&prepared_ip);
                            if let ::core::option::Option::Some(prepared_port) = prepared_port {
                                object_writer.write::<_, _, 2>(&prepared_port);
                            }
                            if let ::core::option::Option::Some(prepared_protocol) =
                                prepared_protocol
                            {
                                object_writer.write::<_, _, 1>(&prepared_protocol);
                            }
                            if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                                object_writer.write::<_, _, 1>(&prepared_type_);
                            }
                            if let ::core::option::Option::Some(prepared_tcp_type) =
                                prepared_tcp_type
                            {
                                object_writer.write::<_, _, 1>(&prepared_tcp_type);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceCandidate>> for IceCandidate {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceCandidate>> for IceCandidate {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceCandidate>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceCandidate> for IceCandidate {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate> {
                    IceCandidate::create(
                        builder,
                        &self.foundation,
                        self.priority,
                        &self.ip,
                        self.protocol,
                        self.port,
                        self.type_,
                        self.tcp_type,
                    )
                }
            }

            /// Builder for serializing an instance of the [IceCandidate] type.
            ///
            /// Can be created using the [IceCandidate::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct IceCandidateBuilder<State>(State);

            impl IceCandidateBuilder<()> {
                /// Setter for the [`foundation` field](IceCandidate#structfield.foundation).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn foundation<T0>(self, value: T0) -> IceCandidateBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    IceCandidateBuilder((value,))
                }
            }

            impl<T0> IceCandidateBuilder<(T0,)> {
                /// Setter for the [`priority` field](IceCandidate#structfield.priority).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority<T1>(self, value: T1) -> IceCandidateBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    IceCandidateBuilder((v0, value))
                }

                /// Sets the [`priority` field](IceCandidate#structfield.priority) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn priority_as_default(
                    self,
                ) -> IceCandidateBuilder<(T0, ::planus::DefaultValue)> {
                    self.priority(::planus::DefaultValue)
                }
            }

            impl<T0, T1> IceCandidateBuilder<(T0, T1)> {
                /// Setter for the [`ip` field](IceCandidate#structfield.ip).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ip<T2>(self, value: T2) -> IceCandidateBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    IceCandidateBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> IceCandidateBuilder<(T0, T1, T2)> {
                /// Setter for the [`protocol` field](IceCandidate#structfield.protocol).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol<T3>(self, value: T3) -> IceCandidateBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<
                        super::transport::Protocol,
                        super::transport::Protocol,
                    >,
                {
                    let (v0, v1, v2) = self.0;
                    IceCandidateBuilder((v0, v1, v2, value))
                }

                /// Sets the [`protocol` field](IceCandidate#structfield.protocol) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn protocol_as_default(
                    self,
                ) -> IceCandidateBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.protocol(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> IceCandidateBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`port` field](IceCandidate#structfield.port).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port<T4>(self, value: T4) -> IceCandidateBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u16, u16>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    IceCandidateBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`port` field](IceCandidate#structfield.port) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn port_as_default(
                    self,
                ) -> IceCandidateBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.port(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> IceCandidateBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`type` field](IceCandidate#structfield.type_).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_<T5>(self, value: T5) -> IceCandidateBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<self::IceCandidateType, self::IceCandidateType>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    IceCandidateBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`type` field](IceCandidate#structfield.type_) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn type_as_default(
                    self,
                ) -> IceCandidateBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.type_(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> IceCandidateBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`tcp_type` field](IceCandidate#structfield.tcp_type).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tcp_type<T6>(
                    self,
                    value: T6,
                ) -> IceCandidateBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsOptional<self::IceCandidateTcpType>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    IceCandidateBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`tcp_type` field](IceCandidate#structfield.tcp_type) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tcp_type_as_null(self) -> IceCandidateBuilder<(T0, T1, T2, T3, T4, T5, ())> {
                    self.tcp_type(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> IceCandidateBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [IceCandidate].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate>
                where
                    Self: ::planus::WriteAsOffset<IceCandidate>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<
                        super::transport::Protocol,
                        super::transport::Protocol,
                    >,
                    T4: ::planus::WriteAsDefault<u16, u16>,
                    T5: ::planus::WriteAsDefault<self::IceCandidateType, self::IceCandidateType>,
                    T6: ::planus::WriteAsOptional<self::IceCandidateTcpType>,
                > ::planus::WriteAs<::planus::Offset<IceCandidate>>
                for IceCandidateBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<IceCandidate>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<
                        super::transport::Protocol,
                        super::transport::Protocol,
                    >,
                    T4: ::planus::WriteAsDefault<u16, u16>,
                    T5: ::planus::WriteAsDefault<self::IceCandidateType, self::IceCandidateType>,
                    T6: ::planus::WriteAsOptional<self::IceCandidateTcpType>,
                > ::planus::WriteAsOptional<::planus::Offset<IceCandidate>>
                for IceCandidateBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<IceCandidate>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceCandidate>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<
                        super::transport::Protocol,
                        super::transport::Protocol,
                    >,
                    T4: ::planus::WriteAsDefault<u16, u16>,
                    T5: ::planus::WriteAsDefault<self::IceCandidateType, self::IceCandidateType>,
                    T6: ::planus::WriteAsOptional<self::IceCandidateTcpType>,
                > ::planus::WriteAsOffset<IceCandidate>
                for IceCandidateBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate> {
                    let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                    IceCandidate::create(builder, v0, v1, v2, v3, v4, v5, v6)
                }
            }

            /// Reference to a deserialized [IceCandidate].
            #[derive(Copy, Clone)]
            pub struct IceCandidateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceCandidateRef<'a> {
                /// Getter for the [`foundation` field](IceCandidate#structfield.foundation).
                #[inline]
                pub fn foundation(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "IceCandidate", "foundation")
                }

                /// Getter for the [`priority` field](IceCandidate#structfield.priority).
                #[inline]
                pub fn priority(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "IceCandidate", "priority")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`ip` field](IceCandidate#structfield.ip).
                #[inline]
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "IceCandidate", "ip")
                }

                /// Getter for the [`protocol` field](IceCandidate#structfield.protocol).
                #[inline]
                pub fn protocol(&self) -> ::planus::Result<super::transport::Protocol> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "IceCandidate", "protocol")?
                            .unwrap_or(super::transport::Protocol::Udp),
                    )
                }

                /// Getter for the [`port` field](IceCandidate#structfield.port).
                #[inline]
                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "IceCandidate", "port")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`type` field](IceCandidate#structfield.type_).
                #[inline]
                pub fn type_(&self) -> ::planus::Result<self::IceCandidateType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "IceCandidate", "type_")?
                            .unwrap_or(self::IceCandidateType::Host),
                    )
                }

                /// Getter for the [`tcp_type` field](IceCandidate#structfield.tcp_type).
                #[inline]
                pub fn tcp_type(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::IceCandidateTcpType>>
                {
                    self.0.access(6, "IceCandidate", "tcp_type")
                }
            }

            impl<'a> ::core::fmt::Debug for IceCandidateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceCandidateRef");
                    f.field("foundation", &self.foundation());
                    f.field("priority", &self.priority());
                    f.field("ip", &self.ip());
                    f.field("protocol", &self.protocol());
                    f.field("port", &self.port());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_tcp_type) =
                        self.tcp_type().transpose()
                    {
                        f.field("tcp_type", &field_tcp_type);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceCandidateRef<'a>> for IceCandidate {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceCandidateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        foundation: ::core::convert::TryInto::try_into(value.foundation()?)?,
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        tcp_type: if let ::core::option::Option::Some(tcp_type) =
                            value.tcp_type()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                tcp_type,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceCandidateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceCandidateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceCandidateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceCandidate>> for IceCandidate {
                type Value = ::planus::Offset<IceCandidate>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceCandidate>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceCandidateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IceCandidateRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConnectRequest` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `ConnectRequest` in the file `../worker/fbs/webRtcTransport.fbs:96`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectRequest {
                /// The field `dtls_parameters` in the table `ConnectRequest`
                pub dtls_parameters: ::planus::alloc::boxed::Box<self::DtlsParameters>,
            }

            impl ConnectRequest {
                /// Creates a [ConnectRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectRequestBuilder<()> {
                    ConnectRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_dtls_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<self::DtlsParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_dtls_parameters = field_dtls_parameters.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::DtlsParameters>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_dtls_parameters);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectRequest> for ConnectRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ConnectRequest::create(builder, &self.dtls_parameters)
                }
            }

            /// Builder for serializing an instance of the [ConnectRequest] type.
            ///
            /// Can be created using the [ConnectRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectRequestBuilder<State>(State);

            impl ConnectRequestBuilder<()> {
                /// Setter for the [`dtls_parameters` field](ConnectRequest#structfield.dtls_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_parameters<T0>(self, value: T0) -> ConnectRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>,
                {
                    ConnectRequestBuilder((value,))
                }
            }

            impl<T0> ConnectRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest>
                where
                    Self: ::planus::WriteAsOffset<ConnectRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>>
                ::planus::WriteAs<::planus::Offset<ConnectRequest>>
                for ConnectRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConnectRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>>
                ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>>
                for ConnectRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConnectRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>>
                ::planus::WriteAsOffset<ConnectRequest> for ConnectRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    let (v0,) = &self.0;
                    ConnectRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ConnectRequest].
            #[derive(Copy, Clone)]
            pub struct ConnectRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectRequestRef<'a> {
                /// Getter for the [`dtls_parameters` field](ConnectRequest#structfield.dtls_parameters).
                #[inline]
                pub fn dtls_parameters(&self) -> ::planus::Result<self::DtlsParametersRef<'a>> {
                    self.0
                        .access_required(0, "ConnectRequest", "dtls_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectRequestRef");
                    f.field("dtls_parameters", &self.dtls_parameters());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectRequestRef<'a>> for ConnectRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        dtls_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.dtls_parameters()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Value = ::planus::Offset<ConnectRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ConnectResponse` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `ConnectResponse` in the file `../worker/fbs/webRtcTransport.fbs:100`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectResponse {
                /// The field `dtls_local_role` in the table `ConnectResponse`
                pub dtls_local_role: self::DtlsRole,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConnectResponse {
                fn default() -> Self {
                    Self {
                        dtls_local_role: self::DtlsRole::Auto,
                    }
                }
            }

            impl ConnectResponse {
                /// Creates a [ConnectResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectResponseBuilder<()> {
                    ConnectResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_dtls_local_role: impl ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                ) -> ::planus::Offset<Self> {
                    let prepared_dtls_local_role =
                        field_dtls_local_role.prepare(builder, &self::DtlsRole::Auto);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_dtls_local_role.is_some() {
                        table_writer.write_entry::<self::DtlsRole>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_dtls_local_role) =
                                prepared_dtls_local_role
                            {
                                object_writer.write::<_, _, 1>(&prepared_dtls_local_role);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectResponse> for ConnectResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ConnectResponse::create(builder, self.dtls_local_role)
                }
            }

            /// Builder for serializing an instance of the [ConnectResponse] type.
            ///
            /// Can be created using the [ConnectResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectResponseBuilder<State>(State);

            impl ConnectResponseBuilder<()> {
                /// Setter for the [`dtls_local_role` field](ConnectResponse#structfield.dtls_local_role).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_local_role<T0>(self, value: T0) -> ConnectResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>,
                {
                    ConnectResponseBuilder((value,))
                }

                /// Sets the [`dtls_local_role` field](ConnectResponse#structfield.dtls_local_role) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_local_role_as_default(
                    self,
                ) -> ConnectResponseBuilder<(::planus::DefaultValue,)> {
                    self.dtls_local_role(::planus::DefaultValue)
                }
            }

            impl<T0> ConnectResponseBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse>
                where
                    Self: ::planus::WriteAsOffset<ConnectResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>>
                ::planus::WriteAs<::planus::Offset<ConnectResponse>>
                for ConnectResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConnectResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>>
                ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>>
                for ConnectResponseBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConnectResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::DtlsRole, self::DtlsRole>>
                ::planus::WriteAsOffset<ConnectResponse> for ConnectResponseBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    let (v0,) = &self.0;
                    ConnectResponse::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ConnectResponse].
            #[derive(Copy, Clone)]
            pub struct ConnectResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectResponseRef<'a> {
                /// Getter for the [`dtls_local_role` field](ConnectResponse#structfield.dtls_local_role).
                #[inline]
                pub fn dtls_local_role(&self) -> ::planus::Result<self::DtlsRole> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ConnectResponse", "dtls_local_role")?
                            .unwrap_or(self::DtlsRole::Auto),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectResponseRef");
                    f.field("dtls_local_role", &self.dtls_local_role());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectResponseRef<'a>> for ConnectResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        dtls_local_role: ::core::convert::TryInto::try_into(
                            value.dtls_local_role()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Value = ::planus::Offset<ConnectResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DumpResponse` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `DumpResponse` in the file `../worker/fbs/webRtcTransport.fbs:104`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                /// The field `base` in the table `DumpResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
                /// The field `ice_role` in the table `DumpResponse`
                pub ice_role: self::IceRole,
                /// The field `ice_parameters` in the table `DumpResponse`
                pub ice_parameters: ::planus::alloc::boxed::Box<self::IceParameters>,
                /// The field `ice_candidates` in the table `DumpResponse`
                pub ice_candidates: ::planus::alloc::vec::Vec<self::IceCandidate>,
                /// The field `ice_state` in the table `DumpResponse`
                pub ice_state: self::IceState,
                /// The field `ice_selected_tuple` in the table `DumpResponse`
                pub ice_selected_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                /// The field `dtls_parameters` in the table `DumpResponse`
                pub dtls_parameters: ::planus::alloc::boxed::Box<self::DtlsParameters>,
                /// The field `dtls_state` in the table `DumpResponse`
                pub dtls_state: self::DtlsState,
            }

            impl DumpResponse {
                /// Creates a [DumpResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DumpResponseBuilder<()> {
                    DumpResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    field_ice_role: impl ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    field_ice_parameters: impl ::planus::WriteAs<::planus::Offset<self::IceParameters>>,
                    field_ice_candidates: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceCandidate>]>,
                    >,
                    field_ice_state: impl ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    field_ice_selected_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_dtls_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<self::DtlsParameters>,
                    >,
                    field_dtls_state: impl ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_ice_role =
                        field_ice_role.prepare(builder, &self::IceRole::Controlled);
                    let prepared_ice_parameters = field_ice_parameters.prepare(builder);
                    let prepared_ice_candidates = field_ice_candidates.prepare(builder);
                    let prepared_ice_state = field_ice_state.prepare(builder, &self::IceState::New);
                    let prepared_ice_selected_tuple = field_ice_selected_tuple.prepare(builder);
                    let prepared_dtls_parameters = field_dtls_parameters.prepare(builder);
                    let prepared_dtls_state =
                        field_dtls_state.prepare(builder, &self::DtlsState::New);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Dump>>(0);
                    table_writer.write_entry::<::planus::Offset<self::IceParameters>>(2);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::IceCandidate>]>>(3);
                    if prepared_ice_selected_tuple.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(5);
                    }
                    table_writer.write_entry::<::planus::Offset<self::DtlsParameters>>(6);
                    if prepared_ice_role.is_some() {
                        table_writer.write_entry::<self::IceRole>(1);
                    }
                    if prepared_ice_state.is_some() {
                        table_writer.write_entry::<self::IceState>(4);
                    }
                    if prepared_dtls_state.is_some() {
                        table_writer.write_entry::<self::DtlsState>(7);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            object_writer.write::<_, _, 4>(&prepared_ice_parameters);
                            object_writer.write::<_, _, 4>(&prepared_ice_candidates);
                            if let ::core::option::Option::Some(prepared_ice_selected_tuple) =
                                prepared_ice_selected_tuple
                            {
                                object_writer.write::<_, _, 4>(&prepared_ice_selected_tuple);
                            }
                            object_writer.write::<_, _, 4>(&prepared_dtls_parameters);
                            if let ::core::option::Option::Some(prepared_ice_role) =
                                prepared_ice_role
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_role);
                            }
                            if let ::core::option::Option::Some(prepared_ice_state) =
                                prepared_ice_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_state);
                            }
                            if let ::core::option::Option::Some(prepared_dtls_state) =
                                prepared_dtls_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_dtls_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.base,
                        self.ice_role,
                        &self.ice_parameters,
                        &self.ice_candidates,
                        self.ice_state,
                        &self.ice_selected_tuple,
                        &self.dtls_parameters,
                        self.dtls_state,
                    )
                }
            }

            /// Builder for serializing an instance of the [DumpResponse] type.
            ///
            /// Can be created using the [DumpResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DumpResponseBuilder<State>(State);

            impl DumpResponseBuilder<()> {
                /// Setter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> DumpResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                {
                    DumpResponseBuilder((value,))
                }
            }

            impl<T0> DumpResponseBuilder<(T0,)> {
                /// Setter for the [`ice_role` field](DumpResponse#structfield.ice_role).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_role<T1>(self, value: T1) -> DumpResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                {
                    let (v0,) = self.0;
                    DumpResponseBuilder((v0, value))
                }

                /// Sets the [`ice_role` field](DumpResponse#structfield.ice_role) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_role_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.ice_role(::planus::DefaultValue)
                }
            }

            impl<T0, T1> DumpResponseBuilder<(T0, T1)> {
                /// Setter for the [`ice_parameters` field](DumpResponse#structfield.ice_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_parameters<T2>(self, value: T2) -> DumpResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<self::IceParameters>>,
                {
                    let (v0, v1) = self.0;
                    DumpResponseBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> DumpResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`ice_candidates` field](DumpResponse#structfield.ice_candidates).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_candidates<T3>(self, value: T3) -> DumpResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IceCandidate>]>>,
                {
                    let (v0, v1, v2) = self.0;
                    DumpResponseBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> DumpResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`ice_state` field](DumpResponse#structfield.ice_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_state<T4>(self, value: T4) -> DumpResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`ice_state` field](DumpResponse#structfield.ice_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_state_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.ice_state(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> DumpResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`ice_selected_tuple` field](DumpResponse#structfield.ice_selected_tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_selected_tuple<T5>(
                    self,
                    value: T5,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`ice_selected_tuple` field](DumpResponse#structfield.ice_selected_tuple) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_selected_tuple_as_null(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.ice_selected_tuple(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`dtls_parameters` field](DumpResponse#structfield.dtls_parameters).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_parameters<T6>(
                    self,
                    value: T6,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`dtls_state` field](DumpResponse#structfield.dtls_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_state<T7>(
                    self,
                    value: T7,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    DumpResponseBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`dtls_state` field](DumpResponse#structfield.dtls_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_state_as_default(
                    self,
                ) -> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.dtls_state(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DumpResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse>
                where
                    Self: ::planus::WriteAsOffset<DumpResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    T2: ::planus::WriteAs<::planus::Offset<self::IceParameters>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IceCandidate>]>>,
                    T4: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T6: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>,
                    T7: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                > ::planus::WriteAs<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    T2: ::planus::WriteAs<::planus::Offset<self::IceParameters>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IceCandidate>]>>,
                    T4: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T6: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>,
                    T7: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                > ::planus::WriteAsOptional<::planus::Offset<DumpResponse>>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<DumpResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    T2: ::planus::WriteAs<::planus::Offset<self::IceParameters>>,
                    T3: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::IceCandidate>]>>,
                    T4: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T6: ::planus::WriteAs<::planus::Offset<self::DtlsParameters>>,
                    T7: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                > ::planus::WriteAsOffset<DumpResponse>
                for DumpResponseBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    DumpResponse::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [DumpResponse].
            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                /// Getter for the [`base` field](DumpResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }

                /// Getter for the [`ice_role` field](DumpResponse#structfield.ice_role).
                #[inline]
                pub fn ice_role(&self) -> ::planus::Result<self::IceRole> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DumpResponse", "ice_role")?
                            .unwrap_or(self::IceRole::Controlled),
                    )
                }

                /// Getter for the [`ice_parameters` field](DumpResponse#structfield.ice_parameters).
                #[inline]
                pub fn ice_parameters(&self) -> ::planus::Result<self::IceParametersRef<'a>> {
                    self.0.access_required(2, "DumpResponse", "ice_parameters")
                }

                /// Getter for the [`ice_candidates` field](DumpResponse#structfield.ice_candidates).
                #[inline]
                pub fn ice_candidates(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::IceCandidateRef<'a>>>,
                > {
                    self.0.access_required(3, "DumpResponse", "ice_candidates")
                }

                /// Getter for the [`ice_state` field](DumpResponse#structfield.ice_state).
                #[inline]
                pub fn ice_state(&self) -> ::planus::Result<self::IceState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "DumpResponse", "ice_state")?
                            .unwrap_or(self::IceState::New),
                    )
                }

                /// Getter for the [`ice_selected_tuple` field](DumpResponse#structfield.ice_selected_tuple).
                #[inline]
                pub fn ice_selected_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(5, "DumpResponse", "ice_selected_tuple")
                }

                /// Getter for the [`dtls_parameters` field](DumpResponse#structfield.dtls_parameters).
                #[inline]
                pub fn dtls_parameters(&self) -> ::planus::Result<self::DtlsParametersRef<'a>> {
                    self.0.access_required(6, "DumpResponse", "dtls_parameters")
                }

                /// Getter for the [`dtls_state` field](DumpResponse#structfield.dtls_state).
                #[inline]
                pub fn dtls_state(&self) -> ::planus::Result<self::DtlsState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "DumpResponse", "dtls_state")?
                            .unwrap_or(self::DtlsState::New),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.field("ice_role", &self.ice_role());
                    f.field("ice_parameters", &self.ice_parameters());
                    f.field("ice_candidates", &self.ice_candidates());
                    f.field("ice_state", &self.ice_state());
                    if let ::core::option::Option::Some(field_ice_selected_tuple) =
                        self.ice_selected_tuple().transpose()
                    {
                        f.field("ice_selected_tuple", &field_ice_selected_tuple);
                    }
                    f.field("dtls_parameters", &self.dtls_parameters());
                    f.field("dtls_state", &self.dtls_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        ice_role: ::core::convert::TryInto::try_into(value.ice_role()?)?,
                        ice_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.ice_parameters()?)?,
                        ),
                        ice_candidates: value.ice_candidates()?.to_vec_result()?,
                        ice_state: ::core::convert::TryInto::try_into(value.ice_state()?)?,
                        ice_selected_tuple: if let ::core::option::Option::Some(
                            ice_selected_tuple,
                        ) = value.ice_selected_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(ice_selected_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        dtls_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.dtls_parameters()?)?,
                        ),
                        dtls_state: ::core::convert::TryInto::try_into(value.dtls_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GetStatsResponse` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `GetStatsResponse` in the file `../worker/fbs/webRtcTransport.fbs:115`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                /// The field `base` in the table `GetStatsResponse`
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
                /// The field `ice_role` in the table `GetStatsResponse`
                pub ice_role: self::IceRole,
                /// The field `ice_state` in the table `GetStatsResponse`
                pub ice_state: self::IceState,
                /// The field `ice_selected_tuple` in the table `GetStatsResponse`
                pub ice_selected_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                /// The field `dtls_state` in the table `GetStatsResponse`
                pub dtls_state: self::DtlsState,
            }

            impl GetStatsResponse {
                /// Creates a [GetStatsResponseBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GetStatsResponseBuilder<()> {
                    GetStatsResponseBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    field_ice_role: impl ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    field_ice_state: impl ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    field_ice_selected_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_dtls_state: impl ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);
                    let prepared_ice_role =
                        field_ice_role.prepare(builder, &self::IceRole::Controlled);
                    let prepared_ice_state = field_ice_state.prepare(builder, &self::IceState::New);
                    let prepared_ice_selected_tuple = field_ice_selected_tuple.prepare(builder);
                    let prepared_dtls_state =
                        field_dtls_state.prepare(builder, &self::DtlsState::New);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Stats>>(0);
                    if prepared_ice_selected_tuple.is_some() {
                        table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(3);
                    }
                    if prepared_ice_role.is_some() {
                        table_writer.write_entry::<self::IceRole>(1);
                    }
                    if prepared_ice_state.is_some() {
                        table_writer.write_entry::<self::IceState>(2);
                    }
                    if prepared_dtls_state.is_some() {
                        table_writer.write_entry::<self::DtlsState>(4);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_base);
                            if let ::core::option::Option::Some(prepared_ice_selected_tuple) =
                                prepared_ice_selected_tuple
                            {
                                object_writer.write::<_, _, 4>(&prepared_ice_selected_tuple);
                            }
                            if let ::core::option::Option::Some(prepared_ice_role) =
                                prepared_ice_role
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_role);
                            }
                            if let ::core::option::Option::Some(prepared_ice_state) =
                                prepared_ice_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_state);
                            }
                            if let ::core::option::Option::Some(prepared_dtls_state) =
                                prepared_dtls_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_dtls_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        &self.base,
                        self.ice_role,
                        self.ice_state,
                        &self.ice_selected_tuple,
                        self.dtls_state,
                    )
                }
            }

            /// Builder for serializing an instance of the [GetStatsResponse] type.
            ///
            /// Can be created using the [GetStatsResponse::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GetStatsResponseBuilder<State>(State);

            impl GetStatsResponseBuilder<()> {
                /// Setter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn base<T0>(self, value: T0) -> GetStatsResponseBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                {
                    GetStatsResponseBuilder((value,))
                }
            }

            impl<T0> GetStatsResponseBuilder<(T0,)> {
                /// Setter for the [`ice_role` field](GetStatsResponse#structfield.ice_role).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_role<T1>(self, value: T1) -> GetStatsResponseBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                {
                    let (v0,) = self.0;
                    GetStatsResponseBuilder((v0, value))
                }

                /// Sets the [`ice_role` field](GetStatsResponse#structfield.ice_role) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_role_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, ::planus::DefaultValue)> {
                    self.ice_role(::planus::DefaultValue)
                }
            }

            impl<T0, T1> GetStatsResponseBuilder<(T0, T1)> {
                /// Setter for the [`ice_state` field](GetStatsResponse#structfield.ice_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_state<T2>(self, value: T2) -> GetStatsResponseBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                {
                    let (v0, v1) = self.0;
                    GetStatsResponseBuilder((v0, v1, value))
                }

                /// Sets the [`ice_state` field](GetStatsResponse#structfield.ice_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_state_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.ice_state(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> GetStatsResponseBuilder<(T0, T1, T2)> {
                /// Setter for the [`ice_selected_tuple` field](GetStatsResponse#structfield.ice_selected_tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_selected_tuple<T3>(
                    self,
                    value: T3,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                {
                    let (v0, v1, v2) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, value))
                }

                /// Sets the [`ice_selected_tuple` field](GetStatsResponse#structfield.ice_selected_tuple) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_selected_tuple_as_null(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, ())> {
                    self.ice_selected_tuple(())
                }
            }

            impl<T0, T1, T2, T3> GetStatsResponseBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`dtls_state` field](GetStatsResponse#structfield.dtls_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_state<T4>(
                    self,
                    value: T4,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GetStatsResponseBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`dtls_state` field](GetStatsResponse#structfield.dtls_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_state_as_default(
                    self,
                ) -> GetStatsResponseBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.dtls_state(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> GetStatsResponseBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GetStatsResponse].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse>
                where
                    Self: ::planus::WriteAsOffset<GetStatsResponse>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    T2: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                > ::planus::WriteAs<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    T2: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                > ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GetStatsResponse>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    T1: ::planus::WriteAsDefault<self::IceRole, self::IceRole>,
                    T2: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<super::transport::Tuple>>,
                    T4: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                > ::planus::WriteAsOffset<GetStatsResponse>
                for GetStatsResponseBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    GetStatsResponse::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [GetStatsResponse].
            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                /// Getter for the [`base` field](GetStatsResponse#structfield.base).
                #[inline]
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }

                /// Getter for the [`ice_role` field](GetStatsResponse#structfield.ice_role).
                #[inline]
                pub fn ice_role(&self) -> ::planus::Result<self::IceRole> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "GetStatsResponse", "ice_role")?
                            .unwrap_or(self::IceRole::Controlled),
                    )
                }

                /// Getter for the [`ice_state` field](GetStatsResponse#structfield.ice_state).
                #[inline]
                pub fn ice_state(&self) -> ::planus::Result<self::IceState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "GetStatsResponse", "ice_state")?
                            .unwrap_or(self::IceState::New),
                    )
                }

                /// Getter for the [`ice_selected_tuple` field](GetStatsResponse#structfield.ice_selected_tuple).
                #[inline]
                pub fn ice_selected_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(3, "GetStatsResponse", "ice_selected_tuple")
                }

                /// Getter for the [`dtls_state` field](GetStatsResponse#structfield.dtls_state).
                #[inline]
                pub fn dtls_state(&self) -> ::planus::Result<self::DtlsState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "GetStatsResponse", "dtls_state")?
                            .unwrap_or(self::DtlsState::New),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.field("ice_role", &self.ice_role());
                    f.field("ice_state", &self.ice_state());
                    if let ::core::option::Option::Some(field_ice_selected_tuple) =
                        self.ice_selected_tuple().transpose()
                    {
                        f.field("ice_selected_tuple", &field_ice_selected_tuple);
                    }
                    f.field("dtls_state", &self.dtls_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        ice_role: ::core::convert::TryInto::try_into(value.ice_role()?)?,
                        ice_state: ::core::convert::TryInto::try_into(value.ice_state()?)?,
                        ice_selected_tuple: if let ::core::option::Option::Some(
                            ice_selected_tuple,
                        ) = value.ice_selected_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(ice_selected_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        dtls_state: ::core::convert::TryInto::try_into(value.dtls_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `IceSelectedTupleChangeNotification` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `IceSelectedTupleChangeNotification` in the file `../worker/fbs/webRtcTransport.fbs:125`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceSelectedTupleChangeNotification {
                /// The field `tuple` in the table `IceSelectedTupleChangeNotification`
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl IceSelectedTupleChangeNotification {
                /// Creates a [IceSelectedTupleChangeNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> IceSelectedTupleChangeNotificationBuilder<()> {
                    IceSelectedTupleChangeNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<super::transport::Tuple>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_tuple);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceSelectedTupleChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceSelectedTupleChangeNotification>
                for IceSelectedTupleChangeNotification
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification> {
                    IceSelectedTupleChangeNotification::create(builder, &self.tuple)
                }
            }

            /// Builder for serializing an instance of the [IceSelectedTupleChangeNotification] type.
            ///
            /// Can be created using the [IceSelectedTupleChangeNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct IceSelectedTupleChangeNotificationBuilder<State>(State);

            impl IceSelectedTupleChangeNotificationBuilder<()> {
                /// Setter for the [`tuple` field](IceSelectedTupleChangeNotification#structfield.tuple).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn tuple<T0>(
                    self,
                    value: T0,
                ) -> IceSelectedTupleChangeNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                {
                    IceSelectedTupleChangeNotificationBuilder((value,))
                }
            }

            impl<T0> IceSelectedTupleChangeNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [IceSelectedTupleChangeNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification>
                where
                    Self: ::planus::WriteAsOffset<IceSelectedTupleChangeNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAs<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<IceSelectedTupleChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOptional<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<IceSelectedTupleChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceSelectedTupleChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>>
                ::planus::WriteAsOffset<IceSelectedTupleChangeNotification>
                for IceSelectedTupleChangeNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification> {
                    let (v0,) = &self.0;
                    IceSelectedTupleChangeNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [IceSelectedTupleChangeNotification].
            #[derive(Copy, Clone)]
            pub struct IceSelectedTupleChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceSelectedTupleChangeNotificationRef<'a> {
                /// Getter for the [`tuple` field](IceSelectedTupleChangeNotification#structfield.tuple).
                #[inline]
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0
                        .access_required(0, "IceSelectedTupleChangeNotification", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for IceSelectedTupleChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceSelectedTupleChangeNotificationRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceSelectedTupleChangeNotificationRef<'a>>
                for IceSelectedTupleChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: IceSelectedTupleChangeNotificationRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceSelectedTupleChangeNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceSelectedTupleChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceSelectedTupleChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotification
            {
                type Value = ::planus::Offset<IceSelectedTupleChangeNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceSelectedTupleChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceSelectedTupleChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceSelectedTupleChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `IceStateChangeNotification` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `IceStateChangeNotification` in the file `../worker/fbs/webRtcTransport.fbs:129`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceStateChangeNotification {
                /// The field `ice_state` in the table `IceStateChangeNotification`
                pub ice_state: self::IceState,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for IceStateChangeNotification {
                fn default() -> Self {
                    Self {
                        ice_state: self::IceState::New,
                    }
                }
            }

            impl IceStateChangeNotification {
                /// Creates a [IceStateChangeNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> IceStateChangeNotificationBuilder<()> {
                    IceStateChangeNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ice_state: impl ::planus::WriteAsDefault<self::IceState, self::IceState>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ice_state = field_ice_state.prepare(builder, &self::IceState::New);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_ice_state.is_some() {
                        table_writer.write_entry::<self::IceState>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_ice_state) =
                                prepared_ice_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_ice_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceStateChangeNotification> for IceStateChangeNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification> {
                    IceStateChangeNotification::create(builder, self.ice_state)
                }
            }

            /// Builder for serializing an instance of the [IceStateChangeNotification] type.
            ///
            /// Can be created using the [IceStateChangeNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct IceStateChangeNotificationBuilder<State>(State);

            impl IceStateChangeNotificationBuilder<()> {
                /// Setter for the [`ice_state` field](IceStateChangeNotification#structfield.ice_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_state<T0>(self, value: T0) -> IceStateChangeNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::IceState, self::IceState>,
                {
                    IceStateChangeNotificationBuilder((value,))
                }

                /// Sets the [`ice_state` field](IceStateChangeNotification#structfield.ice_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ice_state_as_default(
                    self,
                ) -> IceStateChangeNotificationBuilder<(::planus::DefaultValue,)> {
                    self.ice_state(::planus::DefaultValue)
                }
            }

            impl<T0> IceStateChangeNotificationBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [IceStateChangeNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification>
                where
                    Self: ::planus::WriteAsOffset<IceStateChangeNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::IceState, self::IceState>>
                ::planus::WriteAs<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<IceStateChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::IceState, self::IceState>>
                ::planus::WriteAsOptional<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotificationBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<IceStateChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::IceState, self::IceState>>
                ::planus::WriteAsOffset<IceStateChangeNotification>
                for IceStateChangeNotificationBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification> {
                    let (v0,) = &self.0;
                    IceStateChangeNotification::create(builder, v0)
                }
            }

            /// Reference to a deserialized [IceStateChangeNotification].
            #[derive(Copy, Clone)]
            pub struct IceStateChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceStateChangeNotificationRef<'a> {
                /// Getter for the [`ice_state` field](IceStateChangeNotification#structfield.ice_state).
                #[inline]
                pub fn ice_state(&self) -> ::planus::Result<self::IceState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "IceStateChangeNotification", "ice_state")?
                            .unwrap_or(self::IceState::New),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for IceStateChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceStateChangeNotificationRef");
                    f.field("ice_state", &self.ice_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceStateChangeNotificationRef<'a>>
                for IceStateChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceStateChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ice_state: ::core::convert::TryInto::try_into(value.ice_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceStateChangeNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceStateChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceStateChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotification
            {
                type Value = ::planus::Offset<IceStateChangeNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceStateChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceStateChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceStateChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `DtlsStateChangeNotification` in the namespace `FBS.WebRtcTransport`
            ///
            /// Generated from these locations:
            /// * Table `DtlsStateChangeNotification` in the file `../worker/fbs/webRtcTransport.fbs:133`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DtlsStateChangeNotification {
                /// The field `dtls_state` in the table `DtlsStateChangeNotification`
                pub dtls_state: self::DtlsState,
                /// The field `remote_cert` in the table `DtlsStateChangeNotification`
                pub remote_cert: ::core::option::Option<::planus::alloc::string::String>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DtlsStateChangeNotification {
                fn default() -> Self {
                    Self {
                        dtls_state: self::DtlsState::New,
                        remote_cert: ::core::default::Default::default(),
                    }
                }
            }

            impl DtlsStateChangeNotification {
                /// Creates a [DtlsStateChangeNotificationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DtlsStateChangeNotificationBuilder<()> {
                    DtlsStateChangeNotificationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_dtls_state: impl ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                    field_remote_cert: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_dtls_state =
                        field_dtls_state.prepare(builder, &self::DtlsState::New);
                    let prepared_remote_cert = field_remote_cert.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_remote_cert.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(1);
                    }
                    if prepared_dtls_state.is_some() {
                        table_writer.write_entry::<self::DtlsState>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_remote_cert) =
                                prepared_remote_cert
                            {
                                object_writer.write::<_, _, 4>(&prepared_remote_cert);
                            }
                            if let ::core::option::Option::Some(prepared_dtls_state) =
                                prepared_dtls_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_dtls_state);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DtlsStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DtlsStateChangeNotification> for DtlsStateChangeNotification {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification> {
                    DtlsStateChangeNotification::create(builder, self.dtls_state, &self.remote_cert)
                }
            }

            /// Builder for serializing an instance of the [DtlsStateChangeNotification] type.
            ///
            /// Can be created using the [DtlsStateChangeNotification::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DtlsStateChangeNotificationBuilder<State>(State);

            impl DtlsStateChangeNotificationBuilder<()> {
                /// Setter for the [`dtls_state` field](DtlsStateChangeNotification#structfield.dtls_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_state<T0>(self, value: T0) -> DtlsStateChangeNotificationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                {
                    DtlsStateChangeNotificationBuilder((value,))
                }

                /// Sets the [`dtls_state` field](DtlsStateChangeNotification#structfield.dtls_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dtls_state_as_default(
                    self,
                ) -> DtlsStateChangeNotificationBuilder<(::planus::DefaultValue,)> {
                    self.dtls_state(::planus::DefaultValue)
                }
            }

            impl<T0> DtlsStateChangeNotificationBuilder<(T0,)> {
                /// Setter for the [`remote_cert` field](DtlsStateChangeNotification#structfield.remote_cert).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn remote_cert<T1>(
                    self,
                    value: T1,
                ) -> DtlsStateChangeNotificationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0,) = self.0;
                    DtlsStateChangeNotificationBuilder((v0, value))
                }

                /// Sets the [`remote_cert` field](DtlsStateChangeNotification#structfield.remote_cert) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn remote_cert_as_null(self) -> DtlsStateChangeNotificationBuilder<(T0, ())> {
                    self.remote_cert(())
                }
            }

            impl<T0, T1> DtlsStateChangeNotificationBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DtlsStateChangeNotification].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification>
                where
                    Self: ::planus::WriteAsOffset<DtlsStateChangeNotification>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAs<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotificationBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<DtlsStateChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                >
                ::planus::WriteAsOptional<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotificationBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<DtlsStateChangeNotification>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DtlsStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                > ::planus::WriteAsOffset<DtlsStateChangeNotification>
                for DtlsStateChangeNotificationBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification> {
                    let (v0, v1) = &self.0;
                    DtlsStateChangeNotification::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [DtlsStateChangeNotification].
            #[derive(Copy, Clone)]
            pub struct DtlsStateChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DtlsStateChangeNotificationRef<'a> {
                /// Getter for the [`dtls_state` field](DtlsStateChangeNotification#structfield.dtls_state).
                #[inline]
                pub fn dtls_state(&self) -> ::planus::Result<self::DtlsState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "DtlsStateChangeNotification", "dtls_state")?
                            .unwrap_or(self::DtlsState::New),
                    )
                }

                /// Getter for the [`remote_cert` field](DtlsStateChangeNotification#structfield.remote_cert).
                #[inline]
                pub fn remote_cert(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0
                        .access(1, "DtlsStateChangeNotification", "remote_cert")
                }
            }

            impl<'a> ::core::fmt::Debug for DtlsStateChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DtlsStateChangeNotificationRef");
                    f.field("dtls_state", &self.dtls_state());
                    if let ::core::option::Option::Some(field_remote_cert) =
                        self.remote_cert().transpose()
                    {
                        f.field("remote_cert", &field_remote_cert);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DtlsStateChangeNotificationRef<'a>>
                for DtlsStateChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DtlsStateChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        dtls_state: ::core::convert::TryInto::try_into(value.dtls_state()?)?,
                        remote_cert: if let ::core::option::Option::Some(remote_cert) =
                            value.remote_cert()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                remote_cert,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DtlsStateChangeNotificationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DtlsStateChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DtlsStateChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotification
            {
                type Value = ::planus::Offset<DtlsStateChangeNotification>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DtlsStateChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DtlsStateChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DtlsStateChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        /// The namespace `FBS.RtpObserver`
        ///
        /// Generated from these locations:
        /// * File `../worker/fbs/rtpObserver.fbs`
        pub mod rtp_observer {
            /// The table `AddProducerRequest` in the namespace `FBS.RtpObserver`
            ///
            /// Generated from these locations:
            /// * Table `AddProducerRequest` in the file `../worker/fbs/rtpObserver.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct AddProducerRequest {
                /// The field `producer_id` in the table `AddProducerRequest`
                pub producer_id: ::planus::alloc::string::String,
            }

            impl AddProducerRequest {
                /// Creates a [AddProducerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> AddProducerRequestBuilder<()> {
                    AddProducerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<AddProducerRequest>> for AddProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<AddProducerRequest>> for AddProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<AddProducerRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<AddProducerRequest> for AddProducerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest> {
                    AddProducerRequest::create(builder, &self.producer_id)
                }
            }

            /// Builder for serializing an instance of the [AddProducerRequest] type.
            ///
            /// Can be created using the [AddProducerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct AddProducerRequestBuilder<State>(State);

            impl AddProducerRequestBuilder<()> {
                /// Setter for the [`producer_id` field](AddProducerRequest#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T0>(self, value: T0) -> AddProducerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    AddProducerRequestBuilder((value,))
                }
            }

            impl<T0> AddProducerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [AddProducerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest>
                where
                    Self: ::planus::WriteAsOffset<AddProducerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<AddProducerRequest>>
                for AddProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<AddProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<AddProducerRequest>>
                for AddProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<AddProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<AddProducerRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<AddProducerRequest> for AddProducerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest> {
                    let (v0,) = &self.0;
                    AddProducerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [AddProducerRequest].
            #[derive(Copy, Clone)]
            pub struct AddProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> AddProducerRequestRef<'a> {
                /// Getter for the [`producer_id` field](AddProducerRequest#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "AddProducerRequest", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for AddProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("AddProducerRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<AddProducerRequestRef<'a>> for AddProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: AddProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for AddProducerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for AddProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[AddProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<AddProducerRequest>> for AddProducerRequest {
                type Value = ::planus::Offset<AddProducerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<AddProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for AddProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[AddProducerRequestRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RemoveProducerRequest` in the namespace `FBS.RtpObserver`
            ///
            /// Generated from these locations:
            /// * Table `RemoveProducerRequest` in the file `../worker/fbs/rtpObserver.fbs:7`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RemoveProducerRequest {
                /// The field `producer_id` in the table `RemoveProducerRequest`
                pub producer_id: ::planus::alloc::string::String,
            }

            impl RemoveProducerRequest {
                /// Creates a [RemoveProducerRequestBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RemoveProducerRequestBuilder<()> {
                    RemoveProducerRequestBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_producer_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RemoveProducerRequest>> for RemoveProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RemoveProducerRequest>> for RemoveProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RemoveProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RemoveProducerRequest> for RemoveProducerRequest {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest> {
                    RemoveProducerRequest::create(builder, &self.producer_id)
                }
            }

            /// Builder for serializing an instance of the [RemoveProducerRequest] type.
            ///
            /// Can be created using the [RemoveProducerRequest::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RemoveProducerRequestBuilder<State>(State);

            impl RemoveProducerRequestBuilder<()> {
                /// Setter for the [`producer_id` field](RemoveProducerRequest#structfield.producer_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn producer_id<T0>(self, value: T0) -> RemoveProducerRequestBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    RemoveProducerRequestBuilder((value,))
                }
            }

            impl<T0> RemoveProducerRequestBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RemoveProducerRequest].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest>
                where
                    Self: ::planus::WriteAsOffset<RemoveProducerRequest>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<RemoveProducerRequest>>
                for RemoveProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RemoveProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<RemoveProducerRequest>>
                for RemoveProducerRequestBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RemoveProducerRequest>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RemoveProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<RemoveProducerRequest>
                for RemoveProducerRequestBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest> {
                    let (v0,) = &self.0;
                    RemoveProducerRequest::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RemoveProducerRequest].
            #[derive(Copy, Clone)]
            pub struct RemoveProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RemoveProducerRequestRef<'a> {
                /// Getter for the [`producer_id` field](RemoveProducerRequest#structfield.producer_id).
                #[inline]
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "RemoveProducerRequest", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for RemoveProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RemoveProducerRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RemoveProducerRequestRef<'a>> for RemoveProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RemoveProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RemoveProducerRequestRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RemoveProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RemoveProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RemoveProducerRequest>> for RemoveProducerRequest {
                type Value = ::planus::Offset<RemoveProducerRequest>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RemoveProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RemoveProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RemoveProducerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
    }
}
