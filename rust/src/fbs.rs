pub use root::*;

const _: () = ::planus::check_version_compatibility("planus-0.3.1");

#[no_implicit_prelude]
mod root {
    pub mod fbs {
        pub mod active_speaker_observer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ActiveSpeakerObserverOptions {
                pub interval: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ActiveSpeakerObserverOptions {
                fn default() -> Self {
                    Self { interval: 0 }
                }
            }

            impl ActiveSpeakerObserverOptions {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_interval: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_interval = field_interval.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 2>::new(builder);

                    if prepared_interval.is_some() {
                        table_writer.calculate_size::<u16>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_interval) = prepared_interval {
                            table_writer.write::<_, _, 2>(0, &prepared_interval);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptions
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptions
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ActiveSpeakerObserverOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ActiveSpeakerObserverOptions> for ActiveSpeakerObserverOptions {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ActiveSpeakerObserverOptions> {
                    ActiveSpeakerObserverOptions::create(builder, &self.interval)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ActiveSpeakerObserverOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ActiveSpeakerObserverOptionsRef<'a> {
                pub fn interval(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ActiveSpeakerObserverOptions", "interval")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ActiveSpeakerObserverOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ActiveSpeakerObserverOptionsRef");
                    f.field("interval", &self.interval());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ActiveSpeakerObserverOptionsRef<'a>>
                for ActiveSpeakerObserverOptions
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ActiveSpeakerObserverOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        interval: ::core::convert::TryInto::try_into(value.interval()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ActiveSpeakerObserverOptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ActiveSpeakerObserverOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ActiveSpeakerObserverOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ActiveSpeakerObserverOptions>>
                for ActiveSpeakerObserverOptions
            {
                type Value = ::planus::Offset<ActiveSpeakerObserverOptions>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ActiveSpeakerObserverOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ActiveSpeakerObserverOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ActiveSpeakerObserverOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DominantSpeakerNotification {
                pub producer_id: ::core::option::Option<::planus::alloc::string::String>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DominantSpeakerNotification {
                fn default() -> Self {
                    Self {
                        producer_id: ::core::default::Default::default(),
                    }
                }
            }

            impl DominantSpeakerNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_producer_id.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_producer_id) =
                            prepared_producer_id
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_producer_id);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DominantSpeakerNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DominantSpeakerNotification> for DominantSpeakerNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DominantSpeakerNotification> {
                    DominantSpeakerNotification::create(builder, &self.producer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DominantSpeakerNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DominantSpeakerNotificationRef<'a> {
                pub fn producer_id(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0
                        .access(0, "DominantSpeakerNotification", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for DominantSpeakerNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DominantSpeakerNotificationRef");
                    if let ::core::option::Option::Some(field_producer_id) =
                        self.producer_id().transpose()
                    {
                        f.field("producer_id", &field_producer_id);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DominantSpeakerNotificationRef<'a>>
                for DominantSpeakerNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DominantSpeakerNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: if let ::core::option::Option::Some(producer_id) =
                            value.producer_id()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                producer_id,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DominantSpeakerNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DominantSpeakerNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DominantSpeakerNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DominantSpeakerNotification>>
                for DominantSpeakerNotification
            {
                type Value = ::planus::Offset<DominantSpeakerNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DominantSpeakerNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DominantSpeakerNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DominantSpeakerNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod audio_level_observer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct AudioLevelObserverOptions {
                pub max_entries: u16,
                pub threshold: i8,
                pub interval: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for AudioLevelObserverOptions {
                fn default() -> Self {
                    Self {
                        max_entries: 0,
                        threshold: 0,
                        interval: 0,
                    }
                }
            }

            impl AudioLevelObserverOptions {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_max_entries: impl ::planus::WriteAsDefault<u16, u16>,
                    field_threshold: impl ::planus::WriteAsDefault<i8, i8>,
                    field_interval: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_max_entries = field_max_entries.prepare(builder, &0);

                    let prepared_threshold = field_threshold.prepare(builder, &0);

                    let prepared_interval = field_interval.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 5>::new(builder);

                    if prepared_max_entries.is_some() {
                        table_writer.calculate_size::<u16>(2);
                    }
                    if prepared_threshold.is_some() {
                        table_writer.calculate_size::<i8>(4);
                    }
                    if prepared_interval.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_max_entries) =
                            prepared_max_entries
                        {
                            table_writer.write::<_, _, 2>(0, &prepared_max_entries);
                        }
                        if let ::core::option::Option::Some(prepared_interval) = prepared_interval {
                            table_writer.write::<_, _, 2>(2, &prepared_interval);
                        }
                        if let ::core::option::Option::Some(prepared_threshold) = prepared_threshold
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_threshold);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<AudioLevelObserverOptions>> for AudioLevelObserverOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<AudioLevelObserverOptions>>
                for AudioLevelObserverOptions
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<AudioLevelObserverOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<AudioLevelObserverOptions> for AudioLevelObserverOptions {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AudioLevelObserverOptions> {
                    AudioLevelObserverOptions::create(
                        builder,
                        &self.max_entries,
                        &self.threshold,
                        &self.interval,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct AudioLevelObserverOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> AudioLevelObserverOptionsRef<'a> {
                pub fn max_entries(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "AudioLevelObserverOptions", "max_entries")?
                            .unwrap_or(0),
                    )
                }

                pub fn threshold(&self) -> ::planus::Result<i8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "AudioLevelObserverOptions", "threshold")?
                            .unwrap_or(0),
                    )
                }

                pub fn interval(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "AudioLevelObserverOptions", "interval")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for AudioLevelObserverOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("AudioLevelObserverOptionsRef");
                    f.field("max_entries", &self.max_entries());
                    f.field("threshold", &self.threshold());
                    f.field("interval", &self.interval());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<AudioLevelObserverOptionsRef<'a>> for AudioLevelObserverOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: AudioLevelObserverOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        max_entries: ::core::convert::TryInto::try_into(value.max_entries()?)?,
                        threshold: ::core::convert::TryInto::try_into(value.threshold()?)?,
                        interval: ::core::convert::TryInto::try_into(value.interval()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for AudioLevelObserverOptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for AudioLevelObserverOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[AudioLevelObserverOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<AudioLevelObserverOptions>>
                for AudioLevelObserverOptions
            {
                type Value = ::planus::Offset<AudioLevelObserverOptions>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<AudioLevelObserverOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for AudioLevelObserverOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[AudioLevelObserverOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Volume {
                pub producer_id: ::planus::alloc::string::String,
                pub volume: i8,
            }

            impl Volume {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_volume: impl ::planus::WriteAsDefault<i8, i8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let prepared_volume = field_volume.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 5>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_volume.is_some() {
                        table_writer.calculate_size::<i8>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_producer_id);
                        if let ::core::option::Option::Some(prepared_volume) = prepared_volume {
                            table_writer.write::<_, _, 1>(1, &prepared_volume);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Volume>> for Volume {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Volume>> for Volume {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Volume>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Volume> for Volume {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Volume> {
                    Volume::create(builder, &self.producer_id, &self.volume)
                }
            }

            #[derive(Copy, Clone)]
            pub struct VolumeRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> VolumeRef<'a> {
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Volume", "producer_id")
                }

                pub fn volume(&self) -> ::planus::Result<i8> {
                    ::core::result::Result::Ok(self.0.access(1, "Volume", "volume")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for VolumeRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("VolumeRef");
                    f.field("producer_id", &self.producer_id());
                    f.field("volume", &self.volume());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<VolumeRef<'a>> for Volume {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: VolumeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        volume: ::core::convert::TryInto::try_into(value.volume()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for VolumeRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for VolumeRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VolumeRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Volume>> for Volume {
                type Value = ::planus::Offset<Volume>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Volume>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for VolumeRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[VolumeRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct VolumesNotification {
                pub volumes: ::planus::alloc::vec::Vec<self::Volume>,
            }

            impl VolumesNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_volumes: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::Volume>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_volumes = field_volumes.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer
                        .calculate_size::<::planus::Offset<[::planus::Offset<self::Volume>]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_volumes);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<VolumesNotification>> for VolumesNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<VolumesNotification>> for VolumesNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<VolumesNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<VolumesNotification> for VolumesNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VolumesNotification> {
                    VolumesNotification::create(builder, &self.volumes)
                }
            }

            #[derive(Copy, Clone)]
            pub struct VolumesNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> VolumesNotificationRef<'a> {
                pub fn volumes(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::VolumeRef<'a>>>>
                {
                    self.0.access_required(0, "VolumesNotification", "volumes")
                }
            }

            impl<'a> ::core::fmt::Debug for VolumesNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("VolumesNotificationRef");
                    f.field("volumes", &self.volumes());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<VolumesNotificationRef<'a>> for VolumesNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: VolumesNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        volumes: value.volumes()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for VolumesNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for VolumesNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VolumesNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<VolumesNotification>> for VolumesNotification {
                type Value = ::planus::Offset<VolumesNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<VolumesNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for VolumesNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VolumesNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod common {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StringString {
                pub key: ::planus::alloc::string::String,
                pub value: ::planus::alloc::string::String,
            }

            impl StringString {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder);

                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_key);
                        table_writer.write::<_, _, 4>(1, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StringString>> for StringString {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StringString>> for StringString {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringString>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StringString> for StringString {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringString> {
                    StringString::create(builder, &self.key, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StringStringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringStringRef<'a> {
                pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StringString", "key")
                }

                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "StringString", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringStringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringStringRef");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringStringRef<'a>> for StringString {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringStringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringStringRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringStringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringStringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StringString>> for StringString {
                type Value = ::planus::Offset<StringString>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StringString>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringStringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringStringRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StringUint8 {
                pub key: ::planus::alloc::string::String,
                pub value: u8,
            }

            impl StringUint8 {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder);

                    let prepared_value = field_value.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 5>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_value.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_key);
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 1>(1, &prepared_value);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StringUint8>> for StringUint8 {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StringUint8>> for StringUint8 {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringUint8>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StringUint8> for StringUint8 {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringUint8> {
                    StringUint8::create(builder, &self.key, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StringUint8Ref<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringUint8Ref<'a> {
                pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StringUint8", "key")
                }

                pub fn value(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "StringUint8", "value")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for StringUint8Ref<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringUint8Ref");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringUint8Ref<'a>> for StringUint8 {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringUint8Ref<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringUint8Ref<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringUint8Ref<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringUint8Ref]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StringUint8>> for StringUint8 {
                type Value = ::planus::Offset<StringUint8>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StringUint8>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringUint8Ref<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringUint8Ref]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Uint16String {
                pub key: u16,
                pub value: ::planus::alloc::string::String,
            }

            impl Uint16String {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAsDefault<u16, u16>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder, &0);

                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 6>::new(builder);

                    if prepared_key.is_some() {
                        table_writer.calculate_size::<u16>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(1, &prepared_value);
                        if let ::core::option::Option::Some(prepared_key) = prepared_key {
                            table_writer.write::<_, _, 2>(0, &prepared_key);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Uint16String>> for Uint16String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Uint16String>> for Uint16String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Uint16String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Uint16String> for Uint16String {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint16String> {
                    Uint16String::create(builder, &self.key, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct Uint16StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Uint16StringRef<'a> {
                pub fn key(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Uint16String", "key")?.unwrap_or(0),
                    )
                }

                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "Uint16String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for Uint16StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Uint16StringRef");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Uint16StringRef<'a>> for Uint16String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Uint16StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Uint16StringRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Uint16StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Uint16StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Uint16String>> for Uint16String {
                type Value = ::planus::Offset<Uint16String>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Uint16String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Uint16StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Uint16StringRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Uint32String {
                pub key: u32,
                pub value: ::planus::alloc::string::String,
            }

            impl Uint32String {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAsDefault<u32, u32>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder, &0);

                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    if prepared_key.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_key) = prepared_key {
                            table_writer.write::<_, _, 4>(0, &prepared_key);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Uint32String>> for Uint32String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Uint32String>> for Uint32String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Uint32String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Uint32String> for Uint32String {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Uint32String> {
                    Uint32String::create(builder, &self.key, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct Uint32StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Uint32StringRef<'a> {
                pub fn key(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Uint32String", "key")?.unwrap_or(0),
                    )
                }

                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "Uint32String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for Uint32StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Uint32StringRef");
                    f.field("key", &self.key());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Uint32StringRef<'a>> for Uint32String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Uint32StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Uint32StringRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Uint32StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Uint32StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Uint32String>> for Uint32String {
                type Value = ::planus::Offset<Uint32String>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Uint32String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Uint32StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Uint32StringRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StringStringArray {
                pub key: ::planus::alloc::string::String,
                pub values: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
            }

            impl StringStringArray {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_key: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_values: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_key = field_key.prepare(builder);

                    let prepared_values = field_values.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_values.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_key);
                        if let ::core::option::Option::Some(prepared_values) = prepared_values {
                            table_writer.write::<_, _, 4>(1, &prepared_values);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StringStringArray>> for StringStringArray {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StringStringArray>> for StringStringArray {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StringStringArray>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StringStringArray> for StringStringArray {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StringStringArray> {
                    StringStringArray::create(builder, &self.key, &self.values)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StringStringArrayRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringStringArrayRef<'a> {
                pub fn key(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StringStringArray", "key")
                }

                pub fn values(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(1, "StringStringArray", "values")
                }
            }

            impl<'a> ::core::fmt::Debug for StringStringArrayRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringStringArrayRef");
                    f.field("key", &self.key());
                    if let ::core::option::Option::Some(field_values) = self.values().transpose() {
                        f.field("values", &field_values);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringStringArrayRef<'a>> for StringStringArray {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringStringArrayRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        key: ::core::convert::TryInto::try_into(value.key()?)?,
                        values: if let ::core::option::Option::Some(values) = value.values()? {
                            ::core::option::Option::Some(values.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringStringArrayRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringStringArrayRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringStringArrayRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StringStringArray>> for StringStringArray {
                type Value = ::planus::Offset<StringStringArray>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StringStringArray>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringStringArrayRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringStringArrayRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod consumer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumerLayers {
                pub spatial_layer: i16,
                pub temporal_layer: ::core::option::Option<i16>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConsumerLayers {
                fn default() -> Self {
                    Self {
                        spatial_layer: 0,
                        temporal_layer: ::core::default::Default::default(),
                    }
                }
            }

            impl ConsumerLayers {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_temporal_layer: impl ::planus::WriteAsOptional<i16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_spatial_layer = field_spatial_layer.prepare(builder, &0);

                    let prepared_temporal_layer = field_temporal_layer.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 4>::new(builder);

                    if prepared_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(2);
                    }
                    if prepared_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_spatial_layer) =
                            prepared_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(0, &prepared_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_temporal_layer) =
                            prepared_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(1, &prepared_temporal_layer);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumerLayers>> for ConsumerLayers {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumerLayers>> for ConsumerLayers {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerLayers>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumerLayers> for ConsumerLayers {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerLayers> {
                    ConsumerLayers::create(builder, &self.spatial_layer, &self.temporal_layer)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConsumerLayersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumerLayersRef<'a> {
                pub fn spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ConsumerLayers", "spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn temporal_layer(&self) -> ::planus::Result<::core::option::Option<i16>> {
                    self.0.access(1, "ConsumerLayers", "temporal_layer")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumerLayersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumerLayersRef");
                    f.field("spatial_layer", &self.spatial_layer());
                    if let ::core::option::Option::Some(field_temporal_layer) =
                        self.temporal_layer().transpose()
                    {
                        f.field("temporal_layer", &field_temporal_layer);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumerLayersRef<'a>> for ConsumerLayers {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumerLayersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        spatial_layer: ::core::convert::TryInto::try_into(value.spatial_layer()?)?,
                        temporal_layer: if let ::core::option::Option::Some(temporal_layer) =
                            value.temporal_layer()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                temporal_layer,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumerLayersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumerLayersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumerLayersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumerLayers>> for ConsumerLayers {
                type Value = ::planus::Offset<ConsumerLayers>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumerLayers>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumerLayersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumerLayersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumerScore {
                pub score: u8,
                pub producer_score: u8,
                pub producer_scores: ::core::option::Option<::planus::alloc::vec::Vec<u8>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConsumerScore {
                fn default() -> Self {
                    Self {
                        score: 0,
                        producer_score: 0,
                        producer_scores: ::core::default::Default::default(),
                    }
                }
            }

            impl ConsumerScore {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_producer_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_producer_scores: impl ::planus::WriteAsOptional<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_score = field_score.prepare(builder, &0);

                    let prepared_producer_score = field_producer_score.prepare(builder, &0);

                    let prepared_producer_scores = field_producer_scores.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 6>::new(builder);

                    if prepared_score.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }
                    if prepared_producer_score.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }
                    if prepared_producer_scores.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[u8]>>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_producer_scores) =
                            prepared_producer_scores
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_producer_scores);
                        }
                        if let ::core::option::Option::Some(prepared_score) = prepared_score {
                            table_writer.write::<_, _, 1>(0, &prepared_score);
                        }
                        if let ::core::option::Option::Some(prepared_producer_score) =
                            prepared_producer_score
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_producer_score);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumerScore>> for ConsumerScore {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumerScore>> for ConsumerScore {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumerScore>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumerScore> for ConsumerScore {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumerScore> {
                    ConsumerScore::create(
                        builder,
                        &self.score,
                        &self.producer_score,
                        &self.producer_scores,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConsumerScoreRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumerScoreRef<'a> {
                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "ConsumerScore", "score")?.unwrap_or(0),
                    )
                }

                pub fn producer_score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ConsumerScore", "producer_score")?
                            .unwrap_or(0),
                    )
                }

                pub fn producer_scores(
                    &self,
                ) -> ::planus::Result<::core::option::Option<::planus::Vector<'a, u8>>>
                {
                    self.0.access(2, "ConsumerScore", "producer_scores")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumerScoreRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumerScoreRef");
                    f.field("score", &self.score());
                    f.field("producer_score", &self.producer_score());
                    if let ::core::option::Option::Some(field_producer_scores) =
                        self.producer_scores().transpose()
                    {
                        f.field("producer_scores", &field_producer_scores);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumerScoreRef<'a>> for ConsumerScore {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumerScoreRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                        producer_score: ::core::convert::TryInto::try_into(
                            value.producer_score()?,
                        )?,
                        producer_scores: if let ::core::option::Option::Some(producer_scores) =
                            value.producer_scores()?
                        {
                            ::core::option::Option::Some(producer_scores.to_vec()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumerScoreRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumerScoreRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumerScoreRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumerScore>> for ConsumerScore {
                type Value = ::planus::Offset<ConsumerScore>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumerScore>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumerScoreRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumerScoreRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPreferredLayersRequest {
                pub preferred_layers: ::planus::alloc::boxed::Box<self::ConsumerLayers>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPreferredLayersRequest {
                fn default() -> Self {
                    Self {
                        preferred_layers: ::core::default::Default::default(),
                    }
                }
            }

            impl SetPreferredLayersRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_preferred_layers: impl ::planus::WriteAs<
                        ::planus::Offset<self::ConsumerLayers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::ConsumerLayers>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_preferred_layers);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPreferredLayersRequest>> for SetPreferredLayersRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPreferredLayersRequest>>
                for SetPreferredLayersRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPreferredLayersRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPreferredLayersRequest> for SetPreferredLayersRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersRequest> {
                    SetPreferredLayersRequest::create(builder, &self.preferred_layers)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetPreferredLayersRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPreferredLayersRequestRef<'a> {
                pub fn preferred_layers(&self) -> ::planus::Result<self::ConsumerLayersRef<'a>> {
                    self.0
                        .access_required(0, "SetPreferredLayersRequest", "preferred_layers")
                }
            }

            impl<'a> ::core::fmt::Debug for SetPreferredLayersRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPreferredLayersRequestRef");
                    f.field("preferred_layers", &self.preferred_layers());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPreferredLayersRequestRef<'a>> for SetPreferredLayersRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPreferredLayersRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        preferred_layers: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.preferred_layers()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPreferredLayersRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPreferredLayersRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPreferredLayersRequest>>
                for SetPreferredLayersRequest
            {
                type Value = ::planus::Offset<SetPreferredLayersRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPreferredLayersRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPreferredLayersRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPreferredLayersResponse {
                pub preferred_layers:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::ConsumerLayers>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPreferredLayersResponse {
                fn default() -> Self {
                    Self {
                        preferred_layers: ::core::default::Default::default(),
                    }
                }
            }

            impl SetPreferredLayersResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_preferred_layers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::ConsumerLayers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_preferred_layers.is_some() {
                        table_writer.calculate_size::<::planus::Offset<self::ConsumerLayers>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_preferred_layers) =
                            prepared_preferred_layers
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_preferred_layers);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponse
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponse
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPreferredLayersResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPreferredLayersResponse> for SetPreferredLayersResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPreferredLayersResponse> {
                    SetPreferredLayersResponse::create(builder, &self.preferred_layers)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetPreferredLayersResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPreferredLayersResponseRef<'a> {
                pub fn preferred_layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ConsumerLayersRef<'a>>>
                {
                    self.0
                        .access(0, "SetPreferredLayersResponse", "preferred_layers")
                }
            }

            impl<'a> ::core::fmt::Debug for SetPreferredLayersResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPreferredLayersResponseRef");
                    if let ::core::option::Option::Some(field_preferred_layers) =
                        self.preferred_layers().transpose()
                    {
                        f.field("preferred_layers", &field_preferred_layers);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPreferredLayersResponseRef<'a>>
                for SetPreferredLayersResponse
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPreferredLayersResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        preferred_layers: if let ::core::option::Option::Some(preferred_layers) =
                            value.preferred_layers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(preferred_layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPreferredLayersResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPreferredLayersResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPreferredLayersResponse>>
                for SetPreferredLayersResponse
            {
                type Value = ::planus::Offset<SetPreferredLayersResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPreferredLayersResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPreferredLayersResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPreferredLayersResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPriorityRequest {
                pub priority: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPriorityRequest {
                fn default() -> Self {
                    Self { priority: 0 }
                }
            }

            impl SetPriorityRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_priority: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_priority = field_priority.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_priority.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_priority) = prepared_priority {
                            table_writer.write::<_, _, 1>(0, &prepared_priority);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPriorityRequest>> for SetPriorityRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPriorityRequest>> for SetPriorityRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPriorityRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPriorityRequest> for SetPriorityRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityRequest> {
                    SetPriorityRequest::create(builder, &self.priority)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetPriorityRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPriorityRequestRef<'a> {
                pub fn priority(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetPriorityRequest", "priority")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetPriorityRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPriorityRequestRef");
                    f.field("priority", &self.priority());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPriorityRequestRef<'a>> for SetPriorityRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPriorityRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPriorityRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPriorityRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPriorityRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPriorityRequest>> for SetPriorityRequest {
                type Value = ::planus::Offset<SetPriorityRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPriorityRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPriorityRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SetPriorityRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetPriorityResponse {
                pub priority: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetPriorityResponse {
                fn default() -> Self {
                    Self { priority: 0 }
                }
            }

            impl SetPriorityResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_priority: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_priority = field_priority.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_priority.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_priority) = prepared_priority {
                            table_writer.write::<_, _, 1>(0, &prepared_priority);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetPriorityResponse>> for SetPriorityResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetPriorityResponse>> for SetPriorityResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetPriorityResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetPriorityResponse> for SetPriorityResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetPriorityResponse> {
                    SetPriorityResponse::create(builder, &self.priority)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetPriorityResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetPriorityResponseRef<'a> {
                pub fn priority(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetPriorityResponse", "priority")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetPriorityResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetPriorityResponseRef");
                    f.field("priority", &self.priority());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetPriorityResponseRef<'a>> for SetPriorityResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetPriorityResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetPriorityResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetPriorityResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPriorityResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetPriorityResponse>> for SetPriorityResponse {
                type Value = ::planus::Offset<SetPriorityResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetPriorityResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetPriorityResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetPriorityResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EnableTraceEventRequest {
                pub events: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            }

            impl EnableTraceEventRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_events: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_events = field_events.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_events);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EnableTraceEventRequest> for EnableTraceEventRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    EnableTraceEventRequest::create(builder, &self.events)
                }
            }

            #[derive(Copy, Clone)]
            pub struct EnableTraceEventRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EnableTraceEventRequestRef<'a> {
                pub fn events(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(0, "EnableTraceEventRequest", "events")
                }
            }

            impl<'a> ::core::fmt::Debug for EnableTraceEventRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EnableTraceEventRequestRef");
                    f.field("events", &self.events());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EnableTraceEventRequestRef<'a>> for EnableTraceEventRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EnableTraceEventRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        events: value.events()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EnableTraceEventRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EnableTraceEventRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Value = ::planus::Offset<EnableTraceEventRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EnableTraceEventRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EnableTraceEventRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum DumpData {
                SimpleConsumerDump(::planus::alloc::boxed::Box<self::SimpleConsumerDump>),
                SimulcastConsumerDump(::planus::alloc::boxed::Box<self::SimulcastConsumerDump>),
                SvcConsumerDump(::planus::alloc::boxed::Box<self::SvcConsumerDump>),
                PipeConsumerDump(::planus::alloc::boxed::Box<self::PipeConsumerDump>),
            }

            impl DumpData {
                pub fn create_simple_consumer_dump(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::SimpleConsumerDump>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_simulcast_consumer_dump(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::SimulcastConsumerDump>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_svc_consumer_dump(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::SvcConsumerDump>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_pipe_consumer_dump(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PipeConsumerDump>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<DumpData> for DumpData {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::SimpleConsumerDump(value) => {
                            Self::create_simple_consumer_dump(builder, value)
                        }
                        Self::SimulcastConsumerDump(value) => {
                            Self::create_simulcast_consumer_dump(builder, value)
                        }
                        Self::SvcConsumerDump(value) => {
                            Self::create_svc_consumer_dump(builder, value)
                        }
                        Self::PipeConsumerDump(value) => {
                            Self::create_pipe_consumer_dump(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<DumpData> for DumpData {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum DumpDataRef<'a> {
                SimpleConsumerDump(self::SimpleConsumerDumpRef<'a>),
                SimulcastConsumerDump(self::SimulcastConsumerDumpRef<'a>),
                SvcConsumerDump(self::SvcConsumerDumpRef<'a>),
                PipeConsumerDump(self::PipeConsumerDumpRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<DumpDataRef<'a>> for DumpData {
                type Error = ::planus::Error;

                fn try_from(value: DumpDataRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        DumpDataRef::SimpleConsumerDump(value) => {
                            DumpData::SimpleConsumerDump(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        DumpDataRef::SimulcastConsumerDump(value) => {
                            DumpData::SimulcastConsumerDump(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        DumpDataRef::SvcConsumerDump(value) => {
                            DumpData::SvcConsumerDump(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        DumpDataRef::PipeConsumerDump(value) => {
                            DumpData::PipeConsumerDump(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for DumpDataRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::SimpleConsumerDump(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::SimulcastConsumerDump(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::SvcConsumerDump(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::PipeConsumerDump(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub data: ::core::option::Option<self::DumpData>,
                pub type_: super::rtp_parameters::Type,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DumpResponse {
                fn default() -> Self {
                    Self {
                        data: ::core::default::Default::default(),
                        type_: super::rtp_parameters::Type::None,
                    }
                }
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAsOptionalUnion<self::DumpData>,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::None);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 6>::new(builder);

                    if prepared_data.is_some() {
                        table_writer.calculate_size::<u8>(2);
                        table_writer.calculate_size::<::planus::Offset<self::DumpData>>(4);
                    }
                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::Type>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_data) = prepared_data {
                            table_writer.write::<_, _, 4>(1, &prepared_data.offset());
                        }
                        if let ::core::option::Option::Some(prepared_data) = prepared_data {
                            table_writer.write::<_, _, 1>(0, &prepared_data.tag());
                        }
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(2, &prepared_type_);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(builder, &self.data, &self.type_)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn data(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::DumpDataRef<'a>>>
                {
                    self.0.access_union(0, "DumpResponse", "data")
                }

                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "DumpResponse", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::None),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    if let ::core::option::Option::Some(field_data) = self.data().transpose() {
                        f.field("data", &field_data);
                    }
                    f.field("type_", &self.type_());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: if let ::core::option::Option::Some(data) = value.data()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(data)?)
                        } else {
                            ::core::option::Option::None
                        },
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BaseConsumerDump {
                pub id: ::planus::alloc::string::String,
                pub producer_id: ::planus::alloc::string::String,
                pub kind: super::rtp_parameters::MediaKind,
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                pub consumable_rtp_encodings: ::core::option::Option<
                    ::planus::alloc::vec::Vec<super::rtp_parameters::RtpEncodingParameters>,
                >,
                pub supported_codec_payload_types:
                    ::core::option::Option<::planus::alloc::vec::Vec<u8>>,
                pub trace_event_types: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                pub paused: bool,
                pub producer_paused: bool,
                pub priority: u8,
            }

            impl BaseConsumerDump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_consumable_rtp_encodings: impl ::planus::WriteAsOptional<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    field_supported_codec_payload_types: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[u8]>,
                    >,
                    field_trace_event_types: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_producer_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_priority: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::All);

                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);

                    let prepared_consumable_rtp_encodings =
                        field_consumable_rtp_encodings.prepare(builder);

                    let prepared_supported_codec_payload_types =
                        field_supported_codec_payload_types.prepare(builder);

                    let prepared_trace_event_types = field_trace_event_types.prepare(builder);

                    let prepared_paused = field_paused.prepare(builder, &false);

                    let prepared_producer_paused = field_producer_paused.prepare(builder, &false);

                    let prepared_priority = field_priority.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<22, 28>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_kind.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::MediaKind>(6);
                    }
                    table_writer
                        .calculate_size::<::planus::Offset<super::rtp_parameters::RtpParameters>>(
                            8,
                        );
                    if prepared_consumable_rtp_encodings.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >>(10);
                    }
                    if prepared_supported_codec_payload_types.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[u8]>>(12);
                    }
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(14);
                    if prepared_paused.is_some() {
                        table_writer.calculate_size::<bool>(16);
                    }
                    if prepared_producer_paused.is_some() {
                        table_writer.calculate_size::<bool>(18);
                    }
                    if prepared_priority.is_some() {
                        table_writer.calculate_size::<u8>(20);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        table_writer.write::<_, _, 4>(1, &prepared_producer_id);
                        table_writer.write::<_, _, 4>(3, &prepared_rtp_parameters);
                        if let ::core::option::Option::Some(prepared_consumable_rtp_encodings) =
                            prepared_consumable_rtp_encodings
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_consumable_rtp_encodings);
                        }
                        if let ::core::option::Option::Some(
                            prepared_supported_codec_payload_types,
                        ) = prepared_supported_codec_payload_types
                        {
                            table_writer
                                .write::<_, _, 4>(5, &prepared_supported_codec_payload_types);
                        }
                        table_writer.write::<_, _, 4>(6, &prepared_trace_event_types);
                        if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                            table_writer.write::<_, _, 1>(2, &prepared_kind);
                        }
                        if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                            table_writer.write::<_, _, 1>(7, &prepared_paused);
                        }
                        if let ::core::option::Option::Some(prepared_producer_paused) =
                            prepared_producer_paused
                        {
                            table_writer.write::<_, _, 1>(8, &prepared_producer_paused);
                        }
                        if let ::core::option::Option::Some(prepared_priority) = prepared_priority {
                            table_writer.write::<_, _, 1>(9, &prepared_priority);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BaseConsumerDump>> for BaseConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BaseConsumerDump>> for BaseConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BaseConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BaseConsumerDump> for BaseConsumerDump {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BaseConsumerDump> {
                    BaseConsumerDump::create(
                        builder,
                        &self.id,
                        &self.producer_id,
                        &self.kind,
                        &self.rtp_parameters,
                        &self.consumable_rtp_encodings,
                        &self.supported_codec_payload_types,
                        &self.trace_event_types,
                        &self.paused,
                        &self.producer_paused,
                        &self.priority,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct BaseConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BaseConsumerDumpRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "BaseConsumerDump", "id")
                }

                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "BaseConsumerDump", "producer_id")
                }

                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "BaseConsumerDump", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::All),
                    )
                }

                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0
                        .access_required(3, "BaseConsumerDump", "rtp_parameters")
                }

                pub fn consumable_rtp_encodings(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<
                            'a,
                            ::planus::Result<super::rtp_parameters::RtpEncodingParametersRef<'a>>,
                        >,
                    >,
                > {
                    self.0
                        .access(4, "BaseConsumerDump", "consumable_rtp_encodings")
                }

                pub fn supported_codec_payload_types(
                    &self,
                ) -> ::planus::Result<::core::option::Option<::planus::Vector<'a, u8>>>
                {
                    self.0
                        .access(5, "BaseConsumerDump", "supported_codec_payload_types")
                }

                pub fn trace_event_types(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(6, "BaseConsumerDump", "trace_event_types")
                }

                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "BaseConsumerDump", "paused")?
                            .unwrap_or(false),
                    )
                }

                pub fn producer_paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "BaseConsumerDump", "producer_paused")?
                            .unwrap_or(false),
                    )
                }

                pub fn priority(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "BaseConsumerDump", "priority")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BaseConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BaseConsumerDumpRef");
                    f.field("id", &self.id());
                    f.field("producer_id", &self.producer_id());
                    f.field("kind", &self.kind());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    if let ::core::option::Option::Some(field_consumable_rtp_encodings) =
                        self.consumable_rtp_encodings().transpose()
                    {
                        f.field("consumable_rtp_encodings", &field_consumable_rtp_encodings);
                    }
                    if let ::core::option::Option::Some(field_supported_codec_payload_types) =
                        self.supported_codec_payload_types().transpose()
                    {
                        f.field(
                            "supported_codec_payload_types",
                            &field_supported_codec_payload_types,
                        );
                    }
                    f.field("trace_event_types", &self.trace_event_types());
                    f.field("paused", &self.paused());
                    f.field("producer_paused", &self.producer_paused());
                    f.field("priority", &self.priority());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BaseConsumerDumpRef<'a>> for BaseConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BaseConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        consumable_rtp_encodings: if let ::core::option::Option::Some(
                            consumable_rtp_encodings,
                        ) = value.consumable_rtp_encodings()?
                        {
                            ::core::option::Option::Some(consumable_rtp_encodings.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        supported_codec_payload_types: if let ::core::option::Option::Some(
                            supported_codec_payload_types,
                        ) =
                            value.supported_codec_payload_types()?
                        {
                            ::core::option::Option::Some(supported_codec_payload_types.to_vec()?)
                        } else {
                            ::core::option::Option::None
                        },
                        trace_event_types: value.trace_event_types()?.to_vec_result()?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        producer_paused: ::core::convert::TryInto::try_into(
                            value.producer_paused()?,
                        )?,
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BaseConsumerDumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BaseConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BaseConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BaseConsumerDump>> for BaseConsumerDump {
                type Value = ::planus::Offset<BaseConsumerDump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BaseConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BaseConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BaseConsumerDumpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct SimpleConsumerDump {
                pub base: ::planus::alloc::boxed::Box<self::BaseConsumerDump>,
                pub rtp_stream: ::planus::alloc::boxed::Box<super::rtp_stream::Dump>,
            }

            impl SimpleConsumerDump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    field_rtp_stream: impl ::planus::WriteAs<::planus::Offset<super::rtp_stream::Dump>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_rtp_stream = field_rtp_stream.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::BaseConsumerDump>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::rtp_stream::Dump>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_rtp_stream);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SimpleConsumerDump>> for SimpleConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SimpleConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SimpleConsumerDump>> for SimpleConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SimpleConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SimpleConsumerDump> for SimpleConsumerDump {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SimpleConsumerDump> {
                    SimpleConsumerDump::create(builder, &self.base, &self.rtp_stream)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SimpleConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SimpleConsumerDumpRef<'a> {
                pub fn base(&self) -> ::planus::Result<self::BaseConsumerDumpRef<'a>> {
                    self.0.access_required(0, "SimpleConsumerDump", "base")
                }

                pub fn rtp_stream(&self) -> ::planus::Result<super::rtp_stream::DumpRef<'a>> {
                    self.0
                        .access_required(1, "SimpleConsumerDump", "rtp_stream")
                }
            }

            impl<'a> ::core::fmt::Debug for SimpleConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SimpleConsumerDumpRef");
                    f.field("base", &self.base());
                    f.field("rtp_stream", &self.rtp_stream());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SimpleConsumerDumpRef<'a>> for SimpleConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SimpleConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtp_stream: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_stream()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SimpleConsumerDumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SimpleConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SimpleConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SimpleConsumerDump>> for SimpleConsumerDump {
                type Value = ::planus::Offset<SimpleConsumerDump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SimpleConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SimpleConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SimpleConsumerDumpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct SimulcastConsumerDump {
                pub base: ::planus::alloc::boxed::Box<self::BaseConsumerDump>,
                pub rtp_stream: ::planus::alloc::boxed::Box<super::rtp_stream::Dump>,
                pub preferred_spatial_layer: i16,
                pub target_spatial_layer: i16,
                pub current_spatial_layer: i16,
                pub preferred_temporal_layer: i16,
                pub target_temporal_layer: i16,
                pub current_temporal_layer: i16,
            }

            impl SimulcastConsumerDump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    field_rtp_stream: impl ::planus::WriteAs<::planus::Offset<super::rtp_stream::Dump>>,
                    field_preferred_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_target_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_current_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_preferred_temporal_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_target_temporal_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_current_temporal_layer: impl ::planus::WriteAsDefault<i16, i16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_rtp_stream = field_rtp_stream.prepare(builder);

                    let prepared_preferred_spatial_layer =
                        field_preferred_spatial_layer.prepare(builder, &0);

                    let prepared_target_spatial_layer =
                        field_target_spatial_layer.prepare(builder, &0);

                    let prepared_current_spatial_layer =
                        field_current_spatial_layer.prepare(builder, &0);

                    let prepared_preferred_temporal_layer =
                        field_preferred_temporal_layer.prepare(builder, &0);

                    let prepared_target_temporal_layer =
                        field_target_temporal_layer.prepare(builder, &0);

                    let prepared_current_temporal_layer =
                        field_current_temporal_layer.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 20>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::BaseConsumerDump>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::rtp_stream::Dump>>(4);
                    if prepared_preferred_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(6);
                    }
                    if prepared_target_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(8);
                    }
                    if prepared_current_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(10);
                    }
                    if prepared_preferred_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(12);
                    }
                    if prepared_target_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(14);
                    }
                    if prepared_current_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(16);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_rtp_stream);
                        if let ::core::option::Option::Some(prepared_preferred_spatial_layer) =
                            prepared_preferred_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(2, &prepared_preferred_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_target_spatial_layer) =
                            prepared_target_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(3, &prepared_target_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_current_spatial_layer) =
                            prepared_current_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(4, &prepared_current_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_preferred_temporal_layer) =
                            prepared_preferred_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(5, &prepared_preferred_temporal_layer);
                        }
                        if let ::core::option::Option::Some(prepared_target_temporal_layer) =
                            prepared_target_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(6, &prepared_target_temporal_layer);
                        }
                        if let ::core::option::Option::Some(prepared_current_temporal_layer) =
                            prepared_current_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(7, &prepared_current_temporal_layer);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SimulcastConsumerDump>> for SimulcastConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SimulcastConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SimulcastConsumerDump>> for SimulcastConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SimulcastConsumerDump>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SimulcastConsumerDump> for SimulcastConsumerDump {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SimulcastConsumerDump> {
                    SimulcastConsumerDump::create(
                        builder,
                        &self.base,
                        &self.rtp_stream,
                        &self.preferred_spatial_layer,
                        &self.target_spatial_layer,
                        &self.current_spatial_layer,
                        &self.preferred_temporal_layer,
                        &self.target_temporal_layer,
                        &self.current_temporal_layer,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct SimulcastConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SimulcastConsumerDumpRef<'a> {
                pub fn base(&self) -> ::planus::Result<self::BaseConsumerDumpRef<'a>> {
                    self.0.access_required(0, "SimulcastConsumerDump", "base")
                }

                pub fn rtp_stream(&self) -> ::planus::Result<super::rtp_stream::DumpRef<'a>> {
                    self.0
                        .access_required(1, "SimulcastConsumerDump", "rtp_stream")
                }

                pub fn preferred_spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "SimulcastConsumerDump", "preferred_spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn target_spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "SimulcastConsumerDump", "target_spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn current_spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "SimulcastConsumerDump", "current_spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn preferred_temporal_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "SimulcastConsumerDump", "preferred_temporal_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn target_temporal_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "SimulcastConsumerDump", "target_temporal_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn current_temporal_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "SimulcastConsumerDump", "current_temporal_layer")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SimulcastConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SimulcastConsumerDumpRef");
                    f.field("base", &self.base());
                    f.field("rtp_stream", &self.rtp_stream());
                    f.field("preferred_spatial_layer", &self.preferred_spatial_layer());
                    f.field("target_spatial_layer", &self.target_spatial_layer());
                    f.field("current_spatial_layer", &self.current_spatial_layer());
                    f.field("preferred_temporal_layer", &self.preferred_temporal_layer());
                    f.field("target_temporal_layer", &self.target_temporal_layer());
                    f.field("current_temporal_layer", &self.current_temporal_layer());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SimulcastConsumerDumpRef<'a>> for SimulcastConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SimulcastConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtp_stream: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_stream()?)?,
                        ),
                        preferred_spatial_layer: ::core::convert::TryInto::try_into(
                            value.preferred_spatial_layer()?,
                        )?,
                        target_spatial_layer: ::core::convert::TryInto::try_into(
                            value.target_spatial_layer()?,
                        )?,
                        current_spatial_layer: ::core::convert::TryInto::try_into(
                            value.current_spatial_layer()?,
                        )?,
                        preferred_temporal_layer: ::core::convert::TryInto::try_into(
                            value.preferred_temporal_layer()?,
                        )?,
                        target_temporal_layer: ::core::convert::TryInto::try_into(
                            value.target_temporal_layer()?,
                        )?,
                        current_temporal_layer: ::core::convert::TryInto::try_into(
                            value.current_temporal_layer()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SimulcastConsumerDumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SimulcastConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SimulcastConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SimulcastConsumerDump>> for SimulcastConsumerDump {
                type Value = ::planus::Offset<SimulcastConsumerDump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SimulcastConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SimulcastConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SimulcastConsumerDumpRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct SvcConsumerDump {
                pub base: ::planus::alloc::boxed::Box<self::BaseConsumerDump>,
                pub rtp_stream: ::planus::alloc::boxed::Box<super::rtp_stream::Dump>,
                pub preferred_spatial_layer: i16,
                pub target_spatial_layer: i16,
                pub current_spatial_layer: i16,
                pub preferred_temporal_layer: i16,
                pub target_temporal_layer: i16,
                pub current_temporal_layer: i16,
            }

            impl SvcConsumerDump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    field_rtp_stream: impl ::planus::WriteAs<::planus::Offset<super::rtp_stream::Dump>>,
                    field_preferred_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_target_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_current_spatial_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_preferred_temporal_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_target_temporal_layer: impl ::planus::WriteAsDefault<i16, i16>,
                    field_current_temporal_layer: impl ::planus::WriteAsDefault<i16, i16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_rtp_stream = field_rtp_stream.prepare(builder);

                    let prepared_preferred_spatial_layer =
                        field_preferred_spatial_layer.prepare(builder, &0);

                    let prepared_target_spatial_layer =
                        field_target_spatial_layer.prepare(builder, &0);

                    let prepared_current_spatial_layer =
                        field_current_spatial_layer.prepare(builder, &0);

                    let prepared_preferred_temporal_layer =
                        field_preferred_temporal_layer.prepare(builder, &0);

                    let prepared_target_temporal_layer =
                        field_target_temporal_layer.prepare(builder, &0);

                    let prepared_current_temporal_layer =
                        field_current_temporal_layer.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 20>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::BaseConsumerDump>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::rtp_stream::Dump>>(4);
                    if prepared_preferred_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(6);
                    }
                    if prepared_target_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(8);
                    }
                    if prepared_current_spatial_layer.is_some() {
                        table_writer.calculate_size::<i16>(10);
                    }
                    if prepared_preferred_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(12);
                    }
                    if prepared_target_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(14);
                    }
                    if prepared_current_temporal_layer.is_some() {
                        table_writer.calculate_size::<i16>(16);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_rtp_stream);
                        if let ::core::option::Option::Some(prepared_preferred_spatial_layer) =
                            prepared_preferred_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(2, &prepared_preferred_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_target_spatial_layer) =
                            prepared_target_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(3, &prepared_target_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_current_spatial_layer) =
                            prepared_current_spatial_layer
                        {
                            table_writer.write::<_, _, 2>(4, &prepared_current_spatial_layer);
                        }
                        if let ::core::option::Option::Some(prepared_preferred_temporal_layer) =
                            prepared_preferred_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(5, &prepared_preferred_temporal_layer);
                        }
                        if let ::core::option::Option::Some(prepared_target_temporal_layer) =
                            prepared_target_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(6, &prepared_target_temporal_layer);
                        }
                        if let ::core::option::Option::Some(prepared_current_temporal_layer) =
                            prepared_current_temporal_layer
                        {
                            table_writer.write::<_, _, 2>(7, &prepared_current_temporal_layer);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SvcConsumerDump>> for SvcConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SvcConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SvcConsumerDump>> for SvcConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SvcConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SvcConsumerDump> for SvcConsumerDump {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SvcConsumerDump> {
                    SvcConsumerDump::create(
                        builder,
                        &self.base,
                        &self.rtp_stream,
                        &self.preferred_spatial_layer,
                        &self.target_spatial_layer,
                        &self.current_spatial_layer,
                        &self.preferred_temporal_layer,
                        &self.target_temporal_layer,
                        &self.current_temporal_layer,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct SvcConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SvcConsumerDumpRef<'a> {
                pub fn base(&self) -> ::planus::Result<self::BaseConsumerDumpRef<'a>> {
                    self.0.access_required(0, "SvcConsumerDump", "base")
                }

                pub fn rtp_stream(&self) -> ::planus::Result<super::rtp_stream::DumpRef<'a>> {
                    self.0.access_required(1, "SvcConsumerDump", "rtp_stream")
                }

                pub fn preferred_spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "SvcConsumerDump", "preferred_spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn target_spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "SvcConsumerDump", "target_spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn current_spatial_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "SvcConsumerDump", "current_spatial_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn preferred_temporal_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "SvcConsumerDump", "preferred_temporal_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn target_temporal_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "SvcConsumerDump", "target_temporal_layer")?
                            .unwrap_or(0),
                    )
                }

                pub fn current_temporal_layer(&self) -> ::planus::Result<i16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "SvcConsumerDump", "current_temporal_layer")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SvcConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SvcConsumerDumpRef");
                    f.field("base", &self.base());
                    f.field("rtp_stream", &self.rtp_stream());
                    f.field("preferred_spatial_layer", &self.preferred_spatial_layer());
                    f.field("target_spatial_layer", &self.target_spatial_layer());
                    f.field("current_spatial_layer", &self.current_spatial_layer());
                    f.field("preferred_temporal_layer", &self.preferred_temporal_layer());
                    f.field("target_temporal_layer", &self.target_temporal_layer());
                    f.field("current_temporal_layer", &self.current_temporal_layer());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SvcConsumerDumpRef<'a>> for SvcConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SvcConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtp_stream: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_stream()?)?,
                        ),
                        preferred_spatial_layer: ::core::convert::TryInto::try_into(
                            value.preferred_spatial_layer()?,
                        )?,
                        target_spatial_layer: ::core::convert::TryInto::try_into(
                            value.target_spatial_layer()?,
                        )?,
                        current_spatial_layer: ::core::convert::TryInto::try_into(
                            value.current_spatial_layer()?,
                        )?,
                        preferred_temporal_layer: ::core::convert::TryInto::try_into(
                            value.preferred_temporal_layer()?,
                        )?,
                        target_temporal_layer: ::core::convert::TryInto::try_into(
                            value.target_temporal_layer()?,
                        )?,
                        current_temporal_layer: ::core::convert::TryInto::try_into(
                            value.current_temporal_layer()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SvcConsumerDumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SvcConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SvcConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SvcConsumerDump>> for SvcConsumerDump {
                type Value = ::planus::Offset<SvcConsumerDump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SvcConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SvcConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SvcConsumerDumpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct PipeConsumerDump {
                pub base: ::planus::alloc::boxed::Box<self::BaseConsumerDump>,
                pub rtp_streams: ::planus::alloc::vec::Vec<super::rtp_stream::Dump>,
            }

            impl PipeConsumerDump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::BaseConsumerDump>>,
                    field_rtp_streams: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_rtp_streams = field_rtp_streams.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::BaseConsumerDump>>(2);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_rtp_streams);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PipeConsumerDump>> for PipeConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeConsumerDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PipeConsumerDump>> for PipeConsumerDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PipeConsumerDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PipeConsumerDump> for PipeConsumerDump {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeConsumerDump> {
                    PipeConsumerDump::create(builder, &self.base, &self.rtp_streams)
                }
            }

            #[derive(Copy, Clone)]
            pub struct PipeConsumerDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PipeConsumerDumpRef<'a> {
                pub fn base(&self) -> ::planus::Result<self::BaseConsumerDumpRef<'a>> {
                    self.0.access_required(0, "PipeConsumerDump", "base")
                }

                pub fn rtp_streams(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::rtp_stream::DumpRef<'a>>>,
                > {
                    self.0.access_required(1, "PipeConsumerDump", "rtp_streams")
                }
            }

            impl<'a> ::core::fmt::Debug for PipeConsumerDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PipeConsumerDumpRef");
                    f.field("base", &self.base());
                    f.field("rtp_streams", &self.rtp_streams());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PipeConsumerDumpRef<'a>> for PipeConsumerDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PipeConsumerDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtp_streams: value.rtp_streams()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PipeConsumerDumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PipeConsumerDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PipeConsumerDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PipeConsumerDump>> for PipeConsumerDump {
                type Value = ::planus::Offset<PipeConsumerDump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PipeConsumerDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PipeConsumerDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PipeConsumerDumpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub stats:
                    ::core::option::Option<::planus::alloc::vec::Vec<super::rtp_stream::Stats>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GetStatsResponse {
                fn default() -> Self {
                    Self {
                        stats: ::core::default::Default::default(),
                    }
                }
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stats: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_stats = field_stats.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_stats.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_stats) = prepared_stats {
                            table_writer.write::<_, _, 4>(0, &prepared_stats);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.stats)
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn stats(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<super::rtp_stream::StatsRef<'a>>>,
                    >,
                > {
                    self.0.access(0, "GetStatsResponse", "stats")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    if let ::core::option::Option::Some(field_stats) = self.stats().transpose() {
                        f.field("stats", &field_stats);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stats: if let ::core::option::Option::Some(stats) = value.stats()? {
                            ::core::option::Option::Some(stats.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct LayersChangeNotification {
                pub layers:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::ConsumerLayers>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for LayersChangeNotification {
                fn default() -> Self {
                    Self {
                        layers: ::core::default::Default::default(),
                    }
                }
            }

            impl LayersChangeNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_layers: impl ::planus::WriteAsOptional<::planus::Offset<self::ConsumerLayers>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_layers = field_layers.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_layers.is_some() {
                        table_writer.calculate_size::<::planus::Offset<self::ConsumerLayers>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_layers) = prepared_layers {
                            table_writer.write::<_, _, 4>(0, &prepared_layers);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<LayersChangeNotification>> for LayersChangeNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<LayersChangeNotification>>
                for LayersChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<LayersChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<LayersChangeNotification> for LayersChangeNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LayersChangeNotification> {
                    LayersChangeNotification::create(builder, &self.layers)
                }
            }

            #[derive(Copy, Clone)]
            pub struct LayersChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> LayersChangeNotificationRef<'a> {
                pub fn layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ConsumerLayersRef<'a>>>
                {
                    self.0.access(0, "LayersChangeNotification", "layers")
                }
            }

            impl<'a> ::core::fmt::Debug for LayersChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("LayersChangeNotificationRef");
                    if let ::core::option::Option::Some(field_layers) = self.layers().transpose() {
                        f.field("layers", &field_layers);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<LayersChangeNotificationRef<'a>> for LayersChangeNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: LayersChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        layers: if let ::core::option::Option::Some(layers) = value.layers()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for LayersChangeNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for LayersChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[LayersChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<LayersChangeNotification>>
                for LayersChangeNotification
            {
                type Value = ::planus::Offset<LayersChangeNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<LayersChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for LayersChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[LayersChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpNotification {
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl RtpNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[u8]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpNotification>> for RtpNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpNotification>> for RtpNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpNotification> for RtpNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpNotification> {
                    RtpNotification::create(builder, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpNotificationRef<'a> {
                pub fn data(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(0, "RtpNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpNotificationRef<'a>> for RtpNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpNotification>> for RtpNotification {
                type Value = ::planus::Offset<RtpNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ScoreNotification {
                pub score: ::planus::alloc::boxed::Box<self::ConsumerScore>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ScoreNotification {
                fn default() -> Self {
                    Self {
                        score: ::core::default::Default::default(),
                    }
                }
            }

            impl ScoreNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_score: impl ::planus::WriteAs<::planus::Offset<self::ConsumerScore>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_score = field_score.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::ConsumerScore>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_score);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScoreNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ScoreNotification> for ScoreNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ScoreNotification::create(builder, &self.score)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ScoreNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScoreNotificationRef<'a> {
                pub fn score(&self) -> ::planus::Result<self::ConsumerScoreRef<'a>> {
                    self.0.access_required(0, "ScoreNotification", "score")
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreNotificationRef");
                    f.field("score", &self.score());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScoreNotificationRef<'a>> for ScoreNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScoreNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        score: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.score()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScoreNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScoreNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Value = ::planus::Offset<ScoreNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ScoreNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScoreNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ScoreNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceType {
                Keyframe = 0,
                Fir = 1,
                Nack = 2,
                Pli = 3,
                Rtp = 4,
            }

            impl ::core::convert::TryFrom<u8> for TraceType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceType::Keyframe),
                        1 => ::core::result::Result::Ok(TraceType::Fir),
                        2 => ::core::result::Result::Ok(TraceType::Nack),
                        3 => ::core::result::Result::Ok(TraceType::Pli),
                        4 => ::core::result::Result::Ok(TraceType::Rtp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceType> for u8 {
                fn from(value: TraceType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceType> for TraceType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceType, TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceType,
                ) -> ::core::option::Option<TraceType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceType {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceType> for TraceType {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceDirection {
                DirectionIn = 0,
                DirectionOut = 1,
            }

            impl ::core::convert::TryFrom<u8> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceDirection::DirectionIn),
                        1 => ::core::result::Result::Ok(TraceDirection::DirectionOut),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceDirection> for u8 {
                fn from(value: TraceDirection) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceDirection {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceDirection> for TraceDirection {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceDirection {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceDirection, TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceDirection,
                ) -> ::core::option::Option<TraceDirection> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceDirection> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceDirection {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceDirection",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceDirection> for TraceDirection {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum TraceInfo {
                KeyFrameTraceInfo(::planus::alloc::boxed::Box<self::KeyFrameTraceInfo>),
                FirTraceInfo(::planus::alloc::boxed::Box<self::FirTraceInfo>),
                PliTraceInfo(::planus::alloc::boxed::Box<self::PliTraceInfo>),
                RtpTraceInfo(::planus::alloc::boxed::Box<self::RtpTraceInfo>),
            }

            impl TraceInfo {
                pub fn create_key_frame_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_fir_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::FirTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_pli_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PliTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_rtp_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RtpTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<TraceInfo> for TraceInfo {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::KeyFrameTraceInfo(value) => {
                            Self::create_key_frame_trace_info(builder, value)
                        }
                        Self::FirTraceInfo(value) => Self::create_fir_trace_info(builder, value),
                        Self::PliTraceInfo(value) => Self::create_pli_trace_info(builder, value),
                        Self::RtpTraceInfo(value) => Self::create_rtp_trace_info(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum TraceInfoRef<'a> {
                KeyFrameTraceInfo(self::KeyFrameTraceInfoRef<'a>),
                FirTraceInfo(self::FirTraceInfoRef<'a>),
                PliTraceInfo(self::PliTraceInfoRef<'a>),
                RtpTraceInfo(self::RtpTraceInfoRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<TraceInfoRef<'a>> for TraceInfo {
                type Error = ::planus::Error;

                fn try_from(value: TraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        TraceInfoRef::KeyFrameTraceInfo(value) => {
                            TraceInfo::KeyFrameTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::FirTraceInfo(value) => {
                            TraceInfo::FirTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::PliTraceInfo(value) => {
                            TraceInfo::PliTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::RtpTraceInfo(value) => {
                            TraceInfo::RtpTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for TraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::KeyFrameTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::FirTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::PliTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::RtpTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct KeyFrameTraceInfo {
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for KeyFrameTraceInfo {
                fn default() -> Self {
                    Self { is_rtx: false }
                }
            }

            impl KeyFrameTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_is_rtx.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                            table_writer.write::<_, _, 1>(0, &prepared_is_rtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<KeyFrameTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<KeyFrameTraceInfo> for KeyFrameTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    KeyFrameTraceInfo::create(builder, &self.is_rtx)
                }
            }

            #[derive(Copy, Clone)]
            pub struct KeyFrameTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> KeyFrameTraceInfoRef<'a> {
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "KeyFrameTraceInfo", "is_rtx")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for KeyFrameTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("KeyFrameTraceInfoRef");
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<KeyFrameTraceInfoRef<'a>> for KeyFrameTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: KeyFrameTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for KeyFrameTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for KeyFrameTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[KeyFrameTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Value = ::planus::Offset<KeyFrameTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<KeyFrameTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for KeyFrameTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[KeyFrameTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct FirTraceInfo {
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for FirTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl FirTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FirTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<FirTraceInfo> for FirTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    FirTraceInfo::create(builder, &self.ssrc)
                }
            }

            #[derive(Copy, Clone)]
            pub struct FirTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FirTraceInfoRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "FirTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for FirTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FirTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FirTraceInfoRef<'a>> for FirTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FirTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FirTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FirTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FirTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Value = ::planus::Offset<FirTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<FirTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FirTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FirTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PliTraceInfo {
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PliTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl PliTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PliTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PliTraceInfo> for PliTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    PliTraceInfo::create(builder, &self.ssrc)
                }
            }

            #[derive(Copy, Clone)]
            pub struct PliTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PliTraceInfoRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "PliTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PliTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PliTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PliTraceInfoRef<'a>> for PliTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PliTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PliTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PliTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PliTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Value = ::planus::Offset<PliTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PliTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PliTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PliTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpTraceInfo {
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpTraceInfo {
                fn default() -> Self {
                    Self { is_rtx: false }
                }
            }

            impl RtpTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_is_rtx.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                            table_writer.write::<_, _, 1>(0, &prepared_is_rtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpTraceInfo> for RtpTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    RtpTraceInfo::create(builder, &self.is_rtx)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpTraceInfoRef<'a> {
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "RtpTraceInfo", "is_rtx")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RtpTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpTraceInfoRef");
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpTraceInfoRef<'a>> for RtpTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Value = ::planus::Offset<RtpTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TraceNotification {
                pub type_: self::TraceType,
                pub timestamp: u64,
                pub direction: self::TraceDirection,
                pub info: ::core::option::Option<self::TraceInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for TraceNotification {
                fn default() -> Self {
                    Self {
                        type_: self::TraceType::Keyframe,
                        timestamp: 0,
                        direction: self::TraceDirection::DirectionIn,
                        info: ::core::default::Default::default(),
                    }
                }
            }

            impl TraceNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<self::TraceType, self::TraceType>,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_direction: impl ::planus::WriteAsDefault<
                        self::TraceDirection,
                        self::TraceDirection,
                    >,
                    field_info: impl ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder, &self::TraceType::Keyframe);

                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_direction =
                        field_direction.prepare(builder, &self::TraceDirection::DirectionIn);

                    let prepared_info = field_info.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 15>::new(builder);

                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<self::TraceType>(2);
                    }
                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }
                    if prepared_direction.is_some() {
                        table_writer.calculate_size::<self::TraceDirection>(6);
                    }
                    if prepared_info.is_some() {
                        table_writer.calculate_size::<u8>(8);
                        table_writer.calculate_size::<::planus::Offset<self::TraceInfo>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(1, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_info) = prepared_info {
                            table_writer.write::<_, _, 4>(4, &prepared_info.offset());
                        }
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(0, &prepared_type_);
                        }
                        if let ::core::option::Option::Some(prepared_direction) = prepared_direction
                        {
                            table_writer.write::<_, _, 1>(2, &prepared_direction);
                        }
                        if let ::core::option::Option::Some(prepared_info) = prepared_info {
                            table_writer.write::<_, _, 1>(3, &prepared_info.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TraceNotification> for TraceNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    TraceNotification::create(
                        builder,
                        &self.type_,
                        &self.timestamp,
                        &self.direction,
                        &self.info,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct TraceNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TraceNotificationRef<'a> {
                pub fn type_(&self) -> ::planus::Result<self::TraceType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TraceNotification", "type_")?
                            .unwrap_or(self::TraceType::Keyframe),
                    )
                }

                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "TraceNotification", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                pub fn direction(&self) -> ::planus::Result<self::TraceDirection> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "TraceNotification", "direction")?
                            .unwrap_or(self::TraceDirection::DirectionIn),
                    )
                }

                pub fn info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TraceInfoRef<'a>>>
                {
                    self.0.access_union(3, "TraceNotification", "info")
                }
            }

            impl<'a> ::core::fmt::Debug for TraceNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TraceNotificationRef");
                    f.field("type_", &self.type_());
                    f.field("timestamp", &self.timestamp());
                    f.field("direction", &self.direction());
                    if let ::core::option::Option::Some(field_info) = self.info().transpose() {
                        f.field("info", &field_info);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TraceNotificationRef<'a>> for TraceNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TraceNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        direction: ::core::convert::TryInto::try_into(value.direction()?)?,
                        info: if let ::core::option::Option::Some(info) = value.info()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(info)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TraceNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TraceNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TraceNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TraceNotification>> for TraceNotification {
                type Value = ::planus::Offset<TraceNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TraceNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TraceNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TraceNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod rtp_parameters {
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum MediaKind {
                All = 0,
                Audio = 1,
                Video = 2,
            }

            impl ::core::convert::TryFrom<u8> for MediaKind {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(MediaKind::All),
                        1 => ::core::result::Result::Ok(MediaKind::Audio),
                        2 => ::core::result::Result::Ok(MediaKind::Video),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<MediaKind> for u8 {
                fn from(value: MediaKind) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for MediaKind {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<MediaKind> for MediaKind {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<MediaKind> for MediaKind {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> MediaKind {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<MediaKind, MediaKind> for MediaKind {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &MediaKind,
                ) -> ::core::option::Option<MediaKind> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<MediaKind> for MediaKind {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<MediaKind> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for MediaKind {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for MediaKind {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "MediaKind",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<MediaKind> for MediaKind {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Type {
                None = 0,
                Simple = 1,
                Simulcast = 2,
                Svc = 3,
                Pipe = 4,
            }

            impl ::core::convert::TryFrom<u8> for Type {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Type::None),
                        1 => ::core::result::Result::Ok(Type::Simple),
                        2 => ::core::result::Result::Ok(Type::Simulcast),
                        3 => ::core::result::Result::Ok(Type::Svc),
                        4 => ::core::result::Result::Ok(Type::Pipe),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Type> for u8 {
                fn from(value: Type) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Type {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Type> for Type {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Type {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Type, Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Type,
                ) -> ::core::option::Option<Type> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Type> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Type {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Type {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Type",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Type> for Type {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Boolean {
                pub value: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Boolean {
                fn default() -> Self {
                    Self { value: 0 }
                }
            }

            impl Boolean {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_value.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 1>(0, &prepared_value);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Boolean>> for Boolean {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Boolean>> for Boolean {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Boolean>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Boolean> for Boolean {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Boolean> {
                    Boolean::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct BooleanRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BooleanRef<'a> {
                pub fn value(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(self.0.access(0, "Boolean", "value")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for BooleanRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BooleanRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BooleanRef<'a>> for Boolean {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BooleanRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BooleanRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BooleanRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BooleanRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Boolean>> for Boolean {
                type Value = ::planus::Offset<Boolean>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Boolean>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BooleanRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BooleanRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Integer {
                pub value: i32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Integer {
                fn default() -> Self {
                    Self { value: 0 }
                }
            }

            impl Integer {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsDefault<i32, i32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_value.is_some() {
                        table_writer.calculate_size::<i32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 4>(0, &prepared_value);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Integer>> for Integer {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Integer>> for Integer {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Integer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Integer> for Integer {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Integer> {
                    Integer::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct IntegerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IntegerRef<'a> {
                pub fn value(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(self.0.access(0, "Integer", "value")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for IntegerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IntegerRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IntegerRef<'a>> for Integer {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IntegerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IntegerRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IntegerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IntegerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Integer>> for Integer {
                type Value = ::planus::Offset<Integer>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Integer>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IntegerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IntegerRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IntegerArray {
                pub value: ::core::option::Option<::planus::alloc::vec::Vec<i32>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for IntegerArray {
                fn default() -> Self {
                    Self {
                        value: ::core::default::Default::default(),
                    }
                }
            }

            impl IntegerArray {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsOptional<::planus::Offset<[i32]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_value.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[i32]>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 4>(0, &prepared_value);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IntegerArray>> for IntegerArray {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IntegerArray> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IntegerArray>> for IntegerArray {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IntegerArray>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IntegerArray> for IntegerArray {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IntegerArray> {
                    IntegerArray::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct IntegerArrayRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IntegerArrayRef<'a> {
                pub fn value(
                    &self,
                ) -> ::planus::Result<::core::option::Option<::planus::Vector<'a, i32>>>
                {
                    self.0.access(0, "IntegerArray", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for IntegerArrayRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IntegerArrayRef");
                    if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                        f.field("value", &field_value);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IntegerArrayRef<'a>> for IntegerArray {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IntegerArrayRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: if let ::core::option::Option::Some(value) = value.value()? {
                            ::core::option::Option::Some(value.to_vec()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IntegerArrayRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IntegerArrayRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IntegerArrayRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IntegerArray>> for IntegerArray {
                type Value = ::planus::Offset<IntegerArray>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IntegerArray>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IntegerArrayRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IntegerArrayRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Double {
                pub value: f64,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Double {
                fn default() -> Self {
                    Self { value: 0.0 }
                }
            }

            impl Double {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsDefault<f64, f64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder, &0.0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 8>::new(builder);

                    if prepared_value.is_some() {
                        table_writer.calculate_size::<f64>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 8>(0, &prepared_value);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Double>> for Double {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Double>> for Double {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Double>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Double> for Double {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Double> {
                    Double::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DoubleRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DoubleRef<'a> {
                pub fn value(&self) -> ::planus::Result<f64> {
                    ::core::result::Result::Ok(self.0.access(0, "Double", "value")?.unwrap_or(0.0))
                }
            }

            impl<'a> ::core::fmt::Debug for DoubleRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DoubleRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DoubleRef<'a>> for Double {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DoubleRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DoubleRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DoubleRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DoubleRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Double>> for Double {
                type Value = ::planus::Offset<Double>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Double>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DoubleRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DoubleRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct String {
                pub value: ::core::option::Option<::planus::alloc::string::String>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for String {
                fn default() -> Self {
                    Self {
                        value: ::core::default::Default::default(),
                    }
                }
            }

            impl String {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_value.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 4>(0, &prepared_value);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String> for String {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    String::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringRef<'a> {
                pub fn value(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringRef");
                    if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                        f.field("value", &field_value);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringRef<'a>> for String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: if let ::core::option::Option::Some(value) = value.value()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(value)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String>> for String {
                type Value = ::planus::Offset<String>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Value {
                Boolean(::planus::alloc::boxed::Box<self::Boolean>),
                Integer(::planus::alloc::boxed::Box<self::Integer>),
                Double(::planus::alloc::boxed::Box<self::Double>),
                String(::planus::alloc::boxed::Box<self::String>),
                IntegerArray(::planus::alloc::boxed::Box<self::IntegerArray>),
            }

            impl Value {
                pub fn create_boolean(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Boolean>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_integer(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Integer>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_double(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Double>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_string(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::String>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                pub fn create_integer_array(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::IntegerArray>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Value> for Value {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::Boolean(value) => Self::create_boolean(builder, value),
                        Self::Integer(value) => Self::create_integer(builder, value),
                        Self::Double(value) => Self::create_double(builder, value),
                        Self::String(value) => Self::create_string(builder, value),
                        Self::IntegerArray(value) => Self::create_integer_array(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Value> for Value {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum ValueRef<'a> {
                Boolean(self::BooleanRef<'a>),
                Integer(self::IntegerRef<'a>),
                Double(self::DoubleRef<'a>),
                String(self::StringRef<'a>),
                IntegerArray(self::IntegerArrayRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<ValueRef<'a>> for Value {
                type Error = ::planus::Error;

                fn try_from(value: ValueRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        ValueRef::Boolean(value) => {
                            Value::Boolean(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        ValueRef::Integer(value) => {
                            Value::Integer(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        ValueRef::Double(value) => Value::Double(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        ValueRef::String(value) => Value::String(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        ValueRef::IntegerArray(value) => {
                            Value::IntegerArray(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for ValueRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::Boolean(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Integer(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::Double(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::String(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::IntegerArray(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Parameter {
                pub name: ::planus::alloc::string::String,
                pub value: ::core::option::Option<self::Value>,
            }

            impl Parameter {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAsOptionalUnion<self::Value>,
                ) -> ::planus::Offset<Self> {
                    let prepared_name = field_name.prepare(builder);

                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 9>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_value.is_some() {
                        table_writer.calculate_size::<u8>(4);
                        table_writer.calculate_size::<::planus::Offset<self::Value>>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_name);
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 4>(2, &prepared_value.offset());
                        }
                        if let ::core::option::Option::Some(prepared_value) = prepared_value {
                            table_writer.write::<_, _, 1>(1, &prepared_value.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Parameter>> for Parameter {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Parameter>> for Parameter {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Parameter>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Parameter> for Parameter {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Parameter> {
                    Parameter::create(builder, &self.name, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ParameterRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ParameterRef<'a> {
                pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Parameter", "name")
                }

                pub fn value(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ValueRef<'a>>> {
                    self.0.access_union(1, "Parameter", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for ParameterRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ParameterRef");
                    f.field("name", &self.name());
                    if let ::core::option::Option::Some(field_value) = self.value().transpose() {
                        f.field("value", &field_value);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ParameterRef<'a>> for Parameter {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ParameterRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        name: ::core::convert::TryInto::try_into(value.name()?)?,
                        value: if let ::core::option::Option::Some(value) = value.value()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(value)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ParameterRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ParameterRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ParameterRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Parameter>> for Parameter {
                type Value = ::planus::Offset<Parameter>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Parameter>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ParameterRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ParameterRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpFeedback {
                pub type_: ::planus::alloc::string::String,
                pub parameter: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl RtcpFeedback {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_parameter: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_parameter = field_parameter.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_parameter.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_type_);
                        if let ::core::option::Option::Some(prepared_parameter) = prepared_parameter
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_parameter);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpFeedback>> for RtcpFeedback {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpFeedback>> for RtcpFeedback {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpFeedback>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpFeedback> for RtcpFeedback {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpFeedback> {
                    RtcpFeedback::create(builder, &self.type_, &self.parameter)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtcpFeedbackRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpFeedbackRef<'a> {
                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "RtcpFeedback", "type_")
                }

                pub fn parameter(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "RtcpFeedback", "parameter")
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpFeedbackRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpFeedbackRef");
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_parameter) =
                        self.parameter().transpose()
                    {
                        f.field("parameter", &field_parameter);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpFeedbackRef<'a>> for RtcpFeedback {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpFeedbackRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        parameter: if let ::core::option::Option::Some(parameter) =
                            value.parameter()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                parameter,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpFeedbackRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpFeedbackRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpFeedbackRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpFeedback>> for RtcpFeedback {
                type Value = ::planus::Offset<RtcpFeedback>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpFeedback>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpFeedbackRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtcpFeedbackRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RtpCodecParameters {
                pub mime_type: ::planus::alloc::string::String,
                pub payload_type: u8,
                pub clock_rate: u32,
                pub channels: ::core::option::Option<u8>,
                pub parameters: ::core::option::Option<::planus::alloc::vec::Vec<self::Parameter>>,
                pub rtcp_feedback:
                    ::core::option::Option<::planus::alloc::vec::Vec<self::RtcpFeedback>>,
            }

            impl RtpCodecParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_clock_rate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_channels: impl ::planus::WriteAsOptional<u8>,
                    field_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                    field_rtcp_feedback: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_mime_type = field_mime_type.prepare(builder);

                    let prepared_payload_type = field_payload_type.prepare(builder, &0);

                    let prepared_clock_rate = field_clock_rate.prepare(builder, &0);

                    let prepared_channels = field_channels.prepare(builder);

                    let prepared_parameters = field_parameters.prepare(builder);

                    let prepared_rtcp_feedback = field_rtcp_feedback.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 18>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }
                    if prepared_clock_rate.is_some() {
                        table_writer.calculate_size::<u32>(6);
                    }
                    if prepared_channels.is_some() {
                        table_writer.calculate_size::<u8>(8);
                    }
                    if prepared_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::Parameter>]>>(10);
                    }
                    if prepared_rtcp_feedback.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::RtcpFeedback>]>>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_mime_type);
                        if let ::core::option::Option::Some(prepared_clock_rate) =
                            prepared_clock_rate
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_clock_rate);
                        }
                        if let ::core::option::Option::Some(prepared_parameters) =
                            prepared_parameters
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp_feedback) =
                            prepared_rtcp_feedback
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_rtcp_feedback);
                        }
                        if let ::core::option::Option::Some(prepared_payload_type) =
                            prepared_payload_type
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_payload_type);
                        }
                        if let ::core::option::Option::Some(prepared_channels) = prepared_channels {
                            table_writer.write::<_, _, 1>(3, &prepared_channels);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpCodecParameters>> for RtpCodecParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpCodecParameters>> for RtpCodecParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpCodecParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpCodecParameters> for RtpCodecParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpCodecParameters> {
                    RtpCodecParameters::create(
                        builder,
                        &self.mime_type,
                        &self.payload_type,
                        &self.clock_rate,
                        &self.channels,
                        &self.parameters,
                        &self.rtcp_feedback,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpCodecParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpCodecParametersRef<'a> {
                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "RtpCodecParameters", "mime_type")
                }

                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "RtpCodecParameters", "payload_type")?
                            .unwrap_or(0),
                    )
                }

                pub fn clock_rate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "RtpCodecParameters", "clock_rate")?
                            .unwrap_or(0),
                    )
                }

                pub fn channels(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(3, "RtpCodecParameters", "channels")
                }

                pub fn parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::ParameterRef<'a>>>,
                    >,
                > {
                    self.0.access(4, "RtpCodecParameters", "parameters")
                }

                pub fn rtcp_feedback(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::RtcpFeedbackRef<'a>>>,
                    >,
                > {
                    self.0.access(5, "RtpCodecParameters", "rtcp_feedback")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpCodecParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpCodecParametersRef");
                    f.field("mime_type", &self.mime_type());
                    f.field("payload_type", &self.payload_type());
                    f.field("clock_rate", &self.clock_rate());
                    if let ::core::option::Option::Some(field_channels) =
                        self.channels().transpose()
                    {
                        f.field("channels", &field_channels);
                    }
                    if let ::core::option::Option::Some(field_parameters) =
                        self.parameters().transpose()
                    {
                        f.field("parameters", &field_parameters);
                    }
                    if let ::core::option::Option::Some(field_rtcp_feedback) =
                        self.rtcp_feedback().transpose()
                    {
                        f.field("rtcp_feedback", &field_rtcp_feedback);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpCodecParametersRef<'a>> for RtpCodecParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpCodecParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        clock_rate: ::core::convert::TryInto::try_into(value.clock_rate()?)?,
                        channels: if let ::core::option::Option::Some(channels) =
                            value.channels()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                channels,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        parameters: if let ::core::option::Option::Some(parameters) =
                            value.parameters()?
                        {
                            ::core::option::Option::Some(parameters.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp_feedback: if let ::core::option::Option::Some(rtcp_feedback) =
                            value.rtcp_feedback()?
                        {
                            ::core::option::Option::Some(rtcp_feedback.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpCodecParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpCodecParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpCodecParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpCodecParameters>> for RtpCodecParameters {
                type Value = ::planus::Offset<RtpCodecParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpCodecParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpCodecParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpCodecParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RtpHeaderExtensionParameters {
                pub uri: ::planus::alloc::string::String,
                pub id: u8,
                pub encrypt: bool,
                pub parameters: ::core::option::Option<::planus::alloc::vec::Vec<self::Parameter>>,
            }

            impl RtpHeaderExtensionParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_uri: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_id: impl ::planus::WriteAsDefault<u8, u8>,
                    field_encrypt: impl ::planus::WriteAsDefault<bool, bool>,
                    field_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Parameter>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_uri = field_uri.prepare(builder);

                    let prepared_id = field_id.prepare(builder, &0);

                    let prepared_encrypt = field_encrypt.prepare(builder, &false);

                    let prepared_parameters = field_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 10>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_id.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }
                    if prepared_encrypt.is_some() {
                        table_writer.calculate_size::<bool>(6);
                    }
                    if prepared_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::Parameter>]>>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_uri);
                        if let ::core::option::Option::Some(prepared_parameters) =
                            prepared_parameters
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            table_writer.write::<_, _, 1>(1, &prepared_id);
                        }
                        if let ::core::option::Option::Some(prepared_encrypt) = prepared_encrypt {
                            table_writer.write::<_, _, 1>(2, &prepared_encrypt);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParameters
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParameters
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpHeaderExtensionParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpHeaderExtensionParameters> for RtpHeaderExtensionParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpHeaderExtensionParameters> {
                    RtpHeaderExtensionParameters::create(
                        builder,
                        &self.uri,
                        &self.id,
                        &self.encrypt,
                        &self.parameters,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpHeaderExtensionParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpHeaderExtensionParametersRef<'a> {
                pub fn uri(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "RtpHeaderExtensionParameters", "uri")
                }

                pub fn id(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "RtpHeaderExtensionParameters", "id")?
                            .unwrap_or(0),
                    )
                }

                pub fn encrypt(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "RtpHeaderExtensionParameters", "encrypt")?
                            .unwrap_or(false),
                    )
                }

                pub fn parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::ParameterRef<'a>>>,
                    >,
                > {
                    self.0
                        .access(3, "RtpHeaderExtensionParameters", "parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpHeaderExtensionParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpHeaderExtensionParametersRef");
                    f.field("uri", &self.uri());
                    f.field("id", &self.id());
                    f.field("encrypt", &self.encrypt());
                    if let ::core::option::Option::Some(field_parameters) =
                        self.parameters().transpose()
                    {
                        f.field("parameters", &field_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpHeaderExtensionParametersRef<'a>>
                for RtpHeaderExtensionParameters
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpHeaderExtensionParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        uri: ::core::convert::TryInto::try_into(value.uri()?)?,
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        encrypt: ::core::convert::TryInto::try_into(value.encrypt()?)?,
                        parameters: if let ::core::option::Option::Some(parameters) =
                            value.parameters()?
                        {
                            ::core::option::Option::Some(parameters.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpHeaderExtensionParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpHeaderExtensionParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpHeaderExtensionParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpHeaderExtensionParameters>>
                for RtpHeaderExtensionParameters
            {
                type Value = ::planus::Offset<RtpHeaderExtensionParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpHeaderExtensionParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpHeaderExtensionParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpHeaderExtensionParametersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Rtx {
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Rtx {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl Rtx {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Rtx>> for Rtx {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Rtx>> for Rtx {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rtx>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Rtx> for Rtx {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rtx> {
                    Rtx::create(builder, &self.ssrc)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtxRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtxRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Rtx", "ssrc")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for RtxRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtxRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtxRef<'a>> for Rtx {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtxRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtxRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtxRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[RtxRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Rtx>> for Rtx {
                type Value = ::planus::Offset<Rtx>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Rtx>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtxRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtxRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpEncodingParameters {
                pub ssrc: ::core::option::Option<u32>,
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                pub codec_payload_type: ::core::option::Option<u8>,
                pub rtx: ::core::option::Option<::planus::alloc::boxed::Box<self::Rtx>>,
                pub dtx: bool,
                pub scalability_mode: ::core::option::Option<::planus::alloc::string::String>,
                pub max_bitrate: ::core::option::Option<u32>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpEncodingParameters {
                fn default() -> Self {
                    Self {
                        ssrc: ::core::default::Default::default(),
                        rid: ::core::default::Default::default(),
                        codec_payload_type: ::core::default::Default::default(),
                        rtx: ::core::default::Default::default(),
                        dtx: false,
                        scalability_mode: ::core::default::Default::default(),
                        max_bitrate: ::core::default::Default::default(),
                    }
                }
            }

            impl RtpEncodingParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_codec_payload_type: impl ::planus::WriteAsOptional<u8>,
                    field_rtx: impl ::planus::WriteAsOptional<::planus::Offset<self::Rtx>>,
                    field_dtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_scalability_mode: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_max_bitrate: impl ::planus::WriteAsOptional<u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder);

                    let prepared_rid = field_rid.prepare(builder);

                    let prepared_codec_payload_type = field_codec_payload_type.prepare(builder);

                    let prepared_rtx = field_rtx.prepare(builder);

                    let prepared_dtx = field_dtx.prepare(builder, &false);

                    let prepared_scalability_mode = field_scalability_mode.prepare(builder);

                    let prepared_max_bitrate = field_max_bitrate.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<16, 22>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_rid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(4);
                    }
                    if prepared_codec_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(6);
                    }
                    if prepared_rtx.is_some() {
                        table_writer.calculate_size::<::planus::Offset<self::Rtx>>(8);
                    }
                    if prepared_dtx.is_some() {
                        table_writer.calculate_size::<bool>(10);
                    }
                    if prepared_scalability_mode.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(12);
                    }
                    if prepared_max_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(14);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                        if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                            table_writer.write::<_, _, 4>(1, &prepared_rid);
                        }
                        if let ::core::option::Option::Some(prepared_rtx) = prepared_rtx {
                            table_writer.write::<_, _, 4>(3, &prepared_rtx);
                        }
                        if let ::core::option::Option::Some(prepared_scalability_mode) =
                            prepared_scalability_mode
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_scalability_mode);
                        }
                        if let ::core::option::Option::Some(prepared_max_bitrate) =
                            prepared_max_bitrate
                        {
                            table_writer.write::<_, _, 4>(6, &prepared_max_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_codec_payload_type) =
                            prepared_codec_payload_type
                        {
                            table_writer.write::<_, _, 1>(2, &prepared_codec_payload_type);
                        }
                        if let ::core::option::Option::Some(prepared_dtx) = prepared_dtx {
                            table_writer.write::<_, _, 1>(4, &prepared_dtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpEncodingParameters>> for RtpEncodingParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpEncodingParameters>> for RtpEncodingParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpEncodingParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpEncodingParameters> for RtpEncodingParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpEncodingParameters> {
                    RtpEncodingParameters::create(
                        builder,
                        &self.ssrc,
                        &self.rid,
                        &self.codec_payload_type,
                        &self.rtx,
                        &self.dtx,
                        &self.scalability_mode,
                        &self.max_bitrate,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpEncodingParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpEncodingParametersRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(0, "RtpEncodingParameters", "ssrc")
                }

                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "RtpEncodingParameters", "rid")
                }

                pub fn codec_payload_type(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0
                        .access(2, "RtpEncodingParameters", "codec_payload_type")
                }

                pub fn rtx(&self) -> ::planus::Result<::core::option::Option<self::RtxRef<'a>>> {
                    self.0.access(3, "RtpEncodingParameters", "rtx")
                }

                pub fn dtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "RtpEncodingParameters", "dtx")?
                            .unwrap_or(false),
                    )
                }

                pub fn scalability_mode(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0
                        .access(5, "RtpEncodingParameters", "scalability_mode")
                }

                pub fn max_bitrate(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(6, "RtpEncodingParameters", "max_bitrate")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpEncodingParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpEncodingParametersRef");
                    if let ::core::option::Option::Some(field_ssrc) = self.ssrc().transpose() {
                        f.field("ssrc", &field_ssrc);
                    }
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_codec_payload_type) =
                        self.codec_payload_type().transpose()
                    {
                        f.field("codec_payload_type", &field_codec_payload_type);
                    }
                    if let ::core::option::Option::Some(field_rtx) = self.rtx().transpose() {
                        f.field("rtx", &field_rtx);
                    }
                    f.field("dtx", &self.dtx());
                    if let ::core::option::Option::Some(field_scalability_mode) =
                        self.scalability_mode().transpose()
                    {
                        f.field("scalability_mode", &field_scalability_mode);
                    }
                    if let ::core::option::Option::Some(field_max_bitrate) =
                        self.max_bitrate().transpose()
                    {
                        f.field("max_bitrate", &field_max_bitrate);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpEncodingParametersRef<'a>> for RtpEncodingParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpEncodingParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: if let ::core::option::Option::Some(ssrc) = value.ssrc()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(ssrc)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        codec_payload_type: if let ::core::option::Option::Some(
                            codec_payload_type,
                        ) = value.codec_payload_type()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                codec_payload_type,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx: if let ::core::option::Option::Some(rtx) = value.rtx()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtx)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        dtx: ::core::convert::TryInto::try_into(value.dtx()?)?,
                        scalability_mode: if let ::core::option::Option::Some(scalability_mode) =
                            value.scalability_mode()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                scalability_mode,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_bitrate: if let ::core::option::Option::Some(max_bitrate) =
                            value.max_bitrate()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_bitrate,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpEncodingParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpEncodingParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpEncodingParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpEncodingParameters>> for RtpEncodingParameters {
                type Value = ::planus::Offset<RtpEncodingParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpEncodingParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpEncodingParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpEncodingParametersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpParameters {
                pub cname: ::core::option::Option<::planus::alloc::string::String>,
                pub reduced_size: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtcpParameters {
                fn default() -> Self {
                    Self {
                        cname: ::core::default::Default::default(),
                        reduced_size: true,
                    }
                }
            }

            impl RtcpParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_cname: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_reduced_size: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_cname = field_cname.prepare(builder);

                    let prepared_reduced_size = field_reduced_size.prepare(builder, &true);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 5>::new(builder);

                    if prepared_cname.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }
                    if prepared_reduced_size.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_cname) = prepared_cname {
                            table_writer.write::<_, _, 4>(0, &prepared_cname);
                        }
                        if let ::core::option::Option::Some(prepared_reduced_size) =
                            prepared_reduced_size
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_reduced_size);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpParameters>> for RtcpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpParameters>> for RtcpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpParameters> for RtcpParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpParameters> {
                    RtcpParameters::create(builder, &self.cname, &self.reduced_size)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtcpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpParametersRef<'a> {
                pub fn cname(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "RtcpParameters", "cname")
                }

                pub fn reduced_size(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "RtcpParameters", "reduced_size")?
                            .unwrap_or(true),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpParametersRef");
                    if let ::core::option::Option::Some(field_cname) = self.cname().transpose() {
                        f.field("cname", &field_cname);
                    }
                    f.field("reduced_size", &self.reduced_size());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpParametersRef<'a>> for RtcpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        cname: if let ::core::option::Option::Some(cname) = value.cname()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(cname)?)
                        } else {
                            ::core::option::Option::None
                        },
                        reduced_size: ::core::convert::TryInto::try_into(value.reduced_size()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpParameters>> for RtcpParameters {
                type Value = ::planus::Offset<RtcpParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtcpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RtpParameters {
                pub mid: ::core::option::Option<::planus::alloc::string::String>,
                pub codecs: ::planus::alloc::vec::Vec<self::RtpCodecParameters>,
                pub header_extensions: ::core::option::Option<
                    ::planus::alloc::vec::Vec<self::RtpHeaderExtensionParameters>,
                >,
                pub encodings:
                    ::core::option::Option<::planus::alloc::vec::Vec<self::RtpEncodingParameters>>,
                pub rtcp: ::core::option::Option<::planus::alloc::boxed::Box<self::RtcpParameters>>,
            }

            impl RtpParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_mid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_codecs: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>,
                    >,
                    field_header_extensions: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtpHeaderExtensionParameters>]>,
                    >,
                    field_encodings: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::RtpEncodingParameters>]>,
                    >,
                    field_rtcp: impl ::planus::WriteAsOptional<::planus::Offset<self::RtcpParameters>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_mid = field_mid.prepare(builder);

                    let prepared_codecs = field_codecs.prepare(builder);

                    let prepared_header_extensions = field_header_extensions.prepare(builder);

                    let prepared_encodings = field_encodings.prepare(builder);

                    let prepared_rtcp = field_rtcp.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 20>::new(builder);

                    if prepared_mid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::RtpCodecParameters>]>>(4);
                    if prepared_header_extensions.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<self::RtpHeaderExtensionParameters>],
                        >>(6);
                    }
                    if prepared_encodings.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<self::RtpEncodingParameters>],
                        >>(8);
                    }
                    if prepared_rtcp.is_some() {
                        table_writer.calculate_size::<::planus::Offset<self::RtcpParameters>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_mid) = prepared_mid {
                            table_writer.write::<_, _, 4>(0, &prepared_mid);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_codecs);
                        if let ::core::option::Option::Some(prepared_header_extensions) =
                            prepared_header_extensions
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_header_extensions);
                        }
                        if let ::core::option::Option::Some(prepared_encodings) = prepared_encodings
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_encodings);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp) = prepared_rtcp {
                            table_writer.write::<_, _, 4>(4, &prepared_rtcp);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpParameters>> for RtpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpParameters>> for RtpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpParameters> for RtpParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpParameters> {
                    RtpParameters::create(
                        builder,
                        &self.mid,
                        &self.codecs,
                        &self.header_extensions,
                        &self.encodings,
                        &self.rtcp,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpParametersRef<'a> {
                pub fn mid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "RtpParameters", "mid")
                }

                pub fn codecs(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::RtpCodecParametersRef<'a>>>,
                > {
                    self.0.access_required(1, "RtpParameters", "codecs")
                }

                pub fn header_extensions(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<
                            'a,
                            ::planus::Result<self::RtpHeaderExtensionParametersRef<'a>>,
                        >,
                    >,
                > {
                    self.0.access(2, "RtpParameters", "header_extensions")
                }

                pub fn encodings(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::RtpEncodingParametersRef<'a>>>,
                    >,
                > {
                    self.0.access(3, "RtpParameters", "encodings")
                }

                pub fn rtcp(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::RtcpParametersRef<'a>>>
                {
                    self.0.access(4, "RtpParameters", "rtcp")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpParametersRef");
                    if let ::core::option::Option::Some(field_mid) = self.mid().transpose() {
                        f.field("mid", &field_mid);
                    }
                    f.field("codecs", &self.codecs());
                    if let ::core::option::Option::Some(field_header_extensions) =
                        self.header_extensions().transpose()
                    {
                        f.field("header_extensions", &field_header_extensions);
                    }
                    if let ::core::option::Option::Some(field_encodings) =
                        self.encodings().transpose()
                    {
                        f.field("encodings", &field_encodings);
                    }
                    if let ::core::option::Option::Some(field_rtcp) = self.rtcp().transpose() {
                        f.field("rtcp", &field_rtcp);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpParametersRef<'a>> for RtpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        mid: if let ::core::option::Option::Some(mid) = value.mid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(mid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        codecs: value.codecs()?.to_vec_result()?,
                        header_extensions: if let ::core::option::Option::Some(header_extensions) =
                            value.header_extensions()?
                        {
                            ::core::option::Option::Some(header_extensions.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        encodings: if let ::core::option::Option::Some(encodings) =
                            value.encodings()?
                        {
                            ::core::option::Option::Some(encodings.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp: if let ::core::option::Option::Some(rtcp) = value.rtcp()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpParameters>> for RtpParameters {
                type Value = ::planus::Offset<RtpParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CodecMapping {
                pub payload_type: u8,
                pub mapped_payload_type: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for CodecMapping {
                fn default() -> Self {
                    Self {
                        payload_type: 0,
                        mapped_payload_type: 0,
                    }
                }
            }

            impl CodecMapping {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mapped_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_payload_type = field_payload_type.prepare(builder, &0);

                    let prepared_mapped_payload_type =
                        field_mapped_payload_type.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 2>::new(builder);

                    if prepared_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }
                    if prepared_mapped_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_payload_type) =
                            prepared_payload_type
                        {
                            table_writer.write::<_, _, 1>(0, &prepared_payload_type);
                        }
                        if let ::core::option::Option::Some(prepared_mapped_payload_type) =
                            prepared_mapped_payload_type
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_mapped_payload_type);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CodecMapping>> for CodecMapping {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CodecMapping>> for CodecMapping {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CodecMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CodecMapping> for CodecMapping {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CodecMapping> {
                    CodecMapping::create(builder, &self.payload_type, &self.mapped_payload_type)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CodecMappingRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CodecMappingRef<'a> {
                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "CodecMapping", "payload_type")?
                            .unwrap_or(0),
                    )
                }

                pub fn mapped_payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "CodecMapping", "mapped_payload_type")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for CodecMappingRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CodecMappingRef");
                    f.field("payload_type", &self.payload_type());
                    f.field("mapped_payload_type", &self.mapped_payload_type());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CodecMappingRef<'a>> for CodecMapping {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CodecMappingRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        mapped_payload_type: ::core::convert::TryInto::try_into(
                            value.mapped_payload_type()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CodecMappingRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CodecMappingRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CodecMappingRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CodecMapping>> for CodecMapping {
                type Value = ::planus::Offset<CodecMapping>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CodecMapping>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CodecMappingRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[CodecMappingRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EncodingMapping {
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                pub ssrc: ::core::option::Option<u32>,
                pub scalability_mode: ::core::option::Option<::planus::alloc::string::String>,
                pub mapped_ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for EncodingMapping {
                fn default() -> Self {
                    Self {
                        rid: ::core::default::Default::default(),
                        ssrc: ::core::default::Default::default(),
                        scalability_mode: ::core::default::Default::default(),
                        mapped_ssrc: 0,
                    }
                }
            }

            impl EncodingMapping {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_scalability_mode: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_mapped_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rid = field_rid.prepare(builder);

                    let prepared_ssrc = field_ssrc.prepare(builder);

                    let prepared_scalability_mode = field_scalability_mode.prepare(builder);

                    let prepared_mapped_ssrc = field_mapped_ssrc.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 16>::new(builder);

                    if prepared_rid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    if prepared_scalability_mode.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(6);
                    }
                    if prepared_mapped_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                            table_writer.write::<_, _, 4>(0, &prepared_rid);
                        }
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(1, &prepared_ssrc);
                        }
                        if let ::core::option::Option::Some(prepared_scalability_mode) =
                            prepared_scalability_mode
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_scalability_mode);
                        }
                        if let ::core::option::Option::Some(prepared_mapped_ssrc) =
                            prepared_mapped_ssrc
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_mapped_ssrc);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EncodingMapping>> for EncodingMapping {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EncodingMapping>> for EncodingMapping {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EncodingMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EncodingMapping> for EncodingMapping {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EncodingMapping> {
                    EncodingMapping::create(
                        builder,
                        &self.rid,
                        &self.ssrc,
                        &self.scalability_mode,
                        &self.mapped_ssrc,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct EncodingMappingRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EncodingMappingRef<'a> {
                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "EncodingMapping", "rid")
                }

                pub fn ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(1, "EncodingMapping", "ssrc")
                }

                pub fn scalability_mode(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "EncodingMapping", "scalability_mode")
                }

                pub fn mapped_ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "EncodingMapping", "mapped_ssrc")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for EncodingMappingRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EncodingMappingRef");
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_ssrc) = self.ssrc().transpose() {
                        f.field("ssrc", &field_ssrc);
                    }
                    if let ::core::option::Option::Some(field_scalability_mode) =
                        self.scalability_mode().transpose()
                    {
                        f.field("scalability_mode", &field_scalability_mode);
                    }
                    f.field("mapped_ssrc", &self.mapped_ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EncodingMappingRef<'a>> for EncodingMapping {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EncodingMappingRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        ssrc: if let ::core::option::Option::Some(ssrc) = value.ssrc()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(ssrc)?)
                        } else {
                            ::core::option::Option::None
                        },
                        scalability_mode: if let ::core::option::Option::Some(scalability_mode) =
                            value.scalability_mode()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                scalability_mode,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        mapped_ssrc: ::core::convert::TryInto::try_into(value.mapped_ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EncodingMappingRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EncodingMappingRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EncodingMappingRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EncodingMapping>> for EncodingMapping {
                type Value = ::planus::Offset<EncodingMapping>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EncodingMapping>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EncodingMappingRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[EncodingMappingRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpMapping {
                pub codecs: ::planus::alloc::vec::Vec<self::CodecMapping>,
                pub encodings: ::planus::alloc::vec::Vec<self::EncodingMapping>,
            }

            impl RtpMapping {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_codecs: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::CodecMapping>]>,
                    >,
                    field_encodings: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::EncodingMapping>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_codecs = field_codecs.prepare(builder);

                    let prepared_encodings = field_encodings.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer
                        .calculate_size::<::planus::Offset<[::planus::Offset<self::CodecMapping>]>>(
                            2,
                        );
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::EncodingMapping>]>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_codecs);
                        table_writer.write::<_, _, 4>(1, &prepared_encodings);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpMapping>> for RtpMapping {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpMapping>> for RtpMapping {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpMapping>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpMapping> for RtpMapping {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtpMapping> {
                    RtpMapping::create(builder, &self.codecs, &self.encodings)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpMappingRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpMappingRef<'a> {
                pub fn codecs(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::CodecMappingRef<'a>>>,
                > {
                    self.0.access_required(0, "RtpMapping", "codecs")
                }

                pub fn encodings(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::EncodingMappingRef<'a>>>,
                > {
                    self.0.access_required(1, "RtpMapping", "encodings")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpMappingRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpMappingRef");
                    f.field("codecs", &self.codecs());
                    f.field("encodings", &self.encodings());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpMappingRef<'a>> for RtpMapping {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpMappingRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        codecs: value.codecs()?.to_vec_result()?,
                        encodings: value.encodings()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpMappingRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpMappingRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpMappingRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpMapping>> for RtpMapping {
                type Value = ::planus::Offset<RtpMapping>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpMapping>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpMappingRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpMappingRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod rtp_stream {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Params {
                pub encoding_idx: u32,
                pub ssrc: u32,
                pub payload_type: u8,
                pub mime_type: ::planus::alloc::string::String,
                pub clock_rate: u32,
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                pub cname: ::planus::alloc::string::String,
                pub rtx_ssrc: ::core::option::Option<u32>,
                pub rtx_payload_type: ::core::option::Option<u8>,
                pub use_nack: bool,
                pub use_pli: bool,
                pub use_fir: bool,
                pub use_in_band_fec: bool,
                pub use_dtx: bool,
                pub spatial_layers: u8,
                pub temporal_layers: u8,
            }

            impl Params {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_encoding_idx: impl ::planus::WriteAsDefault<u32, u32>,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_clock_rate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_cname: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_rtx_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_rtx_payload_type: impl ::planus::WriteAsOptional<u8>,
                    field_use_nack: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_pli: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_fir: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_in_band_fec: impl ::planus::WriteAsDefault<bool, bool>,
                    field_use_dtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_spatial_layers: impl ::planus::WriteAsDefault<u8, u8>,
                    field_temporal_layers: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_encoding_idx = field_encoding_idx.prepare(builder, &0);

                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let prepared_payload_type = field_payload_type.prepare(builder, &0);

                    let prepared_mime_type = field_mime_type.prepare(builder);

                    let prepared_clock_rate = field_clock_rate.prepare(builder, &0);

                    let prepared_rid = field_rid.prepare(builder);

                    let prepared_cname = field_cname.prepare(builder);

                    let prepared_rtx_ssrc = field_rtx_ssrc.prepare(builder);

                    let prepared_rtx_payload_type = field_rtx_payload_type.prepare(builder);

                    let prepared_use_nack = field_use_nack.prepare(builder, &false);

                    let prepared_use_pli = field_use_pli.prepare(builder, &false);

                    let prepared_use_fir = field_use_fir.prepare(builder, &false);

                    let prepared_use_in_band_fec = field_use_in_band_fec.prepare(builder, &false);

                    let prepared_use_dtx = field_use_dtx.prepare(builder, &false);

                    let prepared_spatial_layers = field_spatial_layers.prepare(builder, &0);

                    let prepared_temporal_layers = field_temporal_layers.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<34, 37>::new(builder);

                    if prepared_encoding_idx.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    if prepared_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(6);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(8);
                    if prepared_clock_rate.is_some() {
                        table_writer.calculate_size::<u32>(10);
                    }
                    if prepared_rid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(12);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(14);
                    if prepared_rtx_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(16);
                    }
                    if prepared_rtx_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(18);
                    }
                    if prepared_use_nack.is_some() {
                        table_writer.calculate_size::<bool>(20);
                    }
                    if prepared_use_pli.is_some() {
                        table_writer.calculate_size::<bool>(22);
                    }
                    if prepared_use_fir.is_some() {
                        table_writer.calculate_size::<bool>(24);
                    }
                    if prepared_use_in_band_fec.is_some() {
                        table_writer.calculate_size::<bool>(26);
                    }
                    if prepared_use_dtx.is_some() {
                        table_writer.calculate_size::<bool>(28);
                    }
                    if prepared_spatial_layers.is_some() {
                        table_writer.calculate_size::<u8>(30);
                    }
                    if prepared_temporal_layers.is_some() {
                        table_writer.calculate_size::<u8>(32);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_encoding_idx) =
                            prepared_encoding_idx
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_encoding_idx);
                        }
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(1, &prepared_ssrc);
                        }
                        table_writer.write::<_, _, 4>(3, &prepared_mime_type);
                        if let ::core::option::Option::Some(prepared_clock_rate) =
                            prepared_clock_rate
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_clock_rate);
                        }
                        if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                            table_writer.write::<_, _, 4>(5, &prepared_rid);
                        }
                        table_writer.write::<_, _, 4>(6, &prepared_cname);
                        if let ::core::option::Option::Some(prepared_rtx_ssrc) = prepared_rtx_ssrc {
                            table_writer.write::<_, _, 4>(7, &prepared_rtx_ssrc);
                        }
                        if let ::core::option::Option::Some(prepared_payload_type) =
                            prepared_payload_type
                        {
                            table_writer.write::<_, _, 1>(2, &prepared_payload_type);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_payload_type) =
                            prepared_rtx_payload_type
                        {
                            table_writer.write::<_, _, 1>(8, &prepared_rtx_payload_type);
                        }
                        if let ::core::option::Option::Some(prepared_use_nack) = prepared_use_nack {
                            table_writer.write::<_, _, 1>(9, &prepared_use_nack);
                        }
                        if let ::core::option::Option::Some(prepared_use_pli) = prepared_use_pli {
                            table_writer.write::<_, _, 1>(10, &prepared_use_pli);
                        }
                        if let ::core::option::Option::Some(prepared_use_fir) = prepared_use_fir {
                            table_writer.write::<_, _, 1>(11, &prepared_use_fir);
                        }
                        if let ::core::option::Option::Some(prepared_use_in_band_fec) =
                            prepared_use_in_band_fec
                        {
                            table_writer.write::<_, _, 1>(12, &prepared_use_in_band_fec);
                        }
                        if let ::core::option::Option::Some(prepared_use_dtx) = prepared_use_dtx {
                            table_writer.write::<_, _, 1>(13, &prepared_use_dtx);
                        }
                        if let ::core::option::Option::Some(prepared_spatial_layers) =
                            prepared_spatial_layers
                        {
                            table_writer.write::<_, _, 1>(14, &prepared_spatial_layers);
                        }
                        if let ::core::option::Option::Some(prepared_temporal_layers) =
                            prepared_temporal_layers
                        {
                            table_writer.write::<_, _, 1>(15, &prepared_temporal_layers);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Params>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Params> for Params {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    Params::create(
                        builder,
                        &self.encoding_idx,
                        &self.ssrc,
                        &self.payload_type,
                        &self.mime_type,
                        &self.clock_rate,
                        &self.rid,
                        &self.cname,
                        &self.rtx_ssrc,
                        &self.rtx_payload_type,
                        &self.use_nack,
                        &self.use_pli,
                        &self.use_fir,
                        &self.use_in_band_fec,
                        &self.use_dtx,
                        &self.spatial_layers,
                        &self.temporal_layers,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ParamsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ParamsRef<'a> {
                pub fn encoding_idx(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Params", "encoding_idx")?.unwrap_or(0),
                    )
                }

                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(1, "Params", "ssrc")?.unwrap_or(0))
                }

                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "Params", "payload_type")?.unwrap_or(0),
                    )
                }

                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "Params", "mime_type")
                }

                pub fn clock_rate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "Params", "clock_rate")?.unwrap_or(0),
                    )
                }

                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "Params", "rid")
                }

                pub fn cname(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(6, "Params", "cname")
                }

                pub fn rtx_ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(7, "Params", "rtx_ssrc")
                }

                pub fn rtx_payload_type(&self) -> ::planus::Result<::core::option::Option<u8>> {
                    self.0.access(8, "Params", "rtx_payload_type")
                }

                pub fn use_nack(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "Params", "use_nack")?.unwrap_or(false),
                    )
                }

                pub fn use_pli(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(10, "Params", "use_pli")?.unwrap_or(false),
                    )
                }

                pub fn use_fir(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(11, "Params", "use_fir")?.unwrap_or(false),
                    )
                }

                pub fn use_in_band_fec(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "Params", "use_in_band_fec")?
                            .unwrap_or(false),
                    )
                }

                pub fn use_dtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "Params", "use_dtx")?.unwrap_or(false),
                    )
                }

                pub fn spatial_layers(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(14, "Params", "spatial_layers")?.unwrap_or(0),
                    )
                }

                pub fn temporal_layers(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(15, "Params", "temporal_layers")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ParamsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ParamsRef");
                    f.field("encoding_idx", &self.encoding_idx());
                    f.field("ssrc", &self.ssrc());
                    f.field("payload_type", &self.payload_type());
                    f.field("mime_type", &self.mime_type());
                    f.field("clock_rate", &self.clock_rate());
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    f.field("cname", &self.cname());
                    if let ::core::option::Option::Some(field_rtx_ssrc) =
                        self.rtx_ssrc().transpose()
                    {
                        f.field("rtx_ssrc", &field_rtx_ssrc);
                    }
                    if let ::core::option::Option::Some(field_rtx_payload_type) =
                        self.rtx_payload_type().transpose()
                    {
                        f.field("rtx_payload_type", &field_rtx_payload_type);
                    }
                    f.field("use_nack", &self.use_nack());
                    f.field("use_pli", &self.use_pli());
                    f.field("use_fir", &self.use_fir());
                    f.field("use_in_band_fec", &self.use_in_band_fec());
                    f.field("use_dtx", &self.use_dtx());
                    f.field("spatial_layers", &self.spatial_layers());
                    f.field("temporal_layers", &self.temporal_layers());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ParamsRef<'a>> for Params {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ParamsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        encoding_idx: ::core::convert::TryInto::try_into(value.encoding_idx()?)?,
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        clock_rate: ::core::convert::TryInto::try_into(value.clock_rate()?)?,
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        cname: ::core::convert::TryInto::try_into(value.cname()?)?,
                        rtx_ssrc: if let ::core::option::Option::Some(rtx_ssrc) =
                            value.rtx_ssrc()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtx_ssrc,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx_payload_type: if let ::core::option::Option::Some(rtx_payload_type) =
                            value.rtx_payload_type()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtx_payload_type,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        use_nack: ::core::convert::TryInto::try_into(value.use_nack()?)?,
                        use_pli: ::core::convert::TryInto::try_into(value.use_pli()?)?,
                        use_fir: ::core::convert::TryInto::try_into(value.use_fir()?)?,
                        use_in_band_fec: ::core::convert::TryInto::try_into(
                            value.use_in_band_fec()?,
                        )?,
                        use_dtx: ::core::convert::TryInto::try_into(value.use_dtx()?)?,
                        spatial_layers: ::core::convert::TryInto::try_into(
                            value.spatial_layers()?,
                        )?,
                        temporal_layers: ::core::convert::TryInto::try_into(
                            value.temporal_layers()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ParamsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ParamsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ParamsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Params>> for Params {
                type Value = ::planus::Offset<Params>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Params>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ParamsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ParamsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Dump {
                pub params: ::planus::alloc::boxed::Box<self::Params>,
                pub score: u8,
                pub rtx_stream:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::rtx_stream::RtxDump>>,
            }

            impl Dump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_params: impl ::planus::WriteAs<::planus::Offset<self::Params>>,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_rtx_stream: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::rtx_stream::RtxDump>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_params = field_params.prepare(builder);

                    let prepared_score = field_score.prepare(builder, &0);

                    let prepared_rtx_stream = field_rtx_stream.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 9>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::Params>>(2);
                    if prepared_score.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }
                    if prepared_rtx_stream.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::rtx_stream::RtxDump>>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_params);
                        if let ::core::option::Option::Some(prepared_rtx_stream) =
                            prepared_rtx_stream
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_rtx_stream);
                        }
                        if let ::core::option::Option::Some(prepared_score) = prepared_score {
                            table_writer.write::<_, _, 1>(1, &prepared_score);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Dump> for Dump {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    Dump::create(builder, &self.params, &self.score, &self.rtx_stream)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpRef<'a> {
                pub fn params(&self) -> ::planus::Result<self::ParamsRef<'a>> {
                    self.0.access_required(0, "Dump", "params")
                }

                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(self.0.access(1, "Dump", "score")?.unwrap_or(0))
                }

                pub fn rtx_stream(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::rtx_stream::RtxDumpRef<'a>>>
                {
                    self.0.access(2, "Dump", "rtx_stream")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpRef");
                    f.field("params", &self.params());
                    f.field("score", &self.score());
                    if let ::core::option::Option::Some(field_rtx_stream) =
                        self.rtx_stream().transpose()
                    {
                        f.field("rtx_stream", &field_rtx_stream);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpRef<'a>> for Dump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        params: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.params()?)?,
                        ),
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                        rtx_stream: if let ::core::option::Option::Some(rtx_stream) =
                            value.rtx_stream()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtx_stream)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Dump>> for Dump {
                type Value = ::planus::Offset<Dump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Dump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BitrateByLayer {
                pub layer: ::planus::alloc::string::String,
                pub bitrate: u64,
            }

            impl BitrateByLayer {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_layer: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_layer = field_layer.prepare(builder);

                    let prepared_bitrate = field_bitrate.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 12>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_bitrate) = prepared_bitrate {
                            table_writer.write::<_, _, 8>(1, &prepared_bitrate);
                        }
                        table_writer.write::<_, _, 4>(0, &prepared_layer);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BitrateByLayer>> for BitrateByLayer {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BitrateByLayer>> for BitrateByLayer {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BitrateByLayer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BitrateByLayer> for BitrateByLayer {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BitrateByLayer> {
                    BitrateByLayer::create(builder, &self.layer, &self.bitrate)
                }
            }

            #[derive(Copy, Clone)]
            pub struct BitrateByLayerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BitrateByLayerRef<'a> {
                pub fn layer(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "BitrateByLayer", "layer")
                }

                pub fn bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "BitrateByLayer", "bitrate")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BitrateByLayerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BitrateByLayerRef");
                    f.field("layer", &self.layer());
                    f.field("bitrate", &self.bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BitrateByLayerRef<'a>> for BitrateByLayer {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BitrateByLayerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        layer: ::core::convert::TryInto::try_into(value.layer()?)?,
                        bitrate: ::core::convert::TryInto::try_into(value.bitrate()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BitrateByLayerRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BitrateByLayerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BitrateByLayerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BitrateByLayer>> for BitrateByLayer {
                type Value = ::planus::Offset<BitrateByLayer>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BitrateByLayer>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BitrateByLayerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BitrateByLayerRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum StatsData {
                BaseStats(::planus::alloc::boxed::Box<self::BaseStats>),
                RecvStats(::planus::alloc::boxed::Box<self::RecvStats>),
                SendStats(::planus::alloc::boxed::Box<self::SendStats>),
            }

            impl StatsData {
                pub fn create_base_stats(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::BaseStats>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_recv_stats(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RecvStats>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_send_stats(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::SendStats>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<StatsData> for StatsData {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::BaseStats(value) => Self::create_base_stats(builder, value),
                        Self::RecvStats(value) => Self::create_recv_stats(builder, value),
                        Self::SendStats(value) => Self::create_send_stats(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<StatsData> for StatsData {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum StatsDataRef<'a> {
                BaseStats(self::BaseStatsRef<'a>),
                RecvStats(self::RecvStatsRef<'a>),
                SendStats(self::SendStatsRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<StatsDataRef<'a>> for StatsData {
                type Error = ::planus::Error;

                fn try_from(value: StatsDataRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        StatsDataRef::BaseStats(value) => {
                            StatsData::BaseStats(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        StatsDataRef::RecvStats(value) => {
                            StatsData::RecvStats(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        StatsDataRef::SendStats(value) => {
                            StatsData::SendStats(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for StatsDataRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::BaseStats(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::RecvStats(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::SendStats(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Stats {
                pub data: ::core::option::Option<self::StatsData>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Stats {
                fn default() -> Self {
                    Self {
                        data: ::core::default::Default::default(),
                    }
                }
            }

            impl Stats {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAsOptionalUnion<self::StatsData>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 5>::new(builder);

                    if prepared_data.is_some() {
                        table_writer.calculate_size::<u8>(2);
                        table_writer.calculate_size::<::planus::Offset<self::StatsData>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_data) = prepared_data {
                            table_writer.write::<_, _, 4>(1, &prepared_data.offset());
                        }
                        if let ::core::option::Option::Some(prepared_data) = prepared_data {
                            table_writer.write::<_, _, 1>(0, &prepared_data.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Stats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Stats> for Stats {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    Stats::create(builder, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StatsRef<'a> {
                pub fn data(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::StatsDataRef<'a>>>
                {
                    self.0.access_union(0, "Stats", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for StatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StatsRef");
                    if let ::core::option::Option::Some(field_data) = self.data().transpose() {
                        f.field("data", &field_data);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StatsRef<'a>> for Stats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: if let ::core::option::Option::Some(data) = value.data()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(data)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StatsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Stats>> for Stats {
                type Value = ::planus::Offset<Stats>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Stats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StatsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BaseStats {
                pub timestamp: u64,
                pub ssrc: u32,
                pub kind: super::rtp_parameters::MediaKind,
                pub mime_type: ::planus::alloc::string::String,
                pub packets_lost: u64,
                pub fraction_lost: u64,
                pub packets_discarded: u64,
                pub packets_retransmitted: u64,
                pub packets_repaired: u64,
                pub nack_count: u64,
                pub nack_packet_count: u64,
                pub pli_count: u64,
                pub fir_count: u64,
                pub score: u8,
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                pub rtx_ssrc: ::core::option::Option<u32>,
                pub rtx_packets_discarded: u64,
                pub round_trip_time: f32,
            }

            impl BaseStats {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_packets_lost: impl ::planus::WriteAsDefault<u64, u64>,
                    field_fraction_lost: impl ::planus::WriteAsDefault<u64, u64>,
                    field_packets_discarded: impl ::planus::WriteAsDefault<u64, u64>,
                    field_packets_retransmitted: impl ::planus::WriteAsDefault<u64, u64>,
                    field_packets_repaired: impl ::planus::WriteAsDefault<u64, u64>,
                    field_nack_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_nack_packet_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_pli_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_fir_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_rtx_ssrc: impl ::planus::WriteAsOptional<u32>,
                    field_rtx_packets_discarded: impl ::planus::WriteAsDefault<u64, u64>,
                    field_round_trip_time: impl ::planus::WriteAsDefault<f32, f32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::All);

                    let prepared_mime_type = field_mime_type.prepare(builder);

                    let prepared_packets_lost = field_packets_lost.prepare(builder, &0);

                    let prepared_fraction_lost = field_fraction_lost.prepare(builder, &0);

                    let prepared_packets_discarded = field_packets_discarded.prepare(builder, &0);

                    let prepared_packets_retransmitted =
                        field_packets_retransmitted.prepare(builder, &0);

                    let prepared_packets_repaired = field_packets_repaired.prepare(builder, &0);

                    let prepared_nack_count = field_nack_count.prepare(builder, &0);

                    let prepared_nack_packet_count = field_nack_packet_count.prepare(builder, &0);

                    let prepared_pli_count = field_pli_count.prepare(builder, &0);

                    let prepared_fir_count = field_fir_count.prepare(builder, &0);

                    let prepared_score = field_score.prepare(builder, &0);

                    let prepared_rid = field_rid.prepare(builder);

                    let prepared_rtx_ssrc = field_rtx_ssrc.prepare(builder);

                    let prepared_rtx_packets_discarded =
                        field_rtx_packets_discarded.prepare(builder, &0);

                    let prepared_round_trip_time = field_round_trip_time.prepare(builder, &0.0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<38, 110>::new(builder);

                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(2);
                    }
                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    if prepared_kind.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::MediaKind>(6);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(8);
                    if prepared_packets_lost.is_some() {
                        table_writer.calculate_size::<u64>(10);
                    }
                    if prepared_fraction_lost.is_some() {
                        table_writer.calculate_size::<u64>(12);
                    }
                    if prepared_packets_discarded.is_some() {
                        table_writer.calculate_size::<u64>(14);
                    }
                    if prepared_packets_retransmitted.is_some() {
                        table_writer.calculate_size::<u64>(16);
                    }
                    if prepared_packets_repaired.is_some() {
                        table_writer.calculate_size::<u64>(18);
                    }
                    if prepared_nack_count.is_some() {
                        table_writer.calculate_size::<u64>(20);
                    }
                    if prepared_nack_packet_count.is_some() {
                        table_writer.calculate_size::<u64>(22);
                    }
                    if prepared_pli_count.is_some() {
                        table_writer.calculate_size::<u64>(24);
                    }
                    if prepared_fir_count.is_some() {
                        table_writer.calculate_size::<u64>(26);
                    }
                    if prepared_score.is_some() {
                        table_writer.calculate_size::<u8>(28);
                    }
                    if prepared_rid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(30);
                    }
                    if prepared_rtx_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(32);
                    }
                    if prepared_rtx_packets_discarded.is_some() {
                        table_writer.calculate_size::<u64>(34);
                    }
                    if prepared_round_trip_time.is_some() {
                        table_writer.calculate_size::<f32>(36);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(0, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_packets_lost) =
                            prepared_packets_lost
                        {
                            table_writer.write::<_, _, 8>(4, &prepared_packets_lost);
                        }
                        if let ::core::option::Option::Some(prepared_fraction_lost) =
                            prepared_fraction_lost
                        {
                            table_writer.write::<_, _, 8>(5, &prepared_fraction_lost);
                        }
                        if let ::core::option::Option::Some(prepared_packets_discarded) =
                            prepared_packets_discarded
                        {
                            table_writer.write::<_, _, 8>(6, &prepared_packets_discarded);
                        }
                        if let ::core::option::Option::Some(prepared_packets_retransmitted) =
                            prepared_packets_retransmitted
                        {
                            table_writer.write::<_, _, 8>(7, &prepared_packets_retransmitted);
                        }
                        if let ::core::option::Option::Some(prepared_packets_repaired) =
                            prepared_packets_repaired
                        {
                            table_writer.write::<_, _, 8>(8, &prepared_packets_repaired);
                        }
                        if let ::core::option::Option::Some(prepared_nack_count) =
                            prepared_nack_count
                        {
                            table_writer.write::<_, _, 8>(9, &prepared_nack_count);
                        }
                        if let ::core::option::Option::Some(prepared_nack_packet_count) =
                            prepared_nack_packet_count
                        {
                            table_writer.write::<_, _, 8>(10, &prepared_nack_packet_count);
                        }
                        if let ::core::option::Option::Some(prepared_pli_count) = prepared_pli_count
                        {
                            table_writer.write::<_, _, 8>(11, &prepared_pli_count);
                        }
                        if let ::core::option::Option::Some(prepared_fir_count) = prepared_fir_count
                        {
                            table_writer.write::<_, _, 8>(12, &prepared_fir_count);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_packets_discarded) =
                            prepared_rtx_packets_discarded
                        {
                            table_writer.write::<_, _, 8>(16, &prepared_rtx_packets_discarded);
                        }
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(1, &prepared_ssrc);
                        }
                        table_writer.write::<_, _, 4>(3, &prepared_mime_type);
                        if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                            table_writer.write::<_, _, 4>(14, &prepared_rid);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_ssrc) = prepared_rtx_ssrc {
                            table_writer.write::<_, _, 4>(15, &prepared_rtx_ssrc);
                        }
                        if let ::core::option::Option::Some(prepared_round_trip_time) =
                            prepared_round_trip_time
                        {
                            table_writer.write::<_, _, 4>(17, &prepared_round_trip_time);
                        }
                        if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                            table_writer.write::<_, _, 1>(2, &prepared_kind);
                        }
                        if let ::core::option::Option::Some(prepared_score) = prepared_score {
                            table_writer.write::<_, _, 1>(13, &prepared_score);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BaseStats>> for BaseStats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BaseStats>> for BaseStats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BaseStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BaseStats> for BaseStats {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BaseStats> {
                    BaseStats::create(
                        builder,
                        &self.timestamp,
                        &self.ssrc,
                        &self.kind,
                        &self.mime_type,
                        &self.packets_lost,
                        &self.fraction_lost,
                        &self.packets_discarded,
                        &self.packets_retransmitted,
                        &self.packets_repaired,
                        &self.nack_count,
                        &self.nack_packet_count,
                        &self.pli_count,
                        &self.fir_count,
                        &self.score,
                        &self.rid,
                        &self.rtx_ssrc,
                        &self.rtx_packets_discarded,
                        &self.round_trip_time,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct BaseStatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BaseStatsRef<'a> {
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "BaseStats", "timestamp")?.unwrap_or(0),
                    )
                }

                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(1, "BaseStats", "ssrc")?.unwrap_or(0))
                }

                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "BaseStats", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::All),
                    )
                }

                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "BaseStats", "mime_type")
                }

                pub fn packets_lost(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "BaseStats", "packets_lost")?.unwrap_or(0),
                    )
                }

                pub fn fraction_lost(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "BaseStats", "fraction_lost")?.unwrap_or(0),
                    )
                }

                pub fn packets_discarded(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "BaseStats", "packets_discarded")?
                            .unwrap_or(0),
                    )
                }

                pub fn packets_retransmitted(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "BaseStats", "packets_retransmitted")?
                            .unwrap_or(0),
                    )
                }

                pub fn packets_repaired(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "BaseStats", "packets_repaired")?
                            .unwrap_or(0),
                    )
                }

                pub fn nack_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "BaseStats", "nack_count")?.unwrap_or(0),
                    )
                }

                pub fn nack_packet_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "BaseStats", "nack_packet_count")?
                            .unwrap_or(0),
                    )
                }

                pub fn pli_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(11, "BaseStats", "pli_count")?.unwrap_or(0),
                    )
                }

                pub fn fir_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(12, "BaseStats", "fir_count")?.unwrap_or(0),
                    )
                }

                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "BaseStats", "score")?.unwrap_or(0),
                    )
                }

                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(14, "BaseStats", "rid")
                }

                pub fn rtx_ssrc(&self) -> ::planus::Result<::core::option::Option<u32>> {
                    self.0.access(15, "BaseStats", "rtx_ssrc")
                }

                pub fn rtx_packets_discarded(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(16, "BaseStats", "rtx_packets_discarded")?
                            .unwrap_or(0),
                    )
                }

                pub fn round_trip_time(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(17, "BaseStats", "round_trip_time")?
                            .unwrap_or(0.0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BaseStatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BaseStatsRef");
                    f.field("timestamp", &self.timestamp());
                    f.field("ssrc", &self.ssrc());
                    f.field("kind", &self.kind());
                    f.field("mime_type", &self.mime_type());
                    f.field("packets_lost", &self.packets_lost());
                    f.field("fraction_lost", &self.fraction_lost());
                    f.field("packets_discarded", &self.packets_discarded());
                    f.field("packets_retransmitted", &self.packets_retransmitted());
                    f.field("packets_repaired", &self.packets_repaired());
                    f.field("nack_count", &self.nack_count());
                    f.field("nack_packet_count", &self.nack_packet_count());
                    f.field("pli_count", &self.pli_count());
                    f.field("fir_count", &self.fir_count());
                    f.field("score", &self.score());
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    if let ::core::option::Option::Some(field_rtx_ssrc) =
                        self.rtx_ssrc().transpose()
                    {
                        f.field("rtx_ssrc", &field_rtx_ssrc);
                    }
                    f.field("rtx_packets_discarded", &self.rtx_packets_discarded());
                    f.field("round_trip_time", &self.round_trip_time());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BaseStatsRef<'a>> for BaseStats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BaseStatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        packets_lost: ::core::convert::TryInto::try_into(value.packets_lost()?)?,
                        fraction_lost: ::core::convert::TryInto::try_into(value.fraction_lost()?)?,
                        packets_discarded: ::core::convert::TryInto::try_into(
                            value.packets_discarded()?,
                        )?,
                        packets_retransmitted: ::core::convert::TryInto::try_into(
                            value.packets_retransmitted()?,
                        )?,
                        packets_repaired: ::core::convert::TryInto::try_into(
                            value.packets_repaired()?,
                        )?,
                        nack_count: ::core::convert::TryInto::try_into(value.nack_count()?)?,
                        nack_packet_count: ::core::convert::TryInto::try_into(
                            value.nack_packet_count()?,
                        )?,
                        pli_count: ::core::convert::TryInto::try_into(value.pli_count()?)?,
                        fir_count: ::core::convert::TryInto::try_into(value.fir_count()?)?,
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx_ssrc: if let ::core::option::Option::Some(rtx_ssrc) =
                            value.rtx_ssrc()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtx_ssrc,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtx_packets_discarded: ::core::convert::TryInto::try_into(
                            value.rtx_packets_discarded()?,
                        )?,
                        round_trip_time: ::core::convert::TryInto::try_into(
                            value.round_trip_time()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BaseStatsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BaseStatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BaseStatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BaseStats>> for BaseStats {
                type Value = ::planus::Offset<BaseStats>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BaseStats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BaseStatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BaseStatsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RecvStats {
                pub base: ::planus::alloc::boxed::Box<self::Stats>,
                pub jitter: u32,
                pub packet_count: u64,
                pub byte_count: u64,
                pub bitrate: u64,
                pub bitrate_by_layer:
                    ::core::option::Option<::planus::alloc::vec::Vec<self::BitrateByLayer>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RecvStats {
                fn default() -> Self {
                    Self {
                        base: ::core::default::Default::default(),
                        jitter: 0,
                        packet_count: 0,
                        byte_count: 0,
                        bitrate: 0,
                        bitrate_by_layer: ::core::default::Default::default(),
                    }
                }
            }

            impl RecvStats {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    field_jitter: impl ::planus::WriteAsDefault<u32, u32>,
                    field_packet_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_byte_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bitrate_by_layer: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_jitter = field_jitter.prepare(builder, &0);

                    let prepared_packet_count = field_packet_count.prepare(builder, &0);

                    let prepared_byte_count = field_byte_count.prepare(builder, &0);

                    let prepared_bitrate = field_bitrate.prepare(builder, &0);

                    let prepared_bitrate_by_layer = field_bitrate_by_layer.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 36>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::Stats>>(2);
                    if prepared_jitter.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    if prepared_packet_count.is_some() {
                        table_writer.calculate_size::<u64>(6);
                    }
                    if prepared_byte_count.is_some() {
                        table_writer.calculate_size::<u64>(8);
                    }
                    if prepared_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(10);
                    }
                    if prepared_bitrate_by_layer.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::BitrateByLayer>]>>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_packet_count) =
                            prepared_packet_count
                        {
                            table_writer.write::<_, _, 8>(2, &prepared_packet_count);
                        }
                        if let ::core::option::Option::Some(prepared_byte_count) =
                            prepared_byte_count
                        {
                            table_writer.write::<_, _, 8>(3, &prepared_byte_count);
                        }
                        if let ::core::option::Option::Some(prepared_bitrate) = prepared_bitrate {
                            table_writer.write::<_, _, 8>(4, &prepared_bitrate);
                        }
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        if let ::core::option::Option::Some(prepared_jitter) = prepared_jitter {
                            table_writer.write::<_, _, 4>(1, &prepared_jitter);
                        }
                        if let ::core::option::Option::Some(prepared_bitrate_by_layer) =
                            prepared_bitrate_by_layer
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_bitrate_by_layer);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RecvStats>> for RecvStats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RecvStats>> for RecvStats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RecvStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RecvStats> for RecvStats {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RecvStats> {
                    RecvStats::create(
                        builder,
                        &self.base,
                        &self.jitter,
                        &self.packet_count,
                        &self.byte_count,
                        &self.bitrate,
                        &self.bitrate_by_layer,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RecvStatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RecvStatsRef<'a> {
                pub fn base(&self) -> ::planus::Result<self::StatsRef<'a>> {
                    self.0.access_required(0, "RecvStats", "base")
                }

                pub fn jitter(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "RecvStats", "jitter")?.unwrap_or(0),
                    )
                }

                pub fn packet_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "RecvStats", "packet_count")?.unwrap_or(0),
                    )
                }

                pub fn byte_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "RecvStats", "byte_count")?.unwrap_or(0),
                    )
                }

                pub fn bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "RecvStats", "bitrate")?.unwrap_or(0),
                    )
                }

                pub fn bitrate_by_layer(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::BitrateByLayerRef<'a>>>,
                    >,
                > {
                    self.0.access(5, "RecvStats", "bitrate_by_layer")
                }
            }

            impl<'a> ::core::fmt::Debug for RecvStatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RecvStatsRef");
                    f.field("base", &self.base());
                    f.field("jitter", &self.jitter());
                    f.field("packet_count", &self.packet_count());
                    f.field("byte_count", &self.byte_count());
                    f.field("bitrate", &self.bitrate());
                    if let ::core::option::Option::Some(field_bitrate_by_layer) =
                        self.bitrate_by_layer().transpose()
                    {
                        f.field("bitrate_by_layer", &field_bitrate_by_layer);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RecvStatsRef<'a>> for RecvStats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RecvStatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        jitter: ::core::convert::TryInto::try_into(value.jitter()?)?,
                        packet_count: ::core::convert::TryInto::try_into(value.packet_count()?)?,
                        byte_count: ::core::convert::TryInto::try_into(value.byte_count()?)?,
                        bitrate: ::core::convert::TryInto::try_into(value.bitrate()?)?,
                        bitrate_by_layer: if let ::core::option::Option::Some(bitrate_by_layer) =
                            value.bitrate_by_layer()?
                        {
                            ::core::option::Option::Some(bitrate_by_layer.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RecvStatsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RecvStatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RecvStatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RecvStats>> for RecvStats {
                type Value = ::planus::Offset<RecvStats>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RecvStats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RecvStatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RecvStatsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct SendStats {
                pub base: ::planus::alloc::boxed::Box<self::Stats>,
                pub packet_count: u64,
                pub byte_count: u64,
                pub bitrate: u64,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SendStats {
                fn default() -> Self {
                    Self {
                        base: ::core::default::Default::default(),
                        packet_count: 0,
                        byte_count: 0,
                        bitrate: 0,
                    }
                }
            }

            impl SendStats {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<self::Stats>>,
                    field_packet_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_byte_count: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_packet_count = field_packet_count.prepare(builder, &0);

                    let prepared_byte_count = field_byte_count.prepare(builder, &0);

                    let prepared_bitrate = field_bitrate.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 28>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::Stats>>(2);
                    if prepared_packet_count.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }
                    if prepared_byte_count.is_some() {
                        table_writer.calculate_size::<u64>(6);
                    }
                    if prepared_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_packet_count) =
                            prepared_packet_count
                        {
                            table_writer.write::<_, _, 8>(1, &prepared_packet_count);
                        }
                        if let ::core::option::Option::Some(prepared_byte_count) =
                            prepared_byte_count
                        {
                            table_writer.write::<_, _, 8>(2, &prepared_byte_count);
                        }
                        if let ::core::option::Option::Some(prepared_bitrate) = prepared_bitrate {
                            table_writer.write::<_, _, 8>(3, &prepared_bitrate);
                        }
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendStats>> for SendStats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendStats>> for SendStats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendStats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendStats> for SendStats {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SendStats> {
                    SendStats::create(
                        builder,
                        &self.base,
                        &self.packet_count,
                        &self.byte_count,
                        &self.bitrate,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct SendStatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendStatsRef<'a> {
                pub fn base(&self) -> ::planus::Result<self::StatsRef<'a>> {
                    self.0.access_required(0, "SendStats", "base")
                }

                pub fn packet_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "SendStats", "packet_count")?.unwrap_or(0),
                    )
                }

                pub fn byte_count(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "SendStats", "byte_count")?.unwrap_or(0),
                    )
                }

                pub fn bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "SendStats", "bitrate")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SendStatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendStatsRef");
                    f.field("base", &self.base());
                    f.field("packet_count", &self.packet_count());
                    f.field("byte_count", &self.byte_count());
                    f.field("bitrate", &self.bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendStatsRef<'a>> for SendStats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendStatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        packet_count: ::core::convert::TryInto::try_into(value.packet_count()?)?,
                        byte_count: ::core::convert::TryInto::try_into(value.byte_count()?)?,
                        bitrate: ::core::convert::TryInto::try_into(value.bitrate()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendStatsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendStatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendStatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendStats>> for SendStats {
                type Value = ::planus::Offset<SendStats>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendStats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendStatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendStatsRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod rtx_stream {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Params {
                pub ssrc: u32,
                pub payload_type: u8,
                pub mime_type: ::planus::alloc::string::String,
                pub clock_rate: u32,
                pub rrid: ::core::option::Option<::planus::alloc::string::String>,
                pub cname: ::planus::alloc::string::String,
            }

            impl Params {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_payload_type: impl ::planus::WriteAsDefault<u8, u8>,
                    field_mime_type: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_clock_rate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rrid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_cname: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let prepared_payload_type = field_payload_type.prepare(builder, &0);

                    let prepared_mime_type = field_mime_type.prepare(builder);

                    let prepared_clock_rate = field_clock_rate.prepare(builder, &0);

                    let prepared_rrid = field_rrid.prepare(builder);

                    let prepared_cname = field_cname.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 21>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_payload_type.is_some() {
                        table_writer.calculate_size::<u8>(4);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_clock_rate.is_some() {
                        table_writer.calculate_size::<u32>(8);
                    }
                    if prepared_rrid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(10);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(12);

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                        table_writer.write::<_, _, 4>(2, &prepared_mime_type);
                        if let ::core::option::Option::Some(prepared_clock_rate) =
                            prepared_clock_rate
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_clock_rate);
                        }
                        if let ::core::option::Option::Some(prepared_rrid) = prepared_rrid {
                            table_writer.write::<_, _, 4>(4, &prepared_rrid);
                        }
                        table_writer.write::<_, _, 4>(5, &prepared_cname);
                        if let ::core::option::Option::Some(prepared_payload_type) =
                            prepared_payload_type
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_payload_type);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Params>> for Params {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Params>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Params> for Params {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Params> {
                    Params::create(
                        builder,
                        &self.ssrc,
                        &self.payload_type,
                        &self.mime_type,
                        &self.clock_rate,
                        &self.rrid,
                        &self.cname,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ParamsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ParamsRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Params", "ssrc")?.unwrap_or(0))
                }

                pub fn payload_type(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Params", "payload_type")?.unwrap_or(0),
                    )
                }

                pub fn mime_type(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "Params", "mime_type")
                }

                pub fn clock_rate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Params", "clock_rate")?.unwrap_or(0),
                    )
                }

                pub fn rrid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "Params", "rrid")
                }

                pub fn cname(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(5, "Params", "cname")
                }
            }

            impl<'a> ::core::fmt::Debug for ParamsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ParamsRef");
                    f.field("ssrc", &self.ssrc());
                    f.field("payload_type", &self.payload_type());
                    f.field("mime_type", &self.mime_type());
                    f.field("clock_rate", &self.clock_rate());
                    if let ::core::option::Option::Some(field_rrid) = self.rrid().transpose() {
                        f.field("rrid", &field_rrid);
                    }
                    f.field("cname", &self.cname());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ParamsRef<'a>> for Params {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ParamsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        payload_type: ::core::convert::TryInto::try_into(value.payload_type()?)?,
                        mime_type: ::core::convert::TryInto::try_into(value.mime_type()?)?,
                        clock_rate: ::core::convert::TryInto::try_into(value.clock_rate()?)?,
                        rrid: if let ::core::option::Option::Some(rrid) = value.rrid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rrid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        cname: ::core::convert::TryInto::try_into(value.cname()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ParamsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ParamsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ParamsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Params>> for Params {
                type Value = ::planus::Offset<Params>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Params>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ParamsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ParamsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtxDump {
                pub params: ::planus::alloc::boxed::Box<self::Params>,
            }

            impl RtxDump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_params: impl ::planus::WriteAs<::planus::Offset<self::Params>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_params = field_params.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::Params>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_params);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtxDump>> for RtxDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtxDump>> for RtxDump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtxDump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtxDump> for RtxDump {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RtxDump> {
                    RtxDump::create(builder, &self.params)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtxDumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtxDumpRef<'a> {
                pub fn params(&self) -> ::planus::Result<self::ParamsRef<'a>> {
                    self.0.access_required(0, "RtxDump", "params")
                }
            }

            impl<'a> ::core::fmt::Debug for RtxDumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtxDumpRef");
                    f.field("params", &self.params());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtxDumpRef<'a>> for RtxDump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtxDumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        params: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.params()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtxDumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtxDumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtxDumpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtxDump>> for RtxDump {
                type Value = ::planus::Offset<RtxDump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtxDump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtxDumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtxDumpRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod data_consumer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetBufferedAmountResponse {
                pub buffered_amount: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GetBufferedAmountResponse {
                fn default() -> Self {
                    Self { buffered_amount: 0 }
                }
            }

            impl GetBufferedAmountResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_buffered_amount.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_buffered_amount) =
                            prepared_buffered_amount
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_buffered_amount);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetBufferedAmountResponse>> for GetBufferedAmountResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetBufferedAmountResponse>>
                for GetBufferedAmountResponse
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetBufferedAmountResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetBufferedAmountResponse> for GetBufferedAmountResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetBufferedAmountResponse> {
                    GetBufferedAmountResponse::create(builder, &self.buffered_amount)
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetBufferedAmountResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetBufferedAmountResponseRef<'a> {
                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GetBufferedAmountResponse", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetBufferedAmountResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetBufferedAmountResponseRef");
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetBufferedAmountResponseRef<'a>> for GetBufferedAmountResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetBufferedAmountResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetBufferedAmountResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetBufferedAmountResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetBufferedAmountResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetBufferedAmountResponse>>
                for GetBufferedAmountResponse
            {
                type Value = ::planus::Offset<GetBufferedAmountResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetBufferedAmountResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetBufferedAmountResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetBufferedAmountResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetBufferedAmountLowThresholdRequest {
                pub threshold: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetBufferedAmountLowThresholdRequest {
                fn default() -> Self {
                    Self { threshold: 0 }
                }
            }

            impl SetBufferedAmountLowThresholdRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_threshold: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_threshold = field_threshold.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_threshold.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_threshold) = prepared_threshold
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_threshold);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetBufferedAmountLowThresholdRequest>
                for SetBufferedAmountLowThresholdRequest
            {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetBufferedAmountLowThresholdRequest> {
                    SetBufferedAmountLowThresholdRequest::create(builder, &self.threshold)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetBufferedAmountLowThresholdRequestRef<'a>(
                ::planus::table_reader::Table<'a>,
            );

            impl<'a> SetBufferedAmountLowThresholdRequestRef<'a> {
                pub fn threshold(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetBufferedAmountLowThresholdRequest", "threshold")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetBufferedAmountLowThresholdRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetBufferedAmountLowThresholdRequestRef");
                    f.field("threshold", &self.threshold());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetBufferedAmountLowThresholdRequestRef<'a>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: SetBufferedAmountLowThresholdRequestRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        threshold: ::core::convert::TryInto::try_into(value.threshold()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetBufferedAmountLowThresholdRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetBufferedAmountLowThresholdRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetBufferedAmountLowThresholdRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetBufferedAmountLowThresholdRequest>>
                for SetBufferedAmountLowThresholdRequest
            {
                type Value = ::planus::Offset<SetBufferedAmountLowThresholdRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetBufferedAmountLowThresholdRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetBufferedAmountLowThresholdRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetBufferedAmountLowThresholdRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub id: ::planus::alloc::string::String,
                pub data_producer_id: ::planus::alloc::string::String,
                pub type_: ::planus::alloc::string::String,
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                pub label: ::planus::alloc::string::String,
                pub protocol: ::planus::alloc::string::String,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);

                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);

                    let prepared_label = field_label.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 24>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(8);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(10);
                    table_writer.calculate_size::<::planus::Offset<str>>(12);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        table_writer.write::<_, _, 4>(1, &prepared_data_producer_id);
                        table_writer.write::<_, _, 4>(2, &prepared_type_);
                        if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                            prepared_sctp_stream_parameters
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_sctp_stream_parameters);
                        }
                        table_writer.write::<_, _, 4>(4, &prepared_label);
                        table_writer.write::<_, _, 4>(5, &prepared_protocol);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.data_producer_id,
                        &self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "DumpResponse", "data_producer_id")
                }

                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "DumpResponse", "type_")
                }

                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0.access(3, "DumpResponse", "sctp_stream_parameters")
                }

                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "DumpResponse", "label")
                }

                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(5, "DumpResponse", "protocol")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("data_producer_id", &self.data_producer_id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub timestamp: u64,
                pub label: ::planus::alloc::string::String,
                pub protocol: ::planus::alloc::string::String,
                pub messages_sent: u64,
                pub bytes_sent: u64,
                pub buffered_amount: u32,
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_messages_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_label = field_label.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let prepared_messages_sent = field_messages_sent.prepare(builder, &0);

                    let prepared_bytes_sent = field_bytes_sent.prepare(builder, &0);

                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 36>::new(builder);

                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_messages_sent.is_some() {
                        table_writer.calculate_size::<u64>(8);
                    }
                    if prepared_bytes_sent.is_some() {
                        table_writer.calculate_size::<u64>(10);
                    }
                    if prepared_buffered_amount.is_some() {
                        table_writer.calculate_size::<u32>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(0, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_messages_sent) =
                            prepared_messages_sent
                        {
                            table_writer.write::<_, _, 8>(3, &prepared_messages_sent);
                        }
                        if let ::core::option::Option::Some(prepared_bytes_sent) =
                            prepared_bytes_sent
                        {
                            table_writer.write::<_, _, 8>(4, &prepared_bytes_sent);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_label);
                        table_writer.write::<_, _, 4>(2, &prepared_protocol);
                        if let ::core::option::Option::Some(prepared_buffered_amount) =
                            prepared_buffered_amount
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_buffered_amount);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        &self.timestamp,
                        &self.label,
                        &self.protocol,
                        &self.messages_sent,
                        &self.bytes_sent,
                        &self.buffered_amount,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GetStatsResponse", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "GetStatsResponse", "label")
                }

                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "GetStatsResponse", "protocol")
                }

                pub fn messages_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "GetStatsResponse", "messages_sent")?
                            .unwrap_or(0),
                    )
                }

                pub fn bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "GetStatsResponse", "bytes_sent")?
                            .unwrap_or(0),
                    )
                }

                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "GetStatsResponse", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("timestamp", &self.timestamp());
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.field("messages_sent", &self.messages_sent());
                    f.field("bytes_sent", &self.bytes_sent());
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        messages_sent: ::core::convert::TryInto::try_into(value.messages_sent()?)?,
                        bytes_sent: ::core::convert::TryInto::try_into(value.bytes_sent()?)?,
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct String {
                pub value: ::planus::alloc::string::String,
            }

            impl String {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String> for String {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    String::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringRef<'a> {
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringRef<'a>> for String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String>> for String {
                type Value = ::planus::Offset<String>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Binary {
                pub value: ::planus::alloc::vec::Vec<u8>,
            }

            impl Binary {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[u8]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Binary>> for Binary {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Binary> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Binary>> for Binary {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Binary>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Binary> for Binary {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Binary> {
                    Binary::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct BinaryRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BinaryRef<'a> {
                pub fn value(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(0, "Binary", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for BinaryRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BinaryRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BinaryRef<'a>> for Binary {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BinaryRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: value.value()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BinaryRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BinaryRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BinaryRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Binary>> for Binary {
                type Value = ::planus::Offset<Binary>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Binary>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BinaryRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BinaryRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Data {
                String(::planus::alloc::boxed::Box<self::String>),
                Binary(::planus::alloc::boxed::Box<self::Binary>),
            }

            impl Data {
                pub fn create_string(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::String>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_binary(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Binary>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Data> for Data {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::String(value) => Self::create_string(builder, value),
                        Self::Binary(value) => Self::create_binary(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Data> for Data {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum DataRef<'a> {
                String(self::StringRef<'a>),
                Binary(self::BinaryRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<DataRef<'a>> for Data {
                type Error = ::planus::Error;

                fn try_from(value: DataRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        DataRef::String(value) => Data::String(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        DataRef::Binary(value) => Data::Binary(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for DataRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::String(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Binary(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendRequest {
                pub ppid: u8,
                pub data: self::Data,
            }

            impl SendRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ppid: impl ::planus::WriteAsDefault<u8, u8>,
                    field_data: impl ::planus::WriteAsUnion<self::Data>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ppid = field_ppid.prepare(builder, &0);

                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 6>::new(builder);

                    if prepared_ppid.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }
                    table_writer.calculate_size::<u8>(4);
                    table_writer.calculate_size::<::planus::Offset<self::Data>>(6);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(2, &prepared_data.offset());
                        if let ::core::option::Option::Some(prepared_ppid) = prepared_ppid {
                            table_writer.write::<_, _, 1>(0, &prepared_ppid);
                        }
                        table_writer.write::<_, _, 1>(1, &prepared_data.tag());
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendRequest>> for SendRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendRequest>> for SendRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendRequest> for SendRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRequest> {
                    SendRequest::create(builder, &self.ppid, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SendRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendRequestRef<'a> {
                pub fn ppid(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SendRequest", "ppid")?.unwrap_or(0),
                    )
                }

                pub fn data(&self) -> ::planus::Result<self::DataRef<'a>> {
                    self.0.access_union_required(1, "SendRequest", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendRequestRef");
                    f.field("ppid", &self.ppid());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendRequestRef<'a>> for SendRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ppid: ::core::convert::TryInto::try_into(value.ppid()?)?,
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendRequest>> for SendRequest {
                type Value = ::planus::Offset<SendRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BufferedAmountLowNotification {
                pub buffered_amount: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BufferedAmountLowNotification {
                fn default() -> Self {
                    Self { buffered_amount: 0 }
                }
            }

            impl BufferedAmountLowNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_buffered_amount.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_buffered_amount) =
                            prepared_buffered_amount
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_buffered_amount);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BufferedAmountLowNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BufferedAmountLowNotification> for BufferedAmountLowNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BufferedAmountLowNotification> {
                    BufferedAmountLowNotification::create(builder, &self.buffered_amount)
                }
            }

            #[derive(Copy, Clone)]
            pub struct BufferedAmountLowNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BufferedAmountLowNotificationRef<'a> {
                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "BufferedAmountLowNotification", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BufferedAmountLowNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BufferedAmountLowNotificationRef");
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BufferedAmountLowNotificationRef<'a>>
                for BufferedAmountLowNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BufferedAmountLowNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BufferedAmountLowNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BufferedAmountLowNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BufferedAmountLowNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BufferedAmountLowNotification>>
                for BufferedAmountLowNotification
            {
                type Value = ::planus::Offset<BufferedAmountLowNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BufferedAmountLowNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BufferedAmountLowNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BufferedAmountLowNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct MessageNotification {
                pub ppid: u32,
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl MessageNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ppid: impl ::planus::WriteAsDefault<u32, u32>,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ppid = field_ppid.prepare(builder, &0);

                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    if prepared_ppid.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<[u8]>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ppid) = prepared_ppid {
                            table_writer.write::<_, _, 4>(0, &prepared_ppid);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_data);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<MessageNotification>> for MessageNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<MessageNotification>> for MessageNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MessageNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<MessageNotification> for MessageNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MessageNotification> {
                    MessageNotification::create(builder, &self.ppid, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct MessageNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MessageNotificationRef<'a> {
                pub fn ppid(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "MessageNotification", "ppid")?
                            .unwrap_or(0),
                    )
                }

                pub fn data(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(1, "MessageNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for MessageNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MessageNotificationRef");
                    f.field("ppid", &self.ppid());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MessageNotificationRef<'a>> for MessageNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MessageNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ppid: ::core::convert::TryInto::try_into(value.ppid()?)?,
                        data: value.data()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MessageNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MessageNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MessageNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<MessageNotification>> for MessageNotification {
                type Value = ::planus::Offset<MessageNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<MessageNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MessageNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MessageNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod sctp_parameters {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct NumSctpStreams {
                pub os: u32,
                pub mis: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for NumSctpStreams {
                fn default() -> Self {
                    Self {
                        os: 1024,
                        mis: 1024,
                    }
                }
            }

            impl NumSctpStreams {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_os: impl ::planus::WriteAsDefault<u32, u32>,
                    field_mis: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_os = field_os.prepare(builder, &1024);

                    let prepared_mis = field_mis.prepare(builder, &1024);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    if prepared_os.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_mis.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_os) = prepared_os {
                            table_writer.write::<_, _, 4>(0, &prepared_os);
                        }
                        if let ::core::option::Option::Some(prepared_mis) = prepared_mis {
                            table_writer.write::<_, _, 4>(1, &prepared_mis);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<NumSctpStreams>> for NumSctpStreams {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<NumSctpStreams>> for NumSctpStreams {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<NumSctpStreams>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<NumSctpStreams> for NumSctpStreams {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<NumSctpStreams> {
                    NumSctpStreams::create(builder, &self.os, &self.mis)
                }
            }

            #[derive(Copy, Clone)]
            pub struct NumSctpStreamsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> NumSctpStreamsRef<'a> {
                pub fn os(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "NumSctpStreams", "os")?.unwrap_or(1024),
                    )
                }

                pub fn mis(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "NumSctpStreams", "mis")?.unwrap_or(1024),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for NumSctpStreamsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("NumSctpStreamsRef");
                    f.field("os", &self.os());
                    f.field("mis", &self.mis());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<NumSctpStreamsRef<'a>> for NumSctpStreams {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: NumSctpStreamsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        os: ::core::convert::TryInto::try_into(value.os()?)?,
                        mis: ::core::convert::TryInto::try_into(value.mis()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for NumSctpStreamsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for NumSctpStreamsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[NumSctpStreamsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<NumSctpStreams>> for NumSctpStreams {
                type Value = ::planus::Offset<NumSctpStreams>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<NumSctpStreams>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for NumSctpStreamsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[NumSctpStreamsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpParameters {
                pub port: u16,
                pub os: u16,
                pub mis: u16,
                pub max_message_size: u32,
                pub send_buffer_size: u32,
                pub sctp_buffered_amount: u32,
                pub is_data_channel: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SctpParameters {
                fn default() -> Self {
                    Self {
                        port: 5000,
                        os: 0,
                        mis: 0,
                        max_message_size: 0,
                        send_buffer_size: 0,
                        sctp_buffered_amount: 0,
                        is_data_channel: false,
                    }
                }
            }

            impl SctpParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_os: impl ::planus::WriteAsDefault<u16, u16>,
                    field_mis: impl ::planus::WriteAsDefault<u16, u16>,
                    field_max_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_send_buffer_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_sctp_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                    field_is_data_channel: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_port = field_port.prepare(builder, &5000);

                    let prepared_os = field_os.prepare(builder, &0);

                    let prepared_mis = field_mis.prepare(builder, &0);

                    let prepared_max_message_size = field_max_message_size.prepare(builder, &0);

                    let prepared_send_buffer_size = field_send_buffer_size.prepare(builder, &0);

                    let prepared_sctp_buffered_amount =
                        field_sctp_buffered_amount.prepare(builder, &0);

                    let prepared_is_data_channel = field_is_data_channel.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<16, 19>::new(builder);

                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(2);
                    }
                    if prepared_os.is_some() {
                        table_writer.calculate_size::<u16>(4);
                    }
                    if prepared_mis.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }
                    if prepared_max_message_size.is_some() {
                        table_writer.calculate_size::<u32>(8);
                    }
                    if prepared_send_buffer_size.is_some() {
                        table_writer.calculate_size::<u32>(10);
                    }
                    if prepared_sctp_buffered_amount.is_some() {
                        table_writer.calculate_size::<u32>(12);
                    }
                    if prepared_is_data_channel.is_some() {
                        table_writer.calculate_size::<bool>(14);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_max_message_size) =
                            prepared_max_message_size
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_max_message_size);
                        }
                        if let ::core::option::Option::Some(prepared_send_buffer_size) =
                            prepared_send_buffer_size
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_send_buffer_size);
                        }
                        if let ::core::option::Option::Some(prepared_sctp_buffered_amount) =
                            prepared_sctp_buffered_amount
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_sctp_buffered_amount);
                        }
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(0, &prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_os) = prepared_os {
                            table_writer.write::<_, _, 2>(1, &prepared_os);
                        }
                        if let ::core::option::Option::Some(prepared_mis) = prepared_mis {
                            table_writer.write::<_, _, 2>(2, &prepared_mis);
                        }
                        if let ::core::option::Option::Some(prepared_is_data_channel) =
                            prepared_is_data_channel
                        {
                            table_writer.write::<_, _, 1>(6, &prepared_is_data_channel);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpParameters>> for SctpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpParameters>> for SctpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpParameters> for SctpParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpParameters> {
                    SctpParameters::create(
                        builder,
                        &self.port,
                        &self.os,
                        &self.mis,
                        &self.max_message_size,
                        &self.send_buffer_size,
                        &self.sctp_buffered_amount,
                        &self.is_data_channel,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct SctpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpParametersRef<'a> {
                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SctpParameters", "port")?.unwrap_or(5000),
                    )
                }

                pub fn os(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "SctpParameters", "os")?.unwrap_or(0),
                    )
                }

                pub fn mis(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "SctpParameters", "mis")?.unwrap_or(0),
                    )
                }

                pub fn max_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "SctpParameters", "max_message_size")?
                            .unwrap_or(0),
                    )
                }

                pub fn send_buffer_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "SctpParameters", "send_buffer_size")?
                            .unwrap_or(0),
                    )
                }

                pub fn sctp_buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "SctpParameters", "sctp_buffered_amount")?
                            .unwrap_or(0),
                    )
                }

                pub fn is_data_channel(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "SctpParameters", "is_data_channel")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SctpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpParametersRef");
                    f.field("port", &self.port());
                    f.field("os", &self.os());
                    f.field("mis", &self.mis());
                    f.field("max_message_size", &self.max_message_size());
                    f.field("send_buffer_size", &self.send_buffer_size());
                    f.field("sctp_buffered_amount", &self.sctp_buffered_amount());
                    f.field("is_data_channel", &self.is_data_channel());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpParametersRef<'a>> for SctpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        os: ::core::convert::TryInto::try_into(value.os()?)?,
                        mis: ::core::convert::TryInto::try_into(value.mis()?)?,
                        max_message_size: ::core::convert::TryInto::try_into(
                            value.max_message_size()?,
                        )?,
                        send_buffer_size: ::core::convert::TryInto::try_into(
                            value.send_buffer_size()?,
                        )?,
                        sctp_buffered_amount: ::core::convert::TryInto::try_into(
                            value.sctp_buffered_amount()?,
                        )?,
                        is_data_channel: ::core::convert::TryInto::try_into(
                            value.is_data_channel()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpParameters>> for SctpParameters {
                type Value = ::planus::Offset<SctpParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SctpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpStreamParameters {
                pub stream_id: u16,
                pub ordered: ::core::option::Option<bool>,
                pub max_packet_life_time: ::core::option::Option<u16>,
                pub max_retransmits: ::core::option::Option<u16>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SctpStreamParameters {
                fn default() -> Self {
                    Self {
                        stream_id: 0,
                        ordered: ::core::default::Default::default(),
                        max_packet_life_time: ::core::default::Default::default(),
                        max_retransmits: ::core::default::Default::default(),
                    }
                }
            }

            impl SctpStreamParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stream_id: impl ::planus::WriteAsDefault<u16, u16>,
                    field_ordered: impl ::planus::WriteAsOptional<bool>,
                    field_max_packet_life_time: impl ::planus::WriteAsOptional<u16>,
                    field_max_retransmits: impl ::planus::WriteAsOptional<u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_stream_id = field_stream_id.prepare(builder, &0);

                    let prepared_ordered = field_ordered.prepare(builder);

                    let prepared_max_packet_life_time = field_max_packet_life_time.prepare(builder);

                    let prepared_max_retransmits = field_max_retransmits.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 7>::new(builder);

                    if prepared_stream_id.is_some() {
                        table_writer.calculate_size::<u16>(2);
                    }
                    if prepared_ordered.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    if prepared_max_packet_life_time.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }
                    if prepared_max_retransmits.is_some() {
                        table_writer.calculate_size::<u16>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_stream_id) = prepared_stream_id
                        {
                            table_writer.write::<_, _, 2>(0, &prepared_stream_id);
                        }
                        if let ::core::option::Option::Some(prepared_max_packet_life_time) =
                            prepared_max_packet_life_time
                        {
                            table_writer.write::<_, _, 2>(2, &prepared_max_packet_life_time);
                        }
                        if let ::core::option::Option::Some(prepared_max_retransmits) =
                            prepared_max_retransmits
                        {
                            table_writer.write::<_, _, 2>(3, &prepared_max_retransmits);
                        }
                        if let ::core::option::Option::Some(prepared_ordered) = prepared_ordered {
                            table_writer.write::<_, _, 1>(1, &prepared_ordered);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpStreamParameters>> for SctpStreamParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpStreamParameters>> for SctpStreamParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpStreamParameters>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpStreamParameters> for SctpStreamParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStreamParameters> {
                    SctpStreamParameters::create(
                        builder,
                        &self.stream_id,
                        &self.ordered,
                        &self.max_packet_life_time,
                        &self.max_retransmits,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct SctpStreamParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpStreamParametersRef<'a> {
                pub fn stream_id(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SctpStreamParameters", "stream_id")?
                            .unwrap_or(0),
                    )
                }

                pub fn ordered(&self) -> ::planus::Result<::core::option::Option<bool>> {
                    self.0.access(1, "SctpStreamParameters", "ordered")
                }

                pub fn max_packet_life_time(
                    &self,
                ) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0
                        .access(2, "SctpStreamParameters", "max_packet_life_time")
                }

                pub fn max_retransmits(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(3, "SctpStreamParameters", "max_retransmits")
                }
            }

            impl<'a> ::core::fmt::Debug for SctpStreamParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpStreamParametersRef");
                    f.field("stream_id", &self.stream_id());
                    if let ::core::option::Option::Some(field_ordered) = self.ordered().transpose()
                    {
                        f.field("ordered", &field_ordered);
                    }
                    if let ::core::option::Option::Some(field_max_packet_life_time) =
                        self.max_packet_life_time().transpose()
                    {
                        f.field("max_packet_life_time", &field_max_packet_life_time);
                    }
                    if let ::core::option::Option::Some(field_max_retransmits) =
                        self.max_retransmits().transpose()
                    {
                        f.field("max_retransmits", &field_max_retransmits);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpStreamParametersRef<'a>> for SctpStreamParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpStreamParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stream_id: ::core::convert::TryInto::try_into(value.stream_id()?)?,
                        ordered: if let ::core::option::Option::Some(ordered) = value.ordered()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                ordered,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_packet_life_time: if let ::core::option::Option::Some(
                            max_packet_life_time,
                        ) = value.max_packet_life_time()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_packet_life_time,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        max_retransmits: if let ::core::option::Option::Some(max_retransmits) =
                            value.max_retransmits()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                max_retransmits,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpStreamParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpStreamParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStreamParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpStreamParameters>> for SctpStreamParameters {
                type Value = ::planus::Offset<SctpStreamParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpStreamParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpStreamParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStreamParametersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod data_producer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub id: ::planus::alloc::string::String,
                pub type_: ::planus::alloc::string::String,
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                pub label: ::planus::alloc::string::String,
                pub protocol: ::planus::alloc::string::String,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);

                    let prepared_label = field_label.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 20>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(6);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(8);
                    table_writer.calculate_size::<::planus::Offset<str>>(10);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        table_writer.write::<_, _, 4>(1, &prepared_type_);
                        if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                            prepared_sctp_stream_parameters
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_sctp_stream_parameters);
                        }
                        table_writer.write::<_, _, 4>(3, &prepared_label);
                        table_writer.write::<_, _, 4>(4, &prepared_protocol);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "DumpResponse", "type_")
                }

                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0.access(2, "DumpResponse", "sctp_stream_parameters")
                }

                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "DumpResponse", "label")
                }

                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "DumpResponse", "protocol")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub timestamp: u64,
                pub label: ::planus::alloc::string::String,
                pub protocol: ::planus::alloc::string::String,
                pub messages_received: u64,
                pub bytes_received: u64,
                pub buffered_amount: u32,
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_label: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_messages_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_buffered_amount: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_label = field_label.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let prepared_messages_received = field_messages_received.prepare(builder, &0);

                    let prepared_bytes_received = field_bytes_received.prepare(builder, &0);

                    let prepared_buffered_amount = field_buffered_amount.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 36>::new(builder);

                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_messages_received.is_some() {
                        table_writer.calculate_size::<u64>(8);
                    }
                    if prepared_bytes_received.is_some() {
                        table_writer.calculate_size::<u64>(10);
                    }
                    if prepared_buffered_amount.is_some() {
                        table_writer.calculate_size::<u32>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(0, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_messages_received) =
                            prepared_messages_received
                        {
                            table_writer.write::<_, _, 8>(3, &prepared_messages_received);
                        }
                        if let ::core::option::Option::Some(prepared_bytes_received) =
                            prepared_bytes_received
                        {
                            table_writer.write::<_, _, 8>(4, &prepared_bytes_received);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_label);
                        table_writer.write::<_, _, 4>(2, &prepared_protocol);
                        if let ::core::option::Option::Some(prepared_buffered_amount) =
                            prepared_buffered_amount
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_buffered_amount);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        &self.timestamp,
                        &self.label,
                        &self.protocol,
                        &self.messages_received,
                        &self.bytes_received,
                        &self.buffered_amount,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GetStatsResponse", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                pub fn label(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "GetStatsResponse", "label")
                }

                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "GetStatsResponse", "protocol")
                }

                pub fn messages_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "GetStatsResponse", "messages_received")?
                            .unwrap_or(0),
                    )
                }

                pub fn bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "GetStatsResponse", "bytes_received")?
                            .unwrap_or(0),
                    )
                }

                pub fn buffered_amount(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "GetStatsResponse", "buffered_amount")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("timestamp", &self.timestamp());
                    f.field("label", &self.label());
                    f.field("protocol", &self.protocol());
                    f.field("messages_received", &self.messages_received());
                    f.field("bytes_received", &self.bytes_received());
                    f.field("buffered_amount", &self.buffered_amount());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        label: ::core::convert::TryInto::try_into(value.label()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        messages_received: ::core::convert::TryInto::try_into(
                            value.messages_received()?,
                        )?,
                        bytes_received: ::core::convert::TryInto::try_into(
                            value.bytes_received()?,
                        )?,
                        buffered_amount: ::core::convert::TryInto::try_into(
                            value.buffered_amount()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct String {
                pub value: ::planus::alloc::string::String,
            }

            impl String {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String>> for String {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String> for String {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String> {
                    String::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct StringRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StringRef<'a> {
                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "String", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for StringRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StringRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StringRef<'a>> for String {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StringRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StringRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StringRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StringRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String>> for String {
                type Value = ::planus::Offset<String>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StringRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StringRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Binary {
                pub value: ::planus::alloc::vec::Vec<u8>,
            }

            impl Binary {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_value: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[u8]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Binary>> for Binary {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Binary> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Binary>> for Binary {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Binary>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Binary> for Binary {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Binary> {
                    Binary::create(builder, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct BinaryRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BinaryRef<'a> {
                pub fn value(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(0, "Binary", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for BinaryRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BinaryRef");
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BinaryRef<'a>> for Binary {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BinaryRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        value: value.value()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BinaryRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BinaryRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BinaryRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Binary>> for Binary {
                type Value = ::planus::Offset<Binary>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Binary>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BinaryRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BinaryRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Data {
                String(::planus::alloc::boxed::Box<self::String>),
                Binary(::planus::alloc::boxed::Box<self::Binary>),
            }

            impl Data {
                pub fn create_string(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::String>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_binary(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Binary>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Data> for Data {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::String(value) => Self::create_string(builder, value),
                        Self::Binary(value) => Self::create_binary(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Data> for Data {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum DataRef<'a> {
                String(self::StringRef<'a>),
                Binary(self::BinaryRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<DataRef<'a>> for Data {
                type Error = ::planus::Error;

                fn try_from(value: DataRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        DataRef::String(value) => Data::String(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        DataRef::Binary(value) => Data::Binary(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for DataRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::String(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Binary(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendNotification {
                pub ppid: u8,
                pub data: self::Data,
            }

            impl SendNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ppid: impl ::planus::WriteAsDefault<u8, u8>,
                    field_data: impl ::planus::WriteAsUnion<self::Data>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ppid = field_ppid.prepare(builder, &0);

                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 6>::new(builder);

                    if prepared_ppid.is_some() {
                        table_writer.calculate_size::<u8>(2);
                    }
                    table_writer.calculate_size::<u8>(4);
                    table_writer.calculate_size::<::planus::Offset<self::Data>>(6);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(2, &prepared_data.offset());
                        if let ::core::option::Option::Some(prepared_ppid) = prepared_ppid {
                            table_writer.write::<_, _, 1>(0, &prepared_ppid);
                        }
                        table_writer.write::<_, _, 1>(1, &prepared_data.tag());
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendNotification> for SendNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    SendNotification::create(builder, &self.ppid, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SendNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendNotificationRef<'a> {
                pub fn ppid(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SendNotification", "ppid")?.unwrap_or(0),
                    )
                }

                pub fn data(&self) -> ::planus::Result<self::DataRef<'a>> {
                    self.0.access_union_required(1, "SendNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendNotificationRef");
                    f.field("ppid", &self.ppid());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendNotificationRef<'a>> for SendNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ppid: ::core::convert::TryInto::try_into(value.ppid()?)?,
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendNotification>> for SendNotification {
                type Value = ::planus::Offset<SendNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod direct_transport {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DirectTransportOptions {
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DirectTransportOptions {
                fn default() -> Self {
                    Self {
                        base: ::core::default::Default::default(),
                    }
                }
            }

            impl DirectTransportOptions {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Options>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DirectTransportOptions>> for DirectTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DirectTransportOptions>>
                for DirectTransportOptions
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DirectTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DirectTransportOptions> for DirectTransportOptions {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DirectTransportOptions> {
                    DirectTransportOptions::create(builder, &self.base)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DirectTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DirectTransportOptionsRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "DirectTransportOptions", "base")
                }
            }

            impl<'a> ::core::fmt::Debug for DirectTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DirectTransportOptionsRef");
                    f.field("base", &self.base());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DirectTransportOptionsRef<'a>> for DirectTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DirectTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DirectTransportOptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DirectTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DirectTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DirectTransportOptions>> for DirectTransportOptions {
                type Value = ::planus::Offset<DirectTransportOptions>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DirectTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DirectTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DirectTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Dump>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(builder, &self.base)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Stats>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.base)
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpNotification {
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl RtcpNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[u8]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpNotification>> for RtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpNotification>> for RtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpNotification> for RtcpNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpNotification> {
                    RtcpNotification::create(builder, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtcpNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpNotificationRef<'a> {
                pub fn data(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(0, "RtcpNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpNotificationRef<'a>> for RtcpNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpNotification>> for RtcpNotification {
                type Value = ::planus::Offset<RtcpNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtcpNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod transport {
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Protocol {
                Udp = 1,
                Tcp = 2,
            }

            impl ::core::convert::TryFrom<u8> for Protocol {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        1 => ::core::result::Result::Ok(Protocol::Udp),
                        2 => ::core::result::Result::Ok(Protocol::Tcp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Protocol> for u8 {
                fn from(value: Protocol) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Protocol {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Protocol> for Protocol {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Protocol> for Protocol {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Protocol {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Protocol, Protocol> for Protocol {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Protocol,
                ) -> ::core::option::Option<Protocol> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Protocol> for Protocol {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Protocol> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Protocol {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Protocol {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Protocol",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Protocol> for Protocol {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenIp {
                pub ip: ::planus::alloc::string::String,
                pub announced_ip: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl ListenIp {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_announced_ip: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);

                    let prepared_announced_ip = field_announced_ip.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_announced_ip.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_ip);
                        if let ::core::option::Option::Some(prepared_announced_ip) =
                            prepared_announced_ip
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_announced_ip);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenIp>> for ListenIp {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenIp> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenIp>> for ListenIp {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenIp>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenIp> for ListenIp {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenIp> {
                    ListenIp::create(builder, &self.ip, &self.announced_ip)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ListenIpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenIpRef<'a> {
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ListenIp", "ip")
                }

                pub fn announced_ip(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "ListenIp", "announced_ip")
                }
            }

            impl<'a> ::core::fmt::Debug for ListenIpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenIpRef");
                    f.field("ip", &self.ip());
                    if let ::core::option::Option::Some(field_announced_ip) =
                        self.announced_ip().transpose()
                    {
                        f.field("announced_ip", &field_announced_ip);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenIpRef<'a>> for ListenIp {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenIpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        announced_ip: if let ::core::option::Option::Some(announced_ip) =
                            value.announced_ip()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                announced_ip,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenIpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenIpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenIpRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenIp>> for ListenIp {
                type Value = ::planus::Offset<ListenIp>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenIp>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenIpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenIpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RestartIceResponse {
                pub username_fragment: ::planus::alloc::string::String,
                pub password: ::planus::alloc::string::String,
                pub ice_lite: bool,
            }

            impl RestartIceResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_username_fragment: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_password: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_lite: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_username_fragment = field_username_fragment.prepare(builder);

                    let prepared_password = field_password.prepare(builder);

                    let prepared_ice_lite = field_ice_lite.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 9>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_ice_lite.is_some() {
                        table_writer.calculate_size::<bool>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_username_fragment);
                        table_writer.write::<_, _, 4>(1, &prepared_password);
                        if let ::core::option::Option::Some(prepared_ice_lite) = prepared_ice_lite {
                            table_writer.write::<_, _, 1>(2, &prepared_ice_lite);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RestartIceResponse>> for RestartIceResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RestartIceResponse>> for RestartIceResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RestartIceResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RestartIceResponse> for RestartIceResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RestartIceResponse> {
                    RestartIceResponse::create(
                        builder,
                        &self.username_fragment,
                        &self.password,
                        &self.ice_lite,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RestartIceResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RestartIceResponseRef<'a> {
                pub fn username_fragment(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "RestartIceResponse", "username_fragment")
                }

                pub fn password(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "RestartIceResponse", "password")
                }

                pub fn ice_lite(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "RestartIceResponse", "ice_lite")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RestartIceResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RestartIceResponseRef");
                    f.field("username_fragment", &self.username_fragment());
                    f.field("password", &self.password());
                    f.field("ice_lite", &self.ice_lite());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RestartIceResponseRef<'a>> for RestartIceResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RestartIceResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        username_fragment: ::core::convert::TryInto::try_into(
                            value.username_fragment()?,
                        )?,
                        password: ::core::convert::TryInto::try_into(value.password()?)?,
                        ice_lite: ::core::convert::TryInto::try_into(value.ice_lite()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RestartIceResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RestartIceResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RestartIceResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RestartIceResponse>> for RestartIceResponse {
                type Value = ::planus::Offset<RestartIceResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RestartIceResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RestartIceResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RestartIceResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct ConsumeRequest {
                pub consumer_id: ::planus::alloc::string::String,
                pub producer_id: ::planus::alloc::string::String,
                pub kind: super::rtp_parameters::MediaKind,
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                pub type_: super::rtp_parameters::Type,
                pub consumable_rtp_encodings:
                    ::planus::alloc::vec::Vec<super::rtp_parameters::RtpEncodingParameters>,
                pub paused: bool,
                pub preferred_layers: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::consumer::ConsumerLayers>,
                >,
                pub ignore_dtx: bool,
            }

            impl ConsumeRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                    field_consumable_rtp_encodings: impl ::planus::WriteAs<
                        ::planus::Offset<
                            [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                        >,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_preferred_layers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerLayers>,
                    >,
                    field_ignore_dtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_consumer_id = field_consumer_id.prepare(builder);

                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::All);

                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);

                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::None);

                    let prepared_consumable_rtp_encodings =
                        field_consumable_rtp_encodings.prepare(builder);

                    let prepared_paused = field_paused.prepare(builder, &false);

                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let prepared_ignore_dtx = field_ignore_dtx.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<20, 24>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_kind.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::MediaKind>(6);
                    }
                    table_writer
                        .calculate_size::<::planus::Offset<super::rtp_parameters::RtpParameters>>(
                            8,
                        );
                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::Type>(10);
                    }
                    table_writer.calculate_size::<::planus::Offset<
                        [::planus::Offset<super::rtp_parameters::RtpEncodingParameters>],
                    >>(12);
                    if prepared_paused.is_some() {
                        table_writer.calculate_size::<bool>(14);
                    }
                    if prepared_preferred_layers.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::consumer::ConsumerLayers>>(
                                16,
                            );
                    }
                    if prepared_ignore_dtx.is_some() {
                        table_writer.calculate_size::<bool>(18);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_consumer_id);
                        table_writer.write::<_, _, 4>(1, &prepared_producer_id);
                        table_writer.write::<_, _, 4>(3, &prepared_rtp_parameters);
                        table_writer.write::<_, _, 4>(5, &prepared_consumable_rtp_encodings);
                        if let ::core::option::Option::Some(prepared_preferred_layers) =
                            prepared_preferred_layers
                        {
                            table_writer.write::<_, _, 4>(7, &prepared_preferred_layers);
                        }
                        if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                            table_writer.write::<_, _, 1>(2, &prepared_kind);
                        }
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(4, &prepared_type_);
                        }
                        if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                            table_writer.write::<_, _, 1>(6, &prepared_paused);
                        }
                        if let ::core::option::Option::Some(prepared_ignore_dtx) =
                            prepared_ignore_dtx
                        {
                            table_writer.write::<_, _, 1>(8, &prepared_ignore_dtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumeRequest>> for ConsumeRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumeRequest>> for ConsumeRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumeRequest> for ConsumeRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeRequest> {
                    ConsumeRequest::create(
                        builder,
                        &self.consumer_id,
                        &self.producer_id,
                        &self.kind,
                        &self.rtp_parameters,
                        &self.type_,
                        &self.consumable_rtp_encodings,
                        &self.paused,
                        &self.preferred_layers,
                        &self.ignore_dtx,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConsumeRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumeRequestRef<'a> {
                pub fn consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ConsumeRequest", "consumer_id")
                }

                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "ConsumeRequest", "producer_id")
                }

                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "ConsumeRequest", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::All),
                    )
                }

                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0
                        .access_required(3, "ConsumeRequest", "rtp_parameters")
                }

                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ConsumeRequest", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::None),
                    )
                }

                pub fn consumable_rtp_encodings(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<
                        'a,
                        ::planus::Result<super::rtp_parameters::RtpEncodingParametersRef<'a>>,
                    >,
                > {
                    self.0
                        .access_required(5, "ConsumeRequest", "consumable_rtp_encodings")
                }

                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "ConsumeRequest", "paused")?
                            .unwrap_or(false),
                    )
                }

                pub fn preferred_layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::consumer::ConsumerLayersRef<'a>>>
                {
                    self.0.access(7, "ConsumeRequest", "preferred_layers")
                }

                pub fn ignore_dtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "ConsumeRequest", "ignore_dtx")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumeRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumeRequestRef");
                    f.field("consumer_id", &self.consumer_id());
                    f.field("producer_id", &self.producer_id());
                    f.field("kind", &self.kind());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("type_", &self.type_());
                    f.field("consumable_rtp_encodings", &self.consumable_rtp_encodings());
                    f.field("paused", &self.paused());
                    if let ::core::option::Option::Some(field_preferred_layers) =
                        self.preferred_layers().transpose()
                    {
                        f.field("preferred_layers", &field_preferred_layers);
                    }
                    f.field("ignore_dtx", &self.ignore_dtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumeRequestRef<'a>> for ConsumeRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumeRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        consumer_id: ::core::convert::TryInto::try_into(value.consumer_id()?)?,
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        consumable_rtp_encodings: value
                            .consumable_rtp_encodings()?
                            .to_vec_result()?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        preferred_layers: if let ::core::option::Option::Some(preferred_layers) =
                            value.preferred_layers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(preferred_layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        ignore_dtx: ::core::convert::TryInto::try_into(value.ignore_dtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumeRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumeRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumeRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumeRequest>> for ConsumeRequest {
                type Value = ::planus::Offset<ConsumeRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumeRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumeRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumeRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumeResponse {
                pub paused: bool,
                pub producer_paused: bool,
                pub score: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::consumer::ConsumerScore>,
                >,
                pub preferred_layers: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::consumer::ConsumerLayers>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConsumeResponse {
                fn default() -> Self {
                    Self {
                        paused: false,
                        producer_paused: false,
                        score: ::core::default::Default::default(),
                        preferred_layers: ::core::default::Default::default(),
                    }
                }
            }

            impl ConsumeResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_producer_paused: impl ::planus::WriteAsDefault<bool, bool>,
                    field_score: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerScore>,
                    >,
                    field_preferred_layers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::consumer::ConsumerLayers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_paused = field_paused.prepare(builder, &false);

                    let prepared_producer_paused = field_producer_paused.prepare(builder, &false);

                    let prepared_score = field_score.prepare(builder);

                    let prepared_preferred_layers = field_preferred_layers.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 10>::new(builder);

                    if prepared_paused.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }
                    if prepared_producer_paused.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    if prepared_score.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::consumer::ConsumerScore>>(6);
                    }
                    if prepared_preferred_layers.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::consumer::ConsumerLayers>>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_score) = prepared_score {
                            table_writer.write::<_, _, 4>(2, &prepared_score);
                        }
                        if let ::core::option::Option::Some(prepared_preferred_layers) =
                            prepared_preferred_layers
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_preferred_layers);
                        }
                        if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                            table_writer.write::<_, _, 1>(0, &prepared_paused);
                        }
                        if let ::core::option::Option::Some(prepared_producer_paused) =
                            prepared_producer_paused
                        {
                            table_writer.write::<_, _, 1>(1, &prepared_producer_paused);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumeResponse>> for ConsumeResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumeResponse>> for ConsumeResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumeResponse> for ConsumeResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeResponse> {
                    ConsumeResponse::create(
                        builder,
                        &self.paused,
                        &self.producer_paused,
                        &self.score,
                        &self.preferred_layers,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConsumeResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumeResponseRef<'a> {
                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ConsumeResponse", "paused")?
                            .unwrap_or(false),
                    )
                }

                pub fn producer_paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ConsumeResponse", "producer_paused")?
                            .unwrap_or(false),
                    )
                }

                pub fn score(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::consumer::ConsumerScoreRef<'a>>>
                {
                    self.0.access(2, "ConsumeResponse", "score")
                }

                pub fn preferred_layers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::consumer::ConsumerLayersRef<'a>>>
                {
                    self.0.access(3, "ConsumeResponse", "preferred_layers")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumeResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumeResponseRef");
                    f.field("paused", &self.paused());
                    f.field("producer_paused", &self.producer_paused());
                    if let ::core::option::Option::Some(field_score) = self.score().transpose() {
                        f.field("score", &field_score);
                    }
                    if let ::core::option::Option::Some(field_preferred_layers) =
                        self.preferred_layers().transpose()
                    {
                        f.field("preferred_layers", &field_preferred_layers);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumeResponseRef<'a>> for ConsumeResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumeResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                        producer_paused: ::core::convert::TryInto::try_into(
                            value.producer_paused()?,
                        )?,
                        score: if let ::core::option::Option::Some(score) = value.score()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(score)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        preferred_layers: if let ::core::option::Option::Some(preferred_layers) =
                            value.preferred_layers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(preferred_layers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumeResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumeResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumeResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumeResponse>> for ConsumeResponse {
                type Value = ::planus::Offset<ConsumeResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumeResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumeResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumeResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct ProduceRequest {
                pub producer_id: ::planus::alloc::string::String,
                pub kind: super::rtp_parameters::MediaKind,
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                pub rtp_mapping: ::planus::alloc::boxed::Box<super::rtp_parameters::RtpMapping>,
                pub key_frame_request_delay: u16,
                pub paused: bool,
            }

            impl ProduceRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_rtp_mapping: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpMapping>,
                    >,
                    field_key_frame_request_delay: impl ::planus::WriteAsDefault<u16, u16>,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::All);

                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);

                    let prepared_rtp_mapping = field_rtp_mapping.prepare(builder);

                    let prepared_key_frame_request_delay =
                        field_key_frame_request_delay.prepare(builder, &0);

                    let prepared_paused = field_paused.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 16>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_kind.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::MediaKind>(4);
                    }
                    table_writer
                        .calculate_size::<::planus::Offset<super::rtp_parameters::RtpParameters>>(
                            6,
                        );
                    table_writer
                        .calculate_size::<::planus::Offset<super::rtp_parameters::RtpMapping>>(8);
                    if prepared_key_frame_request_delay.is_some() {
                        table_writer.calculate_size::<u16>(10);
                    }
                    if prepared_paused.is_some() {
                        table_writer.calculate_size::<bool>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_producer_id);
                        table_writer.write::<_, _, 4>(2, &prepared_rtp_parameters);
                        table_writer.write::<_, _, 4>(3, &prepared_rtp_mapping);
                        if let ::core::option::Option::Some(prepared_key_frame_request_delay) =
                            prepared_key_frame_request_delay
                        {
                            table_writer.write::<_, _, 2>(4, &prepared_key_frame_request_delay);
                        }
                        if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                            table_writer.write::<_, _, 1>(1, &prepared_kind);
                        }
                        if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                            table_writer.write::<_, _, 1>(5, &prepared_paused);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ProduceRequest>> for ProduceRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ProduceRequest>> for ProduceRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ProduceRequest> for ProduceRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceRequest> {
                    ProduceRequest::create(
                        builder,
                        &self.producer_id,
                        &self.kind,
                        &self.rtp_parameters,
                        &self.rtp_mapping,
                        &self.key_frame_request_delay,
                        &self.paused,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ProduceRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ProduceRequestRef<'a> {
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ProduceRequest", "producer_id")
                }

                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ProduceRequest", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::All),
                    )
                }

                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0
                        .access_required(2, "ProduceRequest", "rtp_parameters")
                }

                pub fn rtp_mapping(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpMappingRef<'a>> {
                    self.0.access_required(3, "ProduceRequest", "rtp_mapping")
                }

                pub fn key_frame_request_delay(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ProduceRequest", "key_frame_request_delay")?
                            .unwrap_or(0),
                    )
                }

                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "ProduceRequest", "paused")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ProduceRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ProduceRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.field("kind", &self.kind());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("rtp_mapping", &self.rtp_mapping());
                    f.field("key_frame_request_delay", &self.key_frame_request_delay());
                    f.field("paused", &self.paused());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ProduceRequestRef<'a>> for ProduceRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ProduceRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        rtp_mapping: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_mapping()?)?,
                        ),
                        key_frame_request_delay: ::core::convert::TryInto::try_into(
                            value.key_frame_request_delay()?,
                        )?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ProduceRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ProduceRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ProduceRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ProduceRequest>> for ProduceRequest {
                type Value = ::planus::Offset<ProduceRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ProduceRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ProduceRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ProduceRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ProduceResponse {
                pub type_: super::rtp_parameters::Type,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ProduceResponse {
                fn default() -> Self {
                    Self {
                        type_: super::rtp_parameters::Type::None,
                    }
                }
            }

            impl ProduceResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::Type,
                        super::rtp_parameters::Type,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ =
                        field_type_.prepare(builder, &super::rtp_parameters::Type::None);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::Type>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(0, &prepared_type_);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ProduceResponse>> for ProduceResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ProduceResponse>> for ProduceResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ProduceResponse> for ProduceResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceResponse> {
                    ProduceResponse::create(builder, &self.type_)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ProduceResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ProduceResponseRef<'a> {
                pub fn type_(&self) -> ::planus::Result<super::rtp_parameters::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ProduceResponse", "type_")?
                            .unwrap_or(super::rtp_parameters::Type::None),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ProduceResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ProduceResponseRef");
                    f.field("type_", &self.type_());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ProduceResponseRef<'a>> for ProduceResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ProduceResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ProduceResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ProduceResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ProduceResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ProduceResponse>> for ProduceResponse {
                type Value = ::planus::Offset<ProduceResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ProduceResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ProduceResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ProduceResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ProduceDataRequest {
                pub data_producer_id: ::planus::alloc::string::String,
                pub type_: ::planus::alloc::string::String,
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                pub label: ::core::option::Option<::planus::alloc::string::String>,
                pub protocol: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl ProduceDataRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_protocol: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);

                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);

                    let prepared_label = field_label.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 20>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(6);
                    }
                    if prepared_label.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(8);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data_producer_id);
                        table_writer.write::<_, _, 4>(1, &prepared_type_);
                        if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                            prepared_sctp_stream_parameters
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_sctp_stream_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_label) = prepared_label {
                            table_writer.write::<_, _, 4>(3, &prepared_label);
                        }
                        if let ::core::option::Option::Some(prepared_protocol) = prepared_protocol {
                            table_writer.write::<_, _, 4>(4, &prepared_protocol);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ProduceDataRequest>> for ProduceDataRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ProduceDataRequest>> for ProduceDataRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ProduceDataRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ProduceDataRequest> for ProduceDataRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ProduceDataRequest> {
                    ProduceDataRequest::create(
                        builder,
                        &self.data_producer_id,
                        &self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ProduceDataRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ProduceDataRequestRef<'a> {
                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ProduceDataRequest", "data_producer_id")
                }

                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "ProduceDataRequest", "type_")
                }

                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0
                        .access(2, "ProduceDataRequest", "sctp_stream_parameters")
                }

                pub fn label(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(3, "ProduceDataRequest", "label")
                }

                pub fn protocol(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "ProduceDataRequest", "protocol")
                }
            }

            impl<'a> ::core::fmt::Debug for ProduceDataRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ProduceDataRequestRef");
                    f.field("data_producer_id", &self.data_producer_id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    if let ::core::option::Option::Some(field_label) = self.label().transpose() {
                        f.field("label", &field_label);
                    }
                    if let ::core::option::Option::Some(field_protocol) =
                        self.protocol().transpose()
                    {
                        f.field("protocol", &field_protocol);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ProduceDataRequestRef<'a>> for ProduceDataRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ProduceDataRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: if let ::core::option::Option::Some(label) = value.label()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(label)?)
                        } else {
                            ::core::option::Option::None
                        },
                        protocol: if let ::core::option::Option::Some(protocol) =
                            value.protocol()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                protocol,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ProduceDataRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ProduceDataRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ProduceDataRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ProduceDataRequest>> for ProduceDataRequest {
                type Value = ::planus::Offset<ProduceDataRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ProduceDataRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ProduceDataRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ProduceDataRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsumeDataRequest {
                pub data_consumer_id: ::planus::alloc::string::String,
                pub data_producer_id: ::planus::alloc::string::String,
                pub type_: ::planus::alloc::string::String,
                pub sctp_stream_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpStreamParameters>,
                >,
                pub label: ::core::option::Option<::planus::alloc::string::String>,
                pub protocol: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl ConsumeDataRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_sctp_stream_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpStreamParameters>,
                    >,
                    field_label: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_protocol: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_consumer_id = field_data_consumer_id.prepare(builder);

                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);

                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_sctp_stream_parameters =
                        field_sctp_stream_parameters.prepare(builder);

                    let prepared_label = field_label.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 24>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_sctp_stream_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::sctp_parameters::SctpStreamParameters>>(8);
                    }
                    if prepared_label.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(10);
                    }
                    if prepared_protocol.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data_consumer_id);
                        table_writer.write::<_, _, 4>(1, &prepared_data_producer_id);
                        table_writer.write::<_, _, 4>(2, &prepared_type_);
                        if let ::core::option::Option::Some(prepared_sctp_stream_parameters) =
                            prepared_sctp_stream_parameters
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_sctp_stream_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_label) = prepared_label {
                            table_writer.write::<_, _, 4>(4, &prepared_label);
                        }
                        if let ::core::option::Option::Some(prepared_protocol) = prepared_protocol {
                            table_writer.write::<_, _, 4>(5, &prepared_protocol);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsumeDataRequest>> for ConsumeDataRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsumeDataRequest>> for ConsumeDataRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsumeDataRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsumeDataRequest> for ConsumeDataRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsumeDataRequest> {
                    ConsumeDataRequest::create(
                        builder,
                        &self.data_consumer_id,
                        &self.data_producer_id,
                        &self.type_,
                        &self.sctp_stream_parameters,
                        &self.label,
                        &self.protocol,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConsumeDataRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsumeDataRequestRef<'a> {
                pub fn data_consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ConsumeDataRequest", "data_consumer_id")
                }

                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "ConsumeDataRequest", "data_producer_id")
                }

                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "ConsumeDataRequest", "type_")
                }

                pub fn sctp_stream_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpStreamParametersRef<'a>>,
                > {
                    self.0
                        .access(3, "ConsumeDataRequest", "sctp_stream_parameters")
                }

                pub fn label(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "ConsumeDataRequest", "label")
                }

                pub fn protocol(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "ConsumeDataRequest", "protocol")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsumeDataRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsumeDataRequestRef");
                    f.field("data_consumer_id", &self.data_consumer_id());
                    f.field("data_producer_id", &self.data_producer_id());
                    f.field("type_", &self.type_());
                    if let ::core::option::Option::Some(field_sctp_stream_parameters) =
                        self.sctp_stream_parameters().transpose()
                    {
                        f.field("sctp_stream_parameters", &field_sctp_stream_parameters);
                    }
                    if let ::core::option::Option::Some(field_label) = self.label().transpose() {
                        f.field("label", &field_label);
                    }
                    if let ::core::option::Option::Some(field_protocol) =
                        self.protocol().transpose()
                    {
                        f.field("protocol", &field_protocol);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsumeDataRequestRef<'a>> for ConsumeDataRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsumeDataRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_consumer_id: ::core::convert::TryInto::try_into(
                            value.data_consumer_id()?,
                        )?,
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        sctp_stream_parameters: if let ::core::option::Option::Some(
                            sctp_stream_parameters,
                        ) = value.sctp_stream_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_stream_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        label: if let ::core::option::Option::Some(label) = value.label()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(label)?)
                        } else {
                            ::core::option::Option::None
                        },
                        protocol: if let ::core::option::Option::Some(protocol) =
                            value.protocol()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                protocol,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsumeDataRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsumeDataRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsumeDataRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsumeDataRequest>> for ConsumeDataRequest {
                type Value = ::planus::Offset<ConsumeDataRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsumeDataRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsumeDataRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsumeDataRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Tuple {
                pub local_ip: ::planus::alloc::string::String,
                pub local_port: u16,
                pub remote_ip: ::planus::alloc::string::String,
                pub remote_port: u16,
                pub protocol: ::planus::alloc::string::String,
            }

            impl Tuple {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_local_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_local_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_remote_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_remote_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_local_ip = field_local_ip.prepare(builder);

                    let prepared_local_port = field_local_port.prepare(builder, &0);

                    let prepared_remote_ip = field_remote_ip.prepare(builder);

                    let prepared_remote_port = field_remote_port.prepare(builder, &0);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 16>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_local_port.is_some() {
                        table_writer.calculate_size::<u16>(4);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_remote_port.is_some() {
                        table_writer.calculate_size::<u16>(8);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(10);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_local_ip);
                        table_writer.write::<_, _, 4>(2, &prepared_remote_ip);
                        table_writer.write::<_, _, 4>(4, &prepared_protocol);
                        if let ::core::option::Option::Some(prepared_local_port) =
                            prepared_local_port
                        {
                            table_writer.write::<_, _, 2>(1, &prepared_local_port);
                        }
                        if let ::core::option::Option::Some(prepared_remote_port) =
                            prepared_remote_port
                        {
                            table_writer.write::<_, _, 2>(3, &prepared_remote_port);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Tuple>> for Tuple {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Tuple>> for Tuple {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Tuple>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Tuple> for Tuple {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Tuple> {
                    Tuple::create(
                        builder,
                        &self.local_ip,
                        &self.local_port,
                        &self.remote_ip,
                        &self.remote_port,
                        &self.protocol,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct TupleRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TupleRef<'a> {
                pub fn local_ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Tuple", "local_ip")
                }

                pub fn local_port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Tuple", "local_port")?.unwrap_or(0),
                    )
                }

                pub fn remote_ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "Tuple", "remote_ip")
                }

                pub fn remote_port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Tuple", "remote_port")?.unwrap_or(0),
                    )
                }

                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "Tuple", "protocol")
                }
            }

            impl<'a> ::core::fmt::Debug for TupleRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TupleRef");
                    f.field("local_ip", &self.local_ip());
                    f.field("local_port", &self.local_port());
                    f.field("remote_ip", &self.remote_ip());
                    f.field("remote_port", &self.remote_port());
                    f.field("protocol", &self.protocol());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TupleRef<'a>> for Tuple {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TupleRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        local_ip: ::core::convert::TryInto::try_into(value.local_ip()?)?,
                        local_port: ::core::convert::TryInto::try_into(value.local_port()?)?,
                        remote_ip: ::core::convert::TryInto::try_into(value.remote_ip()?)?,
                        remote_port: ::core::convert::TryInto::try_into(value.remote_port()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TupleRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TupleRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TupleRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Tuple>> for Tuple {
                type Value = ::planus::Offset<Tuple>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Tuple>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TupleRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TupleRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SrtpParameters {
                pub crypto_suite: ::planus::alloc::string::String,
                pub key_base64: ::planus::alloc::string::String,
            }

            impl SrtpParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_crypto_suite: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_key_base64: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_crypto_suite = field_crypto_suite.prepare(builder);

                    let prepared_key_base64 = field_key_base64.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_crypto_suite);
                        table_writer.write::<_, _, 4>(1, &prepared_key_base64);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SrtpParameters>> for SrtpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SrtpParameters>> for SrtpParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SrtpParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SrtpParameters> for SrtpParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SrtpParameters> {
                    SrtpParameters::create(builder, &self.crypto_suite, &self.key_base64)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SrtpParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SrtpParametersRef<'a> {
                pub fn crypto_suite(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "SrtpParameters", "crypto_suite")
                }

                pub fn key_base64(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "SrtpParameters", "key_base64")
                }
            }

            impl<'a> ::core::fmt::Debug for SrtpParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SrtpParametersRef");
                    f.field("crypto_suite", &self.crypto_suite());
                    f.field("key_base64", &self.key_base64());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SrtpParametersRef<'a>> for SrtpParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SrtpParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        crypto_suite: ::core::convert::TryInto::try_into(value.crypto_suite()?)?,
                        key_base64: ::core::convert::TryInto::try_into(value.key_base64()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SrtpParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SrtpParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SrtpParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SrtpParameters>> for SrtpParameters {
                type Value = ::planus::Offset<SrtpParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SrtpParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SrtpParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SrtpParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpListener {
                pub ssrc_table: ::planus::alloc::vec::Vec<super::common::Uint32String>,
                pub mid_table: ::planus::alloc::vec::Vec<super::common::StringString>,
                pub rid_table: ::planus::alloc::vec::Vec<super::common::StringString>,
            }

            impl RtpListener {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    field_mid_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    field_rid_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc_table = field_ssrc_table.prepare(builder);

                    let prepared_mid_table = field_mid_table.prepare(builder);

                    let prepared_rid_table = field_rid_table.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 12>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::Uint32String>]>>(2);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::StringString>]>>(4);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::StringString>]>>(6);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_ssrc_table);
                        table_writer.write::<_, _, 4>(1, &prepared_mid_table);
                        table_writer.write::<_, _, 4>(2, &prepared_rid_table);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpListener>> for RtpListener {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpListener>> for RtpListener {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpListener>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpListener> for RtpListener {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpListener> {
                    RtpListener::create(builder, &self.ssrc_table, &self.mid_table, &self.rid_table)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpListenerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpListenerRef<'a> {
                pub fn ssrc_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint32StringRef<'a>>>,
                > {
                    self.0.access_required(0, "RtpListener", "ssrc_table")
                }

                pub fn mid_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                > {
                    self.0.access_required(1, "RtpListener", "mid_table")
                }

                pub fn rid_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                > {
                    self.0.access_required(2, "RtpListener", "rid_table")
                }
            }

            impl<'a> ::core::fmt::Debug for RtpListenerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpListenerRef");
                    f.field("ssrc_table", &self.ssrc_table());
                    f.field("mid_table", &self.mid_table());
                    f.field("rid_table", &self.rid_table());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpListenerRef<'a>> for RtpListener {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpListenerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc_table: value.ssrc_table()?.to_vec_result()?,
                        mid_table: value.mid_table()?.to_vec_result()?,
                        rid_table: value.rid_table()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpListenerRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpListenerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpListenerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpListener>> for RtpListener {
                type Value = ::planus::Offset<RtpListener>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpListener>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpListenerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpListenerRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpListener {
                pub stream_id_table: ::planus::alloc::vec::Vec<super::common::Uint16String>,
            }

            impl SctpListener {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stream_id_table: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint16String>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_stream_id_table = field_stream_id_table.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::Uint16String>]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_stream_id_table);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpListener>> for SctpListener {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpListener>> for SctpListener {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpListener>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpListener> for SctpListener {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpListener> {
                    SctpListener::create(builder, &self.stream_id_table)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SctpListenerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpListenerRef<'a> {
                pub fn stream_id_table(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint16StringRef<'a>>>,
                > {
                    self.0.access_required(0, "SctpListener", "stream_id_table")
                }
            }

            impl<'a> ::core::fmt::Debug for SctpListenerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpListenerRef");
                    f.field("stream_id_table", &self.stream_id_table());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpListenerRef<'a>> for SctpListener {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpListenerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stream_id_table: value.stream_id_table()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpListenerRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpListenerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpListenerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpListener>> for SctpListener {
                type Value = ::planus::Offset<SctpListener>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpListener>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpListenerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SctpListenerRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Dump {
                pub id: ::planus::alloc::string::String,
                pub direct: bool,
                pub producer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                pub consumer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                pub map_ssrc_consumer_id: ::planus::alloc::vec::Vec<super::common::Uint32String>,
                pub map_rtx_ssrc_consumer_id:
                    ::planus::alloc::vec::Vec<super::common::Uint32String>,
                pub data_producer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                pub data_consumer_ids: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                pub recv_rtp_header_extensions:
                    ::planus::alloc::vec::Vec<super::common::StringUint8>,
                pub rtp_listener: ::planus::alloc::boxed::Box<self::RtpListener>,
                pub max_message_size: u32,
                pub sctp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::SctpParameters>,
                >,
                pub sctp_state: ::core::option::Option<::planus::alloc::string::String>,
                pub sctp_listener:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::SctpListener>>,
                pub trace_event_types: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            }

            impl Dump {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_direct: impl ::planus::WriteAsDefault<bool, bool>,
                    field_producer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_consumer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_map_ssrc_consumer_id: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    field_map_rtx_ssrc_consumer_id: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::Uint32String>]>,
                    >,
                    field_data_producer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_data_consumer_ids: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_recv_rtp_header_extensions: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::common::StringUint8>]>,
                    >,
                    field_rtp_listener: impl ::planus::WriteAs<::planus::Offset<self::RtpListener>>,
                    field_max_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_sctp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::SctpParameters>,
                    >,
                    field_sctp_state: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_sctp_listener: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::SctpListener>,
                    >,
                    field_trace_event_types: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_direct = field_direct.prepare(builder, &false);

                    let prepared_producer_ids = field_producer_ids.prepare(builder);

                    let prepared_consumer_ids = field_consumer_ids.prepare(builder);

                    let prepared_map_ssrc_consumer_id = field_map_ssrc_consumer_id.prepare(builder);

                    let prepared_map_rtx_ssrc_consumer_id =
                        field_map_rtx_ssrc_consumer_id.prepare(builder);

                    let prepared_data_producer_ids = field_data_producer_ids.prepare(builder);

                    let prepared_data_consumer_ids = field_data_consumer_ids.prepare(builder);

                    let prepared_recv_rtp_header_extensions =
                        field_recv_rtp_header_extensions.prepare(builder);

                    let prepared_rtp_listener = field_rtp_listener.prepare(builder);

                    let prepared_max_message_size = field_max_message_size.prepare(builder, &0);

                    let prepared_sctp_parameters = field_sctp_parameters.prepare(builder);

                    let prepared_sctp_state = field_sctp_state.prepare(builder);

                    let prepared_sctp_listener = field_sctp_listener.prepare(builder);

                    let prepared_trace_event_types = field_trace_event_types.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<32, 57>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_direct.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(6);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(8);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::Uint32String>]>>(10);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::Uint32String>]>>(12);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(14);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(16);
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::common::StringUint8>]>>(18);
                    table_writer.calculate_size::<::planus::Offset<self::RtpListener>>(20);
                    if prepared_max_message_size.is_some() {
                        table_writer.calculate_size::<u32>(22);
                    }
                    if prepared_sctp_parameters.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::sctp_parameters::SctpParameters>>(24);
                    }
                    if prepared_sctp_state.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(26);
                    }
                    if prepared_sctp_listener.is_some() {
                        table_writer.calculate_size::<::planus::Offset<self::SctpListener>>(28);
                    }
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(30);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        table_writer.write::<_, _, 4>(2, &prepared_producer_ids);
                        table_writer.write::<_, _, 4>(3, &prepared_consumer_ids);
                        table_writer.write::<_, _, 4>(4, &prepared_map_ssrc_consumer_id);
                        table_writer.write::<_, _, 4>(5, &prepared_map_rtx_ssrc_consumer_id);
                        table_writer.write::<_, _, 4>(6, &prepared_data_producer_ids);
                        table_writer.write::<_, _, 4>(7, &prepared_data_consumer_ids);
                        table_writer.write::<_, _, 4>(8, &prepared_recv_rtp_header_extensions);
                        table_writer.write::<_, _, 4>(9, &prepared_rtp_listener);
                        if let ::core::option::Option::Some(prepared_max_message_size) =
                            prepared_max_message_size
                        {
                            table_writer.write::<_, _, 4>(10, &prepared_max_message_size);
                        }
                        if let ::core::option::Option::Some(prepared_sctp_parameters) =
                            prepared_sctp_parameters
                        {
                            table_writer.write::<_, _, 4>(11, &prepared_sctp_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_sctp_state) =
                            prepared_sctp_state
                        {
                            table_writer.write::<_, _, 4>(12, &prepared_sctp_state);
                        }
                        if let ::core::option::Option::Some(prepared_sctp_listener) =
                            prepared_sctp_listener
                        {
                            table_writer.write::<_, _, 4>(13, &prepared_sctp_listener);
                        }
                        table_writer.write::<_, _, 4>(14, &prepared_trace_event_types);
                        if let ::core::option::Option::Some(prepared_direct) = prepared_direct {
                            table_writer.write::<_, _, 1>(1, &prepared_direct);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Dump>> for Dump {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Dump>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Dump> for Dump {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Dump> {
                    Dump::create(
                        builder,
                        &self.id,
                        &self.direct,
                        &self.producer_ids,
                        &self.consumer_ids,
                        &self.map_ssrc_consumer_id,
                        &self.map_rtx_ssrc_consumer_id,
                        &self.data_producer_ids,
                        &self.data_consumer_ids,
                        &self.recv_rtp_header_extensions,
                        &self.rtp_listener,
                        &self.max_message_size,
                        &self.sctp_parameters,
                        &self.sctp_state,
                        &self.sctp_listener,
                        &self.trace_event_types,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Dump", "id")
                }

                pub fn direct(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(self.0.access(1, "Dump", "direct")?.unwrap_or(false))
                }

                pub fn producer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(2, "Dump", "producer_ids")
                }

                pub fn consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(3, "Dump", "consumer_ids")
                }

                pub fn map_ssrc_consumer_id(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint32StringRef<'a>>>,
                > {
                    self.0.access_required(4, "Dump", "map_ssrc_consumer_id")
                }

                pub fn map_rtx_ssrc_consumer_id(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::Uint32StringRef<'a>>>,
                > {
                    self.0
                        .access_required(5, "Dump", "map_rtx_ssrc_consumer_id")
                }

                pub fn data_producer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(6, "Dump", "data_producer_ids")
                }

                pub fn data_consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(7, "Dump", "data_consumer_ids")
                }

                pub fn recv_rtp_header_extensions(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::common::StringUint8Ref<'a>>>,
                > {
                    self.0
                        .access_required(8, "Dump", "recv_rtp_header_extensions")
                }

                pub fn rtp_listener(&self) -> ::planus::Result<self::RtpListenerRef<'a>> {
                    self.0.access_required(9, "Dump", "rtp_listener")
                }

                pub fn max_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(10, "Dump", "max_message_size")?.unwrap_or(0),
                    )
                }

                pub fn sctp_parameters(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::SctpParametersRef<'a>>,
                > {
                    self.0.access(11, "Dump", "sctp_parameters")
                }

                pub fn sctp_state(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(12, "Dump", "sctp_state")
                }

                pub fn sctp_listener(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::SctpListenerRef<'a>>>
                {
                    self.0.access(13, "Dump", "sctp_listener")
                }

                pub fn trace_event_types(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(14, "Dump", "trace_event_types")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpRef");
                    f.field("id", &self.id());
                    f.field("direct", &self.direct());
                    f.field("producer_ids", &self.producer_ids());
                    f.field("consumer_ids", &self.consumer_ids());
                    f.field("map_ssrc_consumer_id", &self.map_ssrc_consumer_id());
                    f.field("map_rtx_ssrc_consumer_id", &self.map_rtx_ssrc_consumer_id());
                    f.field("data_producer_ids", &self.data_producer_ids());
                    f.field("data_consumer_ids", &self.data_consumer_ids());
                    f.field(
                        "recv_rtp_header_extensions",
                        &self.recv_rtp_header_extensions(),
                    );
                    f.field("rtp_listener", &self.rtp_listener());
                    f.field("max_message_size", &self.max_message_size());
                    if let ::core::option::Option::Some(field_sctp_parameters) =
                        self.sctp_parameters().transpose()
                    {
                        f.field("sctp_parameters", &field_sctp_parameters);
                    }
                    if let ::core::option::Option::Some(field_sctp_state) =
                        self.sctp_state().transpose()
                    {
                        f.field("sctp_state", &field_sctp_state);
                    }
                    if let ::core::option::Option::Some(field_sctp_listener) =
                        self.sctp_listener().transpose()
                    {
                        f.field("sctp_listener", &field_sctp_listener);
                    }
                    f.field("trace_event_types", &self.trace_event_types());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpRef<'a>> for Dump {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        direct: ::core::convert::TryInto::try_into(value.direct()?)?,
                        producer_ids: value.producer_ids()?.to_vec_result()?,
                        consumer_ids: value.consumer_ids()?.to_vec_result()?,
                        map_ssrc_consumer_id: value.map_ssrc_consumer_id()?.to_vec_result()?,
                        map_rtx_ssrc_consumer_id: value
                            .map_rtx_ssrc_consumer_id()?
                            .to_vec_result()?,
                        data_producer_ids: value.data_producer_ids()?.to_vec_result()?,
                        data_consumer_ids: value.data_consumer_ids()?.to_vec_result()?,
                        recv_rtp_header_extensions: value
                            .recv_rtp_header_extensions()?
                            .to_vec_result()?,
                        rtp_listener: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_listener()?)?,
                        ),
                        max_message_size: ::core::convert::TryInto::try_into(
                            value.max_message_size()?,
                        )?,
                        sctp_parameters: if let ::core::option::Option::Some(sctp_parameters) =
                            value.sctp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        sctp_state: if let ::core::option::Option::Some(sctp_state) =
                            value.sctp_state()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                sctp_state,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        sctp_listener: if let ::core::option::Option::Some(sctp_listener) =
                            value.sctp_listener()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(sctp_listener)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        trace_event_types: value.trace_event_types()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Dump>> for Dump {
                type Value = ::planus::Offset<Dump>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Dump>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Options {
                pub direct: bool,
                pub max_message_size: u32,
                pub initial_available_outgoing_bitrate: u32,
                pub enable_sctp: bool,
                pub num_sctp_streams: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::sctp_parameters::NumSctpStreams>,
                >,
                pub max_sctp_message_size: u32,
                pub sctp_send_buffer_size: u32,
                pub is_data_channel: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Options {
                fn default() -> Self {
                    Self {
                        direct: false,
                        max_message_size: 0,
                        initial_available_outgoing_bitrate: 0,
                        enable_sctp: false,
                        num_sctp_streams: ::core::default::Default::default(),
                        max_sctp_message_size: 0,
                        sctp_send_buffer_size: 0,
                        is_data_channel: false,
                    }
                }
            }

            impl Options {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_direct: impl ::planus::WriteAsDefault<bool, bool>,
                    field_max_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_initial_available_outgoing_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_enable_sctp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_num_sctp_streams: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::sctp_parameters::NumSctpStreams>,
                    >,
                    field_max_sctp_message_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_sctp_send_buffer_size: impl ::planus::WriteAsDefault<u32, u32>,
                    field_is_data_channel: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_direct = field_direct.prepare(builder, &false);

                    let prepared_max_message_size = field_max_message_size.prepare(builder, &0);

                    let prepared_initial_available_outgoing_bitrate =
                        field_initial_available_outgoing_bitrate.prepare(builder, &0);

                    let prepared_enable_sctp = field_enable_sctp.prepare(builder, &false);

                    let prepared_num_sctp_streams = field_num_sctp_streams.prepare(builder);

                    let prepared_max_sctp_message_size =
                        field_max_sctp_message_size.prepare(builder, &0);

                    let prepared_sctp_send_buffer_size =
                        field_sctp_send_buffer_size.prepare(builder, &0);

                    let prepared_is_data_channel = field_is_data_channel.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 23>::new(builder);

                    if prepared_direct.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }
                    if prepared_max_message_size.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    if prepared_initial_available_outgoing_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(6);
                    }
                    if prepared_enable_sctp.is_some() {
                        table_writer.calculate_size::<bool>(8);
                    }
                    if prepared_num_sctp_streams.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::sctp_parameters::NumSctpStreams>>(10);
                    }
                    if prepared_max_sctp_message_size.is_some() {
                        table_writer.calculate_size::<u32>(12);
                    }
                    if prepared_sctp_send_buffer_size.is_some() {
                        table_writer.calculate_size::<u32>(14);
                    }
                    if prepared_is_data_channel.is_some() {
                        table_writer.calculate_size::<bool>(16);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_max_message_size) =
                            prepared_max_message_size
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_max_message_size);
                        }
                        if let ::core::option::Option::Some(
                            prepared_initial_available_outgoing_bitrate,
                        ) = prepared_initial_available_outgoing_bitrate
                        {
                            table_writer
                                .write::<_, _, 4>(2, &prepared_initial_available_outgoing_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_num_sctp_streams) =
                            prepared_num_sctp_streams
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_num_sctp_streams);
                        }
                        if let ::core::option::Option::Some(prepared_max_sctp_message_size) =
                            prepared_max_sctp_message_size
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_max_sctp_message_size);
                        }
                        if let ::core::option::Option::Some(prepared_sctp_send_buffer_size) =
                            prepared_sctp_send_buffer_size
                        {
                            table_writer.write::<_, _, 4>(6, &prepared_sctp_send_buffer_size);
                        }
                        if let ::core::option::Option::Some(prepared_direct) = prepared_direct {
                            table_writer.write::<_, _, 1>(0, &prepared_direct);
                        }
                        if let ::core::option::Option::Some(prepared_enable_sctp) =
                            prepared_enable_sctp
                        {
                            table_writer.write::<_, _, 1>(3, &prepared_enable_sctp);
                        }
                        if let ::core::option::Option::Some(prepared_is_data_channel) =
                            prepared_is_data_channel
                        {
                            table_writer.write::<_, _, 1>(7, &prepared_is_data_channel);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Options>> for Options {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Options>> for Options {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Options>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Options> for Options {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Options> {
                    Options::create(
                        builder,
                        &self.direct,
                        &self.max_message_size,
                        &self.initial_available_outgoing_bitrate,
                        &self.enable_sctp,
                        &self.num_sctp_streams,
                        &self.max_sctp_message_size,
                        &self.sctp_send_buffer_size,
                        &self.is_data_channel,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct OptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> OptionsRef<'a> {
                pub fn direct(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Options", "direct")?.unwrap_or(false),
                    )
                }

                pub fn max_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "Options", "max_message_size")?
                            .unwrap_or(0),
                    )
                }

                pub fn initial_available_outgoing_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "Options", "initial_available_outgoing_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn enable_sctp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Options", "enable_sctp")?.unwrap_or(false),
                    )
                }

                pub fn num_sctp_streams(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<super::sctp_parameters::NumSctpStreamsRef<'a>>,
                > {
                    self.0.access(4, "Options", "num_sctp_streams")
                }

                pub fn max_sctp_message_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "Options", "max_sctp_message_size")?
                            .unwrap_or(0),
                    )
                }

                pub fn sctp_send_buffer_size(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "Options", "sctp_send_buffer_size")?
                            .unwrap_or(0),
                    )
                }

                pub fn is_data_channel(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "Options", "is_data_channel")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for OptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("OptionsRef");
                    f.field("direct", &self.direct());
                    f.field("max_message_size", &self.max_message_size());
                    f.field(
                        "initial_available_outgoing_bitrate",
                        &self.initial_available_outgoing_bitrate(),
                    );
                    f.field("enable_sctp", &self.enable_sctp());
                    if let ::core::option::Option::Some(field_num_sctp_streams) =
                        self.num_sctp_streams().transpose()
                    {
                        f.field("num_sctp_streams", &field_num_sctp_streams);
                    }
                    f.field("max_sctp_message_size", &self.max_sctp_message_size());
                    f.field("sctp_send_buffer_size", &self.sctp_send_buffer_size());
                    f.field("is_data_channel", &self.is_data_channel());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<OptionsRef<'a>> for Options {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: OptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        direct: ::core::convert::TryInto::try_into(value.direct()?)?,
                        max_message_size: ::core::convert::TryInto::try_into(
                            value.max_message_size()?,
                        )?,
                        initial_available_outgoing_bitrate: ::core::convert::TryInto::try_into(
                            value.initial_available_outgoing_bitrate()?,
                        )?,
                        enable_sctp: ::core::convert::TryInto::try_into(value.enable_sctp()?)?,
                        num_sctp_streams: if let ::core::option::Option::Some(num_sctp_streams) =
                            value.num_sctp_streams()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(num_sctp_streams)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        max_sctp_message_size: ::core::convert::TryInto::try_into(
                            value.max_sctp_message_size()?,
                        )?,
                        sctp_send_buffer_size: ::core::convert::TryInto::try_into(
                            value.sctp_send_buffer_size()?,
                        )?,
                        is_data_channel: ::core::convert::TryInto::try_into(
                            value.is_data_channel()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for OptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for OptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[OptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Options>> for Options {
                type Value = ::planus::Offset<Options>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Options>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for OptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[OptionsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Stats {
                pub transport_id: ::planus::alloc::string::String,
                pub timestamp: u64,
                pub sctp_state: ::core::option::Option<::planus::alloc::string::String>,
                pub bytes_received: u64,
                pub recv_bitrate: u64,
                pub bytes_sent: u64,
                pub send_bitrate: u64,
                pub rtp_bytes_received: u64,
                pub rtp_recv_bitrate: u64,
                pub rtp_bytes_sent: u64,
                pub rtp_send_bitrate: u64,
                pub rtx_bytes_received: u64,
                pub rtx_recv_bitrate: u64,
                pub rtx_bytes_sent: u64,
                pub rtx_send_bitrate: u64,
                pub probation_bytes_sent: u64,
                pub probation_send_bitrate: u64,
                pub available_outgoing_bitrate: u64,
                pub available_incoming_bitrate: u64,
                pub max_incoming_bitrate: u64,
                pub rtp_packet_loss_received: u64,
                pub rtp_packet_loss_sent: u64,
            }

            impl Stats {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_sctp_state: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_recv_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_send_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_recv_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_send_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtx_bytes_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtx_recv_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtx_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtx_send_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_probation_bytes_sent: impl ::planus::WriteAsDefault<u64, u64>,
                    field_probation_send_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_available_outgoing_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_available_incoming_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_max_incoming_bitrate: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_packet_loss_received: impl ::planus::WriteAsDefault<u64, u64>,
                    field_rtp_packet_loss_sent: impl ::planus::WriteAsDefault<u64, u64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_sctp_state = field_sctp_state.prepare(builder);

                    let prepared_bytes_received = field_bytes_received.prepare(builder, &0);

                    let prepared_recv_bitrate = field_recv_bitrate.prepare(builder, &0);

                    let prepared_bytes_sent = field_bytes_sent.prepare(builder, &0);

                    let prepared_send_bitrate = field_send_bitrate.prepare(builder, &0);

                    let prepared_rtp_bytes_received = field_rtp_bytes_received.prepare(builder, &0);

                    let prepared_rtp_recv_bitrate = field_rtp_recv_bitrate.prepare(builder, &0);

                    let prepared_rtp_bytes_sent = field_rtp_bytes_sent.prepare(builder, &0);

                    let prepared_rtp_send_bitrate = field_rtp_send_bitrate.prepare(builder, &0);

                    let prepared_rtx_bytes_received = field_rtx_bytes_received.prepare(builder, &0);

                    let prepared_rtx_recv_bitrate = field_rtx_recv_bitrate.prepare(builder, &0);

                    let prepared_rtx_bytes_sent = field_rtx_bytes_sent.prepare(builder, &0);

                    let prepared_rtx_send_bitrate = field_rtx_send_bitrate.prepare(builder, &0);

                    let prepared_probation_bytes_sent =
                        field_probation_bytes_sent.prepare(builder, &0);

                    let prepared_probation_send_bitrate =
                        field_probation_send_bitrate.prepare(builder, &0);

                    let prepared_available_outgoing_bitrate =
                        field_available_outgoing_bitrate.prepare(builder, &0);

                    let prepared_available_incoming_bitrate =
                        field_available_incoming_bitrate.prepare(builder, &0);

                    let prepared_max_incoming_bitrate =
                        field_max_incoming_bitrate.prepare(builder, &0);

                    let prepared_rtp_packet_loss_received =
                        field_rtp_packet_loss_received.prepare(builder, &0);

                    let prepared_rtp_packet_loss_sent =
                        field_rtp_packet_loss_sent.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<46, 168>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }
                    if prepared_sctp_state.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(6);
                    }
                    if prepared_bytes_received.is_some() {
                        table_writer.calculate_size::<u64>(8);
                    }
                    if prepared_recv_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(10);
                    }
                    if prepared_bytes_sent.is_some() {
                        table_writer.calculate_size::<u64>(12);
                    }
                    if prepared_send_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(14);
                    }
                    if prepared_rtp_bytes_received.is_some() {
                        table_writer.calculate_size::<u64>(16);
                    }
                    if prepared_rtp_recv_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(18);
                    }
                    if prepared_rtp_bytes_sent.is_some() {
                        table_writer.calculate_size::<u64>(20);
                    }
                    if prepared_rtp_send_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(22);
                    }
                    if prepared_rtx_bytes_received.is_some() {
                        table_writer.calculate_size::<u64>(24);
                    }
                    if prepared_rtx_recv_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(26);
                    }
                    if prepared_rtx_bytes_sent.is_some() {
                        table_writer.calculate_size::<u64>(28);
                    }
                    if prepared_rtx_send_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(30);
                    }
                    if prepared_probation_bytes_sent.is_some() {
                        table_writer.calculate_size::<u64>(32);
                    }
                    if prepared_probation_send_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(34);
                    }
                    if prepared_available_outgoing_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(36);
                    }
                    if prepared_available_incoming_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(38);
                    }
                    if prepared_max_incoming_bitrate.is_some() {
                        table_writer.calculate_size::<u64>(40);
                    }
                    if prepared_rtp_packet_loss_received.is_some() {
                        table_writer.calculate_size::<u64>(42);
                    }
                    if prepared_rtp_packet_loss_sent.is_some() {
                        table_writer.calculate_size::<u64>(44);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(1, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_bytes_received) =
                            prepared_bytes_received
                        {
                            table_writer.write::<_, _, 8>(3, &prepared_bytes_received);
                        }
                        if let ::core::option::Option::Some(prepared_recv_bitrate) =
                            prepared_recv_bitrate
                        {
                            table_writer.write::<_, _, 8>(4, &prepared_recv_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_bytes_sent) =
                            prepared_bytes_sent
                        {
                            table_writer.write::<_, _, 8>(5, &prepared_bytes_sent);
                        }
                        if let ::core::option::Option::Some(prepared_send_bitrate) =
                            prepared_send_bitrate
                        {
                            table_writer.write::<_, _, 8>(6, &prepared_send_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_bytes_received) =
                            prepared_rtp_bytes_received
                        {
                            table_writer.write::<_, _, 8>(7, &prepared_rtp_bytes_received);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_recv_bitrate) =
                            prepared_rtp_recv_bitrate
                        {
                            table_writer.write::<_, _, 8>(8, &prepared_rtp_recv_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_bytes_sent) =
                            prepared_rtp_bytes_sent
                        {
                            table_writer.write::<_, _, 8>(9, &prepared_rtp_bytes_sent);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_send_bitrate) =
                            prepared_rtp_send_bitrate
                        {
                            table_writer.write::<_, _, 8>(10, &prepared_rtp_send_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_bytes_received) =
                            prepared_rtx_bytes_received
                        {
                            table_writer.write::<_, _, 8>(11, &prepared_rtx_bytes_received);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_recv_bitrate) =
                            prepared_rtx_recv_bitrate
                        {
                            table_writer.write::<_, _, 8>(12, &prepared_rtx_recv_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_bytes_sent) =
                            prepared_rtx_bytes_sent
                        {
                            table_writer.write::<_, _, 8>(13, &prepared_rtx_bytes_sent);
                        }
                        if let ::core::option::Option::Some(prepared_rtx_send_bitrate) =
                            prepared_rtx_send_bitrate
                        {
                            table_writer.write::<_, _, 8>(14, &prepared_rtx_send_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_probation_bytes_sent) =
                            prepared_probation_bytes_sent
                        {
                            table_writer.write::<_, _, 8>(15, &prepared_probation_bytes_sent);
                        }
                        if let ::core::option::Option::Some(prepared_probation_send_bitrate) =
                            prepared_probation_send_bitrate
                        {
                            table_writer.write::<_, _, 8>(16, &prepared_probation_send_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_available_outgoing_bitrate) =
                            prepared_available_outgoing_bitrate
                        {
                            table_writer.write::<_, _, 8>(17, &prepared_available_outgoing_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_available_incoming_bitrate) =
                            prepared_available_incoming_bitrate
                        {
                            table_writer.write::<_, _, 8>(18, &prepared_available_incoming_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_max_incoming_bitrate) =
                            prepared_max_incoming_bitrate
                        {
                            table_writer.write::<_, _, 8>(19, &prepared_max_incoming_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_packet_loss_received) =
                            prepared_rtp_packet_loss_received
                        {
                            table_writer.write::<_, _, 8>(20, &prepared_rtp_packet_loss_received);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_packet_loss_sent) =
                            prepared_rtp_packet_loss_sent
                        {
                            table_writer.write::<_, _, 8>(21, &prepared_rtp_packet_loss_sent);
                        }
                        table_writer.write::<_, _, 4>(0, &prepared_transport_id);
                        if let ::core::option::Option::Some(prepared_sctp_state) =
                            prepared_sctp_state
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_sctp_state);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Stats>> for Stats {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Stats>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Stats> for Stats {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Stats> {
                    Stats::create(
                        builder,
                        &self.transport_id,
                        &self.timestamp,
                        &self.sctp_state,
                        &self.bytes_received,
                        &self.recv_bitrate,
                        &self.bytes_sent,
                        &self.send_bitrate,
                        &self.rtp_bytes_received,
                        &self.rtp_recv_bitrate,
                        &self.rtp_bytes_sent,
                        &self.rtp_send_bitrate,
                        &self.rtx_bytes_received,
                        &self.rtx_recv_bitrate,
                        &self.rtx_bytes_sent,
                        &self.rtx_send_bitrate,
                        &self.probation_bytes_sent,
                        &self.probation_send_bitrate,
                        &self.available_outgoing_bitrate,
                        &self.available_incoming_bitrate,
                        &self.max_incoming_bitrate,
                        &self.rtp_packet_loss_received,
                        &self.rtp_packet_loss_sent,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct StatsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StatsRef<'a> {
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Stats", "transport_id")
                }

                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(self.0.access(1, "Stats", "timestamp")?.unwrap_or(0))
                }

                pub fn sctp_state(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "Stats", "sctp_state")
                }

                pub fn bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Stats", "bytes_received")?.unwrap_or(0),
                    )
                }

                pub fn recv_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "Stats", "recv_bitrate")?.unwrap_or(0),
                    )
                }

                pub fn bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "Stats", "bytes_sent")?.unwrap_or(0),
                    )
                }

                pub fn send_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(6, "Stats", "send_bitrate")?.unwrap_or(0),
                    )
                }

                pub fn rtp_bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "Stats", "rtp_bytes_received")?
                            .unwrap_or(0),
                    )
                }

                pub fn rtp_recv_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(8, "Stats", "rtp_recv_bitrate")?.unwrap_or(0),
                    )
                }

                pub fn rtp_bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "Stats", "rtp_bytes_sent")?.unwrap_or(0),
                    )
                }

                pub fn rtp_send_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(10, "Stats", "rtp_send_bitrate")?.unwrap_or(0),
                    )
                }

                pub fn rtx_bytes_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "Stats", "rtx_bytes_received")?
                            .unwrap_or(0),
                    )
                }

                pub fn rtx_recv_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(12, "Stats", "rtx_recv_bitrate")?.unwrap_or(0),
                    )
                }

                pub fn rtx_bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "Stats", "rtx_bytes_sent")?.unwrap_or(0),
                    )
                }

                pub fn rtx_send_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0.access(14, "Stats", "rtx_send_bitrate")?.unwrap_or(0),
                    )
                }

                pub fn probation_bytes_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(15, "Stats", "probation_bytes_sent")?
                            .unwrap_or(0),
                    )
                }

                pub fn probation_send_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(16, "Stats", "probation_send_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn available_outgoing_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(17, "Stats", "available_outgoing_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn available_incoming_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(18, "Stats", "available_incoming_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn max_incoming_bitrate(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(19, "Stats", "max_incoming_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn rtp_packet_loss_received(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(20, "Stats", "rtp_packet_loss_received")?
                            .unwrap_or(0),
                    )
                }

                pub fn rtp_packet_loss_sent(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(21, "Stats", "rtp_packet_loss_sent")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for StatsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StatsRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("timestamp", &self.timestamp());
                    if let ::core::option::Option::Some(field_sctp_state) =
                        self.sctp_state().transpose()
                    {
                        f.field("sctp_state", &field_sctp_state);
                    }
                    f.field("bytes_received", &self.bytes_received());
                    f.field("recv_bitrate", &self.recv_bitrate());
                    f.field("bytes_sent", &self.bytes_sent());
                    f.field("send_bitrate", &self.send_bitrate());
                    f.field("rtp_bytes_received", &self.rtp_bytes_received());
                    f.field("rtp_recv_bitrate", &self.rtp_recv_bitrate());
                    f.field("rtp_bytes_sent", &self.rtp_bytes_sent());
                    f.field("rtp_send_bitrate", &self.rtp_send_bitrate());
                    f.field("rtx_bytes_received", &self.rtx_bytes_received());
                    f.field("rtx_recv_bitrate", &self.rtx_recv_bitrate());
                    f.field("rtx_bytes_sent", &self.rtx_bytes_sent());
                    f.field("rtx_send_bitrate", &self.rtx_send_bitrate());
                    f.field("probation_bytes_sent", &self.probation_bytes_sent());
                    f.field("probation_send_bitrate", &self.probation_send_bitrate());
                    f.field(
                        "available_outgoing_bitrate",
                        &self.available_outgoing_bitrate(),
                    );
                    f.field(
                        "available_incoming_bitrate",
                        &self.available_incoming_bitrate(),
                    );
                    f.field("max_incoming_bitrate", &self.max_incoming_bitrate());
                    f.field("rtp_packet_loss_received", &self.rtp_packet_loss_received());
                    f.field("rtp_packet_loss_sent", &self.rtp_packet_loss_sent());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StatsRef<'a>> for Stats {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StatsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        sctp_state: if let ::core::option::Option::Some(sctp_state) =
                            value.sctp_state()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                sctp_state,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        bytes_received: ::core::convert::TryInto::try_into(
                            value.bytes_received()?,
                        )?,
                        recv_bitrate: ::core::convert::TryInto::try_into(value.recv_bitrate()?)?,
                        bytes_sent: ::core::convert::TryInto::try_into(value.bytes_sent()?)?,
                        send_bitrate: ::core::convert::TryInto::try_into(value.send_bitrate()?)?,
                        rtp_bytes_received: ::core::convert::TryInto::try_into(
                            value.rtp_bytes_received()?,
                        )?,
                        rtp_recv_bitrate: ::core::convert::TryInto::try_into(
                            value.rtp_recv_bitrate()?,
                        )?,
                        rtp_bytes_sent: ::core::convert::TryInto::try_into(
                            value.rtp_bytes_sent()?,
                        )?,
                        rtp_send_bitrate: ::core::convert::TryInto::try_into(
                            value.rtp_send_bitrate()?,
                        )?,
                        rtx_bytes_received: ::core::convert::TryInto::try_into(
                            value.rtx_bytes_received()?,
                        )?,
                        rtx_recv_bitrate: ::core::convert::TryInto::try_into(
                            value.rtx_recv_bitrate()?,
                        )?,
                        rtx_bytes_sent: ::core::convert::TryInto::try_into(
                            value.rtx_bytes_sent()?,
                        )?,
                        rtx_send_bitrate: ::core::convert::TryInto::try_into(
                            value.rtx_send_bitrate()?,
                        )?,
                        probation_bytes_sent: ::core::convert::TryInto::try_into(
                            value.probation_bytes_sent()?,
                        )?,
                        probation_send_bitrate: ::core::convert::TryInto::try_into(
                            value.probation_send_bitrate()?,
                        )?,
                        available_outgoing_bitrate: ::core::convert::TryInto::try_into(
                            value.available_outgoing_bitrate()?,
                        )?,
                        available_incoming_bitrate: ::core::convert::TryInto::try_into(
                            value.available_incoming_bitrate()?,
                        )?,
                        max_incoming_bitrate: ::core::convert::TryInto::try_into(
                            value.max_incoming_bitrate()?,
                        )?,
                        rtp_packet_loss_received: ::core::convert::TryInto::try_into(
                            value.rtp_packet_loss_received()?,
                        )?,
                        rtp_packet_loss_sent: ::core::convert::TryInto::try_into(
                            value.rtp_packet_loss_sent()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StatsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StatsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StatsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Stats>> for Stats {
                type Value = ::planus::Offset<Stats>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Stats>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StatsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StatsRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetMaxIncomingBitrateRequest {
                pub max_incoming_bitrate: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetMaxIncomingBitrateRequest {
                fn default() -> Self {
                    Self {
                        max_incoming_bitrate: 0,
                    }
                }
            }

            impl SetMaxIncomingBitrateRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_max_incoming_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_max_incoming_bitrate =
                        field_max_incoming_bitrate.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_max_incoming_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_max_incoming_bitrate) =
                            prepared_max_incoming_bitrate
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_max_incoming_bitrate);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMaxIncomingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetMaxIncomingBitrateRequest> for SetMaxIncomingBitrateRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxIncomingBitrateRequest> {
                    SetMaxIncomingBitrateRequest::create(builder, &self.max_incoming_bitrate)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetMaxIncomingBitrateRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetMaxIncomingBitrateRequestRef<'a> {
                pub fn max_incoming_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetMaxIncomingBitrateRequest", "max_incoming_bitrate")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetMaxIncomingBitrateRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetMaxIncomingBitrateRequestRef");
                    f.field("max_incoming_bitrate", &self.max_incoming_bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetMaxIncomingBitrateRequestRef<'a>>
                for SetMaxIncomingBitrateRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetMaxIncomingBitrateRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        max_incoming_bitrate: ::core::convert::TryInto::try_into(
                            value.max_incoming_bitrate()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetMaxIncomingBitrateRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetMaxIncomingBitrateRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxIncomingBitrateRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetMaxIncomingBitrateRequest>>
                for SetMaxIncomingBitrateRequest
            {
                type Value = ::planus::Offset<SetMaxIncomingBitrateRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetMaxIncomingBitrateRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetMaxIncomingBitrateRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxIncomingBitrateRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetMaxOutgoingBitrateRequest {
                pub max_outgoing_bitrate: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetMaxOutgoingBitrateRequest {
                fn default() -> Self {
                    Self {
                        max_outgoing_bitrate: 0,
                    }
                }
            }

            impl SetMaxOutgoingBitrateRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_max_outgoing_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_max_outgoing_bitrate =
                        field_max_outgoing_bitrate.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_max_outgoing_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_max_outgoing_bitrate) =
                            prepared_max_outgoing_bitrate
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_max_outgoing_bitrate);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetMaxOutgoingBitrateRequest> for SetMaxOutgoingBitrateRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SetMaxOutgoingBitrateRequest> {
                    SetMaxOutgoingBitrateRequest::create(builder, &self.max_outgoing_bitrate)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SetMaxOutgoingBitrateRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetMaxOutgoingBitrateRequestRef<'a> {
                pub fn max_outgoing_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SetMaxOutgoingBitrateRequest", "max_outgoing_bitrate")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SetMaxOutgoingBitrateRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetMaxOutgoingBitrateRequestRef");
                    f.field("max_outgoing_bitrate", &self.max_outgoing_bitrate());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetMaxOutgoingBitrateRequestRef<'a>>
                for SetMaxOutgoingBitrateRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetMaxOutgoingBitrateRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        max_outgoing_bitrate: ::core::convert::TryInto::try_into(
                            value.max_outgoing_bitrate()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetMaxOutgoingBitrateRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetMaxOutgoingBitrateRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxOutgoingBitrateRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetMaxOutgoingBitrateRequest>>
                for SetMaxOutgoingBitrateRequest
            {
                type Value = ::planus::Offset<SetMaxOutgoingBitrateRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetMaxOutgoingBitrateRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetMaxOutgoingBitrateRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetMaxOutgoingBitrateRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EnableTraceEventRequest {
                pub events: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            }

            impl EnableTraceEventRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_events: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_events = field_events.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_events);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EnableTraceEventRequest> for EnableTraceEventRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    EnableTraceEventRequest::create(builder, &self.events)
                }
            }

            #[derive(Copy, Clone)]
            pub struct EnableTraceEventRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EnableTraceEventRequestRef<'a> {
                pub fn events(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(0, "EnableTraceEventRequest", "events")
                }
            }

            impl<'a> ::core::fmt::Debug for EnableTraceEventRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EnableTraceEventRequestRef");
                    f.field("events", &self.events());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EnableTraceEventRequestRef<'a>> for EnableTraceEventRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EnableTraceEventRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        events: value.events()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EnableTraceEventRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EnableTraceEventRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Value = ::planus::Offset<EnableTraceEventRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EnableTraceEventRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EnableTraceEventRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseProducerRequest {
                pub producer_id: ::planus::alloc::string::String,
            }

            impl CloseProducerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_producer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseProducerRequest>> for CloseProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseProducerRequest>> for CloseProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseProducerRequest> for CloseProducerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseProducerRequest> {
                    CloseProducerRequest::create(builder, &self.producer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseProducerRequestRef<'a> {
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseProducerRequest", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseProducerRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseProducerRequestRef<'a>> for CloseProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseProducerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseProducerRequest>> for CloseProducerRequest {
                type Value = ::planus::Offset<CloseProducerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseProducerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseConsumerRequest {
                pub consumer_id: ::planus::alloc::string::String,
            }

            impl CloseConsumerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_consumer_id = field_consumer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_consumer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseConsumerRequest>> for CloseConsumerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseConsumerRequest>> for CloseConsumerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseConsumerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseConsumerRequest> for CloseConsumerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseConsumerRequest> {
                    CloseConsumerRequest::create(builder, &self.consumer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseConsumerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseConsumerRequestRef<'a> {
                pub fn consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseConsumerRequest", "consumer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseConsumerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseConsumerRequestRef");
                    f.field("consumer_id", &self.consumer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseConsumerRequestRef<'a>> for CloseConsumerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseConsumerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        consumer_id: ::core::convert::TryInto::try_into(value.consumer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseConsumerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseConsumerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseConsumerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseConsumerRequest>> for CloseConsumerRequest {
                type Value = ::planus::Offset<CloseConsumerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseConsumerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseConsumerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseConsumerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseDataProducerRequest {
                pub data_producer_id: ::planus::alloc::string::String,
            }

            impl CloseDataProducerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_producer_id = field_data_producer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data_producer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseDataProducerRequest>> for CloseDataProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseDataProducerRequest>>
                for CloseDataProducerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseDataProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseDataProducerRequest> for CloseDataProducerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataProducerRequest> {
                    CloseDataProducerRequest::create(builder, &self.data_producer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseDataProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseDataProducerRequestRef<'a> {
                pub fn data_producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseDataProducerRequest", "data_producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseDataProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseDataProducerRequestRef");
                    f.field("data_producer_id", &self.data_producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseDataProducerRequestRef<'a>> for CloseDataProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseDataProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_producer_id: ::core::convert::TryInto::try_into(
                            value.data_producer_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseDataProducerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseDataProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseDataProducerRequest>>
                for CloseDataProducerRequest
            {
                type Value = ::planus::Offset<CloseDataProducerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseDataProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseDataProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataProducerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseDataConsumerRequest {
                pub data_consumer_id: ::planus::alloc::string::String,
            }

            impl CloseDataConsumerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data_consumer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data_consumer_id = field_data_consumer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data_consumer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseDataConsumerRequest>> for CloseDataConsumerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseDataConsumerRequest>>
                for CloseDataConsumerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseDataConsumerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseDataConsumerRequest> for CloseDataConsumerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseDataConsumerRequest> {
                    CloseDataConsumerRequest::create(builder, &self.data_consumer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseDataConsumerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseDataConsumerRequestRef<'a> {
                pub fn data_consumer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseDataConsumerRequest", "data_consumer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseDataConsumerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseDataConsumerRequestRef");
                    f.field("data_consumer_id", &self.data_consumer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseDataConsumerRequestRef<'a>> for CloseDataConsumerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseDataConsumerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data_consumer_id: ::core::convert::TryInto::try_into(
                            value.data_consumer_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseDataConsumerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseDataConsumerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataConsumerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseDataConsumerRequest>>
                for CloseDataConsumerRequest
            {
                type Value = ::planus::Offset<CloseDataConsumerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseDataConsumerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseDataConsumerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseDataConsumerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendRtcpNotification {
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl SendRtcpNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[u8]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendRtcpNotification>> for SendRtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendRtcpNotification>> for SendRtcpNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendRtcpNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendRtcpNotification> for SendRtcpNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendRtcpNotification> {
                    SendRtcpNotification::create(builder, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SendRtcpNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendRtcpNotificationRef<'a> {
                pub fn data(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(0, "SendRtcpNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendRtcpNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendRtcpNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendRtcpNotificationRef<'a>> for SendRtcpNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendRtcpNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendRtcpNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendRtcpNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendRtcpNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendRtcpNotification>> for SendRtcpNotification {
                type Value = ::planus::Offset<SendRtcpNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendRtcpNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendRtcpNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendRtcpNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SctpStateChangeNotification {
                pub sctp_state: super::sctp_association::SctpState,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SctpStateChangeNotification {
                fn default() -> Self {
                    Self {
                        sctp_state: super::sctp_association::SctpState::New,
                    }
                }
            }

            impl SctpStateChangeNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_sctp_state: impl ::planus::WriteAsDefault<
                        super::sctp_association::SctpState,
                        super::sctp_association::SctpState,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_sctp_state =
                        field_sctp_state.prepare(builder, &super::sctp_association::SctpState::New);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_sctp_state.is_some() {
                        table_writer.calculate_size::<super::sctp_association::SctpState>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_sctp_state) =
                            prepared_sctp_state
                        {
                            table_writer.write::<_, _, 1>(0, &prepared_sctp_state);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SctpStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SctpStateChangeNotification> for SctpStateChangeNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SctpStateChangeNotification> {
                    SctpStateChangeNotification::create(builder, &self.sctp_state)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SctpStateChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SctpStateChangeNotificationRef<'a> {
                pub fn sctp_state(&self) -> ::planus::Result<super::sctp_association::SctpState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "SctpStateChangeNotification", "sctp_state")?
                            .unwrap_or(super::sctp_association::SctpState::New),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SctpStateChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SctpStateChangeNotificationRef");
                    f.field("sctp_state", &self.sctp_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SctpStateChangeNotificationRef<'a>>
                for SctpStateChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SctpStateChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        sctp_state: ::core::convert::TryInto::try_into(value.sctp_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SctpStateChangeNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SctpStateChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStateChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SctpStateChangeNotification>>
                for SctpStateChangeNotification
            {
                type Value = ::planus::Offset<SctpStateChangeNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SctpStateChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SctpStateChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SctpStateChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceType {
                Probation = 0,
                Bwe = 1,
            }

            impl ::core::convert::TryFrom<u8> for TraceType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceType::Probation),
                        1 => ::core::result::Result::Ok(TraceType::Bwe),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceType> for u8 {
                fn from(value: TraceType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceType> for TraceType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceType, TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceType,
                ) -> ::core::option::Option<TraceType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceType {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceType> for TraceType {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceDirection {
                DirectionIn = 0,
                DirectionOut = 1,
            }

            impl ::core::convert::TryFrom<u8> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceDirection::DirectionIn),
                        1 => ::core::result::Result::Ok(TraceDirection::DirectionOut),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceDirection> for u8 {
                fn from(value: TraceDirection) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceDirection {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceDirection> for TraceDirection {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceDirection {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceDirection, TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceDirection,
                ) -> ::core::option::Option<TraceDirection> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceDirection> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceDirection {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceDirection",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceDirection> for TraceDirection {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum TraceInfo {
                BweTraceInfo(::planus::alloc::boxed::Box<self::BweTraceInfo>),
            }

            impl TraceInfo {
                pub fn create_bwe_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::BweTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<TraceInfo> for TraceInfo {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::BweTraceInfo(value) => Self::create_bwe_trace_info(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum TraceInfoRef<'a> {
                BweTraceInfo(self::BweTraceInfoRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<TraceInfoRef<'a>> for TraceInfo {
                type Error = ::planus::Error;

                fn try_from(value: TraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        TraceInfoRef::BweTraceInfo(value) => {
                            TraceInfo::BweTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for TraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::BweTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BweType {
                TransportCc = 0,
                Remb = 1,
            }

            impl ::core::convert::TryFrom<u8> for BweType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BweType::TransportCc),
                        1 => ::core::result::Result::Ok(BweType::Remb),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BweType> for u8 {
                fn from(value: BweType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BweType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BweType> for BweType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BweType> for BweType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BweType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BweType, BweType> for BweType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BweType,
                ) -> ::core::option::Option<BweType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BweType> for BweType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BweType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BweType {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BweType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BweType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BweType> for BweType {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BweTraceInfo {
                pub desired_bitrate: u32,
                pub effective_desired_bitrate: u32,
                pub min_bitrate: u32,
                pub max_bitrate: u32,
                pub start_bitrate: u32,
                pub max_padding_bitrate: u32,
                pub available_bitrate: u32,
                pub bwe_type: self::BweType,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BweTraceInfo {
                fn default() -> Self {
                    Self {
                        desired_bitrate: 0,
                        effective_desired_bitrate: 0,
                        min_bitrate: 0,
                        max_bitrate: 0,
                        start_bitrate: 0,
                        max_padding_bitrate: 0,
                        available_bitrate: 0,
                        bwe_type: self::BweType::TransportCc,
                    }
                }
            }

            impl BweTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_desired_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_effective_desired_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_min_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_max_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_start_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_max_padding_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_available_bitrate: impl ::planus::WriteAsDefault<u32, u32>,
                    field_bwe_type: impl ::planus::WriteAsDefault<self::BweType, self::BweType>,
                ) -> ::planus::Offset<Self> {
                    let prepared_desired_bitrate = field_desired_bitrate.prepare(builder, &0);

                    let prepared_effective_desired_bitrate =
                        field_effective_desired_bitrate.prepare(builder, &0);

                    let prepared_min_bitrate = field_min_bitrate.prepare(builder, &0);

                    let prepared_max_bitrate = field_max_bitrate.prepare(builder, &0);

                    let prepared_start_bitrate = field_start_bitrate.prepare(builder, &0);

                    let prepared_max_padding_bitrate =
                        field_max_padding_bitrate.prepare(builder, &0);

                    let prepared_available_bitrate = field_available_bitrate.prepare(builder, &0);

                    let prepared_bwe_type =
                        field_bwe_type.prepare(builder, &self::BweType::TransportCc);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 29>::new(builder);

                    if prepared_desired_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_effective_desired_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    if prepared_min_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(6);
                    }
                    if prepared_max_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(8);
                    }
                    if prepared_start_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(10);
                    }
                    if prepared_max_padding_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(12);
                    }
                    if prepared_available_bitrate.is_some() {
                        table_writer.calculate_size::<u32>(14);
                    }
                    if prepared_bwe_type.is_some() {
                        table_writer.calculate_size::<self::BweType>(16);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_desired_bitrate) =
                            prepared_desired_bitrate
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_desired_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_effective_desired_bitrate) =
                            prepared_effective_desired_bitrate
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_effective_desired_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_min_bitrate) =
                            prepared_min_bitrate
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_min_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_max_bitrate) =
                            prepared_max_bitrate
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_max_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_start_bitrate) =
                            prepared_start_bitrate
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_start_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_max_padding_bitrate) =
                            prepared_max_padding_bitrate
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_max_padding_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_available_bitrate) =
                            prepared_available_bitrate
                        {
                            table_writer.write::<_, _, 4>(6, &prepared_available_bitrate);
                        }
                        if let ::core::option::Option::Some(prepared_bwe_type) = prepared_bwe_type {
                            table_writer.write::<_, _, 1>(7, &prepared_bwe_type);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BweTraceInfo>> for BweTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BweTraceInfo>> for BweTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BweTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BweTraceInfo> for BweTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BweTraceInfo> {
                    BweTraceInfo::create(
                        builder,
                        &self.desired_bitrate,
                        &self.effective_desired_bitrate,
                        &self.min_bitrate,
                        &self.max_bitrate,
                        &self.start_bitrate,
                        &self.max_padding_bitrate,
                        &self.available_bitrate,
                        &self.bwe_type,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct BweTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BweTraceInfoRef<'a> {
                pub fn desired_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "BweTraceInfo", "desired_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn effective_desired_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "BweTraceInfo", "effective_desired_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn min_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "BweTraceInfo", "min_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn max_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "BweTraceInfo", "max_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn start_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "BweTraceInfo", "start_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn max_padding_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "BweTraceInfo", "max_padding_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn available_bitrate(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "BweTraceInfo", "available_bitrate")?
                            .unwrap_or(0),
                    )
                }

                pub fn bwe_type(&self) -> ::planus::Result<self::BweType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "BweTraceInfo", "bwe_type")?
                            .unwrap_or(self::BweType::TransportCc),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BweTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BweTraceInfoRef");
                    f.field("desired_bitrate", &self.desired_bitrate());
                    f.field(
                        "effective_desired_bitrate",
                        &self.effective_desired_bitrate(),
                    );
                    f.field("min_bitrate", &self.min_bitrate());
                    f.field("max_bitrate", &self.max_bitrate());
                    f.field("start_bitrate", &self.start_bitrate());
                    f.field("max_padding_bitrate", &self.max_padding_bitrate());
                    f.field("available_bitrate", &self.available_bitrate());
                    f.field("bwe_type", &self.bwe_type());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BweTraceInfoRef<'a>> for BweTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BweTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        desired_bitrate: ::core::convert::TryInto::try_into(
                            value.desired_bitrate()?,
                        )?,
                        effective_desired_bitrate: ::core::convert::TryInto::try_into(
                            value.effective_desired_bitrate()?,
                        )?,
                        min_bitrate: ::core::convert::TryInto::try_into(value.min_bitrate()?)?,
                        max_bitrate: ::core::convert::TryInto::try_into(value.max_bitrate()?)?,
                        start_bitrate: ::core::convert::TryInto::try_into(value.start_bitrate()?)?,
                        max_padding_bitrate: ::core::convert::TryInto::try_into(
                            value.max_padding_bitrate()?,
                        )?,
                        available_bitrate: ::core::convert::TryInto::try_into(
                            value.available_bitrate()?,
                        )?,
                        bwe_type: ::core::convert::TryInto::try_into(value.bwe_type()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BweTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BweTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BweTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BweTraceInfo>> for BweTraceInfo {
                type Value = ::planus::Offset<BweTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BweTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BweTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BweTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TraceNotification {
                pub type_: self::TraceType,
                pub timestamp: u64,
                pub direction: self::TraceDirection,
                pub info: ::core::option::Option<self::TraceInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for TraceNotification {
                fn default() -> Self {
                    Self {
                        type_: self::TraceType::Probation,
                        timestamp: 0,
                        direction: self::TraceDirection::DirectionIn,
                        info: ::core::default::Default::default(),
                    }
                }
            }

            impl TraceNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<self::TraceType, self::TraceType>,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_direction: impl ::planus::WriteAsDefault<
                        self::TraceDirection,
                        self::TraceDirection,
                    >,
                    field_info: impl ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder, &self::TraceType::Probation);

                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_direction =
                        field_direction.prepare(builder, &self::TraceDirection::DirectionIn);

                    let prepared_info = field_info.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 15>::new(builder);

                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<self::TraceType>(2);
                    }
                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }
                    if prepared_direction.is_some() {
                        table_writer.calculate_size::<self::TraceDirection>(6);
                    }
                    if prepared_info.is_some() {
                        table_writer.calculate_size::<u8>(8);
                        table_writer.calculate_size::<::planus::Offset<self::TraceInfo>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(1, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_info) = prepared_info {
                            table_writer.write::<_, _, 4>(4, &prepared_info.offset());
                        }
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(0, &prepared_type_);
                        }
                        if let ::core::option::Option::Some(prepared_direction) = prepared_direction
                        {
                            table_writer.write::<_, _, 1>(2, &prepared_direction);
                        }
                        if let ::core::option::Option::Some(prepared_info) = prepared_info {
                            table_writer.write::<_, _, 1>(3, &prepared_info.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TraceNotification> for TraceNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    TraceNotification::create(
                        builder,
                        &self.type_,
                        &self.timestamp,
                        &self.direction,
                        &self.info,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct TraceNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TraceNotificationRef<'a> {
                pub fn type_(&self) -> ::planus::Result<self::TraceType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TraceNotification", "type_")?
                            .unwrap_or(self::TraceType::Probation),
                    )
                }

                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "TraceNotification", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                pub fn direction(&self) -> ::planus::Result<self::TraceDirection> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "TraceNotification", "direction")?
                            .unwrap_or(self::TraceDirection::DirectionIn),
                    )
                }

                pub fn info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TraceInfoRef<'a>>>
                {
                    self.0.access_union(3, "TraceNotification", "info")
                }
            }

            impl<'a> ::core::fmt::Debug for TraceNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TraceNotificationRef");
                    f.field("type_", &self.type_());
                    f.field("timestamp", &self.timestamp());
                    f.field("direction", &self.direction());
                    if let ::core::option::Option::Some(field_info) = self.info().transpose() {
                        f.field("info", &field_info);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TraceNotificationRef<'a>> for TraceNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TraceNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        direction: ::core::convert::TryInto::try_into(value.direction()?)?,
                        info: if let ::core::option::Option::Some(info) = value.info()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(info)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TraceNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TraceNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TraceNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TraceNotification>> for TraceNotification {
                type Value = ::planus::Offset<TraceNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TraceNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TraceNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TraceNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod sctp_association {
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum SctpState {
                New = 0,
                Connecting = 1,
                Connected = 2,
                Failed = 3,
                Closed = 4,
            }

            impl ::core::convert::TryFrom<u8> for SctpState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(SctpState::New),
                        1 => ::core::result::Result::Ok(SctpState::Connecting),
                        2 => ::core::result::Result::Ok(SctpState::Connected),
                        3 => ::core::result::Result::Ok(SctpState::Failed),
                        4 => ::core::result::Result::Ok(SctpState::Closed),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<SctpState> for u8 {
                fn from(value: SctpState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for SctpState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<SctpState> for SctpState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<SctpState> for SctpState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> SctpState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<SctpState, SctpState> for SctpState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &SctpState,
                ) -> ::core::option::Option<SctpState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<SctpState> for SctpState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<SctpState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for SctpState {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for SctpState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "SctpState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<SctpState> for SctpState {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }
        }
        pub mod log {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Log {
                pub data: ::planus::alloc::string::String,
            }

            impl Log {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Log>> for Log {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Log>> for Log {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Log>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Log> for Log {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Log> {
                    Log::create(builder, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct LogRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> LogRef<'a> {
                pub fn data(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Log", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for LogRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("LogRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<LogRef<'a>> for Log {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: LogRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for LogRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for LogRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location("[LogRef]", "get", buffer.offset_from_start)
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Log>> for Log {
                type Value = ::planus::Offset<Log>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Log>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for LogRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[LogRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod message {
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Type {
                Request = 0,
                Response = 1,
                Notification = 2,
                Log = 3,
            }

            impl ::core::convert::TryFrom<u8> for Type {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Type::Request),
                        1 => ::core::result::Result::Ok(Type::Response),
                        2 => ::core::result::Result::Ok(Type::Notification),
                        3 => ::core::result::Result::Ok(Type::Log),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Type> for u8 {
                fn from(value: Type) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Type {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Type> for Type {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Type {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Type, Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Type,
                ) -> ::core::option::Option<Type> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Type> for Type {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Type> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Type {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Type {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Type",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Type> for Type {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Body {
                Request(::planus::alloc::boxed::Box<super::request::Request>),
                Response(::planus::alloc::boxed::Box<super::response::Response>),
                Notification(::planus::alloc::boxed::Box<super::notification::Notification>),
                Log(::planus::alloc::boxed::Box<super::log::Log>),
            }

            impl Body {
                pub fn create_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::request::Request>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::response::Response>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::notification::Notification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_log(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::log::Log>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::Request(value) => Self::create_request(builder, value),
                        Self::Response(value) => Self::create_response(builder, value),
                        Self::Notification(value) => Self::create_notification(builder, value),
                        Self::Log(value) => Self::create_log(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                Request(super::request::RequestRef<'a>),
                Response(super::response::ResponseRef<'a>),
                Notification(super::notification::NotificationRef<'a>),
                Log(super::log::LogRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::Request(value) => Body::Request(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),

                        BodyRef::Response(value) => {
                            Body::Response(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::Notification(value) => {
                            Body::Notification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::Log(value) => Body::Log(::planus::alloc::boxed::Box::new(
                            ::core::convert::TryFrom::try_from(value)?,
                        )),
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::Request(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Response(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::Notification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::Log(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Message {
                pub type_: self::Type,
                pub data: self::Body,
            }

            impl Message {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<self::Type, self::Type>,
                    field_data: impl ::planus::WriteAsUnion<self::Body>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder, &self::Type::Request);

                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 6>::new(builder);

                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<self::Type>(2);
                    }
                    table_writer.calculate_size::<u8>(4);
                    table_writer.calculate_size::<::planus::Offset<self::Body>>(6);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(2, &prepared_data.offset());
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(0, &prepared_type_);
                        }
                        table_writer.write::<_, _, 1>(1, &prepared_data.tag());
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Message>> for Message {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Message>> for Message {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Message>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Message> for Message {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Message> {
                    Message::create(builder, &self.type_, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct MessageRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MessageRef<'a> {
                pub fn type_(&self) -> ::planus::Result<self::Type> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "Message", "type_")?
                            .unwrap_or(self::Type::Request),
                    )
                }

                pub fn data(&self) -> ::planus::Result<self::BodyRef<'a>> {
                    self.0.access_union_required(1, "Message", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for MessageRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MessageRef");
                    f.field("type_", &self.type_());
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MessageRef<'a>> for Message {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MessageRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        data: ::core::convert::TryInto::try_into(value.data()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MessageRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MessageRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MessageRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Message>> for Message {
                type Value = ::planus::Offset<Message>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Message>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MessageRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[MessageRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod notification {
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Event {
                TransportSendRtcp = 0,
                ProducerSend = 1,
                DataProducerSend = 2,
                WorkerRunning = 3,
                TransportSctpStateChange = 4,
                TransportTrace = 5,
                WebrtctransportIceSelectedTupleChange = 6,
                WebrtctransportIceStateChange = 7,
                WebrtctransportDtlsStateChange = 8,
                PlaintransportTuple = 9,
                PlaintransportRtcpTuple = 10,
                DirecttransportRtcp = 11,
                ProducerScore = 12,
                ProducerTrace = 13,
                ProducerVideoOrientationChange = 14,
                ConsumerProducerPause = 15,
                ConsumerProducerResume = 16,
                ConsumerProducerClose = 17,
                ConsumerLayersChange = 18,
                ConsumerRtp = 19,
                ConsumerScore = 20,
                ConsumerTrace = 21,
                DataconsumerBufferedAmountLow = 22,
                DataconsumerSctpSendbufferFull = 23,
                DataconsumerDataproducerClose = 24,
                DataconsumerMessage = 25,
                ActivespeakerobserverDominantSpeaker = 26,
                AudiolevelobserverSilence = 27,
                AudiolevelobserverVolumes = 28,
            }

            impl ::core::convert::TryFrom<u8> for Event {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Event::TransportSendRtcp),
                        1 => ::core::result::Result::Ok(Event::ProducerSend),
                        2 => ::core::result::Result::Ok(Event::DataProducerSend),
                        3 => ::core::result::Result::Ok(Event::WorkerRunning),
                        4 => ::core::result::Result::Ok(Event::TransportSctpStateChange),
                        5 => ::core::result::Result::Ok(Event::TransportTrace),
                        6 => {
                            ::core::result::Result::Ok(Event::WebrtctransportIceSelectedTupleChange)
                        }
                        7 => ::core::result::Result::Ok(Event::WebrtctransportIceStateChange),
                        8 => ::core::result::Result::Ok(Event::WebrtctransportDtlsStateChange),
                        9 => ::core::result::Result::Ok(Event::PlaintransportTuple),
                        10 => ::core::result::Result::Ok(Event::PlaintransportRtcpTuple),
                        11 => ::core::result::Result::Ok(Event::DirecttransportRtcp),
                        12 => ::core::result::Result::Ok(Event::ProducerScore),
                        13 => ::core::result::Result::Ok(Event::ProducerTrace),
                        14 => ::core::result::Result::Ok(Event::ProducerVideoOrientationChange),
                        15 => ::core::result::Result::Ok(Event::ConsumerProducerPause),
                        16 => ::core::result::Result::Ok(Event::ConsumerProducerResume),
                        17 => ::core::result::Result::Ok(Event::ConsumerProducerClose),
                        18 => ::core::result::Result::Ok(Event::ConsumerLayersChange),
                        19 => ::core::result::Result::Ok(Event::ConsumerRtp),
                        20 => ::core::result::Result::Ok(Event::ConsumerScore),
                        21 => ::core::result::Result::Ok(Event::ConsumerTrace),
                        22 => ::core::result::Result::Ok(Event::DataconsumerBufferedAmountLow),
                        23 => ::core::result::Result::Ok(Event::DataconsumerSctpSendbufferFull),
                        24 => ::core::result::Result::Ok(Event::DataconsumerDataproducerClose),
                        25 => ::core::result::Result::Ok(Event::DataconsumerMessage),
                        26 => {
                            ::core::result::Result::Ok(Event::ActivespeakerobserverDominantSpeaker)
                        }
                        27 => ::core::result::Result::Ok(Event::AudiolevelobserverSilence),
                        28 => ::core::result::Result::Ok(Event::AudiolevelobserverVolumes),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Event> for u8 {
                fn from(value: Event) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Event {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Event> for Event {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Event> for Event {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Event {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Event, Event> for Event {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Event,
                ) -> ::core::option::Option<Event> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Event> for Event {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Event> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Event {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Event {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Event",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Event> for Event {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Body {
                SendRtcpNotification(
                    ::planus::alloc::boxed::Box<super::transport::SendRtcpNotification>,
                ),
                SctpStateChangeNotification(
                    ::planus::alloc::boxed::Box<super::transport::SctpStateChangeNotification>,
                ),
                SendNotification(
                    ::planus::alloc::boxed::Box<super::data_producer::SendNotification>,
                ),
                TraceNotification(::planus::alloc::boxed::Box<super::consumer::TraceNotification>),
                IceSelectedTupleChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::web_rtc_transport::IceSelectedTupleChangeNotification,
                    >,
                ),
                IceStateChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::web_rtc_transport::IceStateChangeNotification,
                    >,
                ),
                DtlsStateChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::web_rtc_transport::DtlsStateChangeNotification,
                    >,
                ),
                TupleNotification(
                    ::planus::alloc::boxed::Box<super::plain_transport::TupleNotification>,
                ),
                RtcpTupleNotification(
                    ::planus::alloc::boxed::Box<super::plain_transport::RtcpTupleNotification>,
                ),
                RtcpNotification(
                    ::planus::alloc::boxed::Box<super::direct_transport::RtcpNotification>,
                ),
                ScoreNotification(::planus::alloc::boxed::Box<super::consumer::ScoreNotification>),
                VideoOrientationChangeNotification(
                    ::planus::alloc::boxed::Box<
                        super::producer::VideoOrientationChangeNotification,
                    >,
                ),
                LayersChangeNotification(
                    ::planus::alloc::boxed::Box<super::consumer::LayersChangeNotification>,
                ),
                RtpNotification(::planus::alloc::boxed::Box<super::consumer::RtpNotification>),
                MessageNotification(
                    ::planus::alloc::boxed::Box<super::data_consumer::MessageNotification>,
                ),
                BufferedAmountLowNotification(
                    ::planus::alloc::boxed::Box<
                        super::data_consumer::BufferedAmountLowNotification,
                    >,
                ),
                DominantSpeakerNotification(
                    ::planus::alloc::boxed::Box<
                        super::active_speaker_observer::DominantSpeakerNotification,
                    >,
                ),
                VolumesNotification(
                    ::planus::alloc::boxed::Box<super::audio_level_observer::VolumesNotification>,
                ),
            }

            impl Body {
                pub fn create_send_rtcp_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SendRtcpNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_sctp_state_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SctpStateChangeNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_send_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_producer::SendNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_trace_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::TraceNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                pub fn create_ice_selected_tuple_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::web_rtc_transport::IceSelectedTupleChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                pub fn create_ice_state_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::web_rtc_transport::IceStateChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }

                pub fn create_dtls_state_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::web_rtc_transport::DtlsStateChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
                }

                pub fn create_tuple_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::TupleNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
                }

                pub fn create_rtcp_tuple_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::plain_transport::RtcpTupleNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
                }

                pub fn create_rtcp_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::direct_transport::RtcpNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
                }

                pub fn create_score_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::ScoreNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
                }

                pub fn create_video_orientation_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::producer::VideoOrientationChangeNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
                }

                pub fn create_layers_change_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::LayersChangeNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
                }

                pub fn create_rtp_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::RtpNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
                }

                pub fn create_message_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::MessageNotification>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
                }

                pub fn create_buffered_amount_low_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::data_consumer::BufferedAmountLowNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
                }

                pub fn create_dominant_speaker_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::active_speaker_observer::DominantSpeakerNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
                }

                pub fn create_volumes_notification(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::audio_level_observer::VolumesNotification,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::SendRtcpNotification(value) => {
                            Self::create_send_rtcp_notification(builder, value)
                        }
                        Self::SctpStateChangeNotification(value) => {
                            Self::create_sctp_state_change_notification(builder, value)
                        }
                        Self::SendNotification(value) => {
                            Self::create_send_notification(builder, value)
                        }
                        Self::TraceNotification(value) => {
                            Self::create_trace_notification(builder, value)
                        }
                        Self::IceSelectedTupleChangeNotification(value) => {
                            Self::create_ice_selected_tuple_change_notification(builder, value)
                        }
                        Self::IceStateChangeNotification(value) => {
                            Self::create_ice_state_change_notification(builder, value)
                        }
                        Self::DtlsStateChangeNotification(value) => {
                            Self::create_dtls_state_change_notification(builder, value)
                        }
                        Self::TupleNotification(value) => {
                            Self::create_tuple_notification(builder, value)
                        }
                        Self::RtcpTupleNotification(value) => {
                            Self::create_rtcp_tuple_notification(builder, value)
                        }
                        Self::RtcpNotification(value) => {
                            Self::create_rtcp_notification(builder, value)
                        }
                        Self::ScoreNotification(value) => {
                            Self::create_score_notification(builder, value)
                        }
                        Self::VideoOrientationChangeNotification(value) => {
                            Self::create_video_orientation_change_notification(builder, value)
                        }
                        Self::LayersChangeNotification(value) => {
                            Self::create_layers_change_notification(builder, value)
                        }
                        Self::RtpNotification(value) => {
                            Self::create_rtp_notification(builder, value)
                        }
                        Self::MessageNotification(value) => {
                            Self::create_message_notification(builder, value)
                        }
                        Self::BufferedAmountLowNotification(value) => {
                            Self::create_buffered_amount_low_notification(builder, value)
                        }
                        Self::DominantSpeakerNotification(value) => {
                            Self::create_dominant_speaker_notification(builder, value)
                        }
                        Self::VolumesNotification(value) => {
                            Self::create_volumes_notification(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                SendRtcpNotification(super::transport::SendRtcpNotificationRef<'a>),
                SctpStateChangeNotification(super::transport::SctpStateChangeNotificationRef<'a>),
                SendNotification(super::data_producer::SendNotificationRef<'a>),
                TraceNotification(super::consumer::TraceNotificationRef<'a>),
                IceSelectedTupleChangeNotification(
                    super::web_rtc_transport::IceSelectedTupleChangeNotificationRef<'a>,
                ),
                IceStateChangeNotification(
                    super::web_rtc_transport::IceStateChangeNotificationRef<'a>,
                ),
                DtlsStateChangeNotification(
                    super::web_rtc_transport::DtlsStateChangeNotificationRef<'a>,
                ),
                TupleNotification(super::plain_transport::TupleNotificationRef<'a>),
                RtcpTupleNotification(super::plain_transport::RtcpTupleNotificationRef<'a>),
                RtcpNotification(super::direct_transport::RtcpNotificationRef<'a>),
                ScoreNotification(super::consumer::ScoreNotificationRef<'a>),
                VideoOrientationChangeNotification(
                    super::producer::VideoOrientationChangeNotificationRef<'a>,
                ),
                LayersChangeNotification(super::consumer::LayersChangeNotificationRef<'a>),
                RtpNotification(super::consumer::RtpNotificationRef<'a>),
                MessageNotification(super::data_consumer::MessageNotificationRef<'a>),
                BufferedAmountLowNotification(
                    super::data_consumer::BufferedAmountLowNotificationRef<'a>,
                ),
                DominantSpeakerNotification(
                    super::active_speaker_observer::DominantSpeakerNotificationRef<'a>,
                ),
                VolumesNotification(super::audio_level_observer::VolumesNotificationRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::SendRtcpNotification(value) => {
                            Body::SendRtcpNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SctpStateChangeNotification(value) => {
                            Body::SctpStateChangeNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SendNotification(value) => {
                            Body::SendNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TraceNotification(value) => {
                            Body::TraceNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::IceSelectedTupleChangeNotification(value) => {
                            Body::IceSelectedTupleChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::IceStateChangeNotification(value) => {
                            Body::IceStateChangeNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DtlsStateChangeNotification(value) => {
                            Body::DtlsStateChangeNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::TupleNotification(value) => {
                            Body::TupleNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RtcpTupleNotification(value) => {
                            Body::RtcpTupleNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RtcpNotification(value) => {
                            Body::RtcpNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ScoreNotification(value) => {
                            Body::ScoreNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::VideoOrientationChangeNotification(value) => {
                            Body::VideoOrientationChangeNotification(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::LayersChangeNotification(value) => {
                            Body::LayersChangeNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RtpNotification(value) => {
                            Body::RtpNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::MessageNotification(value) => {
                            Body::MessageNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::BufferedAmountLowNotification(value) => {
                            Body::BufferedAmountLowNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::DominantSpeakerNotification(value) => {
                            Body::DominantSpeakerNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::VolumesNotification(value) => {
                            Body::VolumesNotification(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::SendRtcpNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::SctpStateChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::SendNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::TraceNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::IceSelectedTupleChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(Self::IceStateChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        7 => ::core::result::Result::Ok(Self::DtlsStateChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        8 => ::core::result::Result::Ok(Self::TupleNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        9 => ::core::result::Result::Ok(Self::RtcpTupleNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        10 => ::core::result::Result::Ok(Self::RtcpNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        11 => ::core::result::Result::Ok(Self::ScoreNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        12 => ::core::result::Result::Ok(Self::VideoOrientationChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        13 => ::core::result::Result::Ok(Self::LayersChangeNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        14 => ::core::result::Result::Ok(Self::RtpNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        15 => ::core::result::Result::Ok(Self::MessageNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        16 => ::core::result::Result::Ok(Self::BufferedAmountLowNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        17 => ::core::result::Result::Ok(Self::DominantSpeakerNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        18 => ::core::result::Result::Ok(Self::VolumesNotification(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Notification {
                pub handler_id: ::core::option::Option<::planus::alloc::string::String>,
                pub event: self::Event,
                pub body: ::core::option::Option<self::Body>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Notification {
                fn default() -> Self {
                    Self {
                        handler_id: ::core::default::Default::default(),
                        event: self::Event::TransportSendRtcp,
                        body: ::core::default::Default::default(),
                    }
                }
            }

            impl Notification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_handler_id: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_event: impl ::planus::WriteAsDefault<self::Event, self::Event>,
                    field_body: impl ::planus::WriteAsOptionalUnion<self::Body>,
                ) -> ::planus::Offset<Self> {
                    let prepared_handler_id = field_handler_id.prepare(builder);

                    let prepared_event =
                        field_event.prepare(builder, &self::Event::TransportSendRtcp);

                    let prepared_body = field_body.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 10>::new(builder);

                    if prepared_handler_id.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }
                    if prepared_event.is_some() {
                        table_writer.calculate_size::<self::Event>(4);
                    }
                    if prepared_body.is_some() {
                        table_writer.calculate_size::<u8>(6);
                        table_writer.calculate_size::<::planus::Offset<self::Body>>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_handler_id) =
                            prepared_handler_id
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_handler_id);
                        }
                        if let ::core::option::Option::Some(prepared_body) = prepared_body {
                            table_writer.write::<_, _, 4>(3, &prepared_body.offset());
                        }
                        if let ::core::option::Option::Some(prepared_event) = prepared_event {
                            table_writer.write::<_, _, 1>(1, &prepared_event);
                        }
                        if let ::core::option::Option::Some(prepared_body) = prepared_body {
                            table_writer.write::<_, _, 1>(2, &prepared_body.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Notification>> for Notification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Notification>> for Notification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Notification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Notification> for Notification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Notification> {
                    Notification::create(builder, &self.handler_id, &self.event, &self.body)
                }
            }

            #[derive(Copy, Clone)]
            pub struct NotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> NotificationRef<'a> {
                pub fn handler_id(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "Notification", "handler_id")
                }

                pub fn event(&self) -> ::planus::Result<self::Event> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "Notification", "event")?
                            .unwrap_or(self::Event::TransportSendRtcp),
                    )
                }

                pub fn body(&self) -> ::planus::Result<::core::option::Option<self::BodyRef<'a>>> {
                    self.0.access_union(2, "Notification", "body")
                }
            }

            impl<'a> ::core::fmt::Debug for NotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("NotificationRef");
                    if let ::core::option::Option::Some(field_handler_id) =
                        self.handler_id().transpose()
                    {
                        f.field("handler_id", &field_handler_id);
                    }
                    f.field("event", &self.event());
                    if let ::core::option::Option::Some(field_body) = self.body().transpose() {
                        f.field("body", &field_body);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<NotificationRef<'a>> for Notification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: NotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        handler_id: if let ::core::option::Option::Some(handler_id) =
                            value.handler_id()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                handler_id,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        event: ::core::convert::TryInto::try_into(value.event()?)?,
                        body: if let ::core::option::Option::Some(body) = value.body()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(body)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for NotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for NotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[NotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Notification>> for Notification {
                type Value = ::planus::Offset<Notification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Notification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for NotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[NotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod request {
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Method {
                WorkerClose = 0,
                WorkerDump = 1,
                WorkerGetResourceUsage = 2,
                WorkerUpdateSettings = 3,
                WorkerCreateWebrtcServer = 4,
                WorkerCreateRouter = 5,
                WorkerWebrtcServerClose = 6,
                WorkerCloseRouter = 7,
                WebrtcServerDump = 8,
                RouterDump = 9,
                RouterCreateWebrtcTransport = 10,
                RouterCreateWebrtcTransportWithServer = 11,
                RouterCreatePlainTransport = 12,
                RouterCreatePipeTransport = 13,
                RouterCreateDirectTransport = 14,
                RouterCloseTransport = 15,
                RouterCreateActiveSpeakerObserver = 16,
                RouterCreateAudioLevelObserver = 17,
                RouterCloseRtpObserver = 18,
                TransportDump = 19,
                TransportGetStats = 20,
                TransportConnect = 21,
                TransportSetMaxIncomingBitrate = 22,
                TransportSetMaxOutgoingBitrate = 23,
                TransportRestartIce = 24,
                TransportProduce = 25,
                TransportProduceData = 26,
                TransportConsume = 27,
                TransportConsumeData = 28,
                TransportEnableTraceEvent = 29,
                TransportCloseProducer = 30,
                TransportCloseConsumer = 31,
                TransportCloseDataProducer = 32,
                TransportCloseDataConsumer = 33,
                PlainTransportConnect = 34,
                PipeTransportConnect = 35,
                WebrtcTransportConnect = 36,
                ProducerDump = 37,
                ProducerGetStats = 38,
                ProducerPause = 39,
                ProducerResume = 40,
                ProducerEnableTraceEvent = 41,
                ConsumerDump = 42,
                ConsumerGetStats = 43,
                ConsumerPause = 44,
                ConsumerResume = 45,
                ConsumerSetPreferredLayers = 46,
                ConsumerSetPriority = 47,
                ConsumerRequestKeyFrame = 48,
                ConsumerEnableTraceEvent = 49,
                DataProducerDump = 50,
                DataProducerGetStats = 51,
                DataConsumerDump = 52,
                DataConsumerGetStats = 53,
                DataConsumerGetBufferedAmount = 54,
                DataConsumerSetBufferedAmountLowThreshold = 55,
                DataConsumerSend = 56,
                RtpObserverPause = 57,
                RtpObserverResume = 58,
                RtpObserverAddProducer = 59,
                RtpObserverRemoveProducer = 60,
            }

            impl ::core::convert::TryFrom<u8> for Method {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Method::WorkerClose),
                        1 => ::core::result::Result::Ok(Method::WorkerDump),
                        2 => ::core::result::Result::Ok(Method::WorkerGetResourceUsage),
                        3 => ::core::result::Result::Ok(Method::WorkerUpdateSettings),
                        4 => ::core::result::Result::Ok(Method::WorkerCreateWebrtcServer),
                        5 => ::core::result::Result::Ok(Method::WorkerCreateRouter),
                        6 => ::core::result::Result::Ok(Method::WorkerWebrtcServerClose),
                        7 => ::core::result::Result::Ok(Method::WorkerCloseRouter),
                        8 => ::core::result::Result::Ok(Method::WebrtcServerDump),
                        9 => ::core::result::Result::Ok(Method::RouterDump),
                        10 => ::core::result::Result::Ok(Method::RouterCreateWebrtcTransport),
                        11 => ::core::result::Result::Ok(
                            Method::RouterCreateWebrtcTransportWithServer,
                        ),
                        12 => ::core::result::Result::Ok(Method::RouterCreatePlainTransport),
                        13 => ::core::result::Result::Ok(Method::RouterCreatePipeTransport),
                        14 => ::core::result::Result::Ok(Method::RouterCreateDirectTransport),
                        15 => ::core::result::Result::Ok(Method::RouterCloseTransport),
                        16 => ::core::result::Result::Ok(Method::RouterCreateActiveSpeakerObserver),
                        17 => ::core::result::Result::Ok(Method::RouterCreateAudioLevelObserver),
                        18 => ::core::result::Result::Ok(Method::RouterCloseRtpObserver),
                        19 => ::core::result::Result::Ok(Method::TransportDump),
                        20 => ::core::result::Result::Ok(Method::TransportGetStats),
                        21 => ::core::result::Result::Ok(Method::TransportConnect),
                        22 => ::core::result::Result::Ok(Method::TransportSetMaxIncomingBitrate),
                        23 => ::core::result::Result::Ok(Method::TransportSetMaxOutgoingBitrate),
                        24 => ::core::result::Result::Ok(Method::TransportRestartIce),
                        25 => ::core::result::Result::Ok(Method::TransportProduce),
                        26 => ::core::result::Result::Ok(Method::TransportProduceData),
                        27 => ::core::result::Result::Ok(Method::TransportConsume),
                        28 => ::core::result::Result::Ok(Method::TransportConsumeData),
                        29 => ::core::result::Result::Ok(Method::TransportEnableTraceEvent),
                        30 => ::core::result::Result::Ok(Method::TransportCloseProducer),
                        31 => ::core::result::Result::Ok(Method::TransportCloseConsumer),
                        32 => ::core::result::Result::Ok(Method::TransportCloseDataProducer),
                        33 => ::core::result::Result::Ok(Method::TransportCloseDataConsumer),
                        34 => ::core::result::Result::Ok(Method::PlainTransportConnect),
                        35 => ::core::result::Result::Ok(Method::PipeTransportConnect),
                        36 => ::core::result::Result::Ok(Method::WebrtcTransportConnect),
                        37 => ::core::result::Result::Ok(Method::ProducerDump),
                        38 => ::core::result::Result::Ok(Method::ProducerGetStats),
                        39 => ::core::result::Result::Ok(Method::ProducerPause),
                        40 => ::core::result::Result::Ok(Method::ProducerResume),
                        41 => ::core::result::Result::Ok(Method::ProducerEnableTraceEvent),
                        42 => ::core::result::Result::Ok(Method::ConsumerDump),
                        43 => ::core::result::Result::Ok(Method::ConsumerGetStats),
                        44 => ::core::result::Result::Ok(Method::ConsumerPause),
                        45 => ::core::result::Result::Ok(Method::ConsumerResume),
                        46 => ::core::result::Result::Ok(Method::ConsumerSetPreferredLayers),
                        47 => ::core::result::Result::Ok(Method::ConsumerSetPriority),
                        48 => ::core::result::Result::Ok(Method::ConsumerRequestKeyFrame),
                        49 => ::core::result::Result::Ok(Method::ConsumerEnableTraceEvent),
                        50 => ::core::result::Result::Ok(Method::DataProducerDump),
                        51 => ::core::result::Result::Ok(Method::DataProducerGetStats),
                        52 => ::core::result::Result::Ok(Method::DataConsumerDump),
                        53 => ::core::result::Result::Ok(Method::DataConsumerGetStats),
                        54 => ::core::result::Result::Ok(Method::DataConsumerGetBufferedAmount),
                        55 => ::core::result::Result::Ok(
                            Method::DataConsumerSetBufferedAmountLowThreshold,
                        ),
                        56 => ::core::result::Result::Ok(Method::DataConsumerSend),
                        57 => ::core::result::Result::Ok(Method::RtpObserverPause),
                        58 => ::core::result::Result::Ok(Method::RtpObserverResume),
                        59 => ::core::result::Result::Ok(Method::RtpObserverAddProducer),
                        60 => ::core::result::Result::Ok(Method::RtpObserverRemoveProducer),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Method> for u8 {
                fn from(value: Method) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Method {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Method> for Method {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Method> for Method {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Method {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Method, Method> for Method {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Method,
                ) -> ::core::option::Option<Method> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Method> for Method {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Method> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Method {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Method {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Method",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Method> for Method {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum Body {
                UpdateSettingsRequest(
                    ::planus::alloc::boxed::Box<super::worker::UpdateSettingsRequest>,
                ),
                CreateWebRtcServerRequest(
                    ::planus::alloc::boxed::Box<super::worker::CreateWebRtcServerRequest>,
                ),
                CloseWebRtcServerRequest(
                    ::planus::alloc::boxed::Box<super::worker::CloseWebRtcServerRequest>,
                ),
                CreateRouterRequest(
                    ::planus::alloc::boxed::Box<super::worker::CreateRouterRequest>,
                ),
                CloseRouterRequest(::planus::alloc::boxed::Box<super::worker::CloseRouterRequest>),
                CreateWebRtcTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateWebRtcTransportRequest>,
                ),
                CreatePlainTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreatePlainTransportRequest>,
                ),
                CreatePipeTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreatePipeTransportRequest>,
                ),
                CreateDirectTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateDirectTransportRequest>,
                ),
                CreateActiveSpeakerObserverRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateActiveSpeakerObserverRequest>,
                ),
                CreateAudioLevelObserverRequest(
                    ::planus::alloc::boxed::Box<super::router::CreateAudioLevelObserverRequest>,
                ),
                CloseTransportRequest(
                    ::planus::alloc::boxed::Box<super::router::CloseTransportRequest>,
                ),
                CloseRtpObserverRequest(
                    ::planus::alloc::boxed::Box<super::router::CloseRtpObserverRequest>,
                ),
                SetMaxIncomingBitrateRequest(
                    ::planus::alloc::boxed::Box<super::transport::SetMaxIncomingBitrateRequest>,
                ),
                SetMaxOutgoingBitrateRequest(
                    ::planus::alloc::boxed::Box<super::transport::SetMaxOutgoingBitrateRequest>,
                ),
                ProduceRequest(::planus::alloc::boxed::Box<super::transport::ProduceRequest>),
                ConsumeRequest(::planus::alloc::boxed::Box<super::transport::ConsumeRequest>),
                ProduceDataRequest(
                    ::planus::alloc::boxed::Box<super::transport::ProduceDataRequest>,
                ),
                ConsumeDataRequest(
                    ::planus::alloc::boxed::Box<super::transport::ConsumeDataRequest>,
                ),
                EnableTraceEventRequest(
                    ::planus::alloc::boxed::Box<super::consumer::EnableTraceEventRequest>,
                ),
                CloseProducerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseProducerRequest>,
                ),
                CloseConsumerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseConsumerRequest>,
                ),
                CloseDataProducerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseDataProducerRequest>,
                ),
                CloseDataConsumerRequest(
                    ::planus::alloc::boxed::Box<super::transport::CloseDataConsumerRequest>,
                ),
                ConnectRequest(
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::ConnectRequest>,
                ),
                SetPreferredLayersRequest(
                    ::planus::alloc::boxed::Box<super::consumer::SetPreferredLayersRequest>,
                ),
                SetPriorityRequest(
                    ::planus::alloc::boxed::Box<super::consumer::SetPriorityRequest>,
                ),
                SetBufferedAmountLowThresholdRequest(
                    ::planus::alloc::boxed::Box<
                        super::data_consumer::SetBufferedAmountLowThresholdRequest,
                    >,
                ),
                SendRequest(::planus::alloc::boxed::Box<super::data_consumer::SendRequest>),
                AddProducerRequest(
                    ::planus::alloc::boxed::Box<super::rtp_observer::AddProducerRequest>,
                ),
                RemoveProducerRequest(
                    ::planus::alloc::boxed::Box<super::rtp_observer::RemoveProducerRequest>,
                ),
            }

            impl Body {
                pub fn create_update_settings_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::UpdateSettingsRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_create_web_rtc_server_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CreateWebRtcServerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_close_web_rtc_server_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CloseWebRtcServerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_create_router_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CreateRouterRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                pub fn create_close_router_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::CloseRouterRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                pub fn create_create_web_rtc_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreateWebRtcTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }

                pub fn create_create_plain_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreatePlainTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
                }

                pub fn create_create_pipe_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreatePipeTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
                }

                pub fn create_create_direct_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreateDirectTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
                }

                pub fn create_create_active_speaker_observer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::router::CreateActiveSpeakerObserverRequest,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
                }

                pub fn create_create_audio_level_observer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CreateAudioLevelObserverRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(11, value.prepare(builder).downcast())
                }

                pub fn create_close_transport_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CloseTransportRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(12, value.prepare(builder).downcast())
                }

                pub fn create_close_rtp_observer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::router::CloseRtpObserverRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(13, value.prepare(builder).downcast())
                }

                pub fn create_set_max_incoming_bitrate_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SetMaxIncomingBitrateRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(14, value.prepare(builder).downcast())
                }

                pub fn create_set_max_outgoing_bitrate_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::SetMaxOutgoingBitrateRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(15, value.prepare(builder).downcast())
                }

                pub fn create_produce_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ProduceRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(16, value.prepare(builder).downcast())
                }

                pub fn create_consume_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ConsumeRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(17, value.prepare(builder).downcast())
                }

                pub fn create_produce_data_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ProduceDataRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(18, value.prepare(builder).downcast())
                }

                pub fn create_consume_data_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ConsumeDataRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(19, value.prepare(builder).downcast())
                }

                pub fn create_enable_trace_event_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::EnableTraceEventRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(20, value.prepare(builder).downcast())
                }

                pub fn create_close_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(21, value.prepare(builder).downcast())
                }

                pub fn create_close_consumer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseConsumerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(22, value.prepare(builder).downcast())
                }

                pub fn create_close_data_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseDataProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(23, value.prepare(builder).downcast())
                }

                pub fn create_close_data_consumer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::CloseDataConsumerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(24, value.prepare(builder).downcast())
                }

                pub fn create_connect_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_transport::ConnectRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(25, value.prepare(builder).downcast())
                }

                pub fn create_set_preferred_layers_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPreferredLayersRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(26, value.prepare(builder).downcast())
                }

                pub fn create_set_priority_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPriorityRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(27, value.prepare(builder).downcast())
                }

                pub fn create_set_buffered_amount_low_threshold_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<
                        super::data_consumer::SetBufferedAmountLowThresholdRequest,
                    >,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(28, value.prepare(builder).downcast())
                }

                pub fn create_send_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::SendRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(29, value.prepare(builder).downcast())
                }

                pub fn create_add_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::rtp_observer::AddProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(30, value.prepare(builder).downcast())
                }

                pub fn create_remove_producer_request(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::rtp_observer::RemoveProducerRequest>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(31, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::UpdateSettingsRequest(value) => {
                            Self::create_update_settings_request(builder, value)
                        }
                        Self::CreateWebRtcServerRequest(value) => {
                            Self::create_create_web_rtc_server_request(builder, value)
                        }
                        Self::CloseWebRtcServerRequest(value) => {
                            Self::create_close_web_rtc_server_request(builder, value)
                        }
                        Self::CreateRouterRequest(value) => {
                            Self::create_create_router_request(builder, value)
                        }
                        Self::CloseRouterRequest(value) => {
                            Self::create_close_router_request(builder, value)
                        }
                        Self::CreateWebRtcTransportRequest(value) => {
                            Self::create_create_web_rtc_transport_request(builder, value)
                        }
                        Self::CreatePlainTransportRequest(value) => {
                            Self::create_create_plain_transport_request(builder, value)
                        }
                        Self::CreatePipeTransportRequest(value) => {
                            Self::create_create_pipe_transport_request(builder, value)
                        }
                        Self::CreateDirectTransportRequest(value) => {
                            Self::create_create_direct_transport_request(builder, value)
                        }
                        Self::CreateActiveSpeakerObserverRequest(value) => {
                            Self::create_create_active_speaker_observer_request(builder, value)
                        }
                        Self::CreateAudioLevelObserverRequest(value) => {
                            Self::create_create_audio_level_observer_request(builder, value)
                        }
                        Self::CloseTransportRequest(value) => {
                            Self::create_close_transport_request(builder, value)
                        }
                        Self::CloseRtpObserverRequest(value) => {
                            Self::create_close_rtp_observer_request(builder, value)
                        }
                        Self::SetMaxIncomingBitrateRequest(value) => {
                            Self::create_set_max_incoming_bitrate_request(builder, value)
                        }
                        Self::SetMaxOutgoingBitrateRequest(value) => {
                            Self::create_set_max_outgoing_bitrate_request(builder, value)
                        }
                        Self::ProduceRequest(value) => Self::create_produce_request(builder, value),
                        Self::ConsumeRequest(value) => Self::create_consume_request(builder, value),
                        Self::ProduceDataRequest(value) => {
                            Self::create_produce_data_request(builder, value)
                        }
                        Self::ConsumeDataRequest(value) => {
                            Self::create_consume_data_request(builder, value)
                        }
                        Self::EnableTraceEventRequest(value) => {
                            Self::create_enable_trace_event_request(builder, value)
                        }
                        Self::CloseProducerRequest(value) => {
                            Self::create_close_producer_request(builder, value)
                        }
                        Self::CloseConsumerRequest(value) => {
                            Self::create_close_consumer_request(builder, value)
                        }
                        Self::CloseDataProducerRequest(value) => {
                            Self::create_close_data_producer_request(builder, value)
                        }
                        Self::CloseDataConsumerRequest(value) => {
                            Self::create_close_data_consumer_request(builder, value)
                        }
                        Self::ConnectRequest(value) => Self::create_connect_request(builder, value),
                        Self::SetPreferredLayersRequest(value) => {
                            Self::create_set_preferred_layers_request(builder, value)
                        }
                        Self::SetPriorityRequest(value) => {
                            Self::create_set_priority_request(builder, value)
                        }
                        Self::SetBufferedAmountLowThresholdRequest(value) => {
                            Self::create_set_buffered_amount_low_threshold_request(builder, value)
                        }
                        Self::SendRequest(value) => Self::create_send_request(builder, value),
                        Self::AddProducerRequest(value) => {
                            Self::create_add_producer_request(builder, value)
                        }
                        Self::RemoveProducerRequest(value) => {
                            Self::create_remove_producer_request(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                UpdateSettingsRequest(super::worker::UpdateSettingsRequestRef<'a>),
                CreateWebRtcServerRequest(super::worker::CreateWebRtcServerRequestRef<'a>),
                CloseWebRtcServerRequest(super::worker::CloseWebRtcServerRequestRef<'a>),
                CreateRouterRequest(super::worker::CreateRouterRequestRef<'a>),
                CloseRouterRequest(super::worker::CloseRouterRequestRef<'a>),
                CreateWebRtcTransportRequest(super::router::CreateWebRtcTransportRequestRef<'a>),
                CreatePlainTransportRequest(super::router::CreatePlainTransportRequestRef<'a>),
                CreatePipeTransportRequest(super::router::CreatePipeTransportRequestRef<'a>),
                CreateDirectTransportRequest(super::router::CreateDirectTransportRequestRef<'a>),
                CreateActiveSpeakerObserverRequest(
                    super::router::CreateActiveSpeakerObserverRequestRef<'a>,
                ),
                CreateAudioLevelObserverRequest(
                    super::router::CreateAudioLevelObserverRequestRef<'a>,
                ),
                CloseTransportRequest(super::router::CloseTransportRequestRef<'a>),
                CloseRtpObserverRequest(super::router::CloseRtpObserverRequestRef<'a>),
                SetMaxIncomingBitrateRequest(super::transport::SetMaxIncomingBitrateRequestRef<'a>),
                SetMaxOutgoingBitrateRequest(super::transport::SetMaxOutgoingBitrateRequestRef<'a>),
                ProduceRequest(super::transport::ProduceRequestRef<'a>),
                ConsumeRequest(super::transport::ConsumeRequestRef<'a>),
                ProduceDataRequest(super::transport::ProduceDataRequestRef<'a>),
                ConsumeDataRequest(super::transport::ConsumeDataRequestRef<'a>),
                EnableTraceEventRequest(super::consumer::EnableTraceEventRequestRef<'a>),
                CloseProducerRequest(super::transport::CloseProducerRequestRef<'a>),
                CloseConsumerRequest(super::transport::CloseConsumerRequestRef<'a>),
                CloseDataProducerRequest(super::transport::CloseDataProducerRequestRef<'a>),
                CloseDataConsumerRequest(super::transport::CloseDataConsumerRequestRef<'a>),
                ConnectRequest(super::web_rtc_transport::ConnectRequestRef<'a>),
                SetPreferredLayersRequest(super::consumer::SetPreferredLayersRequestRef<'a>),
                SetPriorityRequest(super::consumer::SetPriorityRequestRef<'a>),
                SetBufferedAmountLowThresholdRequest(
                    super::data_consumer::SetBufferedAmountLowThresholdRequestRef<'a>,
                ),
                SendRequest(super::data_consumer::SendRequestRef<'a>),
                AddProducerRequest(super::rtp_observer::AddProducerRequestRef<'a>),
                RemoveProducerRequest(super::rtp_observer::RemoveProducerRequestRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::UpdateSettingsRequest(value) => {
                            Body::UpdateSettingsRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreateWebRtcServerRequest(value) => {
                            Body::CreateWebRtcServerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseWebRtcServerRequest(value) => {
                            Body::CloseWebRtcServerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreateRouterRequest(value) => {
                            Body::CreateRouterRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseRouterRequest(value) => {
                            Body::CloseRouterRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreateWebRtcTransportRequest(value) => {
                            Body::CreateWebRtcTransportRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreatePlainTransportRequest(value) => {
                            Body::CreatePlainTransportRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreatePipeTransportRequest(value) => {
                            Body::CreatePipeTransportRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreateDirectTransportRequest(value) => {
                            Body::CreateDirectTransportRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CreateActiveSpeakerObserverRequest(value) => {
                            Body::CreateActiveSpeakerObserverRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::CreateAudioLevelObserverRequest(value) => {
                            Body::CreateAudioLevelObserverRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseTransportRequest(value) => {
                            Body::CloseTransportRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseRtpObserverRequest(value) => {
                            Body::CloseRtpObserverRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetMaxIncomingBitrateRequest(value) => {
                            Body::SetMaxIncomingBitrateRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetMaxOutgoingBitrateRequest(value) => {
                            Body::SetMaxOutgoingBitrateRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProduceRequest(value) => {
                            Body::ProduceRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumeRequest(value) => {
                            Body::ConsumeRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProduceDataRequest(value) => {
                            Body::ProduceDataRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumeDataRequest(value) => {
                            Body::ConsumeDataRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::EnableTraceEventRequest(value) => {
                            Body::EnableTraceEventRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseProducerRequest(value) => {
                            Body::CloseProducerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseConsumerRequest(value) => {
                            Body::CloseConsumerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseDataProducerRequest(value) => {
                            Body::CloseDataProducerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::CloseDataConsumerRequest(value) => {
                            Body::CloseDataConsumerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConnectRequest(value) => {
                            Body::ConnectRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetPreferredLayersRequest(value) => {
                            Body::SetPreferredLayersRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetPriorityRequest(value) => {
                            Body::SetPriorityRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetBufferedAmountLowThresholdRequest(value) => {
                            Body::SetBufferedAmountLowThresholdRequest(
                                ::planus::alloc::boxed::Box::new(
                                    ::core::convert::TryFrom::try_from(value)?,
                                ),
                            )
                        }

                        BodyRef::SendRequest(value) => {
                            Body::SendRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::AddProducerRequest(value) => {
                            Body::AddProducerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RemoveProducerRequest(value) => {
                            Body::RemoveProducerRequest(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::UpdateSettingsRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::CreateWebRtcServerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::CloseWebRtcServerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::CreateRouterRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::CloseRouterRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(Self::CreateWebRtcTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        7 => ::core::result::Result::Ok(Self::CreatePlainTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        8 => ::core::result::Result::Ok(Self::CreatePipeTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        9 => ::core::result::Result::Ok(Self::CreateDirectTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        10 => ::core::result::Result::Ok(Self::CreateActiveSpeakerObserverRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        11 => ::core::result::Result::Ok(Self::CreateAudioLevelObserverRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        12 => ::core::result::Result::Ok(Self::CloseTransportRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        13 => ::core::result::Result::Ok(Self::CloseRtpObserverRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        14 => ::core::result::Result::Ok(Self::SetMaxIncomingBitrateRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        15 => ::core::result::Result::Ok(Self::SetMaxOutgoingBitrateRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        16 => ::core::result::Result::Ok(Self::ProduceRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        17 => ::core::result::Result::Ok(Self::ConsumeRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        18 => ::core::result::Result::Ok(Self::ProduceDataRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        19 => ::core::result::Result::Ok(Self::ConsumeDataRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        20 => ::core::result::Result::Ok(Self::EnableTraceEventRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        21 => ::core::result::Result::Ok(Self::CloseProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        22 => ::core::result::Result::Ok(Self::CloseConsumerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        23 => ::core::result::Result::Ok(Self::CloseDataProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        24 => ::core::result::Result::Ok(Self::CloseDataConsumerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        25 => ::core::result::Result::Ok(Self::ConnectRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        26 => ::core::result::Result::Ok(Self::SetPreferredLayersRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        27 => ::core::result::Result::Ok(Self::SetPriorityRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        28 => {
                            ::core::result::Result::Ok(Self::SetBufferedAmountLowThresholdRequest(
                                ::planus::TableRead::from_buffer(buffer, field_offset)?,
                            ))
                        }
                        29 => ::core::result::Result::Ok(Self::SendRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        30 => ::core::result::Result::Ok(Self::AddProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        31 => ::core::result::Result::Ok(Self::RemoveProducerRequest(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Request {
                pub id: u32,
                pub method: self::Method,
                pub handler_id: ::core::option::Option<::planus::alloc::string::String>,
                pub body: ::core::option::Option<self::Body>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Request {
                fn default() -> Self {
                    Self {
                        id: 0,
                        method: self::Method::WorkerClose,
                        handler_id: ::core::default::Default::default(),
                        body: ::core::default::Default::default(),
                    }
                }
            }

            impl Request {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_method: impl ::planus::WriteAsDefault<self::Method, self::Method>,
                    field_handler_id: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_body: impl ::planus::WriteAsOptionalUnion<self::Body>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder, &0);

                    let prepared_method = field_method.prepare(builder, &self::Method::WorkerClose);

                    let prepared_handler_id = field_handler_id.prepare(builder);

                    let prepared_body = field_body.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 14>::new(builder);

                    if prepared_id.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_method.is_some() {
                        table_writer.calculate_size::<self::Method>(4);
                    }
                    if prepared_handler_id.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(6);
                    }
                    if prepared_body.is_some() {
                        table_writer.calculate_size::<u8>(8);
                        table_writer.calculate_size::<::planus::Offset<self::Body>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            table_writer.write::<_, _, 4>(0, &prepared_id);
                        }
                        if let ::core::option::Option::Some(prepared_handler_id) =
                            prepared_handler_id
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_handler_id);
                        }
                        if let ::core::option::Option::Some(prepared_body) = prepared_body {
                            table_writer.write::<_, _, 4>(4, &prepared_body.offset());
                        }
                        if let ::core::option::Option::Some(prepared_method) = prepared_method {
                            table_writer.write::<_, _, 1>(1, &prepared_method);
                        }
                        if let ::core::option::Option::Some(prepared_body) = prepared_body {
                            table_writer.write::<_, _, 1>(3, &prepared_body.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Request>> for Request {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Request>> for Request {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Request>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Request> for Request {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Request> {
                    Request::create(
                        builder,
                        &self.id,
                        &self.method,
                        &self.handler_id,
                        &self.body,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct RequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RequestRef<'a> {
                pub fn id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Request", "id")?.unwrap_or(0))
                }

                pub fn method(&self) -> ::planus::Result<self::Method> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "Request", "method")?
                            .unwrap_or(self::Method::WorkerClose),
                    )
                }

                pub fn handler_id(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "Request", "handler_id")
                }

                pub fn body(&self) -> ::planus::Result<::core::option::Option<self::BodyRef<'a>>> {
                    self.0.access_union(3, "Request", "body")
                }
            }

            impl<'a> ::core::fmt::Debug for RequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RequestRef");
                    f.field("id", &self.id());
                    f.field("method", &self.method());
                    if let ::core::option::Option::Some(field_handler_id) =
                        self.handler_id().transpose()
                    {
                        f.field("handler_id", &field_handler_id);
                    }
                    if let ::core::option::Option::Some(field_body) = self.body().transpose() {
                        f.field("body", &field_body);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RequestRef<'a>> for Request {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        method: ::core::convert::TryInto::try_into(value.method()?)?,
                        handler_id: if let ::core::option::Option::Some(handler_id) =
                            value.handler_id()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                handler_id,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        body: if let ::core::option::Option::Some(body) = value.body()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(body)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Request>> for Request {
                type Value = ::planus::Offset<Request>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Request>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RequestRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod response {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Body {
                DumpResponse(::planus::alloc::boxed::Box<super::data_consumer::DumpResponse>),
                ResourceUsageResponse(
                    ::planus::alloc::boxed::Box<super::worker::ResourceUsageResponse>,
                ),
                ProduceResponse(::planus::alloc::boxed::Box<super::transport::ProduceResponse>),
                ConsumeResponse(::planus::alloc::boxed::Box<super::transport::ConsumeResponse>),
                RestartIceResponse(
                    ::planus::alloc::boxed::Box<super::transport::RestartIceResponse>,
                ),
                ConnectResponse(
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::ConnectResponse>,
                ),
                GetStatsResponse(
                    ::planus::alloc::boxed::Box<super::data_consumer::GetStatsResponse>,
                ),
                SetPreferredLayersResponse(
                    ::planus::alloc::boxed::Box<super::consumer::SetPreferredLayersResponse>,
                ),
                SetPriorityResponse(
                    ::planus::alloc::boxed::Box<super::consumer::SetPriorityResponse>,
                ),
                GetBufferedAmountResponse(
                    ::planus::alloc::boxed::Box<super::data_consumer::GetBufferedAmountResponse>,
                ),
            }

            impl Body {
                pub fn create_dump_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::DumpResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_resource_usage_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::worker::ResourceUsageResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_produce_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ProduceResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_consume_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::ConsumeResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                pub fn create_restart_ice_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::transport::RestartIceResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                pub fn create_connect_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::web_rtc_transport::ConnectResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }

                pub fn create_get_stats_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::GetStatsResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(7, value.prepare(builder).downcast())
                }

                pub fn create_set_preferred_layers_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPreferredLayersResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(8, value.prepare(builder).downcast())
                }

                pub fn create_set_priority_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::consumer::SetPriorityResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(9, value.prepare(builder).downcast())
                }

                pub fn create_get_buffered_amount_response(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<super::data_consumer::GetBufferedAmountResponse>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(10, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Body> for Body {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::DumpResponse(value) => Self::create_dump_response(builder, value),
                        Self::ResourceUsageResponse(value) => {
                            Self::create_resource_usage_response(builder, value)
                        }
                        Self::ProduceResponse(value) => {
                            Self::create_produce_response(builder, value)
                        }
                        Self::ConsumeResponse(value) => {
                            Self::create_consume_response(builder, value)
                        }
                        Self::RestartIceResponse(value) => {
                            Self::create_restart_ice_response(builder, value)
                        }
                        Self::ConnectResponse(value) => {
                            Self::create_connect_response(builder, value)
                        }
                        Self::GetStatsResponse(value) => {
                            Self::create_get_stats_response(builder, value)
                        }
                        Self::SetPreferredLayersResponse(value) => {
                            Self::create_set_preferred_layers_response(builder, value)
                        }
                        Self::SetPriorityResponse(value) => {
                            Self::create_set_priority_response(builder, value)
                        }
                        Self::GetBufferedAmountResponse(value) => {
                            Self::create_get_buffered_amount_response(builder, value)
                        }
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Body> for Body {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum BodyRef<'a> {
                DumpResponse(super::data_consumer::DumpResponseRef<'a>),
                ResourceUsageResponse(super::worker::ResourceUsageResponseRef<'a>),
                ProduceResponse(super::transport::ProduceResponseRef<'a>),
                ConsumeResponse(super::transport::ConsumeResponseRef<'a>),
                RestartIceResponse(super::transport::RestartIceResponseRef<'a>),
                ConnectResponse(super::web_rtc_transport::ConnectResponseRef<'a>),
                GetStatsResponse(super::data_consumer::GetStatsResponseRef<'a>),
                SetPreferredLayersResponse(super::consumer::SetPreferredLayersResponseRef<'a>),
                SetPriorityResponse(super::consumer::SetPriorityResponseRef<'a>),
                GetBufferedAmountResponse(super::data_consumer::GetBufferedAmountResponseRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<BodyRef<'a>> for Body {
                type Error = ::planus::Error;

                fn try_from(value: BodyRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        BodyRef::DumpResponse(value) => {
                            Body::DumpResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ResourceUsageResponse(value) => {
                            Body::ResourceUsageResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ProduceResponse(value) => {
                            Body::ProduceResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConsumeResponse(value) => {
                            Body::ConsumeResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::RestartIceResponse(value) => {
                            Body::RestartIceResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::ConnectResponse(value) => {
                            Body::ConnectResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::GetStatsResponse(value) => {
                            Body::GetStatsResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetPreferredLayersResponse(value) => {
                            Body::SetPreferredLayersResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::SetPriorityResponse(value) => {
                            Body::SetPriorityResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        BodyRef::GetBufferedAmountResponse(value) => {
                            Body::GetBufferedAmountResponse(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for BodyRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::DumpResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::ResourceUsageResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::ProduceResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::ConsumeResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::RestartIceResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(Self::ConnectResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        7 => ::core::result::Result::Ok(Self::GetStatsResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        8 => ::core::result::Result::Ok(Self::SetPreferredLayersResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        9 => ::core::result::Result::Ok(Self::SetPriorityResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        10 => ::core::result::Result::Ok(Self::GetBufferedAmountResponse(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Response {
                pub id: u32,
                pub accepted: bool,
                pub body: ::core::option::Option<self::Body>,
                pub error: ::core::option::Option<::planus::alloc::string::String>,
                pub reason: ::core::option::Option<::planus::alloc::string::String>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Response {
                fn default() -> Self {
                    Self {
                        id: 0,
                        accepted: false,
                        body: ::core::default::Default::default(),
                        error: ::core::default::Default::default(),
                        reason: ::core::default::Default::default(),
                    }
                }
            }

            impl Response {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_accepted: impl ::planus::WriteAsDefault<bool, bool>,
                    field_body: impl ::planus::WriteAsOptionalUnion<self::Body>,
                    field_error: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_reason: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder, &0);

                    let prepared_accepted = field_accepted.prepare(builder, &false);

                    let prepared_body = field_body.prepare(builder);

                    let prepared_error = field_error.prepare(builder);

                    let prepared_reason = field_reason.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 18>::new(builder);

                    if prepared_id.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_accepted.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    if prepared_body.is_some() {
                        table_writer.calculate_size::<u8>(6);
                        table_writer.calculate_size::<::planus::Offset<self::Body>>(8);
                    }
                    if prepared_error.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(10);
                    }
                    if prepared_reason.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_id) = prepared_id {
                            table_writer.write::<_, _, 4>(0, &prepared_id);
                        }
                        if let ::core::option::Option::Some(prepared_body) = prepared_body {
                            table_writer.write::<_, _, 4>(3, &prepared_body.offset());
                        }
                        if let ::core::option::Option::Some(prepared_error) = prepared_error {
                            table_writer.write::<_, _, 4>(4, &prepared_error);
                        }
                        if let ::core::option::Option::Some(prepared_reason) = prepared_reason {
                            table_writer.write::<_, _, 4>(5, &prepared_reason);
                        }
                        if let ::core::option::Option::Some(prepared_accepted) = prepared_accepted {
                            table_writer.write::<_, _, 1>(1, &prepared_accepted);
                        }
                        if let ::core::option::Option::Some(prepared_body) = prepared_body {
                            table_writer.write::<_, _, 1>(2, &prepared_body.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Response>> for Response {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Response>> for Response {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Response>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Response> for Response {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Response> {
                    Response::create(
                        builder,
                        &self.id,
                        &self.accepted,
                        &self.body,
                        &self.error,
                        &self.reason,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ResponseRef<'a> {
                pub fn id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Response", "id")?.unwrap_or(0))
                }

                pub fn accepted(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "Response", "accepted")?.unwrap_or(false),
                    )
                }

                pub fn body(&self) -> ::planus::Result<::core::option::Option<self::BodyRef<'a>>> {
                    self.0.access_union(2, "Response", "body")
                }

                pub fn error(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(4, "Response", "error")
                }

                pub fn reason(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "Response", "reason")
                }
            }

            impl<'a> ::core::fmt::Debug for ResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ResponseRef");
                    f.field("id", &self.id());
                    f.field("accepted", &self.accepted());
                    if let ::core::option::Option::Some(field_body) = self.body().transpose() {
                        f.field("body", &field_body);
                    }
                    if let ::core::option::Option::Some(field_error) = self.error().transpose() {
                        f.field("error", &field_error);
                    }
                    if let ::core::option::Option::Some(field_reason) = self.reason().transpose() {
                        f.field("reason", &field_reason);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ResponseRef<'a>> for Response {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        accepted: ::core::convert::TryInto::try_into(value.accepted()?)?,
                        body: if let ::core::option::Option::Some(body) = value.body()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(body)?)
                        } else {
                            ::core::option::Option::None
                        },
                        error: if let ::core::option::Option::Some(error) = value.error()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(error)?)
                        } else {
                            ::core::option::Option::None
                        },
                        reason: if let ::core::option::Option::Some(reason) = value.reason()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                reason,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Response>> for Response {
                type Value = ::planus::Offset<Response>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Response>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ResponseRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod worker {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ChannelMessageHandlers {
                pub channel_request_handlers: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
                pub channel_notification_handlers: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ChannelMessageHandlers {
                fn default() -> Self {
                    Self {
                        channel_request_handlers: ::core::default::Default::default(),
                        channel_notification_handlers: ::core::default::Default::default(),
                    }
                }
            }

            impl ChannelMessageHandlers {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_channel_request_handlers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_channel_notification_handlers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_channel_request_handlers =
                        field_channel_request_handlers.prepare(builder);

                    let prepared_channel_notification_handlers =
                        field_channel_notification_handlers.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    if prepared_channel_request_handlers.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(2);
                    }
                    if prepared_channel_notification_handlers.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_channel_request_handlers) =
                            prepared_channel_request_handlers
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_channel_request_handlers);
                        }
                        if let ::core::option::Option::Some(
                            prepared_channel_notification_handlers,
                        ) = prepared_channel_notification_handlers
                        {
                            table_writer
                                .write::<_, _, 4>(1, &prepared_channel_notification_handlers);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ChannelMessageHandlers>> for ChannelMessageHandlers {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ChannelMessageHandlers>>
                for ChannelMessageHandlers
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ChannelMessageHandlers>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ChannelMessageHandlers> for ChannelMessageHandlers {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ChannelMessageHandlers> {
                    ChannelMessageHandlers::create(
                        builder,
                        &self.channel_request_handlers,
                        &self.channel_notification_handlers,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ChannelMessageHandlersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ChannelMessageHandlersRef<'a> {
                pub fn channel_request_handlers(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0
                        .access(0, "ChannelMessageHandlers", "channel_request_handlers")
                }

                pub fn channel_notification_handlers(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0
                        .access(1, "ChannelMessageHandlers", "channel_notification_handlers")
                }
            }

            impl<'a> ::core::fmt::Debug for ChannelMessageHandlersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ChannelMessageHandlersRef");
                    if let ::core::option::Option::Some(field_channel_request_handlers) =
                        self.channel_request_handlers().transpose()
                    {
                        f.field("channel_request_handlers", &field_channel_request_handlers);
                    }
                    if let ::core::option::Option::Some(field_channel_notification_handlers) =
                        self.channel_notification_handlers().transpose()
                    {
                        f.field(
                            "channel_notification_handlers",
                            &field_channel_notification_handlers,
                        );
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ChannelMessageHandlersRef<'a>> for ChannelMessageHandlers {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ChannelMessageHandlersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        channel_request_handlers: if let ::core::option::Option::Some(
                            channel_request_handlers,
                        ) = value.channel_request_handlers()?
                        {
                            ::core::option::Option::Some(channel_request_handlers.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        channel_notification_handlers: if let ::core::option::Option::Some(
                            channel_notification_handlers,
                        ) =
                            value.channel_notification_handlers()?
                        {
                            ::core::option::Option::Some(
                                channel_notification_handlers.to_vec_result()?,
                            )
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ChannelMessageHandlersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ChannelMessageHandlersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ChannelMessageHandlersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ChannelMessageHandlers>> for ChannelMessageHandlers {
                type Value = ::planus::Offset<ChannelMessageHandlers>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ChannelMessageHandlers>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ChannelMessageHandlersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ChannelMessageHandlersRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub pid: u32,
                pub web_rtc_server_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
                pub router_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
                pub channel_message_handlers: ::core::option::Option<
                    ::planus::alloc::boxed::Box<self::ChannelMessageHandlers>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DumpResponse {
                fn default() -> Self {
                    Self {
                        pid: 0,
                        web_rtc_server_ids: ::core::default::Default::default(),
                        router_ids: ::core::default::Default::default(),
                        channel_message_handlers: ::core::default::Default::default(),
                    }
                }
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_pid: impl ::planus::WriteAsDefault<u32, u32>,
                    field_web_rtc_server_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_router_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_channel_message_handlers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::ChannelMessageHandlers>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_pid = field_pid.prepare(builder, &0);

                    let prepared_web_rtc_server_ids = field_web_rtc_server_ids.prepare(builder);

                    let prepared_router_ids = field_router_ids.prepare(builder);

                    let prepared_channel_message_handlers =
                        field_channel_message_handlers.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 16>::new(builder);

                    if prepared_pid.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_web_rtc_server_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(4);
                    }
                    if prepared_router_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(6);
                    }
                    if prepared_channel_message_handlers.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<self::ChannelMessageHandlers>>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_pid) = prepared_pid {
                            table_writer.write::<_, _, 4>(0, &prepared_pid);
                        }
                        if let ::core::option::Option::Some(prepared_web_rtc_server_ids) =
                            prepared_web_rtc_server_ids
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_web_rtc_server_ids);
                        }
                        if let ::core::option::Option::Some(prepared_router_ids) =
                            prepared_router_ids
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_router_ids);
                        }
                        if let ::core::option::Option::Some(prepared_channel_message_handlers) =
                            prepared_channel_message_handlers
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_channel_message_handlers);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.pid,
                        &self.web_rtc_server_ids,
                        &self.router_ids,
                        &self.channel_message_handlers,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn pid(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "DumpResponse", "pid")?.unwrap_or(0),
                    )
                }

                pub fn web_rtc_server_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(1, "DumpResponse", "web_rtc_server_ids")
                }

                pub fn router_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(2, "DumpResponse", "router_ids")
                }

                pub fn channel_message_handlers(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ChannelMessageHandlersRef<'a>>>
                {
                    self.0.access(3, "DumpResponse", "channel_message_handlers")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("pid", &self.pid());
                    if let ::core::option::Option::Some(field_web_rtc_server_ids) =
                        self.web_rtc_server_ids().transpose()
                    {
                        f.field("web_rtc_server_ids", &field_web_rtc_server_ids);
                    }
                    if let ::core::option::Option::Some(field_router_ids) =
                        self.router_ids().transpose()
                    {
                        f.field("router_ids", &field_router_ids);
                    }
                    if let ::core::option::Option::Some(field_channel_message_handlers) =
                        self.channel_message_handlers().transpose()
                    {
                        f.field("channel_message_handlers", &field_channel_message_handlers);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        pid: ::core::convert::TryInto::try_into(value.pid()?)?,
                        web_rtc_server_ids: if let ::core::option::Option::Some(
                            web_rtc_server_ids,
                        ) = value.web_rtc_server_ids()?
                        {
                            ::core::option::Option::Some(web_rtc_server_ids.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        router_ids: if let ::core::option::Option::Some(router_ids) =
                            value.router_ids()?
                        {
                            ::core::option::Option::Some(router_ids.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        channel_message_handlers: if let ::core::option::Option::Some(
                            channel_message_handlers,
                        ) = value.channel_message_handlers()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(channel_message_handlers)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ResourceUsageResponse {
                pub ru_utime: u64,
                pub ru_stime: u64,
                pub ru_maxrss: u64,
                pub ru_ixrss: u64,
                pub ru_idrss: u64,
                pub ru_isrss: u64,
                pub ru_minflt: u64,
                pub ru_majflt: u64,
                pub ru_nswap: u64,
                pub ru_inblock: u64,
                pub ru_oublock: u64,
                pub ru_msgsnd: u64,
                pub ru_msgrcv: u64,
                pub ru_nsignals: u64,
                pub ru_nvcsw: u64,
                pub ru_nivcsw: u64,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ResourceUsageResponse {
                fn default() -> Self {
                    Self {
                        ru_utime: 0,
                        ru_stime: 0,
                        ru_maxrss: 0,
                        ru_ixrss: 0,
                        ru_idrss: 0,
                        ru_isrss: 0,
                        ru_minflt: 0,
                        ru_majflt: 0,
                        ru_nswap: 0,
                        ru_inblock: 0,
                        ru_oublock: 0,
                        ru_msgsnd: 0,
                        ru_msgrcv: 0,
                        ru_nsignals: 0,
                        ru_nvcsw: 0,
                        ru_nivcsw: 0,
                    }
                }
            }

            impl ResourceUsageResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ru_utime: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_stime: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_maxrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_ixrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_idrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_isrss: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_minflt: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_majflt: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nswap: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_inblock: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_oublock: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_msgsnd: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_msgrcv: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nsignals: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nvcsw: impl ::planus::WriteAsDefault<u64, u64>,
                    field_ru_nivcsw: impl ::planus::WriteAsDefault<u64, u64>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ru_utime = field_ru_utime.prepare(builder, &0);

                    let prepared_ru_stime = field_ru_stime.prepare(builder, &0);

                    let prepared_ru_maxrss = field_ru_maxrss.prepare(builder, &0);

                    let prepared_ru_ixrss = field_ru_ixrss.prepare(builder, &0);

                    let prepared_ru_idrss = field_ru_idrss.prepare(builder, &0);

                    let prepared_ru_isrss = field_ru_isrss.prepare(builder, &0);

                    let prepared_ru_minflt = field_ru_minflt.prepare(builder, &0);

                    let prepared_ru_majflt = field_ru_majflt.prepare(builder, &0);

                    let prepared_ru_nswap = field_ru_nswap.prepare(builder, &0);

                    let prepared_ru_inblock = field_ru_inblock.prepare(builder, &0);

                    let prepared_ru_oublock = field_ru_oublock.prepare(builder, &0);

                    let prepared_ru_msgsnd = field_ru_msgsnd.prepare(builder, &0);

                    let prepared_ru_msgrcv = field_ru_msgrcv.prepare(builder, &0);

                    let prepared_ru_nsignals = field_ru_nsignals.prepare(builder, &0);

                    let prepared_ru_nvcsw = field_ru_nvcsw.prepare(builder, &0);

                    let prepared_ru_nivcsw = field_ru_nivcsw.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<34, 128>::new(builder);

                    if prepared_ru_utime.is_some() {
                        table_writer.calculate_size::<u64>(2);
                    }
                    if prepared_ru_stime.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }
                    if prepared_ru_maxrss.is_some() {
                        table_writer.calculate_size::<u64>(6);
                    }
                    if prepared_ru_ixrss.is_some() {
                        table_writer.calculate_size::<u64>(8);
                    }
                    if prepared_ru_idrss.is_some() {
                        table_writer.calculate_size::<u64>(10);
                    }
                    if prepared_ru_isrss.is_some() {
                        table_writer.calculate_size::<u64>(12);
                    }
                    if prepared_ru_minflt.is_some() {
                        table_writer.calculate_size::<u64>(14);
                    }
                    if prepared_ru_majflt.is_some() {
                        table_writer.calculate_size::<u64>(16);
                    }
                    if prepared_ru_nswap.is_some() {
                        table_writer.calculate_size::<u64>(18);
                    }
                    if prepared_ru_inblock.is_some() {
                        table_writer.calculate_size::<u64>(20);
                    }
                    if prepared_ru_oublock.is_some() {
                        table_writer.calculate_size::<u64>(22);
                    }
                    if prepared_ru_msgsnd.is_some() {
                        table_writer.calculate_size::<u64>(24);
                    }
                    if prepared_ru_msgrcv.is_some() {
                        table_writer.calculate_size::<u64>(26);
                    }
                    if prepared_ru_nsignals.is_some() {
                        table_writer.calculate_size::<u64>(28);
                    }
                    if prepared_ru_nvcsw.is_some() {
                        table_writer.calculate_size::<u64>(30);
                    }
                    if prepared_ru_nivcsw.is_some() {
                        table_writer.calculate_size::<u64>(32);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ru_utime) = prepared_ru_utime {
                            table_writer.write::<_, _, 8>(0, &prepared_ru_utime);
                        }
                        if let ::core::option::Option::Some(prepared_ru_stime) = prepared_ru_stime {
                            table_writer.write::<_, _, 8>(1, &prepared_ru_stime);
                        }
                        if let ::core::option::Option::Some(prepared_ru_maxrss) = prepared_ru_maxrss
                        {
                            table_writer.write::<_, _, 8>(2, &prepared_ru_maxrss);
                        }
                        if let ::core::option::Option::Some(prepared_ru_ixrss) = prepared_ru_ixrss {
                            table_writer.write::<_, _, 8>(3, &prepared_ru_ixrss);
                        }
                        if let ::core::option::Option::Some(prepared_ru_idrss) = prepared_ru_idrss {
                            table_writer.write::<_, _, 8>(4, &prepared_ru_idrss);
                        }
                        if let ::core::option::Option::Some(prepared_ru_isrss) = prepared_ru_isrss {
                            table_writer.write::<_, _, 8>(5, &prepared_ru_isrss);
                        }
                        if let ::core::option::Option::Some(prepared_ru_minflt) = prepared_ru_minflt
                        {
                            table_writer.write::<_, _, 8>(6, &prepared_ru_minflt);
                        }
                        if let ::core::option::Option::Some(prepared_ru_majflt) = prepared_ru_majflt
                        {
                            table_writer.write::<_, _, 8>(7, &prepared_ru_majflt);
                        }
                        if let ::core::option::Option::Some(prepared_ru_nswap) = prepared_ru_nswap {
                            table_writer.write::<_, _, 8>(8, &prepared_ru_nswap);
                        }
                        if let ::core::option::Option::Some(prepared_ru_inblock) =
                            prepared_ru_inblock
                        {
                            table_writer.write::<_, _, 8>(9, &prepared_ru_inblock);
                        }
                        if let ::core::option::Option::Some(prepared_ru_oublock) =
                            prepared_ru_oublock
                        {
                            table_writer.write::<_, _, 8>(10, &prepared_ru_oublock);
                        }
                        if let ::core::option::Option::Some(prepared_ru_msgsnd) = prepared_ru_msgsnd
                        {
                            table_writer.write::<_, _, 8>(11, &prepared_ru_msgsnd);
                        }
                        if let ::core::option::Option::Some(prepared_ru_msgrcv) = prepared_ru_msgrcv
                        {
                            table_writer.write::<_, _, 8>(12, &prepared_ru_msgrcv);
                        }
                        if let ::core::option::Option::Some(prepared_ru_nsignals) =
                            prepared_ru_nsignals
                        {
                            table_writer.write::<_, _, 8>(13, &prepared_ru_nsignals);
                        }
                        if let ::core::option::Option::Some(prepared_ru_nvcsw) = prepared_ru_nvcsw {
                            table_writer.write::<_, _, 8>(14, &prepared_ru_nvcsw);
                        }
                        if let ::core::option::Option::Some(prepared_ru_nivcsw) = prepared_ru_nivcsw
                        {
                            table_writer.write::<_, _, 8>(15, &prepared_ru_nivcsw);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ResourceUsageResponse>> for ResourceUsageResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ResourceUsageResponse>> for ResourceUsageResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ResourceUsageResponse>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ResourceUsageResponse> for ResourceUsageResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ResourceUsageResponse> {
                    ResourceUsageResponse::create(
                        builder,
                        &self.ru_utime,
                        &self.ru_stime,
                        &self.ru_maxrss,
                        &self.ru_ixrss,
                        &self.ru_idrss,
                        &self.ru_isrss,
                        &self.ru_minflt,
                        &self.ru_majflt,
                        &self.ru_nswap,
                        &self.ru_inblock,
                        &self.ru_oublock,
                        &self.ru_msgsnd,
                        &self.ru_msgrcv,
                        &self.ru_nsignals,
                        &self.ru_nvcsw,
                        &self.ru_nivcsw,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ResourceUsageResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ResourceUsageResponseRef<'a> {
                pub fn ru_utime(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ResourceUsageResponse", "ru_utime")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_stime(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ResourceUsageResponse", "ru_stime")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_maxrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "ResourceUsageResponse", "ru_maxrss")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_ixrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "ResourceUsageResponse", "ru_ixrss")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_idrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "ResourceUsageResponse", "ru_idrss")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_isrss(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "ResourceUsageResponse", "ru_isrss")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_minflt(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "ResourceUsageResponse", "ru_minflt")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_majflt(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "ResourceUsageResponse", "ru_majflt")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_nswap(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "ResourceUsageResponse", "ru_nswap")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_inblock(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "ResourceUsageResponse", "ru_inblock")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_oublock(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "ResourceUsageResponse", "ru_oublock")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_msgsnd(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "ResourceUsageResponse", "ru_msgsnd")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_msgrcv(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "ResourceUsageResponse", "ru_msgrcv")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_nsignals(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(13, "ResourceUsageResponse", "ru_nsignals")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_nvcsw(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(14, "ResourceUsageResponse", "ru_nvcsw")?
                            .unwrap_or(0),
                    )
                }

                pub fn ru_nivcsw(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(15, "ResourceUsageResponse", "ru_nivcsw")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ResourceUsageResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ResourceUsageResponseRef");
                    f.field("ru_utime", &self.ru_utime());
                    f.field("ru_stime", &self.ru_stime());
                    f.field("ru_maxrss", &self.ru_maxrss());
                    f.field("ru_ixrss", &self.ru_ixrss());
                    f.field("ru_idrss", &self.ru_idrss());
                    f.field("ru_isrss", &self.ru_isrss());
                    f.field("ru_minflt", &self.ru_minflt());
                    f.field("ru_majflt", &self.ru_majflt());
                    f.field("ru_nswap", &self.ru_nswap());
                    f.field("ru_inblock", &self.ru_inblock());
                    f.field("ru_oublock", &self.ru_oublock());
                    f.field("ru_msgsnd", &self.ru_msgsnd());
                    f.field("ru_msgrcv", &self.ru_msgrcv());
                    f.field("ru_nsignals", &self.ru_nsignals());
                    f.field("ru_nvcsw", &self.ru_nvcsw());
                    f.field("ru_nivcsw", &self.ru_nivcsw());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ResourceUsageResponseRef<'a>> for ResourceUsageResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ResourceUsageResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ru_utime: ::core::convert::TryInto::try_into(value.ru_utime()?)?,
                        ru_stime: ::core::convert::TryInto::try_into(value.ru_stime()?)?,
                        ru_maxrss: ::core::convert::TryInto::try_into(value.ru_maxrss()?)?,
                        ru_ixrss: ::core::convert::TryInto::try_into(value.ru_ixrss()?)?,
                        ru_idrss: ::core::convert::TryInto::try_into(value.ru_idrss()?)?,
                        ru_isrss: ::core::convert::TryInto::try_into(value.ru_isrss()?)?,
                        ru_minflt: ::core::convert::TryInto::try_into(value.ru_minflt()?)?,
                        ru_majflt: ::core::convert::TryInto::try_into(value.ru_majflt()?)?,
                        ru_nswap: ::core::convert::TryInto::try_into(value.ru_nswap()?)?,
                        ru_inblock: ::core::convert::TryInto::try_into(value.ru_inblock()?)?,
                        ru_oublock: ::core::convert::TryInto::try_into(value.ru_oublock()?)?,
                        ru_msgsnd: ::core::convert::TryInto::try_into(value.ru_msgsnd()?)?,
                        ru_msgrcv: ::core::convert::TryInto::try_into(value.ru_msgrcv()?)?,
                        ru_nsignals: ::core::convert::TryInto::try_into(value.ru_nsignals()?)?,
                        ru_nvcsw: ::core::convert::TryInto::try_into(value.ru_nvcsw()?)?,
                        ru_nivcsw: ::core::convert::TryInto::try_into(value.ru_nivcsw()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ResourceUsageResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ResourceUsageResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ResourceUsageResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ResourceUsageResponse>> for ResourceUsageResponse {
                type Value = ::planus::Offset<ResourceUsageResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ResourceUsageResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ResourceUsageResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ResourceUsageResponseRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct UpdateSettingsRequest {
                pub log_level: ::core::option::Option<::planus::alloc::string::String>,
                pub log_tags: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for UpdateSettingsRequest {
                fn default() -> Self {
                    Self {
                        log_level: ::core::default::Default::default(),
                        log_tags: ::core::default::Default::default(),
                    }
                }
            }

            impl UpdateSettingsRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_log_level: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_log_tags: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_log_level = field_log_level.prepare(builder);

                    let prepared_log_tags = field_log_tags.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    if prepared_log_level.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }
                    if prepared_log_tags.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_log_level) = prepared_log_level
                        {
                            table_writer.write::<_, _, 4>(0, &prepared_log_level);
                        }
                        if let ::core::option::Option::Some(prepared_log_tags) = prepared_log_tags {
                            table_writer.write::<_, _, 4>(1, &prepared_log_tags);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<UpdateSettingsRequest>> for UpdateSettingsRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<UpdateSettingsRequest>> for UpdateSettingsRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<UpdateSettingsRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<UpdateSettingsRequest> for UpdateSettingsRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<UpdateSettingsRequest> {
                    UpdateSettingsRequest::create(builder, &self.log_level, &self.log_tags)
                }
            }

            #[derive(Copy, Clone)]
            pub struct UpdateSettingsRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> UpdateSettingsRequestRef<'a> {
                pub fn log_level(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "UpdateSettingsRequest", "log_level")
                }

                pub fn log_tags(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(1, "UpdateSettingsRequest", "log_tags")
                }
            }

            impl<'a> ::core::fmt::Debug for UpdateSettingsRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("UpdateSettingsRequestRef");
                    if let ::core::option::Option::Some(field_log_level) =
                        self.log_level().transpose()
                    {
                        f.field("log_level", &field_log_level);
                    }
                    if let ::core::option::Option::Some(field_log_tags) =
                        self.log_tags().transpose()
                    {
                        f.field("log_tags", &field_log_tags);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<UpdateSettingsRequestRef<'a>> for UpdateSettingsRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: UpdateSettingsRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        log_level: if let ::core::option::Option::Some(log_level) =
                            value.log_level()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                log_level,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        log_tags: if let ::core::option::Option::Some(log_tags) =
                            value.log_tags()?
                        {
                            ::core::option::Option::Some(log_tags.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for UpdateSettingsRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for UpdateSettingsRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[UpdateSettingsRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<UpdateSettingsRequest>> for UpdateSettingsRequest {
                type Value = ::planus::Offset<UpdateSettingsRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<UpdateSettingsRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for UpdateSettingsRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[UpdateSettingsRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateWebRtcServerRequest {
                pub web_rtc_server_id: ::planus::alloc::string::String,
                pub listen_infos: ::core::option::Option<
                    ::planus::alloc::vec::Vec<super::web_rtc_server::ListenInfo>,
                >,
            }

            impl CreateWebRtcServerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_web_rtc_server_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_listen_infos: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::web_rtc_server::ListenInfo>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_web_rtc_server_id = field_web_rtc_server_id.prepare(builder);

                    let prepared_listen_infos = field_listen_infos.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_listen_infos.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::web_rtc_server::ListenInfo>],
                        >>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_web_rtc_server_id);
                        if let ::core::option::Option::Some(prepared_listen_infos) =
                            prepared_listen_infos
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_listen_infos);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateWebRtcServerRequest>> for CreateWebRtcServerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateWebRtcServerRequest>>
                for CreateWebRtcServerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateWebRtcServerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateWebRtcServerRequest> for CreateWebRtcServerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcServerRequest> {
                    CreateWebRtcServerRequest::create(
                        builder,
                        &self.web_rtc_server_id,
                        &self.listen_infos,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreateWebRtcServerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateWebRtcServerRequestRef<'a> {
                pub fn web_rtc_server_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateWebRtcServerRequest", "web_rtc_server_id")
                }

                pub fn listen_infos(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<
                            'a,
                            ::planus::Result<super::web_rtc_server::ListenInfoRef<'a>>,
                        >,
                    >,
                > {
                    self.0
                        .access(1, "CreateWebRtcServerRequest", "listen_infos")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateWebRtcServerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateWebRtcServerRequestRef");
                    f.field("web_rtc_server_id", &self.web_rtc_server_id());
                    if let ::core::option::Option::Some(field_listen_infos) =
                        self.listen_infos().transpose()
                    {
                        f.field("listen_infos", &field_listen_infos);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateWebRtcServerRequestRef<'a>> for CreateWebRtcServerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateWebRtcServerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        web_rtc_server_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_server_id()?,
                        )?,
                        listen_infos: if let ::core::option::Option::Some(listen_infos) =
                            value.listen_infos()?
                        {
                            ::core::option::Option::Some(listen_infos.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateWebRtcServerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateWebRtcServerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcServerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateWebRtcServerRequest>>
                for CreateWebRtcServerRequest
            {
                type Value = ::planus::Offset<CreateWebRtcServerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateWebRtcServerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateWebRtcServerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcServerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseWebRtcServerRequest {
                pub web_rtc_server_id: ::planus::alloc::string::String,
            }

            impl CloseWebRtcServerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_web_rtc_server_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_web_rtc_server_id = field_web_rtc_server_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_web_rtc_server_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseWebRtcServerRequest>> for CloseWebRtcServerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseWebRtcServerRequest>>
                for CloseWebRtcServerRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseWebRtcServerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseWebRtcServerRequest> for CloseWebRtcServerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseWebRtcServerRequest> {
                    CloseWebRtcServerRequest::create(builder, &self.web_rtc_server_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseWebRtcServerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseWebRtcServerRequestRef<'a> {
                pub fn web_rtc_server_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseWebRtcServerRequest", "web_rtc_server_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseWebRtcServerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseWebRtcServerRequestRef");
                    f.field("web_rtc_server_id", &self.web_rtc_server_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseWebRtcServerRequestRef<'a>> for CloseWebRtcServerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseWebRtcServerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        web_rtc_server_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_server_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseWebRtcServerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseWebRtcServerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseWebRtcServerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseWebRtcServerRequest>>
                for CloseWebRtcServerRequest
            {
                type Value = ::planus::Offset<CloseWebRtcServerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseWebRtcServerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseWebRtcServerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseWebRtcServerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateRouterRequest {
                pub router_id: ::planus::alloc::string::String,
            }

            impl CreateRouterRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_router_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_router_id = field_router_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_router_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateRouterRequest>> for CreateRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateRouterRequest>> for CreateRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateRouterRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateRouterRequest> for CreateRouterRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateRouterRequest> {
                    CreateRouterRequest::create(builder, &self.router_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreateRouterRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateRouterRequestRef<'a> {
                pub fn router_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateRouterRequest", "router_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateRouterRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateRouterRequestRef");
                    f.field("router_id", &self.router_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateRouterRequestRef<'a>> for CreateRouterRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateRouterRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        router_id: ::core::convert::TryInto::try_into(value.router_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateRouterRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateRouterRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateRouterRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateRouterRequest>> for CreateRouterRequest {
                type Value = ::planus::Offset<CreateRouterRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateRouterRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateRouterRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateRouterRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseRouterRequest {
                pub router_id: ::planus::alloc::string::String,
            }

            impl CloseRouterRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_router_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_router_id = field_router_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_router_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseRouterRequest>> for CloseRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseRouterRequest>> for CloseRouterRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseRouterRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseRouterRequest> for CloseRouterRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRouterRequest> {
                    CloseRouterRequest::create(builder, &self.router_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseRouterRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseRouterRequestRef<'a> {
                pub fn router_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "CloseRouterRequest", "router_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseRouterRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseRouterRequestRef");
                    f.field("router_id", &self.router_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseRouterRequestRef<'a>> for CloseRouterRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseRouterRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        router_id: ::core::convert::TryInto::try_into(value.router_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseRouterRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseRouterRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseRouterRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseRouterRequest>> for CloseRouterRequest {
                type Value = ::planus::Offset<CloseRouterRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseRouterRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseRouterRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[CloseRouterRequestRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod router {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub id: ::planus::alloc::string::String,
                pub transport_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
                pub rtp_observer_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
                pub map_producer_id_consumer_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<super::common::StringStringArray>,
                >,
                pub map_consumer_id_producer_id:
                    ::core::option::Option<::planus::alloc::vec::Vec<super::common::StringString>>,
                pub map_producer_id_observer_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<super::common::StringStringArray>,
                >,
                pub map_data_producer_id_data_consumer_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<super::common::StringStringArray>,
                >,
                pub map_data_consumer_id_data_producer_id:
                    ::core::option::Option<::planus::alloc::vec::Vec<super::common::StringString>>,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_transport_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_rtp_observer_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_map_producer_id_consumer_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    field_map_consumer_id_producer_id: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                    field_map_producer_id_observer_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    field_map_data_producer_id_data_consumer_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::common::StringStringArray>]>,
                    >,
                    field_map_data_consumer_id_data_producer_id: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::common::StringString>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_transport_ids = field_transport_ids.prepare(builder);

                    let prepared_rtp_observer_ids = field_rtp_observer_ids.prepare(builder);

                    let prepared_map_producer_id_consumer_ids =
                        field_map_producer_id_consumer_ids.prepare(builder);

                    let prepared_map_consumer_id_producer_id =
                        field_map_consumer_id_producer_id.prepare(builder);

                    let prepared_map_producer_id_observer_ids =
                        field_map_producer_id_observer_ids.prepare(builder);

                    let prepared_map_data_producer_id_data_consumer_ids =
                        field_map_data_producer_id_data_consumer_ids.prepare(builder);

                    let prepared_map_data_consumer_id_data_producer_id =
                        field_map_data_consumer_id_data_producer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 32>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_transport_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(4);
                    }
                    if prepared_rtp_observer_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(6);
                    }
                    if prepared_map_producer_id_consumer_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::common::StringStringArray>],
                        >>(8);
                    }
                    if prepared_map_consumer_id_producer_id.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::common::StringString>],
                        >>(10);
                    }
                    if prepared_map_producer_id_observer_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::common::StringStringArray>],
                        >>(12);
                    }
                    if prepared_map_data_producer_id_data_consumer_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::common::StringStringArray>],
                        >>(14);
                    }
                    if prepared_map_data_consumer_id_data_producer_id.is_some() {
                        table_writer.calculate_size::<::planus::Offset<
                            [::planus::Offset<super::common::StringString>],
                        >>(16);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        if let ::core::option::Option::Some(prepared_transport_ids) =
                            prepared_transport_ids
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_transport_ids);
                        }
                        if let ::core::option::Option::Some(prepared_rtp_observer_ids) =
                            prepared_rtp_observer_ids
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_rtp_observer_ids);
                        }
                        if let ::core::option::Option::Some(prepared_map_producer_id_consumer_ids) =
                            prepared_map_producer_id_consumer_ids
                        {
                            table_writer
                                .write::<_, _, 4>(3, &prepared_map_producer_id_consumer_ids);
                        }
                        if let ::core::option::Option::Some(prepared_map_consumer_id_producer_id) =
                            prepared_map_consumer_id_producer_id
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_map_consumer_id_producer_id);
                        }
                        if let ::core::option::Option::Some(prepared_map_producer_id_observer_ids) =
                            prepared_map_producer_id_observer_ids
                        {
                            table_writer
                                .write::<_, _, 4>(5, &prepared_map_producer_id_observer_ids);
                        }
                        if let ::core::option::Option::Some(
                            prepared_map_data_producer_id_data_consumer_ids,
                        ) = prepared_map_data_producer_id_data_consumer_ids
                        {
                            table_writer.write::<_, _, 4>(
                                6,
                                &prepared_map_data_producer_id_data_consumer_ids,
                            );
                        }
                        if let ::core::option::Option::Some(
                            prepared_map_data_consumer_id_data_producer_id,
                        ) = prepared_map_data_consumer_id_data_producer_id
                        {
                            table_writer.write::<_, _, 4>(
                                7,
                                &prepared_map_data_consumer_id_data_producer_id,
                            );
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.transport_ids,
                        &self.rtp_observer_ids,
                        &self.map_producer_id_consumer_ids,
                        &self.map_consumer_id_producer_id,
                        &self.map_producer_id_observer_ids,
                        &self.map_data_producer_id_data_consumer_ids,
                        &self.map_data_consumer_id_data_producer_id,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                pub fn transport_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(1, "DumpResponse", "transport_ids")
                }

                pub fn rtp_observer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(2, "DumpResponse", "rtp_observer_ids")
                }

                pub fn map_producer_id_consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<
                            'a,
                            ::planus::Result<super::common::StringStringArrayRef<'a>>,
                        >,
                    >,
                > {
                    self.0
                        .access(3, "DumpResponse", "map_producer_id_consumer_ids")
                }

                pub fn map_consumer_id_producer_id(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                    >,
                > {
                    self.0
                        .access(4, "DumpResponse", "map_consumer_id_producer_id")
                }

                pub fn map_producer_id_observer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<
                            'a,
                            ::planus::Result<super::common::StringStringArrayRef<'a>>,
                        >,
                    >,
                > {
                    self.0
                        .access(5, "DumpResponse", "map_producer_id_observer_ids")
                }

                pub fn map_data_producer_id_data_consumer_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<
                            'a,
                            ::planus::Result<super::common::StringStringArrayRef<'a>>,
                        >,
                    >,
                > {
                    self.0
                        .access(6, "DumpResponse", "map_data_producer_id_data_consumer_ids")
                }

                pub fn map_data_consumer_id_data_producer_id(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<super::common::StringStringRef<'a>>>,
                    >,
                > {
                    self.0
                        .access(7, "DumpResponse", "map_data_consumer_id_data_producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    if let ::core::option::Option::Some(field_transport_ids) =
                        self.transport_ids().transpose()
                    {
                        f.field("transport_ids", &field_transport_ids);
                    }
                    if let ::core::option::Option::Some(field_rtp_observer_ids) =
                        self.rtp_observer_ids().transpose()
                    {
                        f.field("rtp_observer_ids", &field_rtp_observer_ids);
                    }
                    if let ::core::option::Option::Some(field_map_producer_id_consumer_ids) =
                        self.map_producer_id_consumer_ids().transpose()
                    {
                        f.field(
                            "map_producer_id_consumer_ids",
                            &field_map_producer_id_consumer_ids,
                        );
                    }
                    if let ::core::option::Option::Some(field_map_consumer_id_producer_id) =
                        self.map_consumer_id_producer_id().transpose()
                    {
                        f.field(
                            "map_consumer_id_producer_id",
                            &field_map_consumer_id_producer_id,
                        );
                    }
                    if let ::core::option::Option::Some(field_map_producer_id_observer_ids) =
                        self.map_producer_id_observer_ids().transpose()
                    {
                        f.field(
                            "map_producer_id_observer_ids",
                            &field_map_producer_id_observer_ids,
                        );
                    }
                    if let ::core::option::Option::Some(
                        field_map_data_producer_id_data_consumer_ids,
                    ) = self.map_data_producer_id_data_consumer_ids().transpose()
                    {
                        f.field(
                            "map_data_producer_id_data_consumer_ids",
                            &field_map_data_producer_id_data_consumer_ids,
                        );
                    }
                    if let ::core::option::Option::Some(
                        field_map_data_consumer_id_data_producer_id,
                    ) = self.map_data_consumer_id_data_producer_id().transpose()
                    {
                        f.field(
                            "map_data_consumer_id_data_producer_id",
                            &field_map_data_consumer_id_data_producer_id,
                        );
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        transport_ids: if let ::core::option::Option::Some(transport_ids) =
                            value.transport_ids()?
                        {
                            ::core::option::Option::Some(transport_ids.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtp_observer_ids: if let ::core::option::Option::Some(rtp_observer_ids) =
                            value.rtp_observer_ids()?
                        {
                            ::core::option::Option::Some(rtp_observer_ids.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        map_producer_id_consumer_ids: if let ::core::option::Option::Some(
                            map_producer_id_consumer_ids,
                        ) = value.map_producer_id_consumer_ids()?
                        {
                            ::core::option::Option::Some(
                                map_producer_id_consumer_ids.to_vec_result()?,
                            )
                        } else {
                            ::core::option::Option::None
                        },
                        map_consumer_id_producer_id: if let ::core::option::Option::Some(
                            map_consumer_id_producer_id,
                        ) = value.map_consumer_id_producer_id()?
                        {
                            ::core::option::Option::Some(
                                map_consumer_id_producer_id.to_vec_result()?,
                            )
                        } else {
                            ::core::option::Option::None
                        },
                        map_producer_id_observer_ids: if let ::core::option::Option::Some(
                            map_producer_id_observer_ids,
                        ) = value.map_producer_id_observer_ids()?
                        {
                            ::core::option::Option::Some(
                                map_producer_id_observer_ids.to_vec_result()?,
                            )
                        } else {
                            ::core::option::Option::None
                        },
                        map_data_producer_id_data_consumer_ids:
                            if let ::core::option::Option::Some(
                                map_data_producer_id_data_consumer_ids,
                            ) = value.map_data_producer_id_data_consumer_ids()?
                            {
                                ::core::option::Option::Some(
                                    map_data_producer_id_data_consumer_ids.to_vec_result()?,
                                )
                            } else {
                                ::core::option::Option::None
                            },
                        map_data_consumer_id_data_producer_id: if let ::core::option::Option::Some(
                            map_data_consumer_id_data_producer_id,
                        ) =
                            value.map_data_consumer_id_data_producer_id()?
                        {
                            ::core::option::Option::Some(
                                map_data_consumer_id_data_producer_id.to_vec_result()?,
                            )
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreatePipeTransportRequest {
                pub transport_id: ::planus::alloc::string::String,
                pub options:
                    ::planus::alloc::boxed::Box<super::pipe_transport::PipeTransportOptions>,
            }

            impl CreatePipeTransportRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::pipe_transport::PipeTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::pipe_transport::PipeTransportOptions>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_transport_id);
                        table_writer.write::<_, _, 4>(1, &prepared_options);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreatePipeTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreatePipeTransportRequest> for CreatePipeTransportRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePipeTransportRequest> {
                    CreatePipeTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreatePipeTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreatePipeTransportRequestRef<'a> {
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreatePipeTransportRequest", "transport_id")
                }

                pub fn options(
                    &self,
                ) -> ::planus::Result<super::pipe_transport::PipeTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreatePipeTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreatePipeTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreatePipeTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreatePipeTransportRequestRef<'a>>
                for CreatePipeTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreatePipeTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreatePipeTransportRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreatePipeTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePipeTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreatePipeTransportRequest>>
                for CreatePipeTransportRequest
            {
                type Value = ::planus::Offset<CreatePipeTransportRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreatePipeTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreatePipeTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePipeTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreatePlainTransportRequest {
                pub transport_id: ::planus::alloc::string::String,
                pub options:
                    ::planus::alloc::boxed::Box<super::plain_transport::PlainTransportOptions>,
            }

            impl CreatePlainTransportRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::plain_transport::PlainTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::plain_transport::PlainTransportOptions>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_transport_id);
                        table_writer.write::<_, _, 4>(1, &prepared_options);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreatePlainTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreatePlainTransportRequest> for CreatePlainTransportRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreatePlainTransportRequest> {
                    CreatePlainTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreatePlainTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreatePlainTransportRequestRef<'a> {
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreatePlainTransportRequest", "transport_id")
                }

                pub fn options(
                    &self,
                ) -> ::planus::Result<super::plain_transport::PlainTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreatePlainTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreatePlainTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreatePlainTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreatePlainTransportRequestRef<'a>>
                for CreatePlainTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreatePlainTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreatePlainTransportRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreatePlainTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePlainTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreatePlainTransportRequest>>
                for CreatePlainTransportRequest
            {
                type Value = ::planus::Offset<CreatePlainTransportRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreatePlainTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreatePlainTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreatePlainTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateWebRtcTransportRequest {
                pub transport_id: ::planus::alloc::string::String,
                pub options:
                    ::planus::alloc::boxed::Box<super::web_rtc_transport::WebRtcTransportOptions>,
            }

            impl CreateWebRtcTransportRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::web_rtc_transport::WebRtcTransportOptions>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_transport_id);
                        table_writer.write::<_, _, 4>(1, &prepared_options);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateWebRtcTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateWebRtcTransportRequest> for CreateWebRtcTransportRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateWebRtcTransportRequest> {
                    CreateWebRtcTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreateWebRtcTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateWebRtcTransportRequestRef<'a> {
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateWebRtcTransportRequest", "transport_id")
                }

                pub fn options(
                    &self,
                ) -> ::planus::Result<super::web_rtc_transport::WebRtcTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreateWebRtcTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateWebRtcTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateWebRtcTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateWebRtcTransportRequestRef<'a>>
                for CreateWebRtcTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateWebRtcTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateWebRtcTransportRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateWebRtcTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateWebRtcTransportRequest>>
                for CreateWebRtcTransportRequest
            {
                type Value = ::planus::Offset<CreateWebRtcTransportRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateWebRtcTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateWebRtcTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateWebRtcTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateDirectTransportRequest {
                pub transport_id: ::planus::alloc::string::String,
                pub options:
                    ::planus::alloc::boxed::Box<super::direct_transport::DirectTransportOptions>,
            }

            impl CreateDirectTransportRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::direct_transport::DirectTransportOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::direct_transport::DirectTransportOptions>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_transport_id);
                        table_writer.write::<_, _, 4>(1, &prepared_options);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateDirectTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateDirectTransportRequest> for CreateDirectTransportRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateDirectTransportRequest> {
                    CreateDirectTransportRequest::create(builder, &self.transport_id, &self.options)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreateDirectTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateDirectTransportRequestRef<'a> {
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateDirectTransportRequest", "transport_id")
                }

                pub fn options(
                    &self,
                ) -> ::planus::Result<super::direct_transport::DirectTransportOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreateDirectTransportRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateDirectTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateDirectTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateDirectTransportRequestRef<'a>>
                for CreateDirectTransportRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CreateDirectTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateDirectTransportRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateDirectTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateDirectTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateDirectTransportRequest>>
                for CreateDirectTransportRequest
            {
                type Value = ::planus::Offset<CreateDirectTransportRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateDirectTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateDirectTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateDirectTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateAudioLevelObserverRequest {
                pub rtp_observer_id: ::planus::alloc::string::String,
                pub options: ::planus::alloc::boxed::Box<
                    super::audio_level_observer::AudioLevelObserverOptions,
                >,
            }

            impl CreateAudioLevelObserverRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_observer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<super::audio_level_observer::AudioLevelObserverOptions>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_observer_id = field_rtp_observer_id.prepare(builder);

                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<
                        super::audio_level_observer::AudioLevelObserverOptions,
                    >>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_rtp_observer_id);
                        table_writer.write::<_, _, 4>(1, &prepared_options);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateAudioLevelObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateAudioLevelObserverRequest> for CreateAudioLevelObserverRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateAudioLevelObserverRequest> {
                    CreateAudioLevelObserverRequest::create(
                        builder,
                        &self.rtp_observer_id,
                        &self.options,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreateAudioLevelObserverRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateAudioLevelObserverRequestRef<'a> {
                pub fn rtp_observer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CreateAudioLevelObserverRequest", "rtp_observer_id")
                }

                pub fn options(
                    &self,
                ) -> ::planus::Result<super::audio_level_observer::AudioLevelObserverOptionsRef<'a>>
                {
                    self.0
                        .access_required(1, "CreateAudioLevelObserverRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateAudioLevelObserverRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateAudioLevelObserverRequestRef");
                    f.field("rtp_observer_id", &self.rtp_observer_id());
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateAudioLevelObserverRequestRef<'a>>
                for CreateAudioLevelObserverRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: CreateAudioLevelObserverRequestRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_observer_id: ::core::convert::TryInto::try_into(
                            value.rtp_observer_id()?,
                        )?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateAudioLevelObserverRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateAudioLevelObserverRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateAudioLevelObserverRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateAudioLevelObserverRequest>>
                for CreateAudioLevelObserverRequest
            {
                type Value = ::planus::Offset<CreateAudioLevelObserverRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateAudioLevelObserverRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateAudioLevelObserverRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateAudioLevelObserverRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CreateActiveSpeakerObserverRequest {
                pub active_speaker_observer_id: ::planus::alloc::string::String,
                pub options: ::planus::alloc::boxed::Box<
                    super::active_speaker_observer::ActiveSpeakerObserverOptions,
                >,
            }

            impl CreateActiveSpeakerObserverRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_active_speaker_observer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_options: impl ::planus::WriteAs<
                        ::planus::Offset<
                            super::active_speaker_observer::ActiveSpeakerObserverOptions,
                        >,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_active_speaker_observer_id =
                        field_active_speaker_observer_id.prepare(builder);

                    let prepared_options = field_options.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<
                        super::active_speaker_observer::ActiveSpeakerObserverOptions,
                    >>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_active_speaker_observer_id);
                        table_writer.write::<_, _, 4>(1, &prepared_options);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CreateActiveSpeakerObserverRequest>
                for CreateActiveSpeakerObserverRequest
            {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CreateActiveSpeakerObserverRequest> {
                    CreateActiveSpeakerObserverRequest::create(
                        builder,
                        &self.active_speaker_observer_id,
                        &self.options,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct CreateActiveSpeakerObserverRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CreateActiveSpeakerObserverRequestRef<'a> {
                pub fn active_speaker_observer_id(
                    &self,
                ) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(
                        0,
                        "CreateActiveSpeakerObserverRequest",
                        "active_speaker_observer_id",
                    )
                }

                pub fn options(
                    &self,
                ) -> ::planus::Result<
                    super::active_speaker_observer::ActiveSpeakerObserverOptionsRef<'a>,
                > {
                    self.0
                        .access_required(1, "CreateActiveSpeakerObserverRequest", "options")
                }
            }

            impl<'a> ::core::fmt::Debug for CreateActiveSpeakerObserverRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CreateActiveSpeakerObserverRequestRef");
                    f.field(
                        "active_speaker_observer_id",
                        &self.active_speaker_observer_id(),
                    );
                    f.field("options", &self.options());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CreateActiveSpeakerObserverRequestRef<'a>>
                for CreateActiveSpeakerObserverRequest
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: CreateActiveSpeakerObserverRequestRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        active_speaker_observer_id: ::core::convert::TryInto::try_into(
                            value.active_speaker_observer_id()?,
                        )?,
                        options: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.options()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CreateActiveSpeakerObserverRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CreateActiveSpeakerObserverRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateActiveSpeakerObserverRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CreateActiveSpeakerObserverRequest>>
                for CreateActiveSpeakerObserverRequest
            {
                type Value = ::planus::Offset<CreateActiveSpeakerObserverRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CreateActiveSpeakerObserverRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CreateActiveSpeakerObserverRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CreateActiveSpeakerObserverRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseTransportRequest {
                pub transport_id: ::planus::alloc::string::String,
            }

            impl CloseTransportRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_transport_id = field_transport_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_transport_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseTransportRequest>> for CloseTransportRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseTransportRequest>> for CloseTransportRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseTransportRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseTransportRequest> for CloseTransportRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseTransportRequest> {
                    CloseTransportRequest::create(builder, &self.transport_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseTransportRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseTransportRequestRef<'a> {
                pub fn transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseTransportRequest", "transport_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseTransportRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseTransportRequestRef");
                    f.field("transport_id", &self.transport_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseTransportRequestRef<'a>> for CloseTransportRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseTransportRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        transport_id: ::core::convert::TryInto::try_into(value.transport_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseTransportRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseTransportRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseTransportRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseTransportRequest>> for CloseTransportRequest {
                type Value = ::planus::Offset<CloseTransportRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseTransportRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseTransportRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseTransportRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct CloseRtpObserverRequest {
                pub rtp_observer_id: ::planus::alloc::string::String,
            }

            impl CloseRtpObserverRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_rtp_observer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_rtp_observer_id = field_rtp_observer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_rtp_observer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CloseRtpObserverRequest>> for CloseRtpObserverRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CloseRtpObserverRequest>>
                for CloseRtpObserverRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CloseRtpObserverRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CloseRtpObserverRequest> for CloseRtpObserverRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CloseRtpObserverRequest> {
                    CloseRtpObserverRequest::create(builder, &self.rtp_observer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct CloseRtpObserverRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CloseRtpObserverRequestRef<'a> {
                pub fn rtp_observer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "CloseRtpObserverRequest", "rtp_observer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for CloseRtpObserverRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CloseRtpObserverRequestRef");
                    f.field("rtp_observer_id", &self.rtp_observer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CloseRtpObserverRequestRef<'a>> for CloseRtpObserverRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CloseRtpObserverRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        rtp_observer_id: ::core::convert::TryInto::try_into(
                            value.rtp_observer_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CloseRtpObserverRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CloseRtpObserverRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseRtpObserverRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CloseRtpObserverRequest>> for CloseRtpObserverRequest {
                type Value = ::planus::Offset<CloseRtpObserverRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CloseRtpObserverRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CloseRtpObserverRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CloseRtpObserverRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod web_rtc_server {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenInfo {
                pub protocol: super::transport::Protocol,
                pub ip: ::planus::alloc::string::String,
                pub announced_ip: ::core::option::Option<::planus::alloc::string::String>,
                pub port: u16,
            }

            impl ListenInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_protocol: impl ::planus::WriteAsDefault<
                        super::transport::Protocol,
                        super::transport::Protocol,
                    >,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_announced_ip: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_protocol =
                        field_protocol.prepare(builder, &super::transport::Protocol::Udp);

                    let prepared_ip = field_ip.prepare(builder);

                    let prepared_announced_ip = field_announced_ip.prepare(builder);

                    let prepared_port = field_port.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 11>::new(builder);

                    if prepared_protocol.is_some() {
                        table_writer.calculate_size::<super::transport::Protocol>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_announced_ip.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(6);
                    }
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(8);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(1, &prepared_ip);
                        if let ::core::option::Option::Some(prepared_announced_ip) =
                            prepared_announced_ip
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_announced_ip);
                        }
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(3, &prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_protocol) = prepared_protocol {
                            table_writer.write::<_, _, 1>(0, &prepared_protocol);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenInfo>> for ListenInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenInfo>> for ListenInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenInfo> for ListenInfo {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ListenInfo> {
                    ListenInfo::create(
                        builder,
                        &self.protocol,
                        &self.ip,
                        &self.announced_ip,
                        &self.port,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ListenInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenInfoRef<'a> {
                pub fn protocol(&self) -> ::planus::Result<super::transport::Protocol> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ListenInfo", "protocol")?
                            .unwrap_or(super::transport::Protocol::Udp),
                    )
                }

                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "ListenInfo", "ip")
                }

                pub fn announced_ip(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(2, "ListenInfo", "announced_ip")
                }

                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(self.0.access(3, "ListenInfo", "port")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for ListenInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenInfoRef");
                    f.field("protocol", &self.protocol());
                    f.field("ip", &self.ip());
                    if let ::core::option::Option::Some(field_announced_ip) =
                        self.announced_ip().transpose()
                    {
                        f.field("announced_ip", &field_announced_ip);
                    }
                    f.field("port", &self.port());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenInfoRef<'a>> for ListenInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        announced_ip: if let ::core::option::Option::Some(announced_ip) =
                            value.announced_ip()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                announced_ip,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenInfo>> for ListenInfo {
                type Value = ::planus::Offset<ListenInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IpPort {
                pub ip: ::planus::alloc::string::String,
                pub port: u16,
            }

            impl IpPort {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);

                    let prepared_port = field_port.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 6>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_ip);
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(1, &prepared_port);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IpPort>> for IpPort {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IpPort>> for IpPort {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IpPort>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IpPort> for IpPort {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<IpPort> {
                    IpPort::create(builder, &self.ip, &self.port)
                }
            }

            #[derive(Copy, Clone)]
            pub struct IpPortRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IpPortRef<'a> {
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "IpPort", "ip")
                }

                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(self.0.access(1, "IpPort", "port")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for IpPortRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IpPortRef");
                    f.field("ip", &self.ip());
                    f.field("port", &self.port());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IpPortRef<'a>> for IpPort {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IpPortRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IpPortRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IpPortRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IpPortRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IpPort>> for IpPort {
                type Value = ::planus::Offset<IpPort>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IpPort>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IpPortRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IpPortRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceUserNameFragment {
                pub local_ice_username_fragment: ::planus::alloc::string::String,
                pub web_rtc_transport_id: ::planus::alloc::string::String,
            }

            impl IceUserNameFragment {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_local_ice_username_fragment: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_web_rtc_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_local_ice_username_fragment =
                        field_local_ice_username_fragment.prepare(builder);

                    let prepared_web_rtc_transport_id = field_web_rtc_transport_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_local_ice_username_fragment);
                        table_writer.write::<_, _, 4>(1, &prepared_web_rtc_transport_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceUserNameFragment>> for IceUserNameFragment {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceUserNameFragment>> for IceUserNameFragment {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceUserNameFragment>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceUserNameFragment> for IceUserNameFragment {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceUserNameFragment> {
                    IceUserNameFragment::create(
                        builder,
                        &self.local_ice_username_fragment,
                        &self.web_rtc_transport_id,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct IceUserNameFragmentRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceUserNameFragmentRef<'a> {
                pub fn local_ice_username_fragment(
                    &self,
                ) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "IceUserNameFragment", "local_ice_username_fragment")
                }

                pub fn web_rtc_transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "IceUserNameFragment", "web_rtc_transport_id")
                }
            }

            impl<'a> ::core::fmt::Debug for IceUserNameFragmentRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceUserNameFragmentRef");
                    f.field(
                        "local_ice_username_fragment",
                        &self.local_ice_username_fragment(),
                    );
                    f.field("web_rtc_transport_id", &self.web_rtc_transport_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceUserNameFragmentRef<'a>> for IceUserNameFragment {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceUserNameFragmentRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        local_ice_username_fragment: ::core::convert::TryInto::try_into(
                            value.local_ice_username_fragment()?,
                        )?,
                        web_rtc_transport_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_transport_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceUserNameFragmentRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceUserNameFragmentRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceUserNameFragmentRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceUserNameFragment>> for IceUserNameFragment {
                type Value = ::planus::Offset<IceUserNameFragment>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceUserNameFragment>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceUserNameFragmentRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceUserNameFragmentRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TupleHash {
                pub local_ice_username_fragment: u64,
                pub web_rtc_transport_id: ::planus::alloc::string::String,
            }

            impl TupleHash {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_local_ice_username_fragment: impl ::planus::WriteAsDefault<u64, u64>,
                    field_web_rtc_transport_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_local_ice_username_fragment =
                        field_local_ice_username_fragment.prepare(builder, &0);

                    let prepared_web_rtc_transport_id = field_web_rtc_transport_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 12>::new(builder);

                    if prepared_local_ice_username_fragment.is_some() {
                        table_writer.calculate_size::<u64>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_local_ice_username_fragment) =
                            prepared_local_ice_username_fragment
                        {
                            table_writer.write::<_, _, 8>(0, &prepared_local_ice_username_fragment);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_web_rtc_transport_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TupleHash>> for TupleHash {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TupleHash>> for TupleHash {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TupleHash>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TupleHash> for TupleHash {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TupleHash> {
                    TupleHash::create(
                        builder,
                        &self.local_ice_username_fragment,
                        &self.web_rtc_transport_id,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct TupleHashRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TupleHashRef<'a> {
                pub fn local_ice_username_fragment(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TupleHash", "local_ice_username_fragment")?
                            .unwrap_or(0),
                    )
                }

                pub fn web_rtc_transport_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(1, "TupleHash", "web_rtc_transport_id")
                }
            }

            impl<'a> ::core::fmt::Debug for TupleHashRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TupleHashRef");
                    f.field(
                        "local_ice_username_fragment",
                        &self.local_ice_username_fragment(),
                    );
                    f.field("web_rtc_transport_id", &self.web_rtc_transport_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TupleHashRef<'a>> for TupleHash {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TupleHashRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        local_ice_username_fragment: ::core::convert::TryInto::try_into(
                            value.local_ice_username_fragment()?,
                        )?,
                        web_rtc_transport_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_transport_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TupleHashRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TupleHashRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TupleHashRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TupleHash>> for TupleHash {
                type Value = ::planus::Offset<TupleHash>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TupleHash>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TupleHashRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TupleHashRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub id: ::planus::alloc::string::String,
                pub udp_sockets: ::core::option::Option<::planus::alloc::vec::Vec<self::IpPort>>,
                pub tcp_servers: ::core::option::Option<::planus::alloc::vec::Vec<self::IpPort>>,
                pub web_rtc_transport_ids: ::core::option::Option<
                    ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                >,
                pub local_ice_username_fragments:
                    ::core::option::Option<::planus::alloc::vec::Vec<self::IceUserNameFragment>>,
                pub tuple_hashes:
                    ::core::option::Option<::planus::alloc::vec::Vec<self::TupleHash>>,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_udp_sockets: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::IpPort>]>,
                    >,
                    field_tcp_servers: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::IpPort>]>,
                    >,
                    field_web_rtc_transport_ids: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_local_ice_username_fragments: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>,
                    >,
                    field_tuple_hashes: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::TupleHash>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_udp_sockets = field_udp_sockets.prepare(builder);

                    let prepared_tcp_servers = field_tcp_servers.prepare(builder);

                    let prepared_web_rtc_transport_ids =
                        field_web_rtc_transport_ids.prepare(builder);

                    let prepared_local_ice_username_fragments =
                        field_local_ice_username_fragments.prepare(builder);

                    let prepared_tuple_hashes = field_tuple_hashes.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 24>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_udp_sockets.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<[::planus::Offset<self::IpPort>]>>(
                                4,
                            );
                    }
                    if prepared_tcp_servers.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<[::planus::Offset<self::IpPort>]>>(
                                6,
                            );
                    }
                    if prepared_web_rtc_transport_ids.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(8);
                    }
                    if prepared_local_ice_username_fragments.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::IceUserNameFragment>]>>(10);
                    }
                    if prepared_tuple_hashes.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<self::TupleHash>]>>(12);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        if let ::core::option::Option::Some(prepared_udp_sockets) =
                            prepared_udp_sockets
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_udp_sockets);
                        }
                        if let ::core::option::Option::Some(prepared_tcp_servers) =
                            prepared_tcp_servers
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_tcp_servers);
                        }
                        if let ::core::option::Option::Some(prepared_web_rtc_transport_ids) =
                            prepared_web_rtc_transport_ids
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_web_rtc_transport_ids);
                        }
                        if let ::core::option::Option::Some(prepared_local_ice_username_fragments) =
                            prepared_local_ice_username_fragments
                        {
                            table_writer
                                .write::<_, _, 4>(4, &prepared_local_ice_username_fragments);
                        }
                        if let ::core::option::Option::Some(prepared_tuple_hashes) =
                            prepared_tuple_hashes
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_tuple_hashes);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.udp_sockets,
                        &self.tcp_servers,
                        &self.web_rtc_transport_ids,
                        &self.local_ice_username_fragments,
                        &self.tuple_hashes,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                pub fn udp_sockets(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::IpPortRef<'a>>>,
                    >,
                > {
                    self.0.access(1, "DumpResponse", "udp_sockets")
                }

                pub fn tcp_servers(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::IpPortRef<'a>>>,
                    >,
                > {
                    self.0.access(2, "DumpResponse", "tcp_servers")
                }

                pub fn web_rtc_transport_ids(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                    >,
                > {
                    self.0.access(3, "DumpResponse", "web_rtc_transport_ids")
                }

                pub fn local_ice_username_fragments(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::IceUserNameFragmentRef<'a>>>,
                    >,
                > {
                    self.0
                        .access(4, "DumpResponse", "local_ice_username_fragments")
                }

                pub fn tuple_hashes(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::TupleHashRef<'a>>>,
                    >,
                > {
                    self.0.access(5, "DumpResponse", "tuple_hashes")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    if let ::core::option::Option::Some(field_udp_sockets) =
                        self.udp_sockets().transpose()
                    {
                        f.field("udp_sockets", &field_udp_sockets);
                    }
                    if let ::core::option::Option::Some(field_tcp_servers) =
                        self.tcp_servers().transpose()
                    {
                        f.field("tcp_servers", &field_tcp_servers);
                    }
                    if let ::core::option::Option::Some(field_web_rtc_transport_ids) =
                        self.web_rtc_transport_ids().transpose()
                    {
                        f.field("web_rtc_transport_ids", &field_web_rtc_transport_ids);
                    }
                    if let ::core::option::Option::Some(field_local_ice_username_fragments) =
                        self.local_ice_username_fragments().transpose()
                    {
                        f.field(
                            "local_ice_username_fragments",
                            &field_local_ice_username_fragments,
                        );
                    }
                    if let ::core::option::Option::Some(field_tuple_hashes) =
                        self.tuple_hashes().transpose()
                    {
                        f.field("tuple_hashes", &field_tuple_hashes);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        udp_sockets: if let ::core::option::Option::Some(udp_sockets) =
                            value.udp_sockets()?
                        {
                            ::core::option::Option::Some(udp_sockets.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        tcp_servers: if let ::core::option::Option::Some(tcp_servers) =
                            value.tcp_servers()?
                        {
                            ::core::option::Option::Some(tcp_servers.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        web_rtc_transport_ids: if let ::core::option::Option::Some(
                            web_rtc_transport_ids,
                        ) = value.web_rtc_transport_ids()?
                        {
                            ::core::option::Option::Some(web_rtc_transport_ids.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        local_ice_username_fragments: if let ::core::option::Option::Some(
                            local_ice_username_fragments,
                        ) = value.local_ice_username_fragments()?
                        {
                            ::core::option::Option::Some(
                                local_ice_username_fragments.to_vec_result()?,
                            )
                        } else {
                            ::core::option::Option::None
                        },
                        tuple_hashes: if let ::core::option::Option::Some(tuple_hashes) =
                            value.tuple_hashes()?
                        {
                            ::core::option::Option::Some(tuple_hashes.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod producer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct EnableTraceEventRequest {
                pub events: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
            }

            impl EnableTraceEventRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_events: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_events = field_events.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_events);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<EnableTraceEventRequest>>
                for EnableTraceEventRequest
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<EnableTraceEventRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<EnableTraceEventRequest> for EnableTraceEventRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<EnableTraceEventRequest> {
                    EnableTraceEventRequest::create(builder, &self.events)
                }
            }

            #[derive(Copy, Clone)]
            pub struct EnableTraceEventRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> EnableTraceEventRequestRef<'a> {
                pub fn events(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(0, "EnableTraceEventRequest", "events")
                }
            }

            impl<'a> ::core::fmt::Debug for EnableTraceEventRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("EnableTraceEventRequestRef");
                    f.field("events", &self.events());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<EnableTraceEventRequestRef<'a>> for EnableTraceEventRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: EnableTraceEventRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        events: value.events()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for EnableTraceEventRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for EnableTraceEventRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<EnableTraceEventRequest>> for EnableTraceEventRequest {
                type Value = ::planus::Offset<EnableTraceEventRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<EnableTraceEventRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for EnableTraceEventRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[EnableTraceEventRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub id: ::planus::alloc::string::String,
                pub kind: super::rtp_parameters::MediaKind,
                pub type_: ::planus::alloc::string::String,
                pub rtp_parameters:
                    ::planus::alloc::boxed::Box<super::rtp_parameters::RtpParameters>,
                pub rtp_mapping: ::planus::alloc::boxed::Box<super::rtp_parameters::RtpMapping>,
                pub rtp_streams:
                    ::core::option::Option<::planus::alloc::vec::Vec<super::rtp_stream::Dump>>,
                pub trace_event_types: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                pub paused: bool,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_kind: impl ::planus::WriteAsDefault<
                        super::rtp_parameters::MediaKind,
                        super::rtp_parameters::MediaKind,
                    >,
                    field_type_: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_rtp_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpParameters>,
                    >,
                    field_rtp_mapping: impl ::planus::WriteAs<
                        ::planus::Offset<super::rtp_parameters::RtpMapping>,
                    >,
                    field_rtp_streams: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>,
                    >,
                    field_trace_event_types: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<str>]>,
                    >,
                    field_paused: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder);

                    let prepared_kind =
                        field_kind.prepare(builder, &super::rtp_parameters::MediaKind::All);

                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_rtp_parameters = field_rtp_parameters.prepare(builder);

                    let prepared_rtp_mapping = field_rtp_mapping.prepare(builder);

                    let prepared_rtp_streams = field_rtp_streams.prepare(builder);

                    let prepared_trace_event_types = field_trace_event_types.prepare(builder);

                    let prepared_paused = field_paused.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 26>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_kind.is_some() {
                        table_writer.calculate_size::<super::rtp_parameters::MediaKind>(4);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    table_writer
                        .calculate_size::<::planus::Offset<super::rtp_parameters::RtpParameters>>(
                            8,
                        );
                    table_writer
                        .calculate_size::<::planus::Offset<super::rtp_parameters::RtpMapping>>(10);
                    if prepared_rtp_streams.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::rtp_stream::Dump>]>>(12);
                    }
                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<str>]>>(14);
                    if prepared_paused.is_some() {
                        table_writer.calculate_size::<bool>(16);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_id);
                        table_writer.write::<_, _, 4>(2, &prepared_type_);
                        table_writer.write::<_, _, 4>(3, &prepared_rtp_parameters);
                        table_writer.write::<_, _, 4>(4, &prepared_rtp_mapping);
                        if let ::core::option::Option::Some(prepared_rtp_streams) =
                            prepared_rtp_streams
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_rtp_streams);
                        }
                        table_writer.write::<_, _, 4>(6, &prepared_trace_event_types);
                        if let ::core::option::Option::Some(prepared_kind) = prepared_kind {
                            table_writer.write::<_, _, 1>(1, &prepared_kind);
                        }
                        if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                            table_writer.write::<_, _, 1>(7, &prepared_paused);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.id,
                        &self.kind,
                        &self.type_,
                        &self.rtp_parameters,
                        &self.rtp_mapping,
                        &self.rtp_streams,
                        &self.trace_event_types,
                        &self.paused,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "DumpResponse", "id")
                }

                pub fn kind(&self) -> ::planus::Result<super::rtp_parameters::MediaKind> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DumpResponse", "kind")?
                            .unwrap_or(super::rtp_parameters::MediaKind::All),
                    )
                }

                pub fn type_(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "DumpResponse", "type_")
                }

                pub fn rtp_parameters(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpParametersRef<'a>> {
                    self.0.access_required(3, "DumpResponse", "rtp_parameters")
                }

                pub fn rtp_mapping(
                    &self,
                ) -> ::planus::Result<super::rtp_parameters::RtpMappingRef<'a>> {
                    self.0.access_required(4, "DumpResponse", "rtp_mapping")
                }

                pub fn rtp_streams(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<super::rtp_stream::DumpRef<'a>>>,
                    >,
                > {
                    self.0.access(5, "DumpResponse", "rtp_streams")
                }

                pub fn trace_event_types(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0
                        .access_required(6, "DumpResponse", "trace_event_types")
                }

                pub fn paused(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(7, "DumpResponse", "paused")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("id", &self.id());
                    f.field("kind", &self.kind());
                    f.field("type_", &self.type_());
                    f.field("rtp_parameters", &self.rtp_parameters());
                    f.field("rtp_mapping", &self.rtp_mapping());
                    if let ::core::option::Option::Some(field_rtp_streams) =
                        self.rtp_streams().transpose()
                    {
                        f.field("rtp_streams", &field_rtp_streams);
                    }
                    f.field("trace_event_types", &self.trace_event_types());
                    f.field("paused", &self.paused());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                        kind: ::core::convert::TryInto::try_into(value.kind()?)?,
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        rtp_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_parameters()?)?,
                        ),
                        rtp_mapping: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.rtp_mapping()?)?,
                        ),
                        rtp_streams: if let ::core::option::Option::Some(rtp_streams) =
                            value.rtp_streams()?
                        {
                            ::core::option::Option::Some(rtp_streams.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                        trace_event_types: value.trace_event_types()?.to_vec_result()?,
                        paused: ::core::convert::TryInto::try_into(value.paused()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub stats:
                    ::core::option::Option<::planus::alloc::vec::Vec<super::rtp_stream::Stats>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GetStatsResponse {
                fn default() -> Self {
                    Self {
                        stats: ::core::default::Default::default(),
                    }
                }
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_stats: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_stats = field_stats.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_stats.is_some() {
                        table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::rtp_stream::Stats>]>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_stats) = prepared_stats {
                            table_writer.write::<_, _, 4>(0, &prepared_stats);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.stats)
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn stats(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<super::rtp_stream::StatsRef<'a>>>,
                    >,
                > {
                    self.0.access(0, "GetStatsResponse", "stats")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    if let ::core::option::Option::Some(field_stats) = self.stats().transpose() {
                        f.field("stats", &field_stats);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        stats: if let ::core::option::Option::Some(stats) = value.stats()? {
                            ::core::option::Option::Some(stats.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SendNotification {
                pub data: ::planus::alloc::vec::Vec<u8>,
            }

            impl SendNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_data: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_data = field_data.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[u8]>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_data);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SendNotification>> for SendNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SendNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SendNotification> for SendNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SendNotification> {
                    SendNotification::create(builder, &self.data)
                }
            }

            #[derive(Copy, Clone)]
            pub struct SendNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SendNotificationRef<'a> {
                pub fn data(&self) -> ::planus::Result<::planus::Vector<'a, u8>> {
                    self.0.access_required(0, "SendNotification", "data")
                }
            }

            impl<'a> ::core::fmt::Debug for SendNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SendNotificationRef");
                    f.field("data", &self.data());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SendNotificationRef<'a>> for SendNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SendNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        data: value.data()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SendNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SendNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SendNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SendNotification>> for SendNotification {
                type Value = ::planus::Offset<SendNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SendNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SendNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SendNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Score {
                pub ssrc: u32,
                pub rid: ::core::option::Option<::planus::alloc::string::String>,
                pub score: u8,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Score {
                fn default() -> Self {
                    Self {
                        ssrc: 0,
                        rid: ::core::default::Default::default(),
                        score: 0,
                    }
                }
            }

            impl Score {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                    field_rid: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_score: impl ::planus::WriteAsDefault<u8, u8>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let prepared_rid = field_rid.prepare(builder);

                    let prepared_score = field_score.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 9>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }
                    if prepared_rid.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(4);
                    }
                    if prepared_score.is_some() {
                        table_writer.calculate_size::<u8>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                        if let ::core::option::Option::Some(prepared_rid) = prepared_rid {
                            table_writer.write::<_, _, 4>(1, &prepared_rid);
                        }
                        if let ::core::option::Option::Some(prepared_score) = prepared_score {
                            table_writer.write::<_, _, 1>(2, &prepared_score);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Score>> for Score {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Score>> for Score {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Score>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Score> for Score {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Score> {
                    Score::create(builder, &self.ssrc, &self.rid, &self.score)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ScoreRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScoreRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "Score", "ssrc")?.unwrap_or(0))
                }

                pub fn rid(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "Score", "rid")
                }

                pub fn score(&self) -> ::planus::Result<u8> {
                    ::core::result::Result::Ok(self.0.access(2, "Score", "score")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreRef");
                    f.field("ssrc", &self.ssrc());
                    if let ::core::option::Option::Some(field_rid) = self.rid().transpose() {
                        f.field("rid", &field_rid);
                    }
                    f.field("score", &self.score());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScoreRef<'a>> for Score {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScoreRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                        rid: if let ::core::option::Option::Some(rid) = value.rid()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(rid)?)
                        } else {
                            ::core::option::Option::None
                        },
                        score: ::core::convert::TryInto::try_into(value.score()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScoreRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScoreRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Score>> for Score {
                type Value = ::planus::Offset<Score>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Score>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScoreRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ScoreRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ScoreNotification {
                pub scores: ::core::option::Option<::planus::alloc::vec::Vec<self::Score>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ScoreNotification {
                fn default() -> Self {
                    Self {
                        scores: ::core::default::Default::default(),
                    }
                }
            }

            impl ScoreNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_scores: impl ::planus::WriteAsOptional<
                        ::planus::Offset<[::planus::Offset<self::Score>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_scores = field_scores.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_scores.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<[::planus::Offset<self::Score>]>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_scores) = prepared_scores {
                            table_writer.write::<_, _, 4>(0, &prepared_scores);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScoreNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ScoreNotification> for ScoreNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScoreNotification> {
                    ScoreNotification::create(builder, &self.scores)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ScoreNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScoreNotificationRef<'a> {
                pub fn scores(
                    &self,
                ) -> ::planus::Result<
                    ::core::option::Option<
                        ::planus::Vector<'a, ::planus::Result<self::ScoreRef<'a>>>,
                    >,
                > {
                    self.0.access(0, "ScoreNotification", "scores")
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreNotificationRef");
                    if let ::core::option::Option::Some(field_scores) = self.scores().transpose() {
                        f.field("scores", &field_scores);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScoreNotificationRef<'a>> for ScoreNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScoreNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        scores: if let ::core::option::Option::Some(scores) = value.scores()? {
                            ::core::option::Option::Some(scores.to_vec_result()?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScoreNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScoreNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ScoreNotification>> for ScoreNotification {
                type Value = ::planus::Offset<ScoreNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ScoreNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScoreNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ScoreNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct VideoOrientationChangeNotification {
                pub camera: bool,
                pub flip: bool,
                pub rotation: u16,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for VideoOrientationChangeNotification {
                fn default() -> Self {
                    Self {
                        camera: false,
                        flip: false,
                        rotation: 0,
                    }
                }
            }

            impl VideoOrientationChangeNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_camera: impl ::planus::WriteAsDefault<bool, bool>,
                    field_flip: impl ::planus::WriteAsDefault<bool, bool>,
                    field_rotation: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_camera = field_camera.prepare(builder, &false);

                    let prepared_flip = field_flip.prepare(builder, &false);

                    let prepared_rotation = field_rotation.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 4>::new(builder);

                    if prepared_camera.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }
                    if prepared_flip.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    if prepared_rotation.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_rotation) = prepared_rotation {
                            table_writer.write::<_, _, 2>(2, &prepared_rotation);
                        }
                        if let ::core::option::Option::Some(prepared_camera) = prepared_camera {
                            table_writer.write::<_, _, 1>(0, &prepared_camera);
                        }
                        if let ::core::option::Option::Some(prepared_flip) = prepared_flip {
                            table_writer.write::<_, _, 1>(1, &prepared_flip);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<VideoOrientationChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<VideoOrientationChangeNotification>
                for VideoOrientationChangeNotification
            {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<VideoOrientationChangeNotification> {
                    VideoOrientationChangeNotification::create(
                        builder,
                        &self.camera,
                        &self.flip,
                        &self.rotation,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct VideoOrientationChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> VideoOrientationChangeNotificationRef<'a> {
                pub fn camera(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "VideoOrientationChangeNotification", "camera")?
                            .unwrap_or(false),
                    )
                }

                pub fn flip(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "VideoOrientationChangeNotification", "flip")?
                            .unwrap_or(false),
                    )
                }

                pub fn rotation(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "VideoOrientationChangeNotification", "rotation")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for VideoOrientationChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("VideoOrientationChangeNotificationRef");
                    f.field("camera", &self.camera());
                    f.field("flip", &self.flip());
                    f.field("rotation", &self.rotation());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<VideoOrientationChangeNotificationRef<'a>>
                for VideoOrientationChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: VideoOrientationChangeNotificationRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        camera: ::core::convert::TryInto::try_into(value.camera()?)?,
                        flip: ::core::convert::TryInto::try_into(value.flip()?)?,
                        rotation: ::core::convert::TryInto::try_into(value.rotation()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for VideoOrientationChangeNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for VideoOrientationChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VideoOrientationChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<VideoOrientationChangeNotification>>
                for VideoOrientationChangeNotification
            {
                type Value = ::planus::Offset<VideoOrientationChangeNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<VideoOrientationChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for VideoOrientationChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[VideoOrientationChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceType {
                Keyframe = 0,
                Fir = 1,
                Nack = 2,
                Pli = 3,
                Rtp = 4,
            }

            impl ::core::convert::TryFrom<u8> for TraceType {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceType::Keyframe),
                        1 => ::core::result::Result::Ok(TraceType::Fir),
                        2 => ::core::result::Result::Ok(TraceType::Nack),
                        3 => ::core::result::Result::Ok(TraceType::Pli),
                        4 => ::core::result::Result::Ok(TraceType::Rtp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceType> for u8 {
                fn from(value: TraceType) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceType {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceType> for TraceType {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceType {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceType, TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceType,
                ) -> ::core::option::Option<TraceType> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceType> for TraceType {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceType> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceType {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceType {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceType",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceType> for TraceType {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TraceDirection {
                DirectionIn = 0,
                DirectionOut = 1,
            }

            impl ::core::convert::TryFrom<u8> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TraceDirection::DirectionIn),
                        1 => ::core::result::Result::Ok(TraceDirection::DirectionOut),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TraceDirection> for u8 {
                fn from(value: TraceDirection) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TraceDirection {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TraceDirection> for TraceDirection {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TraceDirection {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TraceDirection, TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TraceDirection,
                ) -> ::core::option::Option<TraceDirection> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TraceDirection> for TraceDirection {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TraceDirection> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TraceDirection {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TraceDirection {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TraceDirection",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TraceDirection> for TraceDirection {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum TraceInfo {
                KeyFrameTraceInfo(::planus::alloc::boxed::Box<self::KeyFrameTraceInfo>),
                FirTraceInfo(::planus::alloc::boxed::Box<self::FirTraceInfo>),
                PliTraceInfo(::planus::alloc::boxed::Box<self::PliTraceInfo>),
                RtpTraceInfo(::planus::alloc::boxed::Box<self::RtpTraceInfo>),
            }

            impl TraceInfo {
                pub fn create_key_frame_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::KeyFrameTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_fir_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::FirTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                pub fn create_pli_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PliTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                pub fn create_rtp_trace_info(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RtpTraceInfo>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<TraceInfo> for TraceInfo {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::KeyFrameTraceInfo(value) => {
                            Self::create_key_frame_trace_info(builder, value)
                        }
                        Self::FirTraceInfo(value) => Self::create_fir_trace_info(builder, value),
                        Self::PliTraceInfo(value) => Self::create_pli_trace_info(builder, value),
                        Self::RtpTraceInfo(value) => Self::create_rtp_trace_info(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<TraceInfo> for TraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum TraceInfoRef<'a> {
                KeyFrameTraceInfo(self::KeyFrameTraceInfoRef<'a>),
                FirTraceInfo(self::FirTraceInfoRef<'a>),
                PliTraceInfo(self::PliTraceInfoRef<'a>),
                RtpTraceInfo(self::RtpTraceInfoRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<TraceInfoRef<'a>> for TraceInfo {
                type Error = ::planus::Error;

                fn try_from(value: TraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        TraceInfoRef::KeyFrameTraceInfo(value) => {
                            TraceInfo::KeyFrameTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::FirTraceInfo(value) => {
                            TraceInfo::FirTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::PliTraceInfo(value) => {
                            TraceInfo::PliTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        TraceInfoRef::RtpTraceInfo(value) => {
                            TraceInfo::RtpTraceInfo(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for TraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::KeyFrameTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::FirTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::PliTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::RtpTraceInfo(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct KeyFrameTraceInfo {
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for KeyFrameTraceInfo {
                fn default() -> Self {
                    Self { is_rtx: false }
                }
            }

            impl KeyFrameTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_is_rtx.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                            table_writer.write::<_, _, 1>(0, &prepared_is_rtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<KeyFrameTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<KeyFrameTraceInfo> for KeyFrameTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<KeyFrameTraceInfo> {
                    KeyFrameTraceInfo::create(builder, &self.is_rtx)
                }
            }

            #[derive(Copy, Clone)]
            pub struct KeyFrameTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> KeyFrameTraceInfoRef<'a> {
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "KeyFrameTraceInfo", "is_rtx")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for KeyFrameTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("KeyFrameTraceInfoRef");
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<KeyFrameTraceInfoRef<'a>> for KeyFrameTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: KeyFrameTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for KeyFrameTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for KeyFrameTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[KeyFrameTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<KeyFrameTraceInfo>> for KeyFrameTraceInfo {
                type Value = ::planus::Offset<KeyFrameTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<KeyFrameTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for KeyFrameTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[KeyFrameTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct FirTraceInfo {
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for FirTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl FirTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FirTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<FirTraceInfo> for FirTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<FirTraceInfo> {
                    FirTraceInfo::create(builder, &self.ssrc)
                }
            }

            #[derive(Copy, Clone)]
            pub struct FirTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FirTraceInfoRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "FirTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for FirTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FirTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FirTraceInfoRef<'a>> for FirTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FirTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FirTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FirTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FirTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<FirTraceInfo>> for FirTraceInfo {
                type Value = ::planus::Offset<FirTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<FirTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FirTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FirTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PliTraceInfo {
                pub ssrc: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PliTraceInfo {
                fn default() -> Self {
                    Self { ssrc: 0 }
                }
            }

            impl PliTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ssrc: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ssrc = field_ssrc.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_ssrc.is_some() {
                        table_writer.calculate_size::<u32>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ssrc) = prepared_ssrc {
                            table_writer.write::<_, _, 4>(0, &prepared_ssrc);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PliTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PliTraceInfo> for PliTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PliTraceInfo> {
                    PliTraceInfo::create(builder, &self.ssrc)
                }
            }

            #[derive(Copy, Clone)]
            pub struct PliTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PliTraceInfoRef<'a> {
                pub fn ssrc(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "PliTraceInfo", "ssrc")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PliTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PliTraceInfoRef");
                    f.field("ssrc", &self.ssrc());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PliTraceInfoRef<'a>> for PliTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PliTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ssrc: ::core::convert::TryInto::try_into(value.ssrc()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PliTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PliTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PliTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PliTraceInfo>> for PliTraceInfo {
                type Value = ::planus::Offset<PliTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PliTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PliTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PliTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtpTraceInfo {
                pub is_rtx: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RtpTraceInfo {
                fn default() -> Self {
                    Self { is_rtx: false }
                }
            }

            impl RtpTraceInfo {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_is_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_is_rtx = field_is_rtx.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_is_rtx.is_some() {
                        table_writer.calculate_size::<bool>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_is_rtx) = prepared_is_rtx {
                            table_writer.write::<_, _, 1>(0, &prepared_is_rtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtpTraceInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtpTraceInfo> for RtpTraceInfo {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtpTraceInfo> {
                    RtpTraceInfo::create(builder, &self.is_rtx)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtpTraceInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtpTraceInfoRef<'a> {
                pub fn is_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "RtpTraceInfo", "is_rtx")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RtpTraceInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtpTraceInfoRef");
                    f.field("is_rtx", &self.is_rtx());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtpTraceInfoRef<'a>> for RtpTraceInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtpTraceInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        is_rtx: ::core::convert::TryInto::try_into(value.is_rtx()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtpTraceInfoRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtpTraceInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtpTraceInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtpTraceInfo>> for RtpTraceInfo {
                type Value = ::planus::Offset<RtpTraceInfo>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtpTraceInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtpTraceInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RtpTraceInfoRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TraceNotification {
                pub type_: self::TraceType,
                pub timestamp: u64,
                pub direction: self::TraceDirection,
                pub info: ::core::option::Option<self::TraceInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for TraceNotification {
                fn default() -> Self {
                    Self {
                        type_: self::TraceType::Keyframe,
                        timestamp: 0,
                        direction: self::TraceDirection::DirectionIn,
                        info: ::core::default::Default::default(),
                    }
                }
            }

            impl TraceNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_type_: impl ::planus::WriteAsDefault<self::TraceType, self::TraceType>,
                    field_timestamp: impl ::planus::WriteAsDefault<u64, u64>,
                    field_direction: impl ::planus::WriteAsDefault<
                        self::TraceDirection,
                        self::TraceDirection,
                    >,
                    field_info: impl ::planus::WriteAsOptionalUnion<self::TraceInfo>,
                ) -> ::planus::Offset<Self> {
                    let prepared_type_ = field_type_.prepare(builder, &self::TraceType::Keyframe);

                    let prepared_timestamp = field_timestamp.prepare(builder, &0);

                    let prepared_direction =
                        field_direction.prepare(builder, &self::TraceDirection::DirectionIn);

                    let prepared_info = field_info.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 15>::new(builder);

                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<self::TraceType>(2);
                    }
                    if prepared_timestamp.is_some() {
                        table_writer.calculate_size::<u64>(4);
                    }
                    if prepared_direction.is_some() {
                        table_writer.calculate_size::<self::TraceDirection>(6);
                    }
                    if prepared_info.is_some() {
                        table_writer.calculate_size::<u8>(8);
                        table_writer.calculate_size::<::planus::Offset<self::TraceInfo>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_timestamp) = prepared_timestamp
                        {
                            table_writer.write::<_, _, 8>(1, &prepared_timestamp);
                        }
                        if let ::core::option::Option::Some(prepared_info) = prepared_info {
                            table_writer.write::<_, _, 4>(4, &prepared_info.offset());
                        }
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 1>(0, &prepared_type_);
                        }
                        if let ::core::option::Option::Some(prepared_direction) = prepared_direction
                        {
                            table_writer.write::<_, _, 1>(2, &prepared_direction);
                        }
                        if let ::core::option::Option::Some(prepared_info) = prepared_info {
                            table_writer.write::<_, _, 1>(3, &prepared_info.tag());
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TraceNotification>> for TraceNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TraceNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TraceNotification> for TraceNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TraceNotification> {
                    TraceNotification::create(
                        builder,
                        &self.type_,
                        &self.timestamp,
                        &self.direction,
                        &self.info,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct TraceNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TraceNotificationRef<'a> {
                pub fn type_(&self) -> ::planus::Result<self::TraceType> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "TraceNotification", "type_")?
                            .unwrap_or(self::TraceType::Keyframe),
                    )
                }

                pub fn timestamp(&self) -> ::planus::Result<u64> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "TraceNotification", "timestamp")?
                            .unwrap_or(0),
                    )
                }

                pub fn direction(&self) -> ::planus::Result<self::TraceDirection> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "TraceNotification", "direction")?
                            .unwrap_or(self::TraceDirection::DirectionIn),
                    )
                }

                pub fn info(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TraceInfoRef<'a>>>
                {
                    self.0.access_union(3, "TraceNotification", "info")
                }
            }

            impl<'a> ::core::fmt::Debug for TraceNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TraceNotificationRef");
                    f.field("type_", &self.type_());
                    f.field("timestamp", &self.timestamp());
                    f.field("direction", &self.direction());
                    if let ::core::option::Option::Some(field_info) = self.info().transpose() {
                        f.field("info", &field_info);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TraceNotificationRef<'a>> for TraceNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TraceNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        type_: ::core::convert::TryInto::try_into(value.type_()?)?,
                        timestamp: ::core::convert::TryInto::try_into(value.timestamp()?)?,
                        direction: ::core::convert::TryInto::try_into(value.direction()?)?,
                        info: if let ::core::option::Option::Some(info) = value.info()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(info)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TraceNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TraceNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TraceNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TraceNotification>> for TraceNotification {
                type Value = ::planus::Offset<TraceNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TraceNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TraceNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TraceNotificationRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod pipe_transport {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PipeTransportOptions {
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
                pub listen_ip: ::planus::alloc::boxed::Box<super::transport::ListenIp>,
                pub port: u16,
                pub enable_rtx: bool,
                pub enable_srtp: bool,
            }

            impl PipeTransportOptions {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    field_listen_ip: impl ::planus::WriteAs<
                        ::planus::Offset<super::transport::ListenIp>,
                    >,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_enable_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_srtp: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_listen_ip = field_listen_ip.prepare(builder);

                    let prepared_port = field_port.prepare(builder, &0);

                    let prepared_enable_rtx = field_enable_rtx.prepare(builder, &false);

                    let prepared_enable_srtp = field_enable_srtp.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 12>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Options>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::transport::ListenIp>>(4);
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }
                    if prepared_enable_rtx.is_some() {
                        table_writer.calculate_size::<bool>(8);
                    }
                    if prepared_enable_srtp.is_some() {
                        table_writer.calculate_size::<bool>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_listen_ip);
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(2, &prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_enable_rtx) =
                            prepared_enable_rtx
                        {
                            table_writer.write::<_, _, 1>(3, &prepared_enable_rtx);
                        }
                        if let ::core::option::Option::Some(prepared_enable_srtp) =
                            prepared_enable_srtp
                        {
                            table_writer.write::<_, _, 1>(4, &prepared_enable_srtp);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PipeTransportOptions>> for PipeTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PipeTransportOptions>> for PipeTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PipeTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PipeTransportOptions> for PipeTransportOptions {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PipeTransportOptions> {
                    PipeTransportOptions::create(
                        builder,
                        &self.base,
                        &self.listen_ip,
                        &self.port,
                        &self.enable_rtx,
                        &self.enable_srtp,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct PipeTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PipeTransportOptionsRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "PipeTransportOptions", "base")
                }

                pub fn listen_ip(&self) -> ::planus::Result<super::transport::ListenIpRef<'a>> {
                    self.0
                        .access_required(1, "PipeTransportOptions", "listen_ip")
                }

                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "PipeTransportOptions", "port")?
                            .unwrap_or(0),
                    )
                }

                pub fn enable_rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "PipeTransportOptions", "enable_rtx")?
                            .unwrap_or(false),
                    )
                }

                pub fn enable_srtp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "PipeTransportOptions", "enable_srtp")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PipeTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PipeTransportOptionsRef");
                    f.field("base", &self.base());
                    f.field("listen_ip", &self.listen_ip());
                    f.field("port", &self.port());
                    f.field("enable_rtx", &self.enable_rtx());
                    f.field("enable_srtp", &self.enable_srtp());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PipeTransportOptionsRef<'a>> for PipeTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PipeTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        listen_ip: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.listen_ip()?)?,
                        ),
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        enable_rtx: ::core::convert::TryInto::try_into(value.enable_rtx()?)?,
                        enable_srtp: ::core::convert::TryInto::try_into(value.enable_srtp()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PipeTransportOptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PipeTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PipeTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PipeTransportOptions>> for PipeTransportOptions {
                type Value = ::planus::Offset<PipeTransportOptions>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PipeTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PipeTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PipeTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectRequest {
                pub ip: ::planus::alloc::string::String,
                pub port: ::core::option::Option<u16>,
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::transport::SrtpParameters>,
                >,
            }

            impl ConnectRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_port: impl ::planus::WriteAsOptional<u16>,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);

                    let prepared_port = field_port.prepare(builder);

                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 10>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(4);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::SrtpParameters>>(
                                6,
                            );
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_ip);
                        if let ::core::option::Option::Some(prepared_srtp_parameters) =
                            prepared_srtp_parameters
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_srtp_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(1, &prepared_port);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectRequest> for ConnectRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ConnectRequest::create(builder, &self.ip, &self.port, &self.srtp_parameters)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConnectRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectRequestRef<'a> {
                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ConnectRequest", "ip")
                }

                pub fn port(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(1, "ConnectRequest", "port")
                }

                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::SrtpParametersRef<'a>>>
                {
                    self.0.access(2, "ConnectRequest", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectRequestRef");
                    f.field("ip", &self.ip());
                    if let ::core::option::Option::Some(field_port) = self.port().transpose() {
                        f.field("port", &field_port);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectRequestRef<'a>> for ConnectRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        port: if let ::core::option::Option::Some(port) = value.port()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(port)?)
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Value = ::planus::Offset<ConnectRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectResponse {
                pub tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConnectResponse {
                fn default() -> Self {
                    Self {
                        tuple: ::core::default::Default::default(),
                    }
                }
            }

            impl ConnectResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    if prepared_tuple.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_tuple) = prepared_tuple {
                            table_writer.write::<_, _, 4>(0, &prepared_tuple);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectResponse> for ConnectResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ConnectResponse::create(builder, &self.tuple)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConnectResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectResponseRef<'a> {
                pub fn tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(0, "ConnectResponse", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectResponseRef");
                    if let ::core::option::Option::Some(field_tuple) = self.tuple().transpose() {
                        f.field("tuple", &field_tuple);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectResponseRef<'a>> for ConnectResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: if let ::core::option::Option::Some(tuple) = value.tuple()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Value = ::planus::Offset<ConnectResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                pub rtx: bool,
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::transport::SrtpParameters>,
                >,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtx: impl ::planus::WriteAsDefault<bool, bool>,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_tuple = field_tuple.prepare(builder);

                    let prepared_rtx = field_rtx.prepare(builder, &false);

                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 13>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Dump>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(4);
                    if prepared_rtx.is_some() {
                        table_writer.calculate_size::<bool>(6);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::SrtpParameters>>(
                                8,
                            );
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_tuple);
                        if let ::core::option::Option::Some(prepared_srtp_parameters) =
                            prepared_srtp_parameters
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_srtp_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_rtx) = prepared_rtx {
                            table_writer.write::<_, _, 1>(2, &prepared_rtx);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.base,
                        &self.tuple,
                        &self.rtx,
                        &self.srtp_parameters,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }

                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(1, "DumpResponse", "tuple")
                }

                pub fn rtx(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "DumpResponse", "rtx")?.unwrap_or(false),
                    )
                }

                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::SrtpParametersRef<'a>>>
                {
                    self.0.access(3, "DumpResponse", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.field("tuple", &self.tuple());
                    f.field("rtx", &self.rtx());
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtx: ::core::convert::TryInto::try_into(value.rtx()?)?,
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Stats>>(2);
                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_tuple);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(builder, &self.base, &self.tuple)
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }

                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(1, "GetStatsResponse", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }
        }
        pub mod plain_transport {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PlainTransportOptions {
                pub base:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Options>>,
                pub listen_ip: ::planus::alloc::boxed::Box<super::transport::ListenIp>,
                pub port: u16,
                pub rtcp_mux: bool,
                pub comedia: bool,
                pub enable_srtp: bool,
                pub srtp_crypto_suite: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl PlainTransportOptions {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Options>,
                    >,
                    field_listen_ip: impl ::planus::WriteAs<
                        ::planus::Offset<super::transport::ListenIp>,
                    >,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_rtcp_mux: impl ::planus::WriteAsDefault<bool, bool>,
                    field_comedia: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_srtp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_srtp_crypto_suite: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_listen_ip = field_listen_ip.prepare(builder);

                    let prepared_port = field_port.prepare(builder, &0);

                    let prepared_rtcp_mux = field_rtcp_mux.prepare(builder, &false);

                    let prepared_comedia = field_comedia.prepare(builder, &false);

                    let prepared_enable_srtp = field_enable_srtp.prepare(builder, &false);

                    let prepared_srtp_crypto_suite = field_srtp_crypto_suite.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<16, 17>::new(builder);

                    if prepared_base.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::Options>>(2);
                    }
                    table_writer.calculate_size::<::planus::Offset<super::transport::ListenIp>>(4);
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }
                    if prepared_rtcp_mux.is_some() {
                        table_writer.calculate_size::<bool>(8);
                    }
                    if prepared_comedia.is_some() {
                        table_writer.calculate_size::<bool>(10);
                    }
                    if prepared_enable_srtp.is_some() {
                        table_writer.calculate_size::<bool>(12);
                    }
                    if prepared_srtp_crypto_suite.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(14);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_base) = prepared_base {
                            table_writer.write::<_, _, 4>(0, &prepared_base);
                        }
                        table_writer.write::<_, _, 4>(1, &prepared_listen_ip);
                        if let ::core::option::Option::Some(prepared_srtp_crypto_suite) =
                            prepared_srtp_crypto_suite
                        {
                            table_writer.write::<_, _, 4>(6, &prepared_srtp_crypto_suite);
                        }
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(2, &prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp_mux) = prepared_rtcp_mux {
                            table_writer.write::<_, _, 1>(3, &prepared_rtcp_mux);
                        }
                        if let ::core::option::Option::Some(prepared_comedia) = prepared_comedia {
                            table_writer.write::<_, _, 1>(4, &prepared_comedia);
                        }
                        if let ::core::option::Option::Some(prepared_enable_srtp) =
                            prepared_enable_srtp
                        {
                            table_writer.write::<_, _, 1>(5, &prepared_enable_srtp);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PlainTransportOptions>> for PlainTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PlainTransportOptions>> for PlainTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlainTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PlainTransportOptions> for PlainTransportOptions {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlainTransportOptions> {
                    PlainTransportOptions::create(
                        builder,
                        &self.base,
                        &self.listen_ip,
                        &self.port,
                        &self.rtcp_mux,
                        &self.comedia,
                        &self.enable_srtp,
                        &self.srtp_crypto_suite,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct PlainTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PlainTransportOptionsRef<'a> {
                pub fn base(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::OptionsRef<'a>>>
                {
                    self.0.access(0, "PlainTransportOptions", "base")
                }

                pub fn listen_ip(&self) -> ::planus::Result<super::transport::ListenIpRef<'a>> {
                    self.0
                        .access_required(1, "PlainTransportOptions", "listen_ip")
                }

                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "PlainTransportOptions", "port")?
                            .unwrap_or(0),
                    )
                }

                pub fn rtcp_mux(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "PlainTransportOptions", "rtcp_mux")?
                            .unwrap_or(false),
                    )
                }

                pub fn comedia(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "PlainTransportOptions", "comedia")?
                            .unwrap_or(false),
                    )
                }

                pub fn enable_srtp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "PlainTransportOptions", "enable_srtp")?
                            .unwrap_or(false),
                    )
                }

                pub fn srtp_crypto_suite(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0
                        .access(6, "PlainTransportOptions", "srtp_crypto_suite")
                }
            }

            impl<'a> ::core::fmt::Debug for PlainTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PlainTransportOptionsRef");
                    if let ::core::option::Option::Some(field_base) = self.base().transpose() {
                        f.field("base", &field_base);
                    }
                    f.field("listen_ip", &self.listen_ip());
                    f.field("port", &self.port());
                    f.field("rtcp_mux", &self.rtcp_mux());
                    f.field("comedia", &self.comedia());
                    f.field("enable_srtp", &self.enable_srtp());
                    if let ::core::option::Option::Some(field_srtp_crypto_suite) =
                        self.srtp_crypto_suite().transpose()
                    {
                        f.field("srtp_crypto_suite", &field_srtp_crypto_suite);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PlainTransportOptionsRef<'a>> for PlainTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PlainTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: if let ::core::option::Option::Some(base) = value.base()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(base)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        listen_ip: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.listen_ip()?)?,
                        ),
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        rtcp_mux: ::core::convert::TryInto::try_into(value.rtcp_mux()?)?,
                        comedia: ::core::convert::TryInto::try_into(value.comedia()?)?,
                        enable_srtp: ::core::convert::TryInto::try_into(value.enable_srtp()?)?,
                        srtp_crypto_suite: if let ::core::option::Option::Some(srtp_crypto_suite) =
                            value.srtp_crypto_suite()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                srtp_crypto_suite,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PlainTransportOptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PlainTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlainTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PlainTransportOptions>> for PlainTransportOptions {
                type Value = ::planus::Offset<PlainTransportOptions>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PlainTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PlainTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlainTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectRequest {
                pub ip: ::core::option::Option<::planus::alloc::string::String>,
                pub port: ::core::option::Option<u16>,
                pub rtcp_port: ::core::option::Option<u16>,
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::transport::SrtpParameters>,
                >,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConnectRequest {
                fn default() -> Self {
                    Self {
                        ip: ::core::default::Default::default(),
                        port: ::core::default::Default::default(),
                        rtcp_port: ::core::default::Default::default(),
                        srtp_parameters: ::core::default::Default::default(),
                    }
                }
            }

            impl ConnectRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ip: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    field_port: impl ::planus::WriteAsOptional<u16>,
                    field_rtcp_port: impl ::planus::WriteAsOptional<u16>,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ip = field_ip.prepare(builder);

                    let prepared_port = field_port.prepare(builder);

                    let prepared_rtcp_port = field_rtcp_port.prepare(builder);

                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<10, 12>::new(builder);

                    if prepared_ip.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(2);
                    }
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(4);
                    }
                    if prepared_rtcp_port.is_some() {
                        table_writer.calculate_size::<u16>(6);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::SrtpParameters>>(
                                8,
                            );
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ip) = prepared_ip {
                            table_writer.write::<_, _, 4>(0, &prepared_ip);
                        }
                        if let ::core::option::Option::Some(prepared_srtp_parameters) =
                            prepared_srtp_parameters
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_srtp_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(1, &prepared_port);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp_port) = prepared_rtcp_port
                        {
                            table_writer.write::<_, _, 2>(2, &prepared_rtcp_port);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectRequest> for ConnectRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ConnectRequest::create(
                        builder,
                        &self.ip,
                        &self.port,
                        &self.rtcp_port,
                        &self.srtp_parameters,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConnectRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectRequestRef<'a> {
                pub fn ip(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(0, "ConnectRequest", "ip")
                }

                pub fn port(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(1, "ConnectRequest", "port")
                }

                pub fn rtcp_port(&self) -> ::planus::Result<::core::option::Option<u16>> {
                    self.0.access(2, "ConnectRequest", "rtcp_port")
                }

                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::SrtpParametersRef<'a>>>
                {
                    self.0.access(3, "ConnectRequest", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectRequestRef");
                    if let ::core::option::Option::Some(field_ip) = self.ip().transpose() {
                        f.field("ip", &field_ip);
                    }
                    if let ::core::option::Option::Some(field_port) = self.port().transpose() {
                        f.field("port", &field_port);
                    }
                    if let ::core::option::Option::Some(field_rtcp_port) =
                        self.rtcp_port().transpose()
                    {
                        f.field("rtcp_port", &field_rtcp_port);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectRequestRef<'a>> for ConnectRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ip: if let ::core::option::Option::Some(ip) = value.ip()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(ip)?)
                        } else {
                            ::core::option::Option::None
                        },
                        port: if let ::core::option::Option::Some(port) = value.port()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(port)?)
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp_port: if let ::core::option::Option::Some(rtcp_port) =
                            value.rtcp_port()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                rtcp_port,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Value = ::planus::Offset<ConnectRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectResponse {
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                pub rtcp_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::transport::SrtpParameters>,
                >,
            }

            impl ConnectResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtcp_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let prepared_rtcp_tuple = field_rtcp_tuple.prepare(builder);

                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 12>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(2);
                    if prepared_rtcp_tuple.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(4);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::SrtpParameters>>(
                                6,
                            );
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_tuple);
                        if let ::core::option::Option::Some(prepared_rtcp_tuple) =
                            prepared_rtcp_tuple
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_rtcp_tuple);
                        }
                        if let ::core::option::Option::Some(prepared_srtp_parameters) =
                            prepared_srtp_parameters
                        {
                            table_writer.write::<_, _, 4>(2, &prepared_srtp_parameters);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectResponse> for ConnectResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ConnectResponse::create(
                        builder,
                        &self.tuple,
                        &self.rtcp_tuple,
                        &self.srtp_parameters,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConnectResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectResponseRef<'a> {
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "ConnectResponse", "tuple")
                }

                pub fn rtcp_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(1, "ConnectResponse", "rtcp_tuple")
                }

                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::SrtpParametersRef<'a>>>
                {
                    self.0.access(2, "ConnectResponse", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectResponseRef");
                    f.field("tuple", &self.tuple());
                    if let ::core::option::Option::Some(field_rtcp_tuple) =
                        self.rtcp_tuple().transpose()
                    {
                        f.field("rtcp_tuple", &field_rtcp_tuple);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectResponseRef<'a>> for ConnectResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtcp_tuple: if let ::core::option::Option::Some(rtcp_tuple) =
                            value.rtcp_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Value = ::planus::Offset<ConnectResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
                pub rtcp_mux: bool,
                pub comedia: bool,
                pub tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                pub rtcp_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                pub srtp_parameters: ::core::option::Option<
                    ::planus::alloc::boxed::Box<super::transport::SrtpParameters>,
                >,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    field_rtcp_mux: impl ::planus::WriteAsDefault<bool, bool>,
                    field_comedia: impl ::planus::WriteAsDefault<bool, bool>,
                    field_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_rtcp_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_srtp_parameters: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::SrtpParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_rtcp_mux = field_rtcp_mux.prepare(builder, &false);

                    let prepared_comedia = field_comedia.prepare(builder, &false);

                    let prepared_tuple = field_tuple.prepare(builder);

                    let prepared_rtcp_tuple = field_rtcp_tuple.prepare(builder);

                    let prepared_srtp_parameters = field_srtp_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<14, 18>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Dump>>(2);
                    if prepared_rtcp_mux.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    if prepared_comedia.is_some() {
                        table_writer.calculate_size::<bool>(6);
                    }
                    if prepared_tuple.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(8);
                    }
                    if prepared_rtcp_tuple.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::Tuple>>(10);
                    }
                    if prepared_srtp_parameters.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::SrtpParameters>>(
                                12,
                            );
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        if let ::core::option::Option::Some(prepared_tuple) = prepared_tuple {
                            table_writer.write::<_, _, 4>(3, &prepared_tuple);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp_tuple) =
                            prepared_rtcp_tuple
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_rtcp_tuple);
                        }
                        if let ::core::option::Option::Some(prepared_srtp_parameters) =
                            prepared_srtp_parameters
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_srtp_parameters);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp_mux) = prepared_rtcp_mux {
                            table_writer.write::<_, _, 1>(1, &prepared_rtcp_mux);
                        }
                        if let ::core::option::Option::Some(prepared_comedia) = prepared_comedia {
                            table_writer.write::<_, _, 1>(2, &prepared_comedia);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.base,
                        &self.rtcp_mux,
                        &self.comedia,
                        &self.tuple,
                        &self.rtcp_tuple,
                        &self.srtp_parameters,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }

                pub fn rtcp_mux(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "DumpResponse", "rtcp_mux")?
                            .unwrap_or(false),
                    )
                }

                pub fn comedia(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "DumpResponse", "comedia")?
                            .unwrap_or(false),
                    )
                }

                pub fn tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(3, "DumpResponse", "tuple")
                }

                pub fn rtcp_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(4, "DumpResponse", "rtcp_tuple")
                }

                pub fn srtp_parameters(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::SrtpParametersRef<'a>>>
                {
                    self.0.access(5, "DumpResponse", "srtp_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.field("rtcp_mux", &self.rtcp_mux());
                    f.field("comedia", &self.comedia());
                    if let ::core::option::Option::Some(field_tuple) = self.tuple().transpose() {
                        f.field("tuple", &field_tuple);
                    }
                    if let ::core::option::Option::Some(field_rtcp_tuple) =
                        self.rtcp_tuple().transpose()
                    {
                        f.field("rtcp_tuple", &field_rtcp_tuple);
                    }
                    if let ::core::option::Option::Some(field_srtp_parameters) =
                        self.srtp_parameters().transpose()
                    {
                        f.field("srtp_parameters", &field_srtp_parameters);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtcp_mux: ::core::convert::TryInto::try_into(value.rtcp_mux()?)?,
                        comedia: ::core::convert::TryInto::try_into(value.comedia()?)?,
                        tuple: if let ::core::option::Option::Some(tuple) = value.tuple()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        rtcp_tuple: if let ::core::option::Option::Some(rtcp_tuple) =
                            value.rtcp_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        srtp_parameters: if let ::core::option::Option::Some(srtp_parameters) =
                            value.srtp_parameters()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(srtp_parameters)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
                pub rtcp_mux: bool,
                pub comedia: bool,
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
                pub rtcp_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    field_rtcp_mux: impl ::planus::WriteAsDefault<bool, bool>,
                    field_comedia: impl ::planus::WriteAsDefault<bool, bool>,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                    field_rtcp_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_rtcp_mux = field_rtcp_mux.prepare(builder, &false);

                    let prepared_comedia = field_comedia.prepare(builder, &false);

                    let prepared_tuple = field_tuple.prepare(builder);

                    let prepared_rtcp_tuple = field_rtcp_tuple.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 14>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Stats>>(2);
                    if prepared_rtcp_mux.is_some() {
                        table_writer.calculate_size::<bool>(4);
                    }
                    if prepared_comedia.is_some() {
                        table_writer.calculate_size::<bool>(6);
                    }
                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(8);
                    if prepared_rtcp_tuple.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::Tuple>>(10);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(3, &prepared_tuple);
                        if let ::core::option::Option::Some(prepared_rtcp_tuple) =
                            prepared_rtcp_tuple
                        {
                            table_writer.write::<_, _, 4>(4, &prepared_rtcp_tuple);
                        }
                        if let ::core::option::Option::Some(prepared_rtcp_mux) = prepared_rtcp_mux {
                            table_writer.write::<_, _, 1>(1, &prepared_rtcp_mux);
                        }
                        if let ::core::option::Option::Some(prepared_comedia) = prepared_comedia {
                            table_writer.write::<_, _, 1>(2, &prepared_comedia);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        &self.base,
                        &self.rtcp_mux,
                        &self.comedia,
                        &self.tuple,
                        &self.rtcp_tuple,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }

                pub fn rtcp_mux(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "GetStatsResponse", "rtcp_mux")?
                            .unwrap_or(false),
                    )
                }

                pub fn comedia(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "GetStatsResponse", "comedia")?
                            .unwrap_or(false),
                    )
                }

                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(3, "GetStatsResponse", "tuple")
                }

                pub fn rtcp_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(4, "GetStatsResponse", "rtcp_tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.field("rtcp_mux", &self.rtcp_mux());
                    f.field("comedia", &self.comedia());
                    f.field("tuple", &self.tuple());
                    if let ::core::option::Option::Some(field_rtcp_tuple) =
                        self.rtcp_tuple().transpose()
                    {
                        f.field("rtcp_tuple", &field_rtcp_tuple);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        rtcp_mux: ::core::convert::TryInto::try_into(value.rtcp_mux()?)?,
                        comedia: ::core::convert::TryInto::try_into(value.comedia()?)?,
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                        rtcp_tuple: if let ::core::option::Option::Some(rtcp_tuple) =
                            value.rtcp_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rtcp_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TupleNotification {
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl TupleNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_tuple);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<TupleNotification>> for TupleNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<TupleNotification>> for TupleNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<TupleNotification>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<TupleNotification> for TupleNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<TupleNotification> {
                    TupleNotification::create(builder, &self.tuple)
                }
            }

            #[derive(Copy, Clone)]
            pub struct TupleNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TupleNotificationRef<'a> {
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "TupleNotification", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for TupleNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TupleNotificationRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TupleNotificationRef<'a>> for TupleNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TupleNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TupleNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TupleNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TupleNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<TupleNotification>> for TupleNotification {
                type Value = ::planus::Offset<TupleNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<TupleNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TupleNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TupleNotificationRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RtcpTupleNotification {
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl RtcpTupleNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_tuple);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RtcpTupleNotification>> for RtcpTupleNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RtcpTupleNotification>> for RtcpTupleNotification {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RtcpTupleNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RtcpTupleNotification> for RtcpTupleNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RtcpTupleNotification> {
                    RtcpTupleNotification::create(builder, &self.tuple)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RtcpTupleNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RtcpTupleNotificationRef<'a> {
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0.access_required(0, "RtcpTupleNotification", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for RtcpTupleNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RtcpTupleNotificationRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RtcpTupleNotificationRef<'a>> for RtcpTupleNotification {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RtcpTupleNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RtcpTupleNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RtcpTupleNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpTupleNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RtcpTupleNotification>> for RtcpTupleNotification {
                type Value = ::planus::Offset<RtcpTupleNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RtcpTupleNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RtcpTupleNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RtcpTupleNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod web_rtc_transport {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenIndividual {
                pub listen_ips: ::planus::alloc::vec::Vec<super::transport::ListenIp>,
                pub port: u16,
            }

            impl ListenIndividual {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_listen_ips: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<super::transport::ListenIp>]>,
                    >,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                ) -> ::planus::Offset<Self> {
                    let prepared_listen_ips = field_listen_ips.prepare(builder);

                    let prepared_port = field_port.prepare(builder, &0);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 6>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<[::planus::Offset<super::transport::ListenIp>]>>(2);
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_listen_ips);
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(1, &prepared_port);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenIndividual>> for ListenIndividual {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenIndividual>> for ListenIndividual {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenIndividual>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenIndividual> for ListenIndividual {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenIndividual> {
                    ListenIndividual::create(builder, &self.listen_ips, &self.port)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ListenIndividualRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenIndividualRef<'a> {
                pub fn listen_ips(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<super::transport::ListenIpRef<'a>>>,
                > {
                    self.0.access_required(0, "ListenIndividual", "listen_ips")
                }

                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "ListenIndividual", "port")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ListenIndividualRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenIndividualRef");
                    f.field("listen_ips", &self.listen_ips());
                    f.field("port", &self.port());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenIndividualRef<'a>> for ListenIndividual {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenIndividualRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        listen_ips: value.listen_ips()?.to_vec_result()?,
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenIndividualRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenIndividualRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenIndividualRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenIndividual>> for ListenIndividual {
                type Value = ::planus::Offset<ListenIndividual>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenIndividual>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenIndividualRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenIndividualRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ListenServer {
                pub web_rtc_server_id: ::planus::alloc::string::String,
            }

            impl ListenServer {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_web_rtc_server_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_web_rtc_server_id = field_web_rtc_server_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_web_rtc_server_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ListenServer>> for ListenServer {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ListenServer>> for ListenServer {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ListenServer>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ListenServer> for ListenServer {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ListenServer> {
                    ListenServer::create(builder, &self.web_rtc_server_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ListenServerRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ListenServerRef<'a> {
                pub fn web_rtc_server_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ListenServer", "web_rtc_server_id")
                }
            }

            impl<'a> ::core::fmt::Debug for ListenServerRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ListenServerRef");
                    f.field("web_rtc_server_id", &self.web_rtc_server_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ListenServerRef<'a>> for ListenServer {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ListenServerRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        web_rtc_server_id: ::core::convert::TryInto::try_into(
                            value.web_rtc_server_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ListenServerRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ListenServerRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ListenServerRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ListenServer>> for ListenServer {
                type Value = ::planus::Offset<ListenServer>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ListenServer>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ListenServerRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ListenServerRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum Listen {
                ListenIndividual(::planus::alloc::boxed::Box<self::ListenIndividual>),
                ListenServer(::planus::alloc::boxed::Box<self::ListenServer>),
            }

            impl Listen {
                pub fn create_listen_individual(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::ListenIndividual>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                pub fn create_listen_server(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::ListenServer>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<Listen> for Listen {
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::ListenIndividual(value) => {
                            Self::create_listen_individual(builder, value)
                        }
                        Self::ListenServer(value) => Self::create_listen_server(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<Listen> for Listen {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub enum ListenRef<'a> {
                ListenIndividual(self::ListenIndividualRef<'a>),
                ListenServer(self::ListenServerRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<ListenRef<'a>> for Listen {
                type Error = ::planus::Error;

                fn try_from(value: ListenRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        ListenRef::ListenIndividual(value) => {
                            Listen::ListenIndividual(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        ListenRef::ListenServer(value) => {
                            Listen::ListenServer(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for ListenRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::ListenIndividual(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::ListenServer(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct WebRtcTransportOptions {
                pub base: ::planus::alloc::boxed::Box<super::transport::Options>,
                pub listen: self::Listen,
                pub enable_udp: bool,
                pub enable_tcp: bool,
                pub prefer_udp: bool,
                pub prefer_tcp: bool,
            }

            impl WebRtcTransportOptions {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Options>>,
                    field_listen: impl ::planus::WriteAsUnion<self::Listen>,
                    field_enable_udp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_tcp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_prefer_udp: impl ::planus::WriteAsDefault<bool, bool>,
                    field_prefer_tcp: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_listen = field_listen.prepare(builder);

                    let prepared_enable_udp = field_enable_udp.prepare(builder, &true);

                    let prepared_enable_tcp = field_enable_tcp.prepare(builder, &false);

                    let prepared_prefer_udp = field_prefer_udp.prepare(builder, &false);

                    let prepared_prefer_tcp = field_prefer_tcp.prepare(builder, &false);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<16, 13>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Options>>(2);
                    table_writer.calculate_size::<u8>(4);
                    table_writer.calculate_size::<::planus::Offset<self::Listen>>(6);
                    if prepared_enable_udp.is_some() {
                        table_writer.calculate_size::<bool>(8);
                    }
                    if prepared_enable_tcp.is_some() {
                        table_writer.calculate_size::<bool>(10);
                    }
                    if prepared_prefer_udp.is_some() {
                        table_writer.calculate_size::<bool>(12);
                    }
                    if prepared_prefer_tcp.is_some() {
                        table_writer.calculate_size::<bool>(14);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(2, &prepared_listen.offset());
                        table_writer.write::<_, _, 1>(1, &prepared_listen.tag());
                        if let ::core::option::Option::Some(prepared_enable_udp) =
                            prepared_enable_udp
                        {
                            table_writer.write::<_, _, 1>(3, &prepared_enable_udp);
                        }
                        if let ::core::option::Option::Some(prepared_enable_tcp) =
                            prepared_enable_tcp
                        {
                            table_writer.write::<_, _, 1>(4, &prepared_enable_tcp);
                        }
                        if let ::core::option::Option::Some(prepared_prefer_udp) =
                            prepared_prefer_udp
                        {
                            table_writer.write::<_, _, 1>(5, &prepared_prefer_udp);
                        }
                        if let ::core::option::Option::Some(prepared_prefer_tcp) =
                            prepared_prefer_tcp
                        {
                            table_writer.write::<_, _, 1>(6, &prepared_prefer_tcp);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<WebRtcTransportOptions>> for WebRtcTransportOptions {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<WebRtcTransportOptions>>
                for WebRtcTransportOptions
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<WebRtcTransportOptions>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<WebRtcTransportOptions> for WebRtcTransportOptions {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<WebRtcTransportOptions> {
                    WebRtcTransportOptions::create(
                        builder,
                        &self.base,
                        &self.listen,
                        &self.enable_udp,
                        &self.enable_tcp,
                        &self.prefer_udp,
                        &self.prefer_tcp,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct WebRtcTransportOptionsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> WebRtcTransportOptionsRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::OptionsRef<'a>> {
                    self.0.access_required(0, "WebRtcTransportOptions", "base")
                }

                pub fn listen(&self) -> ::planus::Result<self::ListenRef<'a>> {
                    self.0
                        .access_union_required(1, "WebRtcTransportOptions", "listen")
                }

                pub fn enable_udp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "WebRtcTransportOptions", "enable_udp")?
                            .unwrap_or(true),
                    )
                }

                pub fn enable_tcp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "WebRtcTransportOptions", "enable_tcp")?
                            .unwrap_or(false),
                    )
                }

                pub fn prefer_udp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "WebRtcTransportOptions", "prefer_udp")?
                            .unwrap_or(false),
                    )
                }

                pub fn prefer_tcp(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "WebRtcTransportOptions", "prefer_tcp")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for WebRtcTransportOptionsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("WebRtcTransportOptionsRef");
                    f.field("base", &self.base());
                    f.field("listen", &self.listen());
                    f.field("enable_udp", &self.enable_udp());
                    f.field("enable_tcp", &self.enable_tcp());
                    f.field("prefer_udp", &self.prefer_udp());
                    f.field("prefer_tcp", &self.prefer_tcp());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<WebRtcTransportOptionsRef<'a>> for WebRtcTransportOptions {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: WebRtcTransportOptionsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        listen: ::core::convert::TryInto::try_into(value.listen()?)?,
                        enable_udp: ::core::convert::TryInto::try_into(value.enable_udp()?)?,
                        enable_tcp: ::core::convert::TryInto::try_into(value.enable_tcp()?)?,
                        prefer_udp: ::core::convert::TryInto::try_into(value.prefer_udp()?)?,
                        prefer_tcp: ::core::convert::TryInto::try_into(value.prefer_tcp()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for WebRtcTransportOptionsRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for WebRtcTransportOptionsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[WebRtcTransportOptionsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<WebRtcTransportOptions>> for WebRtcTransportOptions {
                type Value = ::planus::Offset<WebRtcTransportOptions>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<WebRtcTransportOptions>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for WebRtcTransportOptionsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[WebRtcTransportOptionsRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Fingerprint {
                pub algorithm: ::planus::alloc::string::String,
                pub value: ::planus::alloc::string::String,
            }

            impl Fingerprint {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_algorithm: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_value: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_algorithm = field_algorithm.prepare(builder);

                    let prepared_value = field_value.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_algorithm);
                        table_writer.write::<_, _, 4>(1, &prepared_value);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Fingerprint>> for Fingerprint {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Fingerprint>> for Fingerprint {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Fingerprint>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Fingerprint> for Fingerprint {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Fingerprint> {
                    Fingerprint::create(builder, &self.algorithm, &self.value)
                }
            }

            #[derive(Copy, Clone)]
            pub struct FingerprintRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FingerprintRef<'a> {
                pub fn algorithm(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "Fingerprint", "algorithm")
                }

                pub fn value(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "Fingerprint", "value")
                }
            }

            impl<'a> ::core::fmt::Debug for FingerprintRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FingerprintRef");
                    f.field("algorithm", &self.algorithm());
                    f.field("value", &self.value());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FingerprintRef<'a>> for Fingerprint {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FingerprintRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        algorithm: ::core::convert::TryInto::try_into(value.algorithm()?)?,
                        value: ::core::convert::TryInto::try_into(value.value()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FingerprintRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FingerprintRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FingerprintRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Fingerprint>> for Fingerprint {
                type Value = ::planus::Offset<Fingerprint>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Fingerprint>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FingerprintRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FingerprintRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DtlsParameters {
                pub fingerprints: ::planus::alloc::vec::Vec<self::Fingerprint>,
                pub role: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl DtlsParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_fingerprints: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::Fingerprint>]>,
                    >,
                    field_role: impl ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_fingerprints = field_fingerprints.prepare(builder);

                    let prepared_role = field_role.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 8>::new(builder);

                    table_writer
                        .calculate_size::<::planus::Offset<[::planus::Offset<self::Fingerprint>]>>(
                            2,
                        );
                    if prepared_role.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_fingerprints);
                        if let ::core::option::Option::Some(prepared_role) = prepared_role {
                            table_writer.write::<_, _, 4>(1, &prepared_role);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DtlsParameters>> for DtlsParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DtlsParameters>> for DtlsParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DtlsParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DtlsParameters> for DtlsParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsParameters> {
                    DtlsParameters::create(builder, &self.fingerprints, &self.role)
                }
            }

            #[derive(Copy, Clone)]
            pub struct DtlsParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DtlsParametersRef<'a> {
                pub fn fingerprints(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::FingerprintRef<'a>>>,
                > {
                    self.0.access_required(0, "DtlsParameters", "fingerprints")
                }

                pub fn role(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(1, "DtlsParameters", "role")
                }
            }

            impl<'a> ::core::fmt::Debug for DtlsParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DtlsParametersRef");
                    f.field("fingerprints", &self.fingerprints());
                    if let ::core::option::Option::Some(field_role) = self.role().transpose() {
                        f.field("role", &field_role);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DtlsParametersRef<'a>> for DtlsParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DtlsParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        fingerprints: value.fingerprints()?.to_vec_result()?,
                        role: if let ::core::option::Option::Some(role) = value.role()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(role)?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DtlsParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DtlsParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DtlsParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DtlsParameters>> for DtlsParameters {
                type Value = ::planus::Offset<DtlsParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DtlsParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DtlsParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DtlsParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceParameters {
                pub username_fragment: ::planus::alloc::string::String,
                pub password: ::planus::alloc::string::String,
                pub ice_lite: bool,
            }

            impl IceParameters {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_username_fragment: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_password: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_lite: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_username_fragment = field_username_fragment.prepare(builder);

                    let prepared_password = field_password.prepare(builder);

                    let prepared_ice_lite = field_ice_lite.prepare(builder, &true);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<8, 9>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    if prepared_ice_lite.is_some() {
                        table_writer.calculate_size::<bool>(6);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_username_fragment);
                        table_writer.write::<_, _, 4>(1, &prepared_password);
                        if let ::core::option::Option::Some(prepared_ice_lite) = prepared_ice_lite {
                            table_writer.write::<_, _, 1>(2, &prepared_ice_lite);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceParameters>> for IceParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceParameters>> for IceParameters {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceParameters>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceParameters> for IceParameters {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceParameters> {
                    IceParameters::create(
                        builder,
                        &self.username_fragment,
                        &self.password,
                        &self.ice_lite,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct IceParametersRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceParametersRef<'a> {
                pub fn username_fragment(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "IceParameters", "username_fragment")
                }

                pub fn password(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "IceParameters", "password")
                }

                pub fn ice_lite(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "IceParameters", "ice_lite")?
                            .unwrap_or(true),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for IceParametersRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceParametersRef");
                    f.field("username_fragment", &self.username_fragment());
                    f.field("password", &self.password());
                    f.field("ice_lite", &self.ice_lite());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceParametersRef<'a>> for IceParameters {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceParametersRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        username_fragment: ::core::convert::TryInto::try_into(
                            value.username_fragment()?,
                        )?,
                        password: ::core::convert::TryInto::try_into(value.password()?)?,
                        ice_lite: ::core::convert::TryInto::try_into(value.ice_lite()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceParametersRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceParametersRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceParametersRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceParameters>> for IceParameters {
                type Value = ::planus::Offset<IceParameters>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceParameters>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceParametersRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IceParametersRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceCandidate {
                pub foundation: ::planus::alloc::string::String,
                pub priority: u32,
                pub ip: ::planus::alloc::string::String,
                pub protocol: ::planus::alloc::string::String,
                pub port: u16,
                pub type_: ::core::option::Option<::planus::alloc::string::String>,
                pub tcp_type: ::core::option::Option<::planus::alloc::string::String>,
            }

            impl IceCandidate {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_foundation: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_priority: impl ::planus::WriteAsDefault<u32, u32>,
                    field_ip: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_protocol: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_port: impl ::planus::WriteAsDefault<u16, u16>,
                    field_type_: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_tcp_type: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_foundation = field_foundation.prepare(builder);

                    let prepared_priority = field_priority.prepare(builder, &0);

                    let prepared_ip = field_ip.prepare(builder);

                    let prepared_protocol = field_protocol.prepare(builder);

                    let prepared_port = field_port.prepare(builder, &0);

                    let prepared_type_ = field_type_.prepare(builder);

                    let prepared_tcp_type = field_tcp_type.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<16, 26>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);
                    if prepared_priority.is_some() {
                        table_writer.calculate_size::<u32>(4);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    table_writer.calculate_size::<::planus::Offset<str>>(8);
                    if prepared_port.is_some() {
                        table_writer.calculate_size::<u16>(10);
                    }
                    if prepared_type_.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(12);
                    }
                    if prepared_tcp_type.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(14);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_foundation);
                        if let ::core::option::Option::Some(prepared_priority) = prepared_priority {
                            table_writer.write::<_, _, 4>(1, &prepared_priority);
                        }
                        table_writer.write::<_, _, 4>(2, &prepared_ip);
                        table_writer.write::<_, _, 4>(3, &prepared_protocol);
                        if let ::core::option::Option::Some(prepared_type_) = prepared_type_ {
                            table_writer.write::<_, _, 4>(5, &prepared_type_);
                        }
                        if let ::core::option::Option::Some(prepared_tcp_type) = prepared_tcp_type {
                            table_writer.write::<_, _, 4>(6, &prepared_tcp_type);
                        }
                        if let ::core::option::Option::Some(prepared_port) = prepared_port {
                            table_writer.write::<_, _, 2>(4, &prepared_port);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceCandidate>> for IceCandidate {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceCandidate>> for IceCandidate {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceCandidate>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceCandidate> for IceCandidate {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceCandidate> {
                    IceCandidate::create(
                        builder,
                        &self.foundation,
                        &self.priority,
                        &self.ip,
                        &self.protocol,
                        &self.port,
                        &self.type_,
                        &self.tcp_type,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct IceCandidateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceCandidateRef<'a> {
                pub fn foundation(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "IceCandidate", "foundation")
                }

                pub fn priority(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "IceCandidate", "priority")?.unwrap_or(0),
                    )
                }

                pub fn ip(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "IceCandidate", "ip")
                }

                pub fn protocol(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "IceCandidate", "protocol")
                }

                pub fn port(&self) -> ::planus::Result<u16> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "IceCandidate", "port")?.unwrap_or(0),
                    )
                }

                pub fn type_(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(5, "IceCandidate", "type_")
                }

                pub fn tcp_type(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(6, "IceCandidate", "tcp_type")
                }
            }

            impl<'a> ::core::fmt::Debug for IceCandidateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceCandidateRef");
                    f.field("foundation", &self.foundation());
                    f.field("priority", &self.priority());
                    f.field("ip", &self.ip());
                    f.field("protocol", &self.protocol());
                    f.field("port", &self.port());
                    if let ::core::option::Option::Some(field_type_) = self.type_().transpose() {
                        f.field("type_", &field_type_);
                    }
                    if let ::core::option::Option::Some(field_tcp_type) =
                        self.tcp_type().transpose()
                    {
                        f.field("tcp_type", &field_tcp_type);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceCandidateRef<'a>> for IceCandidate {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceCandidateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        foundation: ::core::convert::TryInto::try_into(value.foundation()?)?,
                        priority: ::core::convert::TryInto::try_into(value.priority()?)?,
                        ip: ::core::convert::TryInto::try_into(value.ip()?)?,
                        protocol: ::core::convert::TryInto::try_into(value.protocol()?)?,
                        port: ::core::convert::TryInto::try_into(value.port()?)?,
                        type_: if let ::core::option::Option::Some(type_) = value.type_()? {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(type_)?)
                        } else {
                            ::core::option::Option::None
                        },
                        tcp_type: if let ::core::option::Option::Some(tcp_type) =
                            value.tcp_type()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                tcp_type,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceCandidateRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceCandidateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceCandidateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceCandidate>> for IceCandidate {
                type Value = ::planus::Offset<IceCandidate>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceCandidate>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceCandidateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[IceCandidateRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectRequest {
                pub dtls_parameters: ::planus::alloc::boxed::Box<self::DtlsParameters>,
            }

            impl ConnectRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_dtls_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<self::DtlsParameters>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_dtls_parameters = field_dtls_parameters.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<self::DtlsParameters>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_dtls_parameters);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectRequest> for ConnectRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectRequest> {
                    ConnectRequest::create(builder, &self.dtls_parameters)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConnectRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectRequestRef<'a> {
                pub fn dtls_parameters(&self) -> ::planus::Result<self::DtlsParametersRef<'a>> {
                    self.0
                        .access_required(0, "ConnectRequest", "dtls_parameters")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectRequestRef");
                    f.field("dtls_parameters", &self.dtls_parameters());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectRequestRef<'a>> for ConnectRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        dtls_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.dtls_parameters()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectRequest>> for ConnectRequest {
                type Value = ::planus::Offset<ConnectRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectResponse {
                pub dtls_local_role: ::planus::alloc::string::String,
            }

            impl ConnectResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_dtls_local_role: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_dtls_local_role = field_dtls_local_role.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_dtls_local_role);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectResponse> for ConnectResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectResponse> {
                    ConnectResponse::create(builder, &self.dtls_local_role)
                }
            }

            #[derive(Copy, Clone)]
            pub struct ConnectResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectResponseRef<'a> {
                pub fn dtls_local_role(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "ConnectResponse", "dtls_local_role")
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectResponseRef");
                    f.field("dtls_local_role", &self.dtls_local_role());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectResponseRef<'a>> for ConnectResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        dtls_local_role: ::core::convert::TryInto::try_into(
                            value.dtls_local_role()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectResponse>> for ConnectResponse {
                type Value = ::planus::Offset<ConnectResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DumpResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Dump>,
                pub ice_role: ::planus::alloc::string::String,
                pub ice_parameters: ::planus::alloc::boxed::Box<self::IceParameters>,
                pub ice_candidates: ::planus::alloc::vec::Vec<self::IceCandidate>,
                pub ice_state: ::planus::alloc::string::String,
                pub ice_selected_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                pub dtls_parameters: ::planus::alloc::boxed::Box<self::DtlsParameters>,
                pub dtls_state: ::planus::alloc::string::String,
            }

            impl DumpResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Dump>>,
                    field_ice_role: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_parameters: impl ::planus::WriteAs<::planus::Offset<self::IceParameters>>,
                    field_ice_candidates: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::IceCandidate>]>,
                    >,
                    field_ice_state: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_selected_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_dtls_parameters: impl ::planus::WriteAs<
                        ::planus::Offset<self::DtlsParameters>,
                    >,
                    field_dtls_state: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_ice_role = field_ice_role.prepare(builder);

                    let prepared_ice_parameters = field_ice_parameters.prepare(builder);

                    let prepared_ice_candidates = field_ice_candidates.prepare(builder);

                    let prepared_ice_state = field_ice_state.prepare(builder);

                    let prepared_ice_selected_tuple = field_ice_selected_tuple.prepare(builder);

                    let prepared_dtls_parameters = field_dtls_parameters.prepare(builder);

                    let prepared_dtls_state = field_dtls_state.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<18, 32>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Dump>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    table_writer.calculate_size::<::planus::Offset<self::IceParameters>>(6);
                    table_writer
                        .calculate_size::<::planus::Offset<[::planus::Offset<self::IceCandidate>]>>(
                            8,
                        );
                    table_writer.calculate_size::<::planus::Offset<str>>(10);
                    if prepared_ice_selected_tuple.is_some() {
                        table_writer
                            .calculate_size::<::planus::Offset<super::transport::Tuple>>(12);
                    }
                    table_writer.calculate_size::<::planus::Offset<self::DtlsParameters>>(14);
                    table_writer.calculate_size::<::planus::Offset<str>>(16);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_ice_role);
                        table_writer.write::<_, _, 4>(2, &prepared_ice_parameters);
                        table_writer.write::<_, _, 4>(3, &prepared_ice_candidates);
                        table_writer.write::<_, _, 4>(4, &prepared_ice_state);
                        if let ::core::option::Option::Some(prepared_ice_selected_tuple) =
                            prepared_ice_selected_tuple
                        {
                            table_writer.write::<_, _, 4>(5, &prepared_ice_selected_tuple);
                        }
                        table_writer.write::<_, _, 4>(6, &prepared_dtls_parameters);
                        table_writer.write::<_, _, 4>(7, &prepared_dtls_state);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DumpResponse>> for DumpResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DumpResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DumpResponse> for DumpResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DumpResponse> {
                    DumpResponse::create(
                        builder,
                        &self.base,
                        &self.ice_role,
                        &self.ice_parameters,
                        &self.ice_candidates,
                        &self.ice_state,
                        &self.ice_selected_tuple,
                        &self.dtls_parameters,
                        &self.dtls_state,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DumpResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DumpResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::DumpRef<'a>> {
                    self.0.access_required(0, "DumpResponse", "base")
                }

                pub fn ice_role(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "DumpResponse", "ice_role")
                }

                pub fn ice_parameters(&self) -> ::planus::Result<self::IceParametersRef<'a>> {
                    self.0.access_required(2, "DumpResponse", "ice_parameters")
                }

                pub fn ice_candidates(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::IceCandidateRef<'a>>>,
                > {
                    self.0.access_required(3, "DumpResponse", "ice_candidates")
                }

                pub fn ice_state(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "DumpResponse", "ice_state")
                }

                pub fn ice_selected_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(5, "DumpResponse", "ice_selected_tuple")
                }

                pub fn dtls_parameters(&self) -> ::planus::Result<self::DtlsParametersRef<'a>> {
                    self.0.access_required(6, "DumpResponse", "dtls_parameters")
                }

                pub fn dtls_state(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(7, "DumpResponse", "dtls_state")
                }
            }

            impl<'a> ::core::fmt::Debug for DumpResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DumpResponseRef");
                    f.field("base", &self.base());
                    f.field("ice_role", &self.ice_role());
                    f.field("ice_parameters", &self.ice_parameters());
                    f.field("ice_candidates", &self.ice_candidates());
                    f.field("ice_state", &self.ice_state());
                    if let ::core::option::Option::Some(field_ice_selected_tuple) =
                        self.ice_selected_tuple().transpose()
                    {
                        f.field("ice_selected_tuple", &field_ice_selected_tuple);
                    }
                    f.field("dtls_parameters", &self.dtls_parameters());
                    f.field("dtls_state", &self.dtls_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DumpResponseRef<'a>> for DumpResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DumpResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        ice_role: ::core::convert::TryInto::try_into(value.ice_role()?)?,
                        ice_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.ice_parameters()?)?,
                        ),
                        ice_candidates: value.ice_candidates()?.to_vec_result()?,
                        ice_state: ::core::convert::TryInto::try_into(value.ice_state()?)?,
                        ice_selected_tuple: if let ::core::option::Option::Some(
                            ice_selected_tuple,
                        ) = value.ice_selected_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(ice_selected_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        dtls_parameters: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.dtls_parameters()?)?,
                        ),
                        dtls_state: ::core::convert::TryInto::try_into(value.dtls_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DumpResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DumpResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DumpResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DumpResponse>> for DumpResponse {
                type Value = ::planus::Offset<DumpResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DumpResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DumpResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DumpResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct GetStatsResponse {
                pub base: ::planus::alloc::boxed::Box<super::transport::Stats>,
                pub ice_role: ::planus::alloc::string::String,
                pub ice_state: ::planus::alloc::string::String,
                pub ice_selected_tuple:
                    ::core::option::Option<::planus::alloc::boxed::Box<super::transport::Tuple>>,
                pub dtls_state: ::planus::alloc::string::String,
            }

            impl GetStatsResponse {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_base: impl ::planus::WriteAs<::planus::Offset<super::transport::Stats>>,
                    field_ice_role: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_state: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_ice_selected_tuple: impl ::planus::WriteAsOptional<
                        ::planus::Offset<super::transport::Tuple>,
                    >,
                    field_dtls_state: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_base = field_base.prepare(builder);

                    let prepared_ice_role = field_ice_role.prepare(builder);

                    let prepared_ice_state = field_ice_state.prepare(builder);

                    let prepared_ice_selected_tuple = field_ice_selected_tuple.prepare(builder);

                    let prepared_dtls_state = field_dtls_state.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<12, 20>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Stats>>(2);
                    table_writer.calculate_size::<::planus::Offset<str>>(4);
                    table_writer.calculate_size::<::planus::Offset<str>>(6);
                    if prepared_ice_selected_tuple.is_some() {
                        table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(8);
                    }
                    table_writer.calculate_size::<::planus::Offset<str>>(10);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_base);
                        table_writer.write::<_, _, 4>(1, &prepared_ice_role);
                        table_writer.write::<_, _, 4>(2, &prepared_ice_state);
                        if let ::core::option::Option::Some(prepared_ice_selected_tuple) =
                            prepared_ice_selected_tuple
                        {
                            table_writer.write::<_, _, 4>(3, &prepared_ice_selected_tuple);
                        }
                        table_writer.write::<_, _, 4>(4, &prepared_dtls_state);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GetStatsResponse>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GetStatsResponse> for GetStatsResponse {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<GetStatsResponse> {
                    GetStatsResponse::create(
                        builder,
                        &self.base,
                        &self.ice_role,
                        &self.ice_state,
                        &self.ice_selected_tuple,
                        &self.dtls_state,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct GetStatsResponseRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GetStatsResponseRef<'a> {
                pub fn base(&self) -> ::planus::Result<super::transport::StatsRef<'a>> {
                    self.0.access_required(0, "GetStatsResponse", "base")
                }

                pub fn ice_role(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "GetStatsResponse", "ice_role")
                }

                pub fn ice_state(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "GetStatsResponse", "ice_state")
                }

                pub fn ice_selected_tuple(
                    &self,
                ) -> ::planus::Result<::core::option::Option<super::transport::TupleRef<'a>>>
                {
                    self.0.access(3, "GetStatsResponse", "ice_selected_tuple")
                }

                pub fn dtls_state(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "GetStatsResponse", "dtls_state")
                }
            }

            impl<'a> ::core::fmt::Debug for GetStatsResponseRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GetStatsResponseRef");
                    f.field("base", &self.base());
                    f.field("ice_role", &self.ice_role());
                    f.field("ice_state", &self.ice_state());
                    if let ::core::option::Option::Some(field_ice_selected_tuple) =
                        self.ice_selected_tuple().transpose()
                    {
                        f.field("ice_selected_tuple", &field_ice_selected_tuple);
                    }
                    f.field("dtls_state", &self.dtls_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GetStatsResponseRef<'a>> for GetStatsResponse {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GetStatsResponseRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        base: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.base()?,
                        )?),
                        ice_role: ::core::convert::TryInto::try_into(value.ice_role()?)?,
                        ice_state: ::core::convert::TryInto::try_into(value.ice_state()?)?,
                        ice_selected_tuple: if let ::core::option::Option::Some(
                            ice_selected_tuple,
                        ) = value.ice_selected_tuple()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(ice_selected_tuple)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        dtls_state: ::core::convert::TryInto::try_into(value.dtls_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GetStatsResponseRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GetStatsResponseRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GetStatsResponseRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GetStatsResponse>> for GetStatsResponse {
                type Value = ::planus::Offset<GetStatsResponse>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GetStatsResponse>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GetStatsResponseRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GetStatsResponseRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceSelectedTupleChangeNotification {
                pub tuple: ::planus::alloc::boxed::Box<super::transport::Tuple>,
            }

            impl IceSelectedTupleChangeNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_tuple: impl ::planus::WriteAs<::planus::Offset<super::transport::Tuple>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_tuple = field_tuple.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<super::transport::Tuple>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_tuple);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceSelectedTupleChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceSelectedTupleChangeNotification>
                for IceSelectedTupleChangeNotification
            {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceSelectedTupleChangeNotification> {
                    IceSelectedTupleChangeNotification::create(builder, &self.tuple)
                }
            }

            #[derive(Copy, Clone)]
            pub struct IceSelectedTupleChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceSelectedTupleChangeNotificationRef<'a> {
                pub fn tuple(&self) -> ::planus::Result<super::transport::TupleRef<'a>> {
                    self.0
                        .access_required(0, "IceSelectedTupleChangeNotification", "tuple")
                }
            }

            impl<'a> ::core::fmt::Debug for IceSelectedTupleChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceSelectedTupleChangeNotificationRef");
                    f.field("tuple", &self.tuple());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceSelectedTupleChangeNotificationRef<'a>>
                for IceSelectedTupleChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(
                    value: IceSelectedTupleChangeNotificationRef<'a>,
                ) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        tuple: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.tuple()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceSelectedTupleChangeNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceSelectedTupleChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceSelectedTupleChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceSelectedTupleChangeNotification>>
                for IceSelectedTupleChangeNotification
            {
                type Value = ::planus::Offset<IceSelectedTupleChangeNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceSelectedTupleChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceSelectedTupleChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceSelectedTupleChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum IceState {
                New = 0,
                Connected = 1,
                Completed = 2,
                Disconnected = 3,
                Closed = 4,
            }

            impl ::core::convert::TryFrom<u8> for IceState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(IceState::New),
                        1 => ::core::result::Result::Ok(IceState::Connected),
                        2 => ::core::result::Result::Ok(IceState::Completed),
                        3 => ::core::result::Result::Ok(IceState::Disconnected),
                        4 => ::core::result::Result::Ok(IceState::Closed),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<IceState> for u8 {
                fn from(value: IceState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for IceState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<IceState> for IceState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<IceState> for IceState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> IceState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<IceState, IceState> for IceState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &IceState,
                ) -> ::core::option::Option<IceState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<IceState> for IceState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<IceState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for IceState {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for IceState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "IceState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<IceState> for IceState {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum DtlsState {
                New = 0,
                Connecting = 1,
                Connected = 2,
                Failed = 3,
                Closed = 4,
            }

            impl ::core::convert::TryFrom<u8> for DtlsState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(DtlsState::New),
                        1 => ::core::result::Result::Ok(DtlsState::Connecting),
                        2 => ::core::result::Result::Ok(DtlsState::Connected),
                        3 => ::core::result::Result::Ok(DtlsState::Failed),
                        4 => ::core::result::Result::Ok(DtlsState::Closed),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<DtlsState> for u8 {
                fn from(value: DtlsState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for DtlsState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<DtlsState> for DtlsState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<DtlsState> for DtlsState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> DtlsState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<DtlsState, DtlsState> for DtlsState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &DtlsState,
                ) -> ::core::option::Option<DtlsState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<DtlsState> for DtlsState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<DtlsState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for DtlsState {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for DtlsState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = <u8 as ::planus::VectorRead>::from_buffer(buffer, offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "DtlsState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<DtlsState> for DtlsState {
                const STRIDE: usize = 1;

                type Value = Self;

                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct IceStateChangeNotification {
                pub ice_state: self::IceState,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for IceStateChangeNotification {
                fn default() -> Self {
                    Self {
                        ice_state: self::IceState::New,
                    }
                }
            }

            impl IceStateChangeNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ice_state: impl ::planus::WriteAsDefault<self::IceState, self::IceState>,
                ) -> ::planus::Offset<Self> {
                    let prepared_ice_state = field_ice_state.prepare(builder, &self::IceState::New);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 1>::new(builder);

                    if prepared_ice_state.is_some() {
                        table_writer.calculate_size::<self::IceState>(2);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_ice_state) = prepared_ice_state
                        {
                            table_writer.write::<_, _, 1>(0, &prepared_ice_state);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<IceStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<IceStateChangeNotification> for IceStateChangeNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<IceStateChangeNotification> {
                    IceStateChangeNotification::create(builder, &self.ice_state)
                }
            }

            #[derive(Copy, Clone)]
            pub struct IceStateChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> IceStateChangeNotificationRef<'a> {
                pub fn ice_state(&self) -> ::planus::Result<self::IceState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "IceStateChangeNotification", "ice_state")?
                            .unwrap_or(self::IceState::New),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for IceStateChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("IceStateChangeNotificationRef");
                    f.field("ice_state", &self.ice_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<IceStateChangeNotificationRef<'a>>
                for IceStateChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: IceStateChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ice_state: ::core::convert::TryInto::try_into(value.ice_state()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for IceStateChangeNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for IceStateChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceStateChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<IceStateChangeNotification>>
                for IceStateChangeNotification
            {
                type Value = ::planus::Offset<IceStateChangeNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<IceStateChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for IceStateChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[IceStateChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct DtlsStateChangeNotification {
                pub dtls_state: self::DtlsState,
                pub remote_cert: ::core::option::Option<::planus::alloc::string::String>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DtlsStateChangeNotification {
                fn default() -> Self {
                    Self {
                        dtls_state: self::DtlsState::New,
                        remote_cert: ::core::default::Default::default(),
                    }
                }
            }

            impl DtlsStateChangeNotification {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_dtls_state: impl ::planus::WriteAsDefault<self::DtlsState, self::DtlsState>,
                    field_remote_cert: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_dtls_state =
                        field_dtls_state.prepare(builder, &self::DtlsState::New);

                    let prepared_remote_cert = field_remote_cert.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<6, 5>::new(builder);

                    if prepared_dtls_state.is_some() {
                        table_writer.calculate_size::<self::DtlsState>(2);
                    }
                    if prepared_remote_cert.is_some() {
                        table_writer.calculate_size::<::planus::Offset<str>>(4);
                    }

                    table_writer.finish_calculating();

                    unsafe {
                        if let ::core::option::Option::Some(prepared_remote_cert) =
                            prepared_remote_cert
                        {
                            table_writer.write::<_, _, 4>(1, &prepared_remote_cert);
                        }
                        if let ::core::option::Option::Some(prepared_dtls_state) =
                            prepared_dtls_state
                        {
                            table_writer.write::<_, _, 1>(0, &prepared_dtls_state);
                        }
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotification
            {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DtlsStateChangeNotification>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DtlsStateChangeNotification> for DtlsStateChangeNotification {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DtlsStateChangeNotification> {
                    DtlsStateChangeNotification::create(
                        builder,
                        &self.dtls_state,
                        &self.remote_cert,
                    )
                }
            }

            #[derive(Copy, Clone)]
            pub struct DtlsStateChangeNotificationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DtlsStateChangeNotificationRef<'a> {
                pub fn dtls_state(&self) -> ::planus::Result<self::DtlsState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "DtlsStateChangeNotification", "dtls_state")?
                            .unwrap_or(self::DtlsState::New),
                    )
                }

                pub fn remote_cert(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0
                        .access(1, "DtlsStateChangeNotification", "remote_cert")
                }
            }

            impl<'a> ::core::fmt::Debug for DtlsStateChangeNotificationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DtlsStateChangeNotificationRef");
                    f.field("dtls_state", &self.dtls_state());
                    if let ::core::option::Option::Some(field_remote_cert) =
                        self.remote_cert().transpose()
                    {
                        f.field("remote_cert", &field_remote_cert);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DtlsStateChangeNotificationRef<'a>>
                for DtlsStateChangeNotification
            {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DtlsStateChangeNotificationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        dtls_state: ::core::convert::TryInto::try_into(value.dtls_state()?)?,
                        remote_cert: if let ::core::option::Option::Some(remote_cert) =
                            value.remote_cert()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                remote_cert,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DtlsStateChangeNotificationRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DtlsStateChangeNotificationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DtlsStateChangeNotificationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DtlsStateChangeNotification>>
                for DtlsStateChangeNotification
            {
                type Value = ::planus::Offset<DtlsStateChangeNotification>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DtlsStateChangeNotification>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DtlsStateChangeNotificationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DtlsStateChangeNotificationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
        pub mod rtp_observer {
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct AddProducerRequest {
                pub producer_id: ::planus::alloc::string::String,
            }

            impl AddProducerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_producer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<AddProducerRequest>> for AddProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<AddProducerRequest>> for AddProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<AddProducerRequest>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<AddProducerRequest> for AddProducerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<AddProducerRequest> {
                    AddProducerRequest::create(builder, &self.producer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct AddProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> AddProducerRequestRef<'a> {
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "AddProducerRequest", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for AddProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("AddProducerRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<AddProducerRequestRef<'a>> for AddProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: AddProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for AddProducerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for AddProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[AddProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<AddProducerRequest>> for AddProducerRequest {
                type Value = ::planus::Offset<AddProducerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<AddProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for AddProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[AddProducerRequestRef]", "read_as_root", 0)
                    })
                }
            }

            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RemoveProducerRequest {
                pub producer_id: ::planus::alloc::string::String,
            }

            impl RemoveProducerRequest {
                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_producer_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_producer_id = field_producer_id.prepare(builder);

                    let mut table_writer =
                        ::planus::table_writer::TableWriter::<4, 4>::new(builder);

                    table_writer.calculate_size::<::planus::Offset<str>>(2);

                    table_writer.finish_calculating();

                    unsafe {
                        table_writer.write::<_, _, 4>(0, &prepared_producer_id);
                    }

                    table_writer.finish()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RemoveProducerRequest>> for RemoveProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RemoveProducerRequest>> for RemoveProducerRequest {
                type Prepared = ::planus::Offset<Self>;

                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RemoveProducerRequest>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RemoveProducerRequest> for RemoveProducerRequest {
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveProducerRequest> {
                    RemoveProducerRequest::create(builder, &self.producer_id)
                }
            }

            #[derive(Copy, Clone)]
            pub struct RemoveProducerRequestRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RemoveProducerRequestRef<'a> {
                pub fn producer_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(0, "RemoveProducerRequest", "producer_id")
                }
            }

            impl<'a> ::core::fmt::Debug for RemoveProducerRequestRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RemoveProducerRequestRef");
                    f.field("producer_id", &self.producer_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RemoveProducerRequestRef<'a>> for RemoveProducerRequest {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RemoveProducerRequestRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        producer_id: ::core::convert::TryInto::try_into(value.producer_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RemoveProducerRequestRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RemoveProducerRequestRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RemoveProducerRequestRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RemoveProducerRequest>> for RemoveProducerRequest {
                type Value = ::planus::Offset<RemoveProducerRequest>;
                const STRIDE: usize = 4;
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RemoveProducerRequest>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RemoveProducerRequestRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RemoveProducerRequestRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }
        }
    }
}
